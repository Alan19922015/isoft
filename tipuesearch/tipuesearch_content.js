var tipuesearch = {"pages":[{"title":" ISOFT ","tags":"home","loc":"index.html","text":"ISOFT ISOFT is a piece of software/suite of tools which I developed while\nworking on my PhD thesis to simulate the evolution of ice shelves\ncoupled to ocean plumes. It attempts to provide an object oriented,\nextensible framework with which to model glacial flow using modern\nFortran. Though developed for ice shelves, it could in principle be\nmodified to simulated grounded ice dynamics as well. I've published\nthe code and documentation to GitHub in the hopes that it might be\nuseful to others. Developer Info Chris MacMackin I am a graduate student at the University of Oxford, studying\nthe melting and evolution of ice shelves."},{"title":"meta.F90 – ISOFT","tags":"","loc":"sourcefile/meta.f90.html","text":"Files dependent on this one sourcefile~~meta.f90~~AfferentGraph sourcefile~meta.f90 meta.F90 sourcefile~cryosphere.f90 cryosphere.F90 sourcefile~cryosphere.f90->sourcefile~meta.f90 sourcefile~meta_implementation.f90 meta_implementation.F90 sourcefile~meta_implementation.f90->sourcefile~meta.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules meta_mod Source Code meta.F90 Source Code ! !  meta_parameters.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module meta_mod !* Author: Chris MacMackin !  Date: November 2016 !  License: GPLv3 ! ! Provides functions specifying the version of ISOFT, time of compilation, etc. ! use iso_fortran_env , only : i8 => int64 , compiler_version , compiler_options implicit none character ( len = 3 ), dimension ( 12 ), parameter :: months = [ 'Jan' , & 'Feb' , & 'Mar' , & 'Apr' , & 'May' , & 'Jun' , & 'Jul' , & 'Aug' , & 'Sep' , & 'Oct' , & 'Nov' , & 'Dec' ] character ( len = 42 ), parameter :: time_format = '(a3,1x,i2,1x,i4,1x,i2.2,\":\",' // & 'i2.2,\":\",i2.2)' interface module function version () !* Author: Chris MacMackin !  Date: December 2016 ! ! Returns the version number for ISOFT. ! character ( len = 5 ) :: version end function version module function compile_time () !* Author: Chris MacMackin !  Date: December 2016 ! ! Returns the date and time at which ISOFT was compiled. ! character ( len = 20 ) :: compile_time end function compile_time module function compile_info () !* Author: Chris MacMackin !  Date: April 2017 ! ! Returns compiler version and and flags. ! character ( len = 1000 ) :: compile_info end function compile_info end interface contains function current_time () !* Author: Chris MacMackin !  Date: November 2016 ! ! Returns the current date and time in the same format as the ! [[compile_time]] function. ! character ( len = 20 ) :: current_time integer ( i8 ), dimension ( 8 ) :: time_vals call date_and_time ( values = time_vals ) write ( current_time , time_format ) months ( time_vals ( 2 )), time_vals ( 3 ), & time_vals ( 1 ), time_vals ( 5 ), time_vals ( 6 ), & time_vals ( 7 ) end function current_time end module meta_mod"},{"title":"rksuite_90.f90 – ISOFT","tags":"","loc":"sourcefile/rksuite_90.f90.html","text":"Files dependent on this one sourcefile~~rksuite_90.f90~~AfferentGraph sourcefile~rksuite_90.f90 rksuite_90.f90 sourcefile~upstream_plume.f90 upstream_plume.F90 sourcefile~upstream_plume.f90->sourcefile~rksuite_90.f90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~upstream_plume.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~upstream_plume.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~upstream_plume.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rksuite_90_prec rksuite_90 Source Code rksuite_90.f90 Source Code module rksuite_90_prec ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! use iso_fortran_env integer , parameter :: wp = real64 end module rksuite_90_prec module rksuite_90 ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! use rksuite_90_prec , only : wp implicit none private public :: wp , setup , range_integrate , step_integrate , interpolate , & global_error , statistics , reset_t_end , collect_garbage , & set_stop_on_fatal , get_saved_fatal !starta! public :: rk_comm_real_1d type rk_comm_real_1d private real ( kind = wp ) :: t , t_old , t_start , t_end , dir !indep! real ( kind = wp ) :: h , h_old , h_start , h_average !indep! real ( kind = wp ) :: tol integer :: f_count , full_f_count , step_count , bad_step_count logical :: at_t_start , at_t_end real ( kind = wp ), dimension (:), pointer :: thresh , weights , ymax !shp-dep! real ( kind = wp ), dimension (:), pointer :: scratch , y , yp , y_new !dep! real ( kind = wp ), dimension (:), pointer :: y_old , yp_old , v0 , v1 !dep! real ( kind = wp ), dimension (:), pointer :: err_estimates , v2 , v3 !dep! real ( kind = wp ), dimension (:), pointer :: vtemp !dep! real ( kind = wp ), dimension (:,:), pointer :: stages !dep! real ( kind = wp ) :: a ( 13 , 13 ), b ( 13 ), c ( 13 ), bhat ( 13 ), r ( 11 , 6 ), e ( 7 ) integer :: ptr ( 13 ), no_of_stages , rk_method , intrp_degree logical :: intrp_able , intrp_needs_stages real ( kind = wp ) :: toosml , cost , safety , expon , stability_radius , tan_angle , & rs , rs1 , rs2 , rs3 , rs4 integer :: order , last_stage , max_stiff_iters , no_of_ge_steps logical :: fsal real ( kind = wp ) :: ge_max_contrib real ( kind = wp ) :: t_ge_max_contrib !indep! integer :: ge_f_count real ( kind = wp ), dimension (:), pointer :: ge_assess !shp-dep! real ( kind = wp ), dimension (:), pointer :: ge_y , ge_yp , ge_y_new !dep! real ( kind = wp ), dimension (:), pointer :: ge_err_estimates !dep! real ( kind = wp ), dimension (:,:), pointer :: ge_stages !dep! logical :: erason , erasfl real ( kind = wp ) :: mcheps , dwarf , round_off , sqrrmc , cubrmc , sqtiny integer :: outch logical :: print_message , use_range character ( len = 80 ) :: rec ( 10 ) real ( kind = wp ) :: tlast , range_t_end !indep! real ( kind = wp ), dimension (:), pointer :: xstage , ytemp !dep! real ( kind = wp ), dimension (:,:), pointer :: p !dep! integer :: stiff_bad_step_count , hit_t_end_count real ( kind = wp ) :: errold logical :: chkeff , phase2 integer , dimension ( 7 ) :: save_states logical :: stop_on_fatal , saved_fatal_err end type rk_comm_real_1d !enda! interface setup module procedure setup_r1 end interface interface range_integrate module procedure range_integrate_r1 end interface interface step_integrate module procedure step_integrate_r1 end interface interface statistics module procedure statistics_r1 end interface interface global_error module procedure global_error_r1 end interface interface reset_t_end module procedure reset_t_end_r1 end interface interface interpolate module procedure interpolate_r1 end interface interface set_stop_on_fatal module procedure set_stop_on_fatal_r1 end interface interface get_saved_fatal module procedure get_saved_fatal_r1 end interface interface collect_garbage module procedure collect_garbage_r1 end interface contains !startb! subroutine machine_const ( round_off , sqrrmc , cubrmc , sqtiny , outch ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( out ) :: round_off , sqrrmc , cubrmc , sqtiny integer , intent ( out ) :: outch ! real ( kind = wp ) :: dummy real ( kind = wp ), parameter :: third = 1.0_wp / 3.0_wp , ten = 1 0.0_wp ! outch = 6 ! round_off = ten * epsilon ( dummy ) sqrrmc = sqrt ( epsilon ( dummy )) cubrmc = epsilon ( dummy ) ** third sqtiny = sqrt ( tiny ( dummy )) ! end subroutine machine_const subroutine method_const ( rk_method , a , b , c , bhat , r , e , ptr , no_of_stages , & intrp_degree , intrp_able , intrp_needs_stages , & cost , safety , expon , stability_radius , & tan_angle , rs , rs1 , rs2 , rs3 , rs4 , order , last_stage , & max_stiff_iters , no_of_ge_steps , fsal , cdiff ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! integer , intent ( in ) :: rk_method real ( kind = wp ), intent ( out ) :: a ( 13 , 13 ), b ( 13 ), c ( 13 ), bhat ( 13 ), r ( 11 , 6 ), e ( 7 ) integer , intent ( out ) :: ptr ( 13 ), no_of_stages , intrp_degree logical , intent ( out ) :: intrp_able , intrp_needs_stages real ( kind = wp ), intent ( out ) :: cost , safety , expon , stability_radius , & tan_angle , rs , rs1 , rs2 , rs3 , rs4 , cdiff integer , intent ( out ) :: order , last_stage , max_stiff_iters , no_of_ge_steps logical , intent ( out ) :: fsal ! integer :: i real ( kind = wp ), parameter :: fivepc = 0.05_wp , one = 1.0_wp , two = 2.0_wp , & fifty = 5 0.0_wp ! select case ( rk_method ) case ( 1 ) ! !  METHD = 1. !    This pair is from \"A 3(2) Pair of Runge-Kutta Formulas\" by P. Bogacki !    and L.F. Shampine, Appl. Math. Lett., 2, pp. 321-325, 1989.  The authors !    are grateful to P. Bogacki for his assistance in implementing the pair. ! no_of_stages = 4 ; fsal = . true .; order = 2 tan_angle = 8.9_wp ; stability_radius = 2.3_wp safety = 0.8_wp ; intrp_able = . true .; intrp_degree = 3 intrp_needs_stages = . false .; no_of_ge_steps = 3 ! ptr ( 1 : 4 ) = ( / 0 , 1 , 2 , 3 / ) ! a ( 2 , 1 ) = 1.0_wp / 2.0_wp a ( 3 , 1 ) = 0.0_wp a ( 3 , 2 ) = 3.0_wp / 4.0_wp a ( 4 , 1 ) = 2.0_wp / 9.0_wp a ( 4 , 2 ) = 1.0_wp / 3.0_wp a ( 4 , 3 ) = 4.0_wp / 9.0_wp ! !  The coefficients BHAT refer to the formula used to advance the !  integration, here the one of order 3.  The coefficients B refer !  to the other formula, here the one of order 2. For this pair, BHAT !  is not needed since FSAL = .TRUE. ! b ( 1 ) = 7.0_wp / 2 4.0_wp b ( 2 ) = 1.0_wp / 4.0_wp b ( 3 ) = 1.0_wp / 3.0_wp b ( 4 ) = 1.0_wp / 8.0_wp ! c ( 1 ) = 0.0_wp c ( 2 ) = 1.0_wp / 2.0_wp c ( 3 ) = 3.0_wp / 4.0_wp c ( 4 ) = 1.0_wp ! case ( 2 ) ! !  METHD = 2 !    This pair is from \"An Efficient Runge-Kutta (4,5) Pair\" by P. Bogacki !    and L.F. Shampine, Rept. 89-20, Math. Dept., Southern Methodist !    University, Dallas, Texas, USA, 1989.  The authors are grateful to !    P. Bogacki for his assistance in implementing the pair.  Shampine and !    Bogacki subsequently modified the formula to enhance the reliability of !    the pair.  The original fourth order formula is used in an estimate of !    the local error.  If the step fails, the computation is broken off.  If !    the step is acceptable, the first evaluation of the next step is done, !    i.e., the pair is implemented as FSAL and the local error of the step !    is again estimated with a fourth order formula using the additional data. !    The step must succeed with both estimators to be accepted.  When the !    second estimate is formed, it is used for the subsequent adjustment of !    the step size because it is of higher quality.  The two fourth order !    formulas are well matched to leading order, and only exceptionally do !    the estimators disagree -- problems with discontinuous coefficients are !    handled more reliably by using two estimators as is global error !    estimation. ! no_of_stages = 8 ; fsal = . true .; order = 4 tan_angle = 5.2_wp ; stability_radius = 3.9_wp safety = 0.8_wp ; intrp_able = . true . intrp_needs_stages = . true .; intrp_degree = 6 no_of_ge_steps = 2 ! ptr ( 1 : 8 ) = ( / 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 / ) ! a ( 2 , 1 ) = 1.0_wp / 6.0_wp a ( 3 , 1 ) = 2.0_wp / 2 7.0_wp a ( 3 , 2 ) = 4.0_wp / 2 7.0_wp a ( 4 , 1 ) = 18 3.0_wp / 137 2.0_wp a ( 4 , 2 ) = - 16 2.0_wp / 34 3.0_wp a ( 4 , 3 ) = 105 3.0_wp / 137 2.0_wp a ( 5 , 1 ) = 6 8.0_wp / 29 7.0_wp a ( 5 , 2 ) = - 4.0_wp / 1 1.0_wp a ( 5 , 3 ) = 4 2.0_wp / 14 3.0_wp a ( 5 , 4 ) = 196 0.0_wp / 386 1.0_wp a ( 6 , 1 ) = 59 7.0_wp / 2252 8.0_wp a ( 6 , 2 ) = 8 1.0_wp / 35 2.0_wp a ( 6 , 3 ) = 6309 9.0_wp / 58572 8.0_wp a ( 6 , 4 ) = 5865 3.0_wp / 36608 0.0_wp a ( 6 , 5 ) = 461 7.0_wp / 2048 0.0_wp a ( 7 , 1 ) = 17419 7.0_wp / 95924 4.0_wp a ( 7 , 2 ) = - 3094 2.0_wp / 7993 7.0_wp a ( 7 , 3 ) = 815213 7.0_wp / 1974443 9.0_wp a ( 7 , 4 ) = 66610 6.0_wp / 103918 1.0_wp a ( 7 , 5 ) = - 2942 1.0_wp / 2906 8.0_wp a ( 7 , 6 ) = 48204 8.0_wp / 41421 9.0_wp a ( 8 , 1 ) = 58 7.0_wp / 806 4.0_wp a ( 8 , 2 ) = 0.0_wp a ( 8 , 3 ) = 444033 9.0_wp / 1549184 0.0_wp a ( 8 , 4 ) = 2435 3.0_wp / 12480 0.0_wp a ( 8 , 5 ) = 38 7.0_wp / 4480 0.0_wp a ( 8 , 6 ) = 215 2.0_wp / 598 5.0_wp a ( 8 , 7 ) = 726 7.0_wp / 9408 0.0_wp ! !  The coefficients B refer to the formula of order 4. ! b ( 1 ) = 247 9.0_wp / 3499 2.0_wp b ( 2 ) = 0.0_wp b ( 3 ) = 12 3.0_wp / 41 6.0_wp b ( 4 ) = 61294 1.0_wp / 341172 0.0_wp b ( 5 ) = 4 3.0_wp / 144 0.0_wp b ( 6 ) = 227 2.0_wp / 656 1.0_wp b ( 7 ) = 7993 7.0_wp / 111391 2.0_wp b ( 8 ) = 329 3.0_wp / 55695 6.0_wp ! !  The coefficients E refer to an estimate of the local error based on !  the first formula of order 4.  It is the difference of the fifth order !  result, here located in A(8,:), and the fourth order result.  By !  construction both E(2) and E(7) are zero. ! e ( 1 ) = - 3.0_wp / 128 0.0_wp e ( 2 ) = 0.0_wp e ( 3 ) = 656 1.0_wp / 63232 0.0_wp e ( 4 ) = - 34 3.0_wp / 2080 0.0_wp e ( 5 ) = 24 3.0_wp / 1280 0.0_wp e ( 6 ) = - 1.0_wp / 9 5.0_wp e ( 7 ) = 0.0_wp ! c ( 1 ) = 0.0_wp c ( 2 ) = 1.0_wp / 6.0_wp c ( 3 ) = 2.0_wp / 9.0_wp c ( 4 ) = 3.0_wp / 7.0_wp c ( 5 ) = 2.0_wp / 3.0_wp c ( 6 ) = 3.0_wp / 4.0_wp c ( 7 ) = 1.0_wp c ( 8 ) = 1.0_wp ! !  To do interpolation with this pair, some extra stages have to be computed. !  The following additional A and C coefficients are for this purpose. !  In addition there is an array R that plays a role for interpolation !  analogous to that of BHAT for the basic step. ! c ( 9 ) = 1.0_wp / 2.0_wp c ( 10 ) = 5.0_wp / 6.0_wp c ( 11 ) = 1.0_wp / 9.0_wp ! a ( 9 , 1 ) = 45 5.0_wp / 614 4.0_wp a ( 10 , 1 ) = - 83788834371 5.0_wp / 1317698863718 4.0_wp a ( 11 , 1 ) = 9871907326 3.0_wp / 155196518400 0.0_wp a ( 9 , 2 ) = 0.0_wp a ( 10 , 2 ) = 3040941 5.0_wp / 5295536 2.0_wp a ( 11 , 2 ) = 130 7.0_wp / 12355 2.0_wp a ( 9 , 3 ) = 1025630 1.0_wp / 3540992 0.0_wp a ( 10 , 3 ) = - 4832152596 3.0_wp / 75916806963 2.0_wp a ( 11 , 3 ) = 463206655938 7.0_wp / 7018175324160 0.0_wp a ( 9 , 4 ) = 230736 1.0_wp / 1797120 0.0_wp a ( 10 , 4 ) = 853073845332 1.0_wp / 19765482955776 0.0_wp a ( 11 , 4 ) = 782859430238 9.0_wp / 38218251202560 0.0_wp a ( 9 , 5 ) = - 38 7.0_wp / 10240 0.0_wp a ( 10 , 5 ) = 136164052300 1.0_wp / 162678872064 0.0_wp a ( 11 , 5 ) = 4076368 7.0_wp / 1107025920 0.0_wp a ( 9 , 6 ) = 7 3.0_wp / 513 0.0_wp a ( 10 , 6 ) = - 1314306068 9.0_wp / 3860445889 8.0_wp a ( 11 , 6 ) = 3487273240 7.0_wp / 22461058620 0.0_wp a ( 9 , 7 ) = - 726 7.0_wp / 21504 0.0_wp a ( 10 , 7 ) = 1870022196 9.0_wp / 37958403481 6.0_wp a ( 11 , 7 ) = - 256189 7.0_wp / 3010560 0.0_wp a ( 9 , 8 ) = 1.0_wp / 3 2.0_wp a ( 10 , 8 ) = - 583159 5.0_wp / 84728579 2.0_wp a ( 11 , 8 ) = 1.0_wp / 1 0.0_wp a ( 10 , 9 ) = - 518364 0.0_wp / 2647768 1.0_wp a ( 11 , 9 ) = - 1.0_wp / 1 0.0_wp a ( 11 , 10 ) = - 140331709 3.0_wp / 1137161025 0.0_wp ! r ( 1 : 11 , 1 ) = 0.0_wp ; r ( 2 , 1 : 6 ) = 0.0_wp r ( 1 , 6 ) = - 1213433839 3.0_wp / 105080976 0.0_wp r ( 1 , 5 ) = - 162074122 9.0_wp / 5003856 0.0_wp r ( 1 , 4 ) = - 204805889 3.0_wp / 5987520 0.0_wp r ( 1 , 3 ) = - 8709848000 9.0_wp / 525404880 0.0_wp r ( 1 , 2 ) = - 1151327027 3.0_wp / 350269920 0.0_wp ! r ( 3 , 6 ) = - 3319734036 7.0_wp / 121843321 6.0_wp r ( 3 , 5 ) = - 53986802498 7.0_wp / 609216608 0.0_wp r ( 3 , 4 ) = - 3999118868 1.0_wp / 37490252 8.0_wp r ( 3 , 3 ) = - 6950973822 7.0_wp / 121843321 6.0_wp r ( 3 , 2 ) = - 2932774461 3.0_wp / 243686643 2.0_wp ! r ( 4 , 6 ) = - 28480099720 1.0_wp / 1990533916 8.0_wp r ( 4 , 5 ) = - 789687545047 1.0_wp / 16587782640 0.0_wp r ( 4 , 4 ) = - 33394581287 9.0_wp / 567103680 0.0_wp r ( 4 , 3 ) = - 1620992345623 7.0_wp / 49763347920 0.0_wp r ( 4 , 2 ) = - 238259074169 9.0_wp / 33175565280 0.0_wp ! r ( 5 , 6 ) = - 54091 9.0_wp / 74131 2.0_wp r ( 5 , 5 ) = - 10362606 7.0_wp / 4324320 0.0_wp r ( 5 , 4 ) = - 63377 9.0_wp / 21120 0.0_wp r ( 5 , 3 ) = - 3240678 7.0_wp / 1853280 0.0_wp r ( 5 , 2 ) = - 3659119 3.0_wp / 8648640 0.0_wp ! r ( 6 , 6 ) = 715799830 4.0_wp / 37435097 7.0_wp r ( 6 , 5 ) = 3040584246 4.0_wp / 62391829 5.0_wp r ( 6 , 4 ) = 18302226 4.0_wp / 533263 5.0_wp r ( 6 , 3 ) = - 335702403 2.0_wp / 187175488 5.0_wp r ( 6 , 2 ) = - 61158673 6.0_wp / 8913118 5.0_wp ! r ( 7 , 6 ) = - 13807 3.0_wp / 940 8.0_wp r ( 7 , 5 ) = - 71943 3.0_wp / 1568 0.0_wp r ( 7 , 4 ) = - 162054 1.0_wp / 3136 0.0_wp r ( 7 , 3 ) = - 38515 1.0_wp / 1568 0.0_wp r ( 7 , 2 ) = - 6540 3.0_wp / 1568 0.0_wp ! r ( 8 , 6 ) = 124 5.0_wp / 6 4.0_wp r ( 8 , 5 ) = 399 1.0_wp / 6 4.0_wp r ( 8 , 4 ) = 471 5.0_wp / 6 4.0_wp r ( 8 , 3 ) = 250 1.0_wp / 6 4.0_wp r ( 8 , 2 ) = 14 9.0_wp / 1 6.0_wp r ( 8 , 1 ) = 1.0_wp ! r ( 9 , 6 ) = 5 5.0_wp / 3.0_wp r ( 9 , 5 ) = 7 1.0_wp r ( 9 , 4 ) = 10 3.0_wp r ( 9 , 3 ) = 19 9.0_wp / 3.0_wp r ( 9 , 2 ) = 1 6.0d0 ! r ( 10 , 6 ) = - 177400462 7.0_wp / 7581073 5.0_wp r ( 10 , 5 ) = - 177400462 7.0_wp / 2527024 5.0_wp r ( 10 , 4 ) = - 2647768 1.0_wp / 35997 5.0_wp r ( 10 , 3 ) = - 1141188051 1.0_wp / 37905367 5.0_wp r ( 10 , 2 ) = - 42364289 6.0_wp / 12635122 5.0_wp ! r ( 11 , 6 ) = 3 5.0_wp r ( 11 , 5 ) = 10 5.0_wp r ( 11 , 4 ) = 11 7.0_wp r ( 11 , 3 ) = 5 9.0_wp r ( 11 , 2 ) = 1 2.0_wp ! case ( 3 ) ! !  METHD = 3 !    This pair is from \"High Order Embedded Runge-Kutta Formulae\" by P.J. !    Prince and J.R. Dormand, J. Comp. Appl. Math.,7, pp. 67-75, 1981.  The !    authors are grateful to P. Prince and J. Dormand for their assistance in !    implementing the pair. ! no_of_stages = 13 ; fsal = . false .; order = 7 tan_angle = 1 1.0_wp ; stability_radius = 5.2_wp safety = 0.8_wp ; intrp_able = . false . intrp_needs_stages = . false .; intrp_degree = 0 no_of_ge_steps = 2 ! ptr ( 1 : 13 ) = ( / 0 , 1 , 2 , 1 , 3 , 2 , 4 , 5 , 6 , 7 , 8 , 9 , 1 / ) ! a ( 2 , 1 ) = 5.55555555555555555555555555556e-2_wp a ( 3 , 1 ) = 2.08333333333333333333333333333e-2_wp a ( 3 , 2 ) = 6.25e-2_wp a ( 4 , 1 ) = 3.125e-2_wp a ( 4 , 2 ) = 0.0_wp a ( 4 , 3 ) = 9.375e-2_wp a ( 5 , 1 ) = 3.125e-1_wp a ( 5 , 2 ) = 0.0_wp a ( 5 , 3 ) = - 1.171875_wp a ( 5 , 4 ) = 1.171875_wp a ( 6 , 1 ) = 3.75e-2_wp a ( 6 , 2 ) = 0.0_wp a ( 6 , 3 ) = 0.0_wp a ( 6 , 4 ) = 1.875e-1_wp a ( 6 , 5 ) = 1.5e-1_wp a ( 7 , 1 ) = 4.79101371111111111111111111111e-2_wp a ( 7 , 2 ) = 0.0_wp a ( 7 , 3 ) = 0.0_wp a ( 7 , 4 ) = 1.12248712777777777777777777778e-1_wp a ( 7 , 5 ) = - 2.55056737777777777777777777778e-2_wp a ( 7 , 6 ) = 1.28468238888888888888888888889e-2_wp a ( 8 , 1 ) = 1.6917989787292281181431107136e-2_wp a ( 8 , 2 ) = 0.0_wp a ( 8 , 3 ) = 0.0_wp a ( 8 , 4 ) = 3.87848278486043169526545744159e-1_wp a ( 8 , 5 ) = 3.59773698515003278967008896348e-2_wp a ( 8 , 6 ) = 1.96970214215666060156715256072e-1_wp a ( 8 , 7 ) = - 1.72713852340501838761392997002e-1_wp a ( 9 , 1 ) = 6.90957533591923006485645489846e-2_wp a ( 9 , 2 ) = 0.0_wp a ( 9 , 3 ) = 0.0_wp a ( 9 , 4 ) = - 6.34247976728854151882807874972e-1_wp a ( 9 , 5 ) = - 1.61197575224604080366876923982e-1_wp a ( 9 , 6 ) = 1.38650309458825255419866950133e-1_wp a ( 9 , 7 ) = 9.4092861403575626972423968413e-1_wp a ( 9 , 8 ) = 2.11636326481943981855372117132e-1_wp a ( 10 , 1 ) = 1.83556996839045385489806023537e-1_wp a ( 10 , 2 ) = 0.0_wp a ( 10 , 3 ) = 0.0_wp a ( 10 , 4 ) = - 2.46876808431559245274431575997_wp a ( 10 , 5 ) = - 2.91286887816300456388002572804e-1_wp a ( 10 , 6 ) = - 2.6473020233117375688439799466e-2_wp a ( 10 , 7 ) = 2.84783876419280044916451825422_wp a ( 10 , 8 ) = 2.81387331469849792539403641827e-1_wp a ( 10 , 9 ) = 1.23744899863314657627030212664e-1_wp a ( 11 , 1 ) = - 1.21542481739588805916051052503_wp a ( 11 , 2 ) = 0.0_wp a ( 11 , 3 ) = 0.0_wp a ( 11 , 4 ) = 1.66726086659457724322804132886e1_wp a ( 11 , 5 ) = 9.15741828416817960595718650451e-1_wp a ( 11 , 6 ) = - 6.05660580435747094755450554309_wp a ( 11 , 7 ) = - 1.60035735941561781118417064101e1_wp a ( 11 , 8 ) = 1.4849303086297662557545391898e1_wp a ( 11 , 9 ) = - 1.33715757352898493182930413962e1_wp a ( 11 , 10 ) = 5.13418264817963793317325361166_wp a ( 12 , 1 ) = 2.58860916438264283815730932232e-1_wp a ( 12 , 2 ) = 0.0_wp a ( 12 , 3 ) = 0.0_wp a ( 12 , 4 ) = - 4.77448578548920511231011750971_wp a ( 12 , 5 ) = - 4.3509301377703250944070041181e-1_wp a ( 12 , 6 ) = - 3.04948333207224150956051286631_wp a ( 12 , 7 ) = 5.57792003993609911742367663447_wp a ( 12 , 8 ) = 6.15583158986104009733868912669_wp a ( 12 , 9 ) = - 5.06210458673693837007740643391_wp a ( 12 , 10 ) = 2.19392617318067906127491429047_wp a ( 12 , 11 ) = 1.34627998659334941535726237887e-1_wp a ( 13 , 1 ) = 8.22427599626507477963168204773e-1_wp a ( 13 , 2 ) = 0.0_wp a ( 13 , 3 ) = 0.0_wp a ( 13 , 4 ) = - 1.16586732572776642839765530355e1_wp a ( 13 , 5 ) = - 7.57622116690936195881116154088e-1_wp a ( 13 , 6 ) = 7.13973588159581527978269282765e-1_wp a ( 13 , 7 ) = 1.20757749868900567395661704486e1_wp a ( 13 , 8 ) = - 2.12765911392040265639082085897_wp a ( 13 , 9 ) = 1.99016620704895541832807169835_wp a ( 13 , 10 ) = - 2.34286471544040292660294691857e-1_wp a ( 13 , 11 ) = 1.7589857770794226507310510589e-1_wp a ( 13 , 12 ) = 0.0_wp ! !  The coefficients BHAT refer to the formula used to advance the !  integration, here the one of order 8.  The coefficients B refer !  to the other formula, here the one of order 7. ! bhat ( 1 ) = 4.17474911415302462220859284685e-2_wp bhat ( 2 ) = 0.0_wp bhat ( 3 ) = 0.0_wp bhat ( 4 ) = 0.0_wp bhat ( 5 ) = 0.0_wp bhat ( 6 ) = - 5.54523286112393089615218946547e-2_wp bhat ( 7 ) = 2.39312807201180097046747354249e-1_wp bhat ( 8 ) = 7.0351066940344302305804641089e-1_wp bhat ( 9 ) = - 7.59759613814460929884487677085e-1_wp bhat ( 10 ) = 6.60563030922286341461378594838e-1_wp bhat ( 11 ) = 1.58187482510123335529614838601e-1_wp bhat ( 12 ) = - 2.38109538752862804471863555306e-1_wp bhat ( 13 ) = 2.5e-1_wp ! b ( 1 ) = 2.9553213676353496981964883112e-2_wp b ( 2 ) = 0.0_wp b ( 3 ) = 0.0_wp b ( 4 ) = 0.0_wp b ( 5 ) = 0.0_wp b ( 6 ) = - 8.28606276487797039766805612689e-1_wp b ( 7 ) = 3.11240900051118327929913751627e-1_wp b ( 8 ) = 2.46734519059988698196468570407_wp b ( 9 ) = - 2.54694165184190873912738007542_wp b ( 10 ) = 1.44354858367677524030187495069_wp b ( 11 ) = 7.94155958811272872713019541622e-2_wp b ( 12 ) = 4.44444444444444444444444444445e-2_wp b ( 13 ) = 0.0_wp ! c ( 1 ) = 0.0_wp c ( 2 ) = 5.55555555555555555555555555556e-2_wp c ( 3 ) = 8.33333333333333333333333333334e-2_wp c ( 4 ) = 1.25e-1_wp c ( 5 ) = 3.125e-1_wp c ( 6 ) = 3.75e-1_wp c ( 7 ) = 1.475e-1_wp c ( 8 ) = 4.65e-1_wp c ( 9 ) = 5.64865451382259575398358501426e-1_wp c ( 10 ) = 6.5e-1_wp c ( 11 ) = 9.24656277640504446745013574318e-1_wp c ( 12 ) = 1.0_wp c ( 13 ) = c ( 12 ) ! end select ! !  The definitions of all pairs come here for the calculation of !  LAST_STAGE - the position of the last evaluated stage in a method !  RS1, RS2, RS3, RS4 - minimum and maximum rations used is step selection !  COST - the cost of a step !  MAX_STIFF_ITERS - the number of iterations permitted in stiffness detection !     There are at most Q = 3 function calls per iteration. MAX_STIFF_ITERS !     is determined so that  Q*MAX_STIFF_ITERS <= 5% of the cost of !     50 steps and 1 <= MAX_STIFF_ITERS <= 8. This limits the number of !     function calls in each diagnosis of stiffness to 24. !  EXPON - an exponent for use in step slection !  CDIFF - a coefficent used in determining the minimum permissible step ! last_stage = ptr ( no_of_stages ) if ( fsal ) then cost = real ( no_of_stages - 1 , kind = wp ) else cost = real ( no_of_stages , kind = wp ) end if ! max_stiff_iters = min ( 8 , max ( 1 , int ( fivepc * cost * fifty ))) ! expon = one / ( order + one ) ! !     In calculating CDIFF it is assumed that there will be a non-zero !     difference |C(I) - C(J)| less than one. If C(I) = C(J) for any I not !     equal to J, they should be made precisely equal by assignment. ! cdiff = one do i = 1 , no_of_stages - 1 cdiff = min ( cdiff , minval ( & abs (( c ( i ) - c ( i + 1 : no_of_stages ))), & mask = ( c ( i ) - c ( i + 1 : no_of_stages ) /= 0 )) ) end do ! rs = two ; rs1 = one / rs ; rs2 = rs ** 2 rs3 = rs * rs2 ; rs4 = one / rs3 ! end subroutine method_const !endb! !startc! subroutine setup_r1 ( comm , t_start , y_start , t_end , tolerance , thresholds , & method , task , error_assess , h_start , message ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( in ) :: t_end , t_start !indep! real ( kind = wp ), intent ( in ) :: tolerance real ( kind = wp ), dimension (:), intent ( in ) :: y_start !dep! real ( kind = wp ), dimension (:), intent ( in ) :: thresholds !shp-dep! type ( rk_comm_real_1d ) :: comm real ( kind = wp ), intent ( in ), optional :: h_start !indep! logical , intent ( in ), optional :: error_assess , message character ( len =* ), intent ( in ), optional :: task , method ! character ( len =* ), parameter :: srname = \"SETUP\" ! real ( kind = wp ) :: hmin !indep! real ( kind = wp ) :: cdiff integer :: ier , nrec , tr_dim_of_stages logical :: legalt character ( len = 1 ) :: task1 , method1 ! integer , parameter :: not_ready =- 1 , fatal = 911 , just_fine = 1 real ( kind = wp ), parameter :: zero = 0.0_wp , pt01 = 0.01_wp , fivepc = 0.05_wp , & third = 1.0_wp / 3.0_wp , one = 1.0_wp , two = 2.0_wp , ten = 1 0.0_wp , fifty = 5 0.0_wp ! ier = just_fine ; nrec = 0 ! !  Clear previous state of the suite. ! call setup_global_stuff nullify ( comm % thresh , comm % err_estimates , comm % weights , comm % y_old , & comm % scratch , & comm % y , comm % yp , comm % y_new , comm % yp_old , comm % stages , comm % ge_y , & comm % ge_yp , comm % ge_err_estimates , comm % ge_assess , comm % ge_y_new , & comm % ge_stages , comm % v0 , comm % v1 , comm % v2 , comm % v3 , comm % vtemp , & comm % xstage , comm % ytemp , comm % p ) ! !  Fetch output channel and machine constants; ! call machine_const ( comm % round_off , comm % sqrrmc , comm % cubrmc , comm % sqtiny , & comm % outch ) ! body : do ! !  Check for valid shape if ( size ( shape ( y_start )) > 0 ) then if ( any ( shape ( y_start ) == 0 )) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a)\" ) & \" ** An extent of Y_START has zero length. This is not permitted.\" exit body end if end if ! !  Check and process non-trivial optional arguments if ( present ( task )) then task1 = task ( 1 : 1 ); comm % use_range = task1 == \"R\" . or . task1 == \"r\" legalt = comm % use_range . or . task1 == \"S\" . or . task1 == \"s\" if (. not . legalt ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,a,a/a)\" ) & \" ** You have set the first character of TASK to be '\" , TASK1 , \"'.\" , & \" ** It must be one of 'R','r','S' or 's'.\" exit body end if end if if ( present ( method )) then method1 = method ( 1 : 1 ) select case ( method1 ) case ( \"L\" , \"l\" ); comm % rk_method = 1 case ( \"M\" , \"m\" ); comm % rk_method = 2 case ( \"H\" , \"h\" ); comm % rk_method = 3 case default ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,a,a/a)\" ) & \" ** You have set the first character of METHOD to be '\" , METHOD1 , \"'.\" , & \" ** It must be one of 'L','l','M','m','H' or 'h'.\" exit body end select end if if ( present ( message )) comm % print_message = message ! ! Check consistency of array arguments ! if ( any ( shape ( y_start ) /= shape ( thresholds ))) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** The shapes of Y_START and THRESHOLDS are not consistent.\" exit body end if ! ! Check and process compulsory arguments if ( t_start == t_end ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a,e13.5,a)\" ) & \" ** You have set T_START = T_END = \" , T_START , \".\" exit body else comm % t_end = t_end ; comm % t_start = t_start comm % t_old = t_start ; comm % t = t_start comm % dir = sign ( one , t_end - t_start ) end if if (( tolerance > pt01 ) . or . ( tolerance < comm % round_off )) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,e13.5,a/a,e13.5,a)\" ) & \" ** You have set TOLERANCE = \" , tolerance , \" which is not permitted. The\" , & \" ** range of permitted values is (\" , comm % round_off , \",0.01).\" exit body else comm % tol = tolerance end if if ( minval ( thresholds ) < comm % sqtiny ) then !spec-ar! ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a,e13.5,a)\" ) & \" ** You have set a component of THRESHOLDS to be less than the permitted\" , & \" ** minimum,\" , comm % sqtiny , \".\" exit body end if ! !  Set formula definitions and characteristics call method_const ( comm % rk_method , comm % a , comm % b , comm % c , comm % bhat , & comm % r , comm % e , comm % ptr , comm % no_of_stages , comm % intrp_degree , & comm % intrp_able , comm % intrp_needs_stages , comm % cost , & comm % safety , comm % expon , comm % stability_radius , comm % tan_angle , & comm % rs , comm % rs1 , comm % rs2 , comm % rs3 , comm % rs4 , comm % order , & comm % last_stage , comm % max_stiff_iters , comm % no_of_ge_steps , comm % fsal ,& cdiff ) ! tr_dim_of_stages = maxval ( comm % ptr ( 2 : comm % no_of_stages )) comm % toosml = comm % round_off / cdiff ! !  In STEP_INTEGRATE the first step taken will have magnitude H.  If !  H_START = ABS(H_START) is not equal to zero, H = H_START.  If H_START is !  equal to zero, the code is to find an on-scale initial step size H.  To !  start this process, H is set here to an upper bound on the first step !  size that reflects the scale of the independent variable. !  RANGE_INTEGRATE has some additional information, namely the first output !  point, that is used to refine this bound in STEP_INTEGRATE when called !  from RANGE_INTEGRATE.  If H_START is not zero, but it is either too big !  or too small, the input H_START is ignored and H_START is set to zero to !  activate the automatic determination of an on-scale initial step size. ! hmin = max ( comm % sqtiny , comm % toosml * max ( abs ( t_start ), abs ( t_end ))) if ( abs ( t_end - t_start ) < hmin ) then ier = fatal ; nrec = 4 ; write ( comm % rec , \"(a/a/a,e13.5,a/a,e13.5,a)\" ) & \" ** You have set values for T_END and T_START that are not clearly\" , & \" ** distinguishable for the method and the precision of the computer\" , & \" ** being used. ABS(T_END-T_START) is \" , ABS ( T_END - T_START ), \" but should be\" , & \" **  at least \" , hmin , \".\" exit body end if if ( present ( h_start )) comm % h_start = abs ( h_start ) if ( comm % h_start > abs ( t_end - t_start ) . or . comm % h_start < hmin ) & comm % h_start = zero if ( comm % h_start == zero ) then comm % h = max ( abs ( t_end - t_start ) / comm % rs3 , hmin ) else comm % h = comm % h_start end if ! !  Allocate a number of arrays using pointers. ! allocate ( comm % thresh ( size ( y_start , 1 )), & !alloc! comm % err_estimates ( size ( y_start , 1 )), & !alloc! comm % weights ( size ( y_start , 1 )), & !alloc! comm % y_old ( size ( y_start , 1 )), & !alloc! comm % scratch ( size ( y_start , 1 )), & !alloc! comm % y ( size ( y_start , 1 )), & !alloc! comm % yp ( size ( y_start , 1 )), & !alloc! comm % stages ( size ( y_start , 1 ), tr_dim_of_stages ), & !alloc! comm % ymax ( size ( y_start , 1 )), stat = ier ) !alloc! if ( ier /= 0 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** Not enough storage available to create workspace required internally.\" exit body else comm % y = y_start ; comm % ymax = abs ( y_start ) comm % thresh = thresholds ; comm % y_new => comm % scratch ; comm % yp_old => comm % scratch comm % v0 => comm % err_estimates ; comm % vtemp => comm % scratch comm % v1 => comm % stages (:, 1 ); comm % v2 => comm % stages (:, 2 ) comm % v3 => comm % stages (:, 3 ) end if ! !  Pre-allocate storage for interpolation if the TASK = `R' was specified. ! if ( comm % use_range ) then if ( comm % intrp_able ) then if ( comm % rk_method == 1 ) then comm % p => comm % stages (:, 1 : 2 ) else if ( comm % rk_method == 2 ) then allocate ( comm % p ( size ( y_start , 1 ), 5 ), & !alloc! comm % ytemp ( size ( y_start , 1 )), & !alloc! comm % xstage ( size ( y_start , 1 )), stat = ier ) !alloc! if ( ier /= 0 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** Not enough storage available to create workspace required internally.\" exit body end if end if end if end if ! !  Initialise state and allocate storage for global error assessment ! comm % t_ge_max_contrib = t_start if ( present ( error_assess )) comm % erason = error_assess if ( comm % erason ) then ! !  Storage is required for the stages of a secondary integration. The !  stages of the primary intergration can only be overwritten in the !  cases where there is no interpolant or the interpolant does not !  require information about the stages (e.g. METHOD 'H' and METHOD 'L', !  respectively). if (. not . comm % intrp_needs_stages ) then comm % ge_stages => comm % stages else allocate ( comm % ge_stages ( size ( y_start , 1 ), tr_dim_of_stages ), stat = ier ) !alloc! if ( ier /= 0 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** Not enough storage available to create workspace required internally.\" exit body end if end if allocate ( comm % ge_y ( size ( y_start , 1 )), & !alloc! comm % ge_yp ( size ( y_start , 1 )), & !alloc! comm % ge_err_estimates ( size ( y_start , 1 )), & !alloc! comm % ge_assess ( size ( y_start , 1 )), & !alloc! comm % ge_y_new ( size ( y_start , 1 )), stat = ier ) !alloc! if ( ier /= 0 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** Not enough storage available to create workspace required internally.\" exit body else comm % ge_assess = 0.0_wp ; comm % ge_y = y_start end if end if exit body end do body ! call rkmsg_r1 ( ier , srname , nrec , comm ) ! contains subroutine setup_global_stuff ! comm % h_start = 0.0_wp ; comm % h_old = 0.0_wp comm % f_count = 0 ; comm % full_f_count = 0 ; comm % step_count = 0 ; comm % bad_step_count = 0 comm % at_t_start = . true .; comm % at_t_end = . false . comm % rk_method = 2 ; comm % ge_max_contrib = 0.0_wp ; comm % ge_f_count = 0 comm % erason = . false .; comm % erasfl = . false . comm % print_message = . true .; comm % use_range = . true . comm % stiff_bad_step_count = 0 ; comm % hit_t_end_count = 0 comm % errold = 0.0_wp ; comm % h_average = 0.0_wp comm % chkeff = . false .; comm % phase2 = . true . comm % save_states ( 1 : 7 ) = not_ready comm % stop_on_fatal = . true .; comm % saved_fatal_err = . false . ! end subroutine setup_global_stuff end subroutine setup_r1 subroutine collect_garbage_r1 ( comm ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! Modified by I.Gladwell (Aug 2002) ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ) :: comm ! if ( associated ( comm % thresh )) then deallocate ( comm % thresh ); nullify ( comm % thresh ) end if if ( associated ( comm % y )) then deallocate ( comm % y ); nullify ( comm % y ) end if if ( associated ( comm % yp )) then deallocate ( comm % yp ); nullify ( comm % yp ) end if if ( associated ( comm % ymax )) then deallocate ( comm % ymax ); nullify ( comm % ymax ) end if if ( associated ( comm % scratch )) then deallocate ( comm % scratch ); nullify ( comm % scratch ) nullify ( comm % y_new ); nullify ( comm % yp_old ); nullify ( comm % vtemp ) end if if ( associated ( comm % weights )) then deallocate ( comm % weights ); nullify ( comm % weights ) end if if ( associated ( comm % ytemp )) then deallocate ( comm % ytemp ); nullify ( comm % ytemp ) end if if ( associated ( comm % y_old )) then deallocate ( comm % y_old ); nullify ( comm % y_old ) end if if ( associated ( comm % err_estimates )) then deallocate ( comm % err_estimates ); nullify ( comm % err_estimates ) nullify ( comm % v0 ) end if if ( associated ( comm % p , comm % stages (:, 1 : 2 ))) then nullify ( comm % p ) end if if ( associated ( comm % ge_stages , comm % stages )) then deallocate ( comm % stages ); nullify ( comm % stages ); nullify ( comm % ge_stages ); nullify ( comm % v1 , comm % v2 , comm % v3 ) else if ( associated ( comm % ge_stages )) then deallocate ( comm % ge_stages ); nullify ( comm % ge_stages ) end if if ( associated ( comm % ge_y_new )) then deallocate ( comm % ge_y_new ); nullify ( comm % ge_y_new ) end if if ( associated ( comm % ge_assess )) then deallocate ( comm % ge_assess ); nullify ( comm % ge_assess ) end if if ( associated ( comm % ge_err_estimates )) then deallocate ( comm % ge_err_estimates ); nullify ( comm % ge_err_estimates ) end if if ( associated ( comm % ge_yp )) then deallocate ( comm % ge_yp ); nullify ( comm % ge_yp ) end if if ( associated ( comm % ge_y )) then deallocate ( comm % ge_y ); nullify ( comm % ge_y ) end if if ( associated ( comm % xstage )) then deallocate ( comm % xstage ); nullify ( comm % xstage ) end if if ( associated ( comm % p )) then deallocate ( comm % p ); nullify ( comm % p ) end if if ( associated ( comm % stages )) then deallocate ( comm % stages ); nullify ( comm % stages ) end if ! end subroutine collect_garbage_r1 recursive subroutine range_integrate_r1 ( comm , f , t_want , t_got , y_got , yderiv_got , & flag ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( in ) :: t_want !indep! real ( kind = wp ), intent ( out ) :: t_got !indep! real ( kind = wp ), dimension (:), intent ( out ) :: y_got , yderiv_got !dep! integer , intent ( out ), optional :: flag type ( rk_comm_real_1d ), intent ( inout ) :: comm ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! character ( len =* ), parameter :: srname = \"RANGE_INTEGRATE\" ! real ( kind = wp ) :: hmin , t_now !indep! integer :: step_flag , ier , nrec , state logical :: goback , baderr ! integer , parameter :: not_ready =- 1 , usable =- 2 , fatal = 911 , catastrophe = 912 , & just_fine = 1 logical , parameter :: tell = . false ., ask = . true . real ( kind = wp ), parameter :: zero = 0.0_wp ! ier = just_fine ; nrec = 0 goback = . false .; baderr = . false . body : do ! !  Is it permissible to call RANGE_INTEGRATE? ! state = get_saved_state_r1 ( \"SETUP\" , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( state == not_ready ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** You have not called SETUP, so you cannot use RANGE_INTEGRATE.\" exit body end if if (. not . comm % use_range ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have called RANGE_INTEGRATE after you specified in SETUP that you\" ,& \" ** were going to use STEP_INTEGRATE. This is not permitted.\" exit body end if state = get_saved_state_r1 ( srname , comm % save_states ) if ( state == 5 . or . state == 6 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a/a)\" ) & \" ** This routine has already returned with a hard failure. You must call\" ,& \" ** SETUP to start another problem.\" exit body end if state = usable call set_saved_state_r1 ( srname , state , comm ) ! if ( comm % at_t_start ) then ! !  First call. ! !  A value of T_END is specified in SETUP. When INTRP_ABLE = .FALSE., as with !  METHOD = 'H', output is obtained at the specified T_WANT by resetting T_END !  to T_WANT.  At this point, before the integration gets started, this can !  be done with a simple assignment.  Later it is done with a call to !  RESET_T_END. The original T_END is saved in RANGE_T_END. ! comm % range_t_end = comm % t_end if (. not . comm % intrp_able ) comm % t_end = t_want ! !  The last T_GOT returned is in the variable TLAST. T records how far the !  integration has advanced towards the specified T_END.  When output is !  obtained by interpolation, the integration goes past the T_GOT returned !  (T is closer to the specified T_END than T_GOT). comm % tlast = comm % t_start ; t_got = comm % t_start ! !  If the code is to find an on-scale initial step size H, a bound was placed !  on H in SETUP.  Here the first output point is used to refine this bound. if ( comm % h_start == zero ) then comm % h = min ( abs ( comm % h ), abs ( t_want - comm % t_start )) hmin = max ( comm % sqtiny , comm % toosml * & max ( abs ( comm % t_start ), abs ( comm % t_end ))) comm % h = max ( comm % h , hmin ) end if ! else ! !  Subsequent call. ! if ( comm % tlast == comm % range_t_end ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a)\" ) & \" ** You have called RANGE_INTEGRATE after reaching T_END. (Your last call\" ,& \" ** to RANGE_INTEGRATE  resulted in T_GOT = T_END.)  To start a new\" ,& \" ** problem, you will need to call SETUP.\" exit body end if ! end if ! !  Check for valid T_WANT. ! if ( comm % dir * ( t_want - comm % tlast ) <= zero ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a)\" ) & \" ** You have made a call to RANGE_INTEGRATE with a T_WANT that does not lie\" ,& \" ** between the previous value of T_GOT (T_START on the first call) and\" ,& \" ** T_END. This is not permitted. Check your program carefully.\" exit body end if if ( comm % dir * ( t_want - comm % range_t_end ) > zero ) then hmin = max ( comm % sqtiny , comm % toosml * & max ( abs ( t_want ), abs ( comm % range_t_end ))) if ( abs ( t_want - comm % range_t_end ) < hmin ) then ier = fatal ; nrec = 4 ; write ( comm % rec , \"(a/a/a/a)\" ) & \" ** You have made a call to RANGE_INTEGRATE with a T_WANT that does not lie\" ,& \" ** between the previous value of T_GOT (T_START on the first call) and\" ,& \" ** T_END. This is not permitted. T_WANT is very close to T_END, so you may\" ,& \" ** have meant to set it to be T_END exactly.  Check your program carefully.\" else ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a/a)\" ) & \" ** You have made a call to RANGE_INTEGRATE with a T_WANT that does not lie\" ,& \" ** between the previous value of T_GOT (T_START on the first call) and\" ,& \" ** T_END. This is not permitted. Check your program carefully.\" end if exit body end if if (. not . comm % intrp_able ) then hmin = max ( comm % sqtiny , comm % toosml * max ( abs ( comm % tlast ), abs ( t_want ))) if ( abs ( t_want - comm % tlast ) < hmin ) then ier = fatal ; nrec = 4 ; write ( comm % rec , \"(a/a/a/a,e13.5,a)\" ) & \" ** You have made a call to RANGE_INTEGRATE with a T_WANT that is not\" ,& \" ** sufficiently different from the last value of T_GOT (T_START on the\" ,& \" ** first call). When using METHOD = 'H', it must differ by at least \" ,& \" ** \" , HMIN , \".\" exit body end if ! !  We have a valid T_WANT. There is no interpolation with this METHOD and !  therefore we step to T_WANT exactly by resetting T_END with a call to !  RESET_T_END. On the first step this matter is handled differently as !  explained above. ! if (. not . comm % at_t_start ) then call reset_t_end ( comm , t_want ) baderr = get_saved_fatal_r1 ( comm ) if ( baderr ) exit body end if end if ! !  Process output, decide whether to take another step. ! proceed : do ! if ( comm % intrp_able ) then ! !  Interpolation is possible with this METHOD.  The integration has !  already reached T. If this is past T_WANT, GOBACK is set .TRUE. and !  the answers are obtained by interpolation. ! goback = comm % dir * ( comm % t - t_want ) >= zero if ( goback ) then call interpolate ( comm , f , t_want , y_got , yderiv_got ) baderr = get_saved_fatal_r1 ( comm ) if ( baderr ) exit body t_got = t_want end if else ! !  Interpolation is not possible with this METHOD, so output is obtained !  by integrating to T_WANT = T_END.  Both Y_GOT and YDERIV_GOT are then !  already loaded with the solution at T_WANT by STEP_INTEGRATE. ! goback = comm % t == t_want if ( goback ) t_got = t_want end if ! !  If done, go to the exit point. if ( goback ) exit body ! !  Take a step with STEP_INTEGRATE in the direction of T_END.  On exit, the !  solution is advanced to T_NOW.  The approximate solution at T_NOW is !  available in Y_GOT.  If output is obtained by stepping to the end (T_NOW !  = T_WANT = T_END), Y_GOT can be returned directly.  If output is !  obtained by interpolation, the subroutine INTERPOLATE that does this uses !  the values in COMM for its computations and places the approximate solution !  at T_WANT in the arrays Y_GOT,YDERIV_GOT for return to the calling !  program. T_NOW is output from STEP_INTEGRATE and is actually a copy of T !  from inside COMM. call step_integrate ( comm , f , t_now , y_got , yderiv_got , step_flag ) ier = step_flag ! !  A successful step by STEP_INTEGRATE is indicated by step_flag= 1. ! select case ( step_flag ) case ( 1 ); cycle proceed case ( 2 ); nrec = 4 ; write ( comm % rec , \"(a/a/a/a)\" ) & \" ** The last message was produced on a call to STEP_INTEGRATE from\" ,& \" ** RANGE_INTEGRATE. In RANGE_INTAGRATE the appropriate action is to\" ,& \" ** change to METHOD = 'M', or, if insufficient memory is available,\" ,& \" ** to METHOD = 'L'. \" case ( 3 : 6 ); nrec = 2 ; write ( comm % rec , \"(a)\" ) & \" ** The last message was produced on a call to STEP_INTEGRATE from\" ,& \" ** RANGE_INTEGRATE.\" case default ; baderr = . true . end select t_got = comm % t ; exit body end do proceed ! end do body ! if ( baderr ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a)\" ) & \" ** An internal call by RANGE_INTEGRATE to a subroutine resulted in an\" ,& \" ** error that should not happen. Check your program carefully for array\" ,& \" ** sizes, correct number of arguments, type mismatches ... .\" end if ! comm % tlast = t_got ! !  All exits are done here after a call to RKMSG_R1 to report !  what happened ! call rkmsg_r1 ( ier , srname , nrec , comm , flag ) ! end subroutine range_integrate_r1 recursive subroutine step_integrate_r1 ( comm , f , t_now , y_now , yderiv_now , flag ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( out ) :: t_now !indep! integer , intent ( out ), optional :: flag type ( rk_comm_real_1d ), intent ( inout ) :: comm real ( kind = wp ), dimension (:), intent ( out ) :: y_now , yderiv_now !dep! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! character ( len =* ), parameter :: srname = \"STEP_INTEGRATE\" ! real ( kind = wp ) :: hmin , htry !indep! real ( kind = wp ) :: alpha , beta , err , tau , t1 , t2 , ypnorm , extra_wk integer :: ier , nrec , state logical :: failed , phase1 , phase3 , toomch , sure_stiff ! integer , parameter :: not_ready =- 1 , usable =- 2 , fatal = 911 , catastrophe = 912 , & max_f_count = 5000 , just_fine = 1 logical , parameter :: tell = . false ., ask = . true . real ( kind = wp ), parameter :: zero = 0.0_wp , pt1 = 0.1_wp , pt9 = 0.9_wp , one = 1.0_wp , & two = 2.0_wp , hundrd = 10 0.0_wp ! ier = just_fine ; nrec = 0 ! !  Is it permissible to call STEP_INTEGRATE? ! body : do state = get_saved_state_r1 ( \"SETUP\" , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( state == not_ready ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** You have not called SETUP, so you cannot use STEP_INTEGRATE.\" exit body end if if ( comm % use_range ) then if ( get_saved_state_r1 ( \"RANGE_INTEGRATE\" , comm % save_states ) /= usable ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have called STEP_INTEGRATE after you specified in SETUP that you\" , & \" ** were going to use RANGE_INTEGRATE. This is not permitted.\" comm % use_range = . false . exit body end if end if state = get_saved_state_r1 ( srname , comm % save_states ) if ( state == 5 . or . state == 6 ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a)\" ) & \" ** STEP_INTEGRATE has already returned with a flag value of 5 or 6. You\" ,& \" ** cannot continue integrating this problem. You must call SETUP to start \" ,& \" ** another problem.\" exit body end if ! if ( comm % at_t_start ) then ! comm % yp = f ( comm % t , comm % y ); comm % f_count = comm % f_count + 1 if ( comm % erason ) comm % ge_yp = comm % yp ! !  The weights for the control of the error depend on the size of the !  solution at the beginning and at the end of the step. On the first !  step we do not have all this information. Whilst determining the !  initial step size we initialize each component of WEIGHTS to the !  larger of the corresponding component of both abs(Y) and the threshold. ! comm % weights = max ( abs ( comm % y ), comm % thresh ) ! !  If H_START is equal to zero, the code is to find an on-scale initial !  step size H.  STEP_INTEGRATE has an elaborate scheme of three phases for !  finding such an H, and some preparations are made earlier.  In SETUP an !  upper bound is placed on H that reflects the scale of the independent !  variable.  RANGE_INTEGRATE, when used, refines this bound using the !  first output point.  Here in STEP_INTEGRATE PHASE1 applies a rule of !  thumb based on the error control, the order of the the formula, and the !  size of the initial slope to get a crude approximation to an on-scale H. !  PHASE2 may reduce H in the course of taking the first step.  PHASE3 !  repeatedly adjusts H and retakes the first step until H is on scale. ! !  A guess for the magnitude of the first step size H can be provided to SETUP !  as H_START.  If it is too big or too small, it is ignored and the automatic !  determination of an on-scale initial step size is activated.  If it is !  acceptable, H is set to H_START in SETUP.  Even when H is supplied to !  STEP_INTEGRATE, PHASE3 of the scheme for finding an on-scale initial step !  size is made active so that the code can deal with a bad guess. ! phase1 = comm % h_start == zero ; comm % phase2 = phase1 ; phase3 = . true . if ( phase1 ) then comm % h = abs ( comm % h ) ypnorm = max ( zero , & maxval ( abs ( comm % yp ) / comm % weights , mask = comm % y /= zero )) !spec-ar1! tau = comm % tol ** comm % expon if ( comm % h * ypnorm > tau ) comm % h = tau / ypnorm hmin = max ( comm % sqtiny , comm % toosml * & max ( abs ( comm % t_start ), abs ( comm % t_end ))) comm % h = comm % dir * max ( comm % h , hmin ) phase1 = . false . end if ! else ! ! Continuation call ! if ( comm % at_t_end ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a,e13.5,a/a/a)\" ) & \" ** You have already reached T_END ( = \" , comm % t_end , \"). To integrate\" ,& \" ** furhter with the same problem you must call the routine RESET_T_END\" ,& \" ** with a new value of T_END.\" exit body end if end if ! !  Begin computation of a step here. ! failed = . false . ! take_step : do ! comm % h = sign ( abs ( comm % h ), comm % dir ) ! !  Reduce the step size if necessary so that the code will not step !  past T_END.  \"Look ahead\" to prevent unnecessarily small step sizes. ! comm % at_t_end = comm % dir * (( comm % t + comm % h ) - comm % t_end ) >= zero if ( comm % at_t_end ) then comm % h = comm % t_end - comm % t else if ( comm % dir * (( comm % t + two * comm % h ) - comm % t_end ) >= zero ) then comm % h = ( comm % t_end - comm % t ) / two end if ! !  When the integrator is at T and attempts a step of H, the function !  defining the differential equations will be evaluated at a number of !  arguments between T and T+H.  If H is too small, these arguments cannot !  be clearly distinguished in the precision available. ! hmin = max ( comm % sqtiny , comm % toosml * max ( abs ( comm % t ), abs ( comm % t + comm % h ))) if ( abs ( comm % h ) < hmin ) then ier = 5 ; nrec = 3 ; write ( comm % rec , \"(a/a,e13.5,a,e13.5,a/a)\" ) & \" ** In order to satisfy your error requirements STEP_INTEGRATE would have\" ,& \" ** to use a step size of \" , comm % H , \" at T_NOW = \" , comm % T , \" This is too\" ,& \" ** small for the machine precision.\" exit body end if ! !  Monitor the impact of output on the efficiency of the integration. ! if ( comm % chkeff ) then comm % hit_t_end_count = comm % hit_t_end_count + 1 if ( comm % hit_t_end_count >= 100 . and . & comm % hit_t_end_count >= comm % step_count / 3 ) then ier = 2 ; nrec = 5 ; write ( comm % rec , \"(a/a/a/a/a)\" ) & \" ** More than 100 output points have been obtained by integrating to T_END.\" ,& \" ** They have been sufficiently close to one another that the efficiency\" ,& \" ** of the integration has been degraded. It would probably be (much) more\" ,& \" ** efficient to obtain output by interpolating with INTERPOLATE (after\" ,& \" ** changing to METHOD='M' if you are using METHOD = 'H').\" comm % hit_t_end_count = 0 ; exit body end if end if ! !  Check for stiffness and for too much work.  Stiffness can be !  checked only after a successful step. ! if (. not . failed ) then ! !  Check for too much work. toomch = comm % f_count > max_f_count if ( toomch ) then ier = 3 ; nrec = 3 ; write ( comm % rec , \"(a,i6,a/a/a)\" ) & \" ** Approximately \" , max_f_count , \" function evaluations have been used to\" ,& \" ** compute the solution since the integration started or since this\" , & \" ** message was last printed.\" ! !  After this warning message, F_COUNT is reset to permit the integration !  to continue.  The total number of function evaluations in the primary !  integration is FULL_F_COUNT + F_COUNT ! comm % full_f_count = comm % full_f_count + comm % f_count comm % f_count = 0 end if ! !  Check for stiffness.  If stiffness is detected, the message about too !  much work is augmented inside STIFF to explain that it is due to !  stiffness. ! call stiff_r1 ( comm , f , toomch , sure_stiff ) if ( sure_stiff ) then ! !  Predict how much extra work will be needed to reach TND. extra_wk = ( comm % cost * abs (( comm % t_end - comm % t ) / comm % h_average )) / & real ( comm % full_f_count + comm % f_count , kind = wp ) ier = 4 ; nrec = nrec + 4 write ( comm % rec ( nrec - 3 : nrec ), \"(a/a,e13.5,a/a/a)\" ) & \" ** Your problem has been diagnosed as stiff.  If the  situation persists,\" ,& \" ** it will cost roughly \" , extra_wk , \" times as much to reach T_END as it\" , & \" ** has cost to reach T_NOW. You should probably change to a code intended\" ,& \" ** for stiff problems.\" end if if ( ier /= just_fine ) exit body end if ! !  Take a step.  Whilst finding an on-scale H (PHASE2 = .TRUE.), the input !  value of H might be reduced (repeatedly), but it will not be reduced !  below HMIN.  The local error is estimated, a weight vector is formed, !  and a weighted maximum norm, ERR, of the local error is returned. !  The presence of the optional argument PHASE2 in the call to STEP !  indicates that this is the primary integration. ! !  H is used by both STEP_INTEGRATE and STEP. Since it may be changed inside !  STEP, a local copy is made. ! htry = comm % h call step_r1 ( comm , f , comm % t , comm % y , comm % yp , comm % stages , comm % tol , htry , & comm % y_new , comm % err_estimates , err , hmin , comm % phase2 ) comm % h = htry ! !  Compare the norm of the local error to the tolerance. ! if ( err > comm % tol ) then ! !  Failed step.  Reduce the step size and try again. ! !  First step:  Terminate PHASE3 of the search for an on-scale step size. !               The step size is not on scale, so ERR may not be accurate; !               reduce H by a fixed factor.  Failed attempts to take the !               first step are not counted. !  Later step:  Use ERR to compute an \"optimal\" reduction of H.  More than !               one failure indicates a difficulty with the problem and an !               ERR that may not be accurate, so reduce H by a fixed factor. ! if ( comm % at_t_start ) then phase3 = . false .; alpha = comm % rs1 else comm % bad_step_count = comm % bad_step_count + 1 comm % stiff_bad_step_count = comm % stiff_bad_step_count + 1 if ( failed ) then alpha = comm % rs1 else alpha = comm % safety * ( comm % tol / err ) ** comm % expon alpha = max ( alpha , comm % rs1 ) end if end if comm % h = alpha * comm % h ; failed = . true .; cycle take_step end if ! !  Successful step. ! !  Predict a step size appropriate for the next step.  After the first !  step the prediction can be refined using an idea of H.A. Watts that !  takes account of how well the prediction worked on the previous step. ! beta = ( err / comm % tol ) ** comm % expon if (. not . comm % at_t_start ) then t1 = ( err ** comm % expon ) / comm % h t2 = ( comm % errold ** comm % expon ) / comm % h_old if ( t1 < t2 * hundrd . and . t2 < t1 * hundrd ) beta = beta * ( t1 / t2 ) end if alpha = comm % rs3 if ( comm % safety < beta * alpha ) alpha = comm % safety / beta ! !  On the first step a search is made for an on-scale step size.  PHASE2 !  of the scheme comes to an end here because a step size has been found !  that is both successful and has a credible local error estimate. Except !  in the special case that the first step is also the last, the step is !  repeated in PHASE3 as long as an increase greater than RS2 appears !  possible.  An increase as big as RS3 is permitted.  A step failure !  terminates PHASE3. ! if ( comm % at_t_start ) then comm % phase2 = . false . phase3 = phase3 . and . . not . comm % at_t_end . and . ( alpha > comm % rs2 ) if ( phase3 ) then comm % h = alpha * comm % h ; cycle take_step end if end if ! !  After getting on scale, step size changes are more restricted. ! alpha = min ( alpha , comm % rs ) if ( failed ) alpha = min ( alpha , one ) alpha = max ( alpha , comm % rs1 ) comm % h_old = comm % h ; comm % h = alpha * comm % h ! !  For the diagnosis of stiffness, an average accepted step size, H_AVERAGE, !  must be computed. ! if ( comm % at_t_start ) then comm % h_average = comm % h_old else comm % h_average = pt9 * comm % h_average + pt1 * comm % h_old end if ! comm % at_t_start = . false .; comm % errold = err ; comm % t_old = comm % t ! !  Take care that T is set to precisely T_END when the end of the !  integration is reached. ! if ( comm % at_t_end ) then comm % t = comm % t_end else comm % t = comm % t + comm % h_old end if ! !  Increment counter on accepted steps.  Note that successful steps !  that are repeated whilst getting on scale are not counted. ! comm % step_count = comm % step_count + 1 ! !  Advance the current solution and its derivative. Note that the previous !  derivative will overwrite Y_NEW (see pointer assignments in SETUP). ! comm % y_old = comm % y ; comm % y = comm % y_new comm % yp_old = comm % yp ! if ( comm % fsal ) then ! !  When FSAL = .TRUE., YP is the last stage of the step. ! comm % yp = comm % stages (:, comm % last_stage ) else ! !  Call F to evaluate YP. ! comm % yp = f ( comm % t , comm % y ); comm % f_count = comm % f_count + 1 end if ! !  If global error assessment is desired, advance the secondary !  integration from TOLD to T. ! if ( comm % erason ) then call truerr_r1 ( comm , f , ier ) if ( ier == 6 ) then ! !  The global error estimating procedure has broken down. Treat it as a !  failed step. The solution and derivative are reset to their values at !  the beginning of the step since the last valid error assessment refers !  to them. ! comm % step_count = comm % step_count - 1 ; comm % erasfl = . true . comm % at_t_end = . false . comm % t = comm % t_old ; comm % h = comm % h_old comm % y = comm % y_old ; comm % yp = comm % yp_old if ( comm % step_count > 0 ) then nrec = 2 ; write ( comm % rec , \"(a/a,e13.5/a)\" ) & \" ** The global error assessment may not be reliable for T past \" ,& \" ** T_NOW = \" , comm % t , \". The integration is being terminated.\" exit body else nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** The global error assessment algorithm failed at the start of the \" ,& \" ** integration.  The integration is being terminated.\" exit body end if end if end if exit take_step end do take_step exit body end do body ! !  Exit point for STEP_INTEGRATE !  Set the output variables and flag that interpolation is permitted ! if ( ier < fatal ) then t_now = comm % t ; comm % at_t_end = t_now == comm % t_end comm % chkeff = comm % at_t_end ; y_now = comm % y ; yderiv_now = comm % yp comm % ymax = max ( abs ( comm % y ), comm % ymax ) if ( ier == just_fine ) then state = usable ; call set_saved_state_r1 ( \"INTERPOLATE\" , state , comm ) end if end if ! !  Call RKMSG_R1 to report what happened and set FLAG. ! call rkmsg_r1 ( ier , srname , nrec , comm , flag ) ! end subroutine step_integrate_r1 subroutine truerr_r1 ( comm , f , ier ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ) :: comm integer , intent ( inout ) :: ier ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! real ( kind = wp ) :: hmin , hsec !indep! real ( kind = wp ) :: diff , errmax , mxerlc , tsec , ge_err , ge_test1 , ge_test2 integer :: istep , level ! integer , parameter :: just_fine = 1 real ( kind = wp ), parameter :: pt1 = 0.1_wp , ten = 1 0.0_wp real ( kind = wp ), dimension (:,:), pointer :: ge_stages !dep! real ( kind = wp ), dimension (:), pointer :: ge_y , ge_yp , ge_y_new !dep! real ( kind = wp ), dimension (:), pointer :: ge_err_estimates , y !dep! real ( kind = wp ), dimension (:), pointer :: ge_assess , weights !shp-dep! ! ge_stages => comm % ge_stages ge_y => comm % ge_y ge_yp => comm % ge_yp ge_y_new => comm % ge_y_new ge_err_estimates => comm % ge_err_estimates ge_assess => comm % ge_assess y => comm % y weights => comm % weights ! tsec = comm % t - comm % h_old hsec = comm % h_old / real ( comm % no_of_ge_steps , kind = wp ) hmin = max ( comm % sqtiny , comm % toosml * max ( abs ( tsec ), abs ( comm % t ))) body : do if ( abs ( hsec ) < hmin ) then ier = 6 ; exit body end if ge_test1 = comm % tol / real ( comm % no_of_ge_steps , kind = wp ) ge_test2 = comm % tol / ten ; level = 0 ! !  The subroutine STEP is used to take a step. ! !  Perform secondary integration. ! do istep = 1 , comm % no_of_ge_steps ! !  Take a step. call step_r1 ( comm , f , tsec , ge_y , ge_yp , ge_stages , ge_test1 , hsec , ge_y_new , & ge_err_estimates , ge_err ) ! !  The primary integration is using a step size of H_OLD and the !  secondary integration is using the smaller step size !      HSEC = H_OLD/(NO_OF_GE_STEPS). !  If steps of this size were taken from the same starting point and the !  asymptotic behavior were evident, the smaller step size would result in !  a local error that is considerably smaller, namely by a factor of !  1/(NO_OF_GE_STEPSSEC**(ORDER+1)).  If the two approximate solutions are !  close and TOL is neither too large nor too small, this should be !  approximately true.  The step size is chosen in the primary integration !  so that the local error ERR is no larger than TOL.  The local error, !  GE_ERR, of the secondary integration is compared to TOL in an attempt to !  diagnose a secondary integration that is not rather more accurate than !  the primary integration. ! if ( ge_err >= ge_test1 ) then level = 2 else if ( ge_err > ge_test2 ) then level = level + 1 end if if ( level >= 2 ) then ier = 6 ; exit body end if ! !  Advance TSEC and the dependent variables GE_Y and GE_YP. ! tsec = comm % t - real ( comm % no_of_ge_steps - istep , kind = wp ) * hsec ge_y = ge_y_new ! if ( comm % fsal ) then ! !  When FSAL = .TRUE., the derivative GE_YP is the last stage of the step. ! ge_yp = ge_stages (:, comm % last_stage ) else ! !  Call F to evaluate GE_YP. ! ge_yp = f ( tsec , ge_y ); comm % ge_f_count = comm % ge_f_count + 1 end if ! end do ! !  Update the maximum error seen, GE_MAX_CONTRIB, and its location, !  T_GE_MAX_CONTRIB. Use local variables ERRMAX and MXERLC. ! errmax = comm % ge_max_contrib ; mxerlc = comm % t_ge_max_contrib ; diff = maxval ( abs ( ge_y - y ) / weights ) !spec-ar! if ( diff > errmax ) then errmax = diff ; mxerlc = comm % t end if ! !  If the global error is greater than 0.1, the solutions have diverged so !  far that comparing them may not provide a reliable estimate of the global !  error. The test is made before GE_ASSESS and GE_MAX_CONTRIB, !  T_GE_MAX_CONTRIB are updated so that on a failure, they refer to the !  last reliable results. ! if ( errmax > pt1 ) then ier = 6 else comm % ge_max_contrib = errmax ; comm % t_ge_max_contrib = mxerlc ; ge_assess = ge_assess + ( abs ( ge_y - y ) / weights ) ** 2 ier = just_fine end if exit body ! end do body ! end subroutine truerr_r1 subroutine step_r1 ( comm , f , tnow , y , yp , stages , tol , htry , y_new , & errest , err , hmin , phase_2 ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ), target :: comm real ( kind = wp ), intent ( out ) :: err real ( kind = wp ), intent ( inout ) :: htry !indep! real ( kind = wp ), intent ( in ) :: tnow !indep! real ( kind = wp ), intent ( in ) :: tol real ( kind = wp ), intent ( in ), optional :: hmin !indep! logical , intent ( inout ), optional :: phase_2 ! real ( kind = wp ), dimension (:), intent ( in ) :: y , yp !dep! real ( kind = wp ), dimension (:), intent ( out ) :: errest , y_new !dep! real ( kind = wp ), dimension (:,:), intent ( out ) :: stages !dep! ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! real ( kind = wp ) :: tstg !indep! integer :: i , j logical :: cutbak , main ! intrinsic abs , max , sign ! real ( kind = wp ), dimension (:), pointer :: weights , thresh !shp-dep! real ( kind = wp ), dimension (:,:), pointer :: a !real! real ( kind = wp ), dimension (:), pointer :: b , bhat , c !real! integer , dimension (:), pointer :: ptr !integer! ! real ( kind = wp ), parameter :: zero = 0.0_wp , half = 0.5_wp , one = 1.0_wp ! !  ERREST is used for working storage in this computation. ! weights => comm % weights thresh => comm % thresh a => comm % a b => comm % b bhat => comm % bhat c => comm % c ptr => comm % ptr ! main = present ( hmin ) . and . present ( phase_2 ) attempt_step : do ! if ( main ) then if ( comm % phase2 ) weights = max ( thresh , abs ( y )) end if ! do i = 2 , comm % no_of_stages errest = a ( i , 1 ) * yp do j = 2 , i - 1 if ( a ( i , j ) /= zero ) errest = errest + a ( i , j ) * stages (:, ptr ( j )) end do y_new = y + htry * errest ! !  METHOD = 'M' is special in that an estimate of the local error can be !  formed before the step is completed.  If the step is a failure, !  return immediately.  Otherwise, complete the step and compute a more !  accurate error estimate. ! if ( comm % rk_method == 2 . and . i == 7 ) then call stepb if ( err > tol ) return end if ! tstg = tnow + c ( i ) * htry if ( main . and . comm % at_t_end . and . c ( i ) == one ) tstg = comm % t_end stages (:, ptr ( i )) = f ( tstg , y_new ) ! !  Increment the counter for the number of function evaluations !  depending on whether the primary or secondary integration is taking !  place. ! if ( main ) then comm % f_count = comm % f_count + 1 else comm % ge_f_count = comm % ge_f_count + 1 end if ! !  When PHASE2 is .TRUE. we are in the second phase of the automatic !  selection of the initial step size.  The results of the first three !  stages are monitored in the subroutine STEPA for evidence that H is !  too large -- instability and/or an unreliable estimate of the error !  of the step is then possible.  When the subroutine believes H to be !  too large, it returns CUTBAK = .TRUE. and a suitably reduced H for !  another try. ! if ( main ) then if ( phase_2 ) then if ( i <= 3 . and . abs ( htry ) > hmin ) then call stepa ( stages (:, ptr ( i )), htry , cutbak ) if ( cutbak ) then comm % at_t_end = . false . ! !  Make sure that STEPA does not reduce the step size below the !  minimum. If it does, reset H to HMIN and deactivate PHASE2. ! if ( abs ( htry ) <= hmin ) then htry = sign ( hmin , htry ); comm % phase2 = . false . end if cycle attempt_step end if end if end if end if ! end do ! !  Some formulas are constructed so that the last stage represents !  the result of the step (FSAL=.TRUE.), hence if the step is acceptable, !  it will be the first stage for the next step. When FSAL=.FALSE., we !  have to complete the computation of the step. ! if (. not . comm % fsal ) then errest = bhat ( 1 ) * yp do i = 2 , comm % no_of_stages if ( bhat ( i ) /= zero ) errest = errest + bhat ( i ) * stages (:, ptr ( i )) end do y_new = y + htry * errest end if ! !  Form an estimate of the error in the lower order formula by comparing !  it to the higher order formula of the pair. ERREST has been used !  as working storage above.  The higher order approximation has been !  formed as Y_NEW = Y + HTRY*ERREST where ERREST is a linear !  combination of the stages of the formula. The lower order result also !  has the form Y plus HTRY times a different linear combination of !  the stages. Hence, this different linear combination of stages for !  the lower order formula can just be subtracted from the combination !  stored in ERREST to produce the errors. The result is then !  multiplied by HTRY to obtain the error estimate. ! if ( b ( 1 ) /= zero ) errest = errest - b ( 1 ) * yp do i = 2 , comm % no_of_stages if ( b ( i ) /= zero ) errest = errest - b ( i ) * stages (:, ptr ( i )) end do errest = htry * errest ! !  The error in a solution component is measured relative to a weight !  that is the larger of a threshold and the size of the solution over !  the step.  Using the magnitude of a solution component at both ends !  of the step in the definition of \"size\" increases the robustness of !  the test. When global error estimation is specified, the weight !  vector WEIGHTS is defined by the primary integration and is then !  used in the secondary integration. ! if ( main ) weights = max ( half * ( abs ( y ) + abs ( y_new )), thresh ) ! err = maxval ( abs ( errest / weights )) !spec-ar! ! exit attempt_step ! end do attempt_step ! contains ! subroutine stepa ( ypnew , htry , cutbak ) ! real ( kind = wp ), intent ( inout ) :: htry !indep! real ( kind = wp ), dimension (:), intent ( in ) :: ypnew !dep! logical , intent ( out ) :: cutbak ! real ( kind = wp ) :: argdif , fdiff , scl , tdiff , twt , ynrm , ystgnm ! !  Update the weights to account for the current intermediate solution !  approximation Y_NEW.  Compute the sizes of Y and Y_NEW in the !  new norm.  The size of the Lipschitz constant is assessed by a difference !  in the arguments Y, Y_NEW and a difference in the function evaluated !  at these arguments. ! weights = max ( weights , abs ( y_new )) ynrm = maxval ( abs ( y ) / weights ) !spec-ar! ystgnm = maxval ( abs ( y_new ) / weights ) !spec-ar! argdif = maxval ( abs ( y_new - y ) / weights ) !spec-ar! fdiff = maxval ( abs ( ypnew - yp ) / weights ) !spec-ar! ! !  The transformation of the equation to autonomous form is done !  implicitly.  The difference of the arguments must take into account !  the difference between the values of the independent variable T and !  TSTG. The difference of the corresponding component of the function !  is zero because of the way the standard transformation is done. ! tdiff = tstg - tnow twt = abs ( comm % t_end - tnow ) ynrm = max ( ynrm , abs ( tnow ) / twt ) ystgnm = max ( ystgnm , abs ( tstg ) / twt ) argdif = max ( argdif , abs ( tdiff ) / twt ) ! !  The ratio FDIFF/ARGDIF is a lower bound for, and an approximation to, !  a Lipschitz constant L for the differential equation written in !  autonomous form.  First we must ask if the difference ARGDIF is !  significant in the precision available.  If it appears to be, we insist !  that abs(HTRY)*L be less than an approximate radius, STABILITY_RADIUS, !  of the stability region of the method.  This is more stringent than !  necessary for stability, possibly a lot more stringent, but the aim is !  to get an HTRY small enough that the error estimate for the step is !  credible.  The reduction is required to be at least as much as the step !  control parameter RS1. It is necessary to limit the reduction of HTRY !  at any one time because we may be misled in the size of the reduction !  that is appropriate due to nonlinearity of the differential equation !  and to inaccurate weights caused by HTRY much too large.  The reduction !  is not permitted to be more than the step control parameter RS4. ! cutbak = . false . if ( argdif > comm % round_off * max ( ynrm , ystgnm )) then if (( abs ( htry ) * fdiff ) > ( comm % stability_radius * argdif )) then scl = max ( comm % rs4 , min ( comm % rs1 , & ( comm % stability_radius * argdif ) / ( abs ( htry ) * fdiff ))) htry = scl * htry ; cutbak = . true . end if end if ! end subroutine stepa ! subroutine stepb ! real ( kind = wp ), dimension (:), pointer :: e !real! ! e => comm % e ! if ( main ) then err = maxval ( abs ( e ( 1 ) * yp + e ( 3 ) * stages (:, ptr ( 3 )) + & !spec-ar! e ( 4 ) * stages (:, ptr ( 4 )) + e ( 5 ) * stages (:, ptr ( 5 )) + & e ( 6 ) * stages (:, ptr ( 6 )) ) / & max ( half * ( abs ( y ) + abs ( y_new )), thresh ) ) else err = maxval ( abs ( e ( 1 ) * yp + e ( 3 ) * stages (:, ptr ( 3 )) + & !spec-ar! e ( 4 ) * stages (:, ptr ( 4 )) + e ( 5 ) * stages (:, ptr ( 5 )) + & e ( 6 ) * stages (:, ptr ( 6 )) ) / weights ) end if ! err = abs ( comm % h ) * err ! end subroutine stepb ! end subroutine step_r1 subroutine stiff_r1 ( comm , f , toomch , sure_stiff ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ), target :: comm logical , intent ( in ) :: toomch logical , intent ( out ) :: sure_stiff ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! logical :: maybe_stiff , lots_of_fails ! real ( kind = wp ) :: alpha1 , alpha2 , beta1 , beta2 !dep! real ( kind = wp ) :: rold , v1v0 , v2v0 , v2v1 , v3v1 , v3v2 !dep! real ( kind = wp ) :: dist , res2 , scale , v0nrm , v3nrm , ynrm , rho , v0v0 , v1v1 , & v2v2 , v3v3 , yy , det1 , det2 integer :: ntry complex ( kind = wp ), dimension ( 2 ) :: root_pair , prv_root_pair integer , parameter :: bigr = 1 , smlr = 2 real ( kind = wp ), dimension (:), pointer :: v0 , v1 , v2 , v3 , y , y_old !dep! real ( kind = wp ), dimension (:), pointer :: weights , thresh !shp-dep! ! integer , parameter :: max_f_count = 5000 real ( kind = wp ), parameter :: zero = 0.0_wp , pt001 = 0.001_wp , pt9 = 0.9_wp , & fifth = 0.2_wp , half = 0.5_wp , one = 1.0_wp , two = 2.0_wp , five = 5.0_wp , & large = 1.0e+10_wp ! v0 => comm % v0 v1 => comm % v1 v2 => comm % v2 v3 => comm % v3 weights => comm % weights thresh => comm % thresh y => comm % y y_old => comm % y_old ! sure_stiff = . false . lots_of_fails = . false . ! if ( mod ( comm % step_count - 10 , 40 ) == 0 ) then lots_of_fails = comm % stiff_bad_step_count >= 10 comm % stiff_bad_step_count = 0 end if ! !  If either too much work has been done or there are lots of failed steps, !  test for stiffness. ! maybe_stiff = toomch . or . lots_of_fails if ( maybe_stiff ) then ! !  Regenerate weight vector ! weights = max ( half * ( abs ( y ) + abs ( y_old )), thresh ) maybe_stiff = fifth < abs ( comm % h / comm % h_average ) . and . & abs ( comm % h / comm % h_average ) < five if ( maybe_stiff ) then ! !  The average step size is used to predict the cost in function evaluations !  of finishing the integration to T_END.  If this cost is no more than !  MAX_F_COUNT, the problem is declared not stiff. If the step size is !  being restricted on grounds of stability, it will stay close to H_AVERAGE. !  The prediction will then be good, but the cost is too low to consider !  the problem stiff.  If the step size is not close to H_AVERAGE, the !  problem is not stiff.  Either way there is no point to testing for a step !  size restriction due to stability. ! maybe_stiff = comm % cost * abs (( comm % t_end - comm % t ) / comm % h_average ) > & real ( max_f_count , kind = wp ) if ( maybe_stiff ) then ! !  There have been many step failures or a lot of work has been done.  Now !  we must determine if this is due to the stability characteristics of the !  formula.  This is done by calculating the dominant eigenvalues of the !  local Jacobian and then testing whether H_AVERAGE corresponds to being !  on the boundary of the stability region. !  The size of Y provides scale information needed to approximate !  the Jacobian by differences. ! v0v0 = wt_inner_prod ( v0 , v0 ) yy = wt_inner_prod ( y , y ) ynrm = sqrt ( yy ) scale = ynrm * comm % sqrrmc if ( scale == zero ) then ! !  Degenerate case.  Y is (almost) the zero vector so the scale is not !  defined.  The input vector V0 is the difference between Y and a !  lower order approximation to the solution that is within the error !  tolerance.  When Y vanishes, V0 is itself an acceptable approximate !  solution, so we take SCALE from it, if this is possible. ! scale = v0v0 * comm % sqrrmc maybe_stiff = scale > zero end if end if end if end if ! if (. not . maybe_stiff ) return ! if ( v0v0 == zero ) then ! !  Degenerate case.  V0 is (almost) the zero vector so cannot !  be used to define a direction for an increment to Y.  Try a !  \"random\" direction. ! v0 = one ; v0v0 = wt_inner_prod ( v0 , v0 ) end if ! v0nrm = sqrt ( v0v0 ) v0 = v0 / v0nrm ; v0v0 = one ! !  Use a nonlinear power method to estimate the two dominant eigenvalues. !  V0 is often very rich in the two associated eigenvectors.  For this !  reason the computation is organized with the expectation that a minimal !  number of iterations will suffice.  Indeed, it is necessary to recognize !  a kind of degeneracy when there is a dominant eigenvalue.  The function !  DOMINANT_EIGENVALUE does this.  In the first try, NTRY = 1, a Rayleigh !  quotient for such an eigenvalue is initialized as ROLD.  After each !  iteration, DOMINANT_EIGENVALUE computes a new Rayleigh quotient and !  tests whether the two approximations agree to one tenth of one per cent !  and the eigenvalue, eigenvector pair satisfy a stringent test on the !  residual. ! ntry = 1 do ! v1 = approx_jacobian ( f , v0 , v0v0 ) v1v1 = wt_inner_prod ( v1 , v1 ) ! !  The quantity SQRT(V1V1/V0V0) is a lower bound for the product of H_AVERAGE !  and a Lipschitz constant.  If it should be LARGE, stiffness is not !  restricting the step size to the stability region.  The principle is !  clear enough, but the real reason for this test is to recognize an !  extremely inaccurate computation of V1V1 due to finite precision !  arithmetic in certain degenerate circumstances. ! if ( sqrt ( v1v1 ) > large * sqrt ( v0v0 )) return ! v1v0 = wt_inner_prod ( v1 , v0 ) if ( ntry == 1 ) then rold = v1v0 / v0v0 ! !  This is the first Rayleigh quotient approximating the product of H_AVERAGE !  and a dominant eigenvalue.  If it should be very small, the !  problem is not stiff.  It is important to test for this possibility so !  as to prevent underflow and degeneracies in the subsequent iteration. ! if ( abs ( rold ) < comm % cubrmc ) return else ! if ( dominant_eigenvalue ( v1v1 , v1v0 , v0v0 )) exit end if ! v2 = approx_jacobian ( f , v1 , v1v1 ) v2v2 = wt_inner_prod ( v2 , v2 ) v2v0 = wt_inner_prod ( v2 , v0 ) v2v1 = wt_inner_prod ( v2 , v1 ) if ( dominant_eigenvalue ( v2v2 , v2v1 , v1v1 )) exit ! !  Fit a quadratic in the eigenvalue to the three successive iterates !  V0,V1,V2 of the power method to get a first approximation to !  a pair of eigenvalues.  A test made earlier in DOMINANT_EIGENVALUE !  implies that the quantity DET1 here will not be too small. ! det1 = v0v0 * v1v1 - v1v0 * rev_wt_inner_prod ( v1v0 ) alpha1 = ( - v0v0 * v2v1 + rev_wt_inner_prod ( v1v0 ) * v2v0 ) / det1 beta1 = ( v1v0 * v2v1 - v1v1 * v2v0 ) / det1 ! !  Iterate again to get V3, test again for degeneracy, and then fit a !  quadratic to V1,V2,V3 to get a second approximation to a pair !  of eigenvalues. ! v3 = approx_jacobian ( f , v2 , v2v2 ) v3v3 = wt_inner_prod ( v3 , v3 ) v3v1 = wt_inner_prod ( v3 , v1 ) v3v2 = wt_inner_prod ( v3 , v2 ) if ( dominant_eigenvalue ( v3v3 , v3v2 , v2v2 )) exit ! det2 = v1v1 * v2v2 - v2v1 * rev_wt_inner_prod ( v2v1 ) alpha2 = ( - v1v1 * v3v2 + rev_wt_inner_prod ( v2v1 ) * v3v1 ) / det2 beta2 = ( v2v1 * v3v2 - v2v2 * v3v1 ) / det2 ! !  First test the residual of the quadratic fit to see if we might !  have determined a pair of eigenvalues. ! res2 = abs ( v3v3 + rev_wt_inner_prod ( alpha2 ) * v3v2 + & rev_wt_inner_prod ( beta2 ) * v3v1 + & alpha2 * rev_wt_inner_prod ( v3v2 ) + & alpha2 * rev_wt_inner_prod ( alpha2 ) * v2v2 + & alpha2 * rev_wt_inner_prod ( beta2 ) * v2v1 + & beta2 * rev_wt_inner_prod ( v3v1 ) + & beta2 * rev_wt_inner_prod ( alpha2 ) * rev_wt_inner_prod ( v2v1 ) + & beta2 * rev_wt_inner_prod ( beta2 ) * v1v1 ) if ( res2 <= abs ( v3v3 ) * pt001 ** 2 ) then ! !  Calculate the two approximate pairs of eigenvalues. ! prv_root_pair ( 1 : 2 ) = quadratic_roots ( alpha1 , beta1 ) root_pair ( 1 : 2 ) = quadratic_roots ( alpha2 , beta2 ) ! !  The test for convergence is done on the larger root of the second !  approximation.  It is complicated by the fact that one pair of roots !  might be real and the other complex.  First calculate the spectral !  radius RHO of HAVG*J as the magnitude of ROOT1.  Then see if one of !  the roots R1,R2 is within one per cent of ROOT1.  A subdominant root !  may be very poorly approximated if its magnitude is much smaller than !  RHO -- this does not matter in our use of these eigenvalues. ! rho = abs ( prv_root_pair ( bigr )) dist = min ( abs ( root_pair ( bigr ) - prv_root_pair ( bigr )), & abs ( root_pair ( bigr ) - prv_root_pair ( smlr )) ) if ( dist <= pt001 * rho ) exit end if ! !  Do not have convergence yet.  Because the iterations are cheap, and !  because the convergence criterion is stringent, we are willing to try !  a few iterations. ! ntry = ntry + 1 if ( ntry > comm % max_stiff_iters ) return v3nrm = sqrt ( v3v3 ) v0 = v3 / v3nrm v0v0 = one ! end do ! !  We now have the dominant eigenvalues.  Decide if the average step !  size is being restricted on grounds of stability.  Check the real !  parts of the eigenvalues.  First see if the dominant eigenvalue is !  in the left half plane -- there won't be a stability restriction !  unless it is. If there is another eigenvalue of comparable magnitude !  with a positive real part, the problem is not stiff. If the dominant !  eigenvalue is too close to the imaginary axis, we cannot diagnose !  stiffness. ! if ( real ( root_pair ( bigr )) < zero ) then if ( . not . ( abs ( root_pair ( smlr )) >= pt9 * rho . and . & real ( root_pair ( smlr )) > zero ) ) then if ( abs ( aimag ( root_pair ( bigr ))) <= & abs ( real ( root_pair ( bigr ))) * comm % tan_angle ) then ! !  If the average step size corresponds to being well within the !  stability region, the step size is not being restricted because !  of stability. ! sure_stiff = rho >= pt9 * comm % stability_radius end if end if end if ! contains function approx_jacobian ( f , v , vdotv ) ! real ( kind = wp ), intent ( in ) :: vdotv real ( kind = wp ), dimension (:), intent ( in ) :: v !dep! real ( kind = wp ), dimension ( size ( v , 1 )) :: approx_jacobian !dep! ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! real ( kind = wp ) :: temp1 ! !  Scale V so that it can be used as an increment to Y !  for an accurate difference approximation to the Jacobian. ! temp1 = scale / sqrt ( vdotv ) comm % vtemp = y + temp1 * v ! approx_jacobian = f ( comm % t , comm % vtemp ) comm % f_count = comm % f_count + 1 ! !  Form the difference approximation.  At the same time undo !  the scaling of V and introduce the factor of H_AVERAGE. ! approx_jacobian = & ( comm % h_average / temp1 ) * ( approx_jacobian - comm % yp ) ! end function approx_jacobian function quadratic_roots ( alpha , beta ) ! real ( kind = wp ), intent ( in ) :: alpha , beta !dep! complex ( kind = wp ), dimension ( 2 ) :: quadratic_roots ! complex ( kind = wp ) :: temp , sqdisc , r1 , r2 ! !  For types other than real/complex, this procedure must be constructed !  such that temp and sqdisc are evaluated as compelx quantities ! temp = alpha / two ; sqdisc = sqrt ( temp ** 2 - beta ) ! ! Do we have double root? ! if ( sqdisc == zero ) then quadratic_roots = ( / - temp , - temp / ) ! ! Distinct roots ! else r1 = - temp + sqdisc ; r2 = - temp + sqdisc if ( abs ( r1 ) > abs ( r2 )) then quadratic_roots = ( / r1 , r2 / ) else quadratic_roots = ( / r2 , r1 / ) end if end if ! end function quadratic_roots function dominant_eigenvalue ( v1v1 , v1v0 , v0v0 ) ! real ( kind = wp ), intent ( in ) :: v0v0 , v1v1 real ( kind = wp ), intent ( in ) :: v1v0 !dep! logical :: dominant_eigenvalue ! real ( kind = wp ) :: ratio !dep! real ( kind = wp ) :: res , det logical :: big ! ratio = v1v0 / v0v0 ; rho = abs ( ratio ) det = v0v0 * v1v1 - v1v0 * rev_wt_inner_prod ( v1v0 ); res = abs ( det / v0v0 ) ! big = det == zero . or . & ( res <= abs ( v1v1 ) * pt001 ** 2 . and . abs ( ratio - rold ) <= pt001 * rho ) ! if ( big ) then root_pair ( bigr ) = cmplx ( ratio ) root_pair ( smlr ) = cmplx ( zero ) end if ! rold = ratio dominant_eigenvalue = big ! end function dominant_eigenvalue function wt_inner_prod ( vec_1 , vec_2 ) ! real ( kind = wp ), dimension (:), intent ( in ) :: vec_1 , vec_2 !dep! real ( kind = wp ) :: wt_inner_prod !dep! ! ! wt_inner_prod = sum ( ( vec_1 / weights ) * ( vec_2 / weights ) ) !spec-ar! ! end function wt_inner_prod function rev_wt_inner_prod ( value ) ! real ( kind = wp ), intent ( in ) :: value !dep! real ( kind = wp ) :: rev_wt_inner_prod !dep! ! ! given result of inner product value = v1.v0 ! must return the reverse, ie v0.v1 ! ! for real variables the value is the same ! for complex need to conjugate ! rev_wt_inner_prod = value !spec-line! ! end function rev_wt_inner_prod end subroutine stiff_r1 subroutine statistics_r1 ( comm , total_f_calls , step_cost , waste , num_succ_steps ,& h_next , y_maxvals ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ) :: comm real ( kind = wp ), optional , intent ( out ) :: h_next !indep! real ( kind = wp ), optional , intent ( out ) :: waste real ( kind = wp ), dimension (:), optional , intent ( out ) :: y_maxvals !shp-dep! integer , optional , intent ( out ) :: step_cost , num_succ_steps , total_f_calls ! character ( len =* ), parameter :: srname = \"STATISTICS\" ! integer :: ier , nrec , state ! integer , parameter :: not_ready =- 1 , not_reusable =- 3 , fatal = 911 , & catastrophe = 912 , just_fine = 1 logical , parameter :: ask = . true . real ( kind = wp ), parameter :: zero = 0.0_wp ! ier = just_fine ; nrec = 0 ! body : do ! !  Is it permissible to call STATISTICS? ! state = get_saved_state_r1 ( srname , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( state == not_reusable ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have already made a call to STATISTICS after a hard failure was \" , & \" ** reported from the integrator. You cannot call STATISTICS again.\" exit body end if state = get_saved_state_r1 ( \"STEP_INTEGRATE\" , comm % save_states ) if ( state == not_ready ) then ier = fatal ; nrec = 1 if ( comm % use_range ) then write ( comm % rec , \"(a)\" ) & \" ** You have not called RANGE_INTEGRATE, so you cannot use STATISTICS.\" else write ( comm % rec , \"(a)\" ) & \" ** You have not called STEP_INTEGRATE, so you cannot use STATISTICS.\" end if exit body end if if ( present ( y_maxvals )) then if ( any ( shape ( y_maxvals ) /= shape ( comm % y ))) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,i6,a/a,i6,a)\" ) & \" ** The shape of Y_MAXVALS is not consistent with the shape of the\" , & \" ** dependent variables.\" exit body end if end if ! !  Set flag so that the routine can only be called once after a hard !  failure from the integrator. ! if ( state == 5 . or . state == 6 ) ier = not_reusable ! if ( present ( total_f_calls )) then total_f_calls = comm % full_f_count + comm % f_count !      if (comm%erason) total_f_calls = total_f_calls + comm%ge_f_count end if if ( present ( step_cost )) step_cost = comm % cost if ( present ( num_succ_steps )) num_succ_steps = comm % step_count if ( present ( waste )) then if ( comm % step_count <= 1 ) then waste = zero else waste = real ( comm % bad_step_count , kind = wp ) / & real ( comm % bad_step_count + comm % step_count , kind = wp ) end if end if if ( present ( h_next )) h_next = comm % h if ( present ( y_maxvals )) y_maxvals = comm % ymax exit body end do body ! call rkmsg_r1 ( ier , srname , nrec , comm ) ! end subroutine statistics_r1 subroutine global_error_r1 ( comm , rms_error , max_error , t_max_error ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ) :: comm real ( kind = wp ), optional , intent ( out ) :: max_error real ( kind = wp ), optional , intent ( out ) :: t_max_error !indep! real ( kind = wp ), dimension (:), optional , intent ( out ) :: rms_error !shp-dep! ! character ( len =* ), parameter :: srname = \"GLOBAL_ERROR\" ! integer :: ier , nrec , state ! intrinsic sqrt ! integer , parameter :: not_ready =- 1 , not_reusable =- 3 , fatal = 911 , & catastrophe = 912 , just_fine = 1 logical , parameter :: ask = . true . ! ier = just_fine ; nrec = 0 ! body : do ! !  Is it permissible to call GLOBAL_ERROR? ! state = get_saved_state_r1 ( srname , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( state == not_reusable ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have already made a call to GLOBAL_ERROR after a hard failure was\" , & \" ** reported from the integrator. You cannot call GLOBAL_ERROR again.\" exit body end if state = get_saved_state_r1 ( \"STEP_INTEGRATE\" , comm % save_states ) if ( state == not_ready ) then ier = fatal ; nrec = 1 if ( comm % use_range ) then write ( comm % rec , \"(a)\" ) & \" ** You have not yet called RANGE_INTEGRATE, so you cannot call GLOBAL_ERROR.\" else write ( comm % rec , \"(a)\" ) & \" ** You have not yet called STEP_INTEGRATE, so you cannot call GLOBAL_ERROR.\" end if exit body end if ! !  Set flag so that the routine can only be called once after a hard !  failure from the integrator. ! if ( state == 5 . or . state == 6 ) ier = not_reusable ! !  Check that ERROR_ASSESS was set properly for error assessment in SETUP. ! if (. not . comm % erason ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a)\" ) & \" ** No error assessment is available since you did not ask for it in your\" ,& \" ** call to the routine SETUP. Check your program carefully.\" exit body end if ! ! Check size of RMS_ERROR ! if ( present ( rms_error )) then if ( any ( shape ( rms_error ) /= shape ( comm % y ))) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,a)\" ) & \" ** The shape of RMS_ERROR is not consistent with the shape of the\" , & \" ** dependent variables.\" exit body end if end if ! !  Check to see if the integrator has not actually taken a step. ! if ( comm % step_count == 0 ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** The integrator has not actually taken any successful steps. You cannot\" ,& \" ** call GLOBAL_ERROR in this circumstance. Check your program carefully.\" exit body end if ! !  Compute RMS error and set output variables. ! if ( present ( max_error )) max_error = comm % ge_max_contrib if ( present ( t_max_error )) t_max_error = comm % t_ge_max_contrib if ( present ( rms_error )) rms_error = & sqrt ( comm % ge_assess / real ( comm % step_count , kind = wp )) ! exit body end do body ! call rkmsg_r1 ( ier , srname , nrec , comm ) ! end subroutine global_error_r1 subroutine reset_t_end_r1 ( comm , t_end_new ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( in ) :: t_end_new !indep! type ( rk_comm_real_1d ), intent ( inout ) :: comm ! character ( len =* ), parameter :: srname = \"RESET_T_END\" ! real ( kind = wp ) :: hmin , tdiff !indep! integer :: ier , nrec , state ! integer , parameter :: not_ready =- 1 , usable =- 2 , fatal = 911 , catastrophe = 912 , & just_fine = 1 logical , parameter :: ask = . true . real ( kind = wp ), parameter :: zero = 0.0_wp ! ier = just_fine ; nrec = 0 ! !  Is it permissible to call RESET_T_END? ! body : do ! state = get_saved_state_r1 ( \"STEP_INTEGRATE\" , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( comm % use_range ) then if ( get_saved_state_r1 ( \"RANGE_INTEGRATE\" , comm % save_states ) /= usable ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have called RESET_T_END after you specified to SETUP that you were\" ,& \" ** going to use RANGE_INTEGRATE. This is not permitted.\" exit body end if end if if ( state == not_ready ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** You have not called STEP_INTEGRATE, so you cannot use RESET_T_END.\" exit body end if if ( state == 5 . or . state == 6 ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,i1,a/a)\" ) & \" ** STEP_INTEGRATE has returned with FLAG =  \" , STATE , \" You cannot call\" ,& \" ** RESET_T_END inthis circumstance.\" exit body end if ! !  Check value of T_END_NEW ! if ( comm % dir > zero . and . t_end_new <= comm % t ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a,e13.5/a,e13.5,a)\" ) & \" ** Integration is proceeding in the positive direction. The current value\" ,& \" ** for the independent variable is \" , comm % T , \" and you have set T_END_NEW =\" ,& \" ** \" , T_END_NEW , \".  T_END_NEW must be greater than T.\" exit body else if ( comm % dir < zero . and . t_end_new >= comm % t ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a,e13.5/a,e13.5,a)\" ) & \" ** Integration is proceeding in the negative direction. The current value\" ,& \" ** for the independent variable is \" , comm % T , \" and you have set T_END_NEW =\" ,& \" ** \" , T_END_NEW , \".  T_END_NEW must be less than T.\" exit body else hmin = max ( comm % sqtiny , comm % toosml * max ( abs ( comm % t ), abs ( t_end_new ))) tdiff = abs ( t_end_new - comm % t ) if ( tdiff < hmin ) then ier = fatal ; nrec = 4 write ( comm % rec , \"(a,e13.5,a/a,e13.5,a/a/a,e13.5,a)\" )& \" ** The current value of the independent variable T is \" , comm % T , \". The\" ,& \" ** T_END_NEW you supplied has ABS(T_END_NEW-T) = \" , TDIFF , \". For the METHOD\" ,& \" ** and the precision of the computer being used, this difference must be\" ,& \" ** at least \" , HMIN , \".\" exit body end if end if ! comm % t_end = t_end_new ; comm % at_t_end = . false . ! exit body end do body ! call rkmsg_r1 ( ier , srname , nrec , comm ) ! end subroutine reset_t_end_r1 subroutine interpolate_r1 ( comm , f , t_want , y_want , yderiv_want ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( in ) :: t_want !indep! type ( rk_comm_real_1d ), intent ( inout ), target :: comm real ( kind = wp ), dimension (:), intent ( out ), optional :: y_want !dep! real ( kind = wp ), dimension (:), intent ( out ), optional :: yderiv_want !dep! ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! character ( len =* ), parameter :: srname = \"INTERPOLATE\" integer :: ier , jer , nrec , state , npcls logical :: intrp_initialised ! integer , parameter :: not_ready =- 1 , usable =- 2 , fatal = 911 , catastrophe = 912 , & just_fine = 1 logical , parameter :: ask = . true . ! ier = just_fine ; nrec = 0 ! body : do ! !  Is it permissible to call INTERPOLATE? ! state = get_saved_state_r1 ( \"STEP_INTEGRATE\" , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( comm % use_range ) then if ( get_saved_state_r1 ( \"RANGE_INTEGRATE\" , comm % save_states ) /= usable ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have called INTERPOLATE after you specified to SETUP that you were\" ,& \" ** going to use RANGE_INTEGRATE. This is not permitted.\" exit body end if end if if ( state == not_ready ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** You have not called STEP_INTEGRATE, so you cannot use INTERPOLATE.\" exit body end if if ( state > just_fine ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** STEP_INTEGRATE has returned with a flag value greater than 1. You\" , & \" ** cannot call INTERPOLATE in this circumstance.\" exit body end if ! !  Check sizes of arrays ! if ( present ( y_want )) then if ( any ( shape ( y_want ) /= shape ( comm % y ))) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a,i6,a/a,i6,a/a)\" ) & \" ** The shape of the array Y_WANT is not consistent with the shape of the \" , & \" ** dependent variables.\" exit body end if end if if ( present ( yderiv_want )) then if ( any ( shape ( yderiv_want ) /= shape ( comm % y ))) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a,i6,a/a,i6,a/a)\" ) & \" ** The shape of the array YDERIV_WANT is not consistent with the shape of\" , & \" ** the dependent variables.\" exit body end if end if ! !  Check METHOD is ok to interpolate with ! if ( comm % rk_method == 3 ) then ier = fatal ; nrec = 5 ; write ( comm % rec , \"(a/a/a/a/a)\" ) & \" ** You have been using STEP_INTEGRATE with METHOD = 'H' to integrate your\" ,& \" ** equations. You have just called INTERPOLATE, but interpolation is not\" ,& \" ** available for this METHOD. Either use METHOD = 'M', for which\" ,& \" ** interpolation is available, or use RESET_T_END to make STEP_INTEGRATE\" ,& \" ** step exactly to the points where you want output.\" exit body end if ! !  Get some workspace - !     can overwrite STAGES in METHOD 'L' since they're not requird for the !     interpolant ! select case ( comm % rk_method ) case ( 1 ) if (. not . associated ( comm % p )) comm % p => comm % stages (:, 1 : 2 ) npcls = 2 if (. not . associated ( comm % ytemp )) comm % p => comm % stages (:, 1 : 3 ) case ( 2 ) jer = 0 if (. not . associated ( comm % xstage )) then allocate ( comm % xstage ( size ( comm % y , 1 )), stat = jer ) !alloc! end if if (. not . associated ( comm % ytemp )) then allocate ( comm % ytemp ( size ( comm % y , 1 )), stat = jer ) !alloc! end if if (. not . associated ( comm % p )) then allocate ( comm % p ( size ( comm % y , 1 ), 5 ), stat = jer ) !alloc! end if npcls = 5 if ( jer /= 0 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** Not enough storage available to create workspace required internally.\" exit body end if end select ! !  Check data to see if interpolant has already been calculated for this !  step ! intrp_initialised = get_saved_state_r1 ( srname , comm % save_states ) /= usable ! !  Some initialization must be done before interpolation is possible. ! if (. not . intrp_initialised ) call form_intrp ( f , comm % p ) ! !  The actual evaluation of the interpolating polynomial and/or its first !  derivative is done in EVALUATE_INTRP. ! call evaluate_intrp ( comm % p , y_want , yderiv_want ) exit body ! end do body ! call rkmsg_r1 ( ier , srname , nrec , comm ) ! contains ! subroutine form_intrp ( f , p ) ! real ( kind = wp ), intent ( out ), dimension (:,:) :: p !dep! ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! real ( kind = wp ), dimension (:,:), pointer :: r !real! real ( kind = wp ), dimension (:,:), pointer :: stages !dep! real ( kind = wp ), dimension (:), pointer :: y , yp , y_old , yp_old !dep! real ( kind = wp ), dimension (:), pointer :: xstage !dep! ! stages => comm % stages r => comm % r y => comm % y yp => comm % yp y_old => comm % y_old yp_old => comm % yp_old xstage => comm % xstage ! select case ( comm % rk_method ) case ( 1 ) ! !  METHOD = 'L'.  Use the cubic Hermite interpolant that is fully !  specified by the values and slopes at the two ends of the step. ! p (:, 2 ) = y - y_old p (:, 1 ) = comm % h_old * yp - p (:, 2 ) p (:, 2 ) = p (:, 1 ) - ( p (:, 2 ) - comm % h_old * yp_old ) p (:, 1 ) = p (:, 1 ) + p (:, 2 ) ! case ( 2 ) ! !  METHOD = 'M'. ! if (. not . intrp_initialised ) call extra_stages ( f , comm % ytemp , comm % xstage ) ! !  Form the coefficients of the interpolating polynomial in its shifted !  and scaled form.  The transformation from the form in which the !  polynomial is derived can be somewhat ill-conditioned.  The terms !  are grouped so as to minimize the errors of the transformation. ! !  Coefficient of SIGMA**6 p (:, 5 ) = r ( 5 , 6 ) * stages (:, 4 ) + & (( r ( 10 , 6 ) * xstage + r ( 8 , 6 ) * yp ) + & ( r ( 7 , 6 ) * stages (:, 6 ) + r ( 6 , 6 ) * stages (:, 5 ))) + & (( r ( 4 , 6 ) * stages (:, 3 ) + r ( 9 , 6 ) * stages (:, 7 )) + & ( r ( 3 , 6 ) * stages (:, 2 ) + r ( 11 , 6 ) * stages (:, 1 )) + & r ( 1 , 6 ) * yp_old ) ! !  Coefficient of SIGMA**5 p (:, 4 ) = ( r ( 10 , 5 ) * xstage + r ( 9 , 5 ) * stages (:, 7 )) + & (( r ( 7 , 5 ) * stages (:, 6 ) + r ( 6 , 5 ) * stages (:, 5 )) + & r ( 5 , 5 ) * stages (:, 4 )) + (( r ( 4 , 5 ) * stages (:, 3 ) + & r ( 8 , 5 ) * yp ) + ( r ( 3 , 5 ) * stages (:, 2 ) + r ( 11 , 5 ) * & stages (:, 1 )) + r ( 1 , 5 ) * yp_old ) ! !  Coefficient of SIGMA**4 p (:, 3 ) = (( r ( 4 , 4 ) * stages (:, 3 ) + r ( 8 , 4 ) * yp ) + & ( r ( 7 , 4 ) * stages (:, 6 ) + r ( 6 , 4 ) * stages (:, 5 )) + & r ( 5 , 4 ) * stages (:, 4 )) + (( r ( 10 , 4 ) * xstage + & r ( 9 , 4 ) * stages (:, 7 )) + ( r ( 3 , 4 ) * stages (:, 2 ) + & r ( 11 , 4 ) * stages (:, 1 )) + r ( 1 , 4 ) * yp_old ) ! !  Coefficient of SIGMA**3 p (:, 2 ) = r ( 5 , 3 ) * stages (:, 4 ) + r ( 6 , 3 ) * stages (:, 5 ) + & (( r ( 3 , 3 ) * stages (:, 2 ) + r ( 9 , 3 ) * stages (:, 7 )) + & ( r ( 10 , 3 ) * xstage + r ( 8 , 3 ) * yp ) + r ( 1 , 3 ) * & yp_old ) + (( r ( 4 , 3 ) * stages (:, 3 ) + r ( 11 , 3 ) * & stages (:, 1 )) + r ( 7 , 3 ) * stages (:, 6 )) ! !  Coefficient of SIGMA**2 p (:, 1 ) = r ( 5 , 2 ) * stages (:, 4 ) + (( r ( 6 , 2 ) * stages (:, 5 ) + & r ( 8 , 2 ) * yp ) + r ( 1 , 2 ) * yp_old ) + & (( r ( 3 , 2 ) * stages (:, 2 ) + r ( 9 , 2 ) * stages (:, 7 )) + & r ( 10 , 2 ) * xstage ) + (( r ( 4 , 2 ) * stages (:, 3 ) + & r ( 11 , 2 ) * stages (:, 1 )) + r ( 7 , 2 ) * stages (:, 6 )) ! !  Scale all the coefficients by the step size. p (:,:) = comm % h_old * p (:,:) ! end select ! end subroutine form_intrp subroutine evaluate_intrp ( p , y_want , yderiv_want ) ! real ( kind = wp ), dimension (:), optional , intent ( out ) :: y_want !dep! real ( kind = wp ), dimension (:), optional , intent ( out ) :: yderiv_want !dep! real ( kind = wp ), dimension (:,:), intent ( in ) :: p !dep! ! real :: sigma integer :: i ! sigma = ( t_want - comm % t ) / comm % h_old ! if ( present ( y_want )) then y_want = p (:, comm % intrp_degree - 1 ) * sigma do i = comm % intrp_degree - 2 , 1 , - 1 y_want = ( y_want + p (:, i )) * sigma end do y_want = ( y_want + comm % h_old * comm % yp ) * sigma + comm % y end if ! if ( present ( yderiv_want )) then yderiv_want = comm % intrp_degree * p (:, comm % intrp_degree - 1 ) * sigma do i = comm % intrp_degree - 1 , 2 , - 1 yderiv_want = ( yderiv_want + i * p (:, i - 1 )) * sigma end do yderiv_want = ( yderiv_want + comm % h_old * comm % yp ) / comm % h_old end if ! end subroutine evaluate_intrp subroutine extra_stages ( f , ytemp , xstage ) ! real ( kind = wp ), dimension (:), intent ( out ) :: ytemp , xstage !dep! ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! real ( kind = wp ), dimension (:,:), pointer :: stages !dep! real ( kind = wp ), dimension (:), pointer :: yp , y_old , yp_old !dep! ! real ( kind = wp ), dimension (:,:), pointer :: a !real! real ( kind = wp ), dimension (:), pointer :: c !real! real ( kind = wp ), pointer :: h_old , t_old !indep! ! integer :: i , j ! a => comm % a stages => comm % stages c => comm % c yp => comm % yp y_old => comm % y_old yp_old => comm % yp_old h_old => comm % h_old t_old => comm % t_old ! !  Compute the extra stages needed for interpolation using the facts that !       1. Stage 1 is YP_OLD. !       2. Stage i (i>1) is stored in STAGES(...,i-1). !       3. This pair is FSAL, i.e. STAGES(...,7)=YP, which frees !          up STAGES(...,7) for use by stage 9. !       4. XSTAGE is used for stage 10. !       5. The coefficient of stage 2 in the interpolant is always 0, so !          STAGES(...,1) is used for stage 11. ! do i = 9 , 11 do j = 1 , i - 1 select case ( j ) case ( 1 ); ytemp = a ( i , 1 ) * yp_old ! could have used matmul here but that prevents increasing rank of dep-var case ( 2 : 7 ); ytemp = ytemp + a ( i , j ) * stages (:, j - 1 ) case ( 8 ); ytemp = ytemp + a ( i , j ) * yp case ( 9 ); ytemp = ytemp + a ( i , j ) * stages (:, 7 ) case ( 10 ); ytemp = ytemp + a ( i , j ) * xstage end select end do ytemp = y_old + h_old * ytemp select case ( i ) case ( 9 ) stages (:, 7 ) = f ( t_old + c ( i ) * h_old , ytemp ) case ( 10 ) xstage = f ( t_old + c ( i ) * h_old , ytemp ) case ( 11 ) stages (:, 1 ) = f ( t_old + c ( i ) * h_old , ytemp ) end select comm % f_count = comm % f_count + 1 end do ! end subroutine extra_stages end subroutine interpolate_r1 subroutine rkmsg_r1 ( ier , srname , nrec , comm , flag ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! integer , intent ( in ) :: ier , nrec integer , intent ( out ), optional :: flag character ( len =* ), intent ( in ) :: srname type ( rk_comm_real_1d ), intent ( inout ) :: comm ! logical :: ok , on , range_call ! integer , parameter :: fatal = 911 , catastrophe = 912 , just_fine = 1 logical , parameter :: tell = . false . ! !  Check where the call came from - if it is an indirect call from !  RANGE_INTEGRATE the run is not STOPped. ! range_call = ( srname == \"RESET_T_END\" . or . srname == \"STEP_INTEGRATE\" . or . & srname == \"INTERPOLATE\" ) . and . comm % use_range ! !  Check if can continue with integrator. ! ok = ( srname == \"STEP_INTEGRATE\" . or . srname == \"RANGE_INTEGRATE\" ) . and . & ( ier == 2 . or . ier == 3 . or . ier == 4 ) ! !  Check if program termination has been overridden. ! on = get_stop_on_fatal_r1 ( comm ) ! if (( comm % print_message . and . ier > just_fine ) . or . ier >= fatal ) then write ( comm % outch , \"(/a)\" ) \" **\" write ( comm % outch , \"(a)\" ) comm % rec ( 1 : nrec ) if ( ier >= fatal ) then write ( comm % outch , \"(a/a,a,a/a/)\" ) & \" **\" ,& \" ** Catastrophic error detected in \" , srname , \".\" ,& \" **\" if ((. not . range_call . and . on . and . ier == fatal ) . or . ier == catastrophe ) then write ( comm % outch , \"(a/a/a)\" ) & \" **\" ,& \" ** Execution of your program is being terminated.\" ,& \" **\" stop end if else if ( ok ) then write ( comm % outch , \"(a/a,a,a,i2,a/a/a)\" ) & \" **\" , & \" ** Warning from routine \" , srname , \" with flag set \" , ier , \".\" ,& \" ** You can continue integrating this problem.\" ,& \" **\" else write ( comm % outch , \"(a/a,a,a,i2,a/a/a)\" ) & \" **\" , & \" ** Warning from routine \" , srname , \" with flag set \" , ier , \".\" , & \" ** You cannot continue integrating this problem.\" , & \" **\" end if if (. not . present ( flag )) then write ( comm % outch , \"(a/a/a)\" ) & \" **\" ,& \" ** Execution of your program is being terminated.\" ,& \" **\" stop end if end if end if ! if ( present ( flag )) flag = ier comm % rec ( nrec + 1 : 10 ) = \" \" ! !  Save the status of the routine associated with SRNAME ! call set_saved_state_r1 ( srname , ier , comm ) ! !  Indicate that a catastrophic error has been detected ! !call set_saved_fatal_r1(comm,ier >= catastrophe) ! end subroutine rkmsg_r1 subroutine set_saved_state_r1 ( srname , state , comm ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! integer , intent ( in ) :: state type ( rk_comm_real_1d ), intent ( inout ) :: comm character ( len =* ), intent ( in ) :: srname ! integer :: name ! integer , parameter :: fatal = 911 ! select case ( srname ) case ( \"SETUP\" ); name = 1 case ( \"RANGE_INTEGRATE\" ); name = 2 case ( \"STATISTICS\" ); name = 3 case ( \"GLOBAL_ERROR\" ); name = 4 case ( \"STEP_INTEGRATE\" ); name = 5 case ( \"INTERPOLATE\" ); name = 6 case ( \"RESET_T_END\" ); name = 7 case default ; name = 0 end select ! comm % save_states ( name ) = state comm % saved_fatal_err = state >= fatal ! end subroutine set_saved_state_r1 function get_saved_state_r1 ( srname , save_states ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! integer , dimension ( 7 ), intent ( inout ) :: save_states character ( len =* ), intent ( in ) :: srname integer :: get_saved_state_r1 ! integer :: name ! integer , parameter :: fatal = 911 ! select case ( srname ) case ( \"SETUP\" ); name = 1 case ( \"RANGE_INTEGRATE\" ); name = 2 case ( \"STATISTICS\" ); name = 3 case ( \"GLOBAL_ERROR\" ); name = 4 case ( \"STEP_INTEGRATE\" ); name = 5 case ( \"INTERPOLATE\" ); name = 6 case ( \"RESET_T_END\" ); name = 7 case default ; name = 0 end select ! !  Check for status of given routine but check for any fatal errors first ! if ( any ( save_states ( 1 : 7 ) == fatal )) then get_saved_state_r1 = fatal else get_saved_state_r1 = save_states ( name ) end if ! end function get_saved_state_r1 function get_saved_fatal_r1 ( comm ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( in ) :: comm logical :: get_saved_fatal_r1 ! get_saved_fatal_r1 = comm % saved_fatal_err ! end function get_saved_fatal_r1 subroutine set_stop_on_fatal_r1 ( comm , action ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ) :: comm logical , intent ( in ) :: action ! comm % stop_on_fatal = action ! end subroutine set_stop_on_fatal_r1 function get_stop_on_fatal_r1 ( comm ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( in ) :: comm logical get_stop_on_fatal_r1 ! get_stop_on_fatal_r1 = comm % stop_on_fatal ! end function get_stop_on_fatal_r1 !endc! end module rksuite_90"},{"title":"nitstb2.f – ISOFT","tags":"","loc":"sourcefile/nitstb2.f.html","text":"Contents Subroutines nitstb2 Source Code nitstb2.f Source Code c ------------------------------------------------------------------------ c c This is nittfq2, a copy of the BiCGSTAB routine in the NITSOL c package. It has been modified so that it will take an initial guess of c the solution. c c ------------------------------------------------------------------------ subroutine nitstb2 ( n , xcur , fcur , step , eta , f , jacv , rpar , ipar , $ ijacv , irpre , iksmax , ifdord , nfe , njve , nrpre , nli , r , rtil , $ p , phat , v , t , rwork1 , rwork2 , rsnrm , dinpr , dnorm , itrmks ) implicit none integer n , ipar ( * ), ijacv , irpre , iksmax , ifdord , nfe , njve , $ nrpre , nli , itrmks double precision xcur ( n ), fcur ( n ), fcnrm , step ( n ), eta , rpar ( * ), $ r ( n ), rtil ( n ), p ( n ), phat ( n ), v ( n ), t ( n ), rwork1 ( n ), $ rwork2 ( n ), rsnrm , dinpr , dnorm external f , jacv , dinpr , dnorm c ------------------------------------------------------------------------ c c This is nitstb v0.3, the BiCGSTAB routine for determining (trial) inexact c Newton steps. The original reference is H. van der Vorst, \"Bi-CGSTAB: c A fast and smoothly converging variant of Bi-CG for the soluton of c nonsymmetric linear systems,\" SIAM J. Sci. Statist. Comput., 13 (1992), c pp. 631--644. c c ------------------------------------------------------------------------ c c Explanation: c c  n       = dimension of the problem. c c  xcur    = vector of length n, current approximate solution. c c  fcur    = vector of length n, value of f at xcur. c c************************************************************************* c c FCNRM is no longer an argument, as it needs to be calculated from the c residual, which isn't known until a little way into this routine. It c could be calculated by the calling routine, but that would mean doing c the calculation twice. c c************************************************************************* c c  step    = vector of length n, (trial) step. c c  eta     = relative residual reduction factor. c c  f      = name of user-supplied subroutine for evaluating the function c           the zero of which is sought; this routine has the form c c                 subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c           where xcur is the array containing the current x value, fcur c           is f(xcur) on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmf is an integer termination flag.  The meaning of c           itrmf is as follows: c             0 => normal termination; desired function value calculated. c             1 => failure to produce f(xcur). c c  jacv   = name of user-supplied subroutine for evaluating J*v or c           P(inverse)*v, where J is the Jacobian of f and P is a c           right preconditioning operator. If neither analytic J*v c           evaluations nor right preconditioning is used, this can c           be a dummy subroutine; if right preconditioning is used but c           not analytic J*v evaluations, this need only evaluate c           P(inverse)*v. The form is c c           subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) c c           where xcur and fcur are vectors of length n containing the c           current x and f values, ijob is an integer flag indicating c           which product is desired, v is a vector of length n to be c           multiplied, z is a vector of length n containing the desired c           product on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmjv is an integer termination c           flag. The meaning of ijob is as follows: c             0 => z = J*v c             1 => z = P(inverse)*v c           The meaning of itrmjv is as follows: c             0 => normal termination; desired product evaluated. c             1 => failure to produce J*v. c             2 => failure to produce P(inverse)*v. c           This subroutine is called only from nitjv, and is always c           called with v .ne. z. c c  rpar    = real parameter/work array passed to the f and jacv routines. c c  ipar    = integer parameter/work array passed to the f and jacv routines. c c  ijacv   = flag for determining method of J*v evaluation. c              0 => finite-difference evaluation (default). c              1 => analytic evaluation. c c  irpre   = flag for right preconditioning. c              0 => no right preconditioning c              1 => right preconditioning c c  iksmax  = maximum allowable number of BiCGSTAB iterations. c c  ifdord  = order of the finite-difference formula used in BiCGSTAB c            when J*v products are evaluated using finite-differences. c            When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or c            4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on c            input to this subroutine, ifdord determines the order of the c            finite-difference formula used at each BiCGSTAB iteration c            (default 1). In this case, ijacv is set to -1 below to c            signal to nitjv that the order of the finite-difference c            formula is to be determined by ifdord. The original value c            ijacv = 0 is restored on return. c c  nfe     = number of function evaluations. c c  njve    = number of J*v evaluations. c c  nrpre   = number of P(inverse)*v evaluations. c c  nli     = number of linear iterations. c c  r       = residual vector c c  rtil    = \"r-tilde\" vector used in BiCGSTAB c c  p       = vector used in BiCGSTAB c c  phat    = vector used in BiCGSTAB c c  v       = vector used in BiCGSTAB c c  t       = vector used in BiCGSTAB c c  rwork1  = work vector, passed on to nitjv c c  rwork2  = work vector, passed on to nitjv c c  rsnrm   = BiCGSTAB residual norm on return. c c  dinpr   = inner-product routine, either user-supplied or blas ddot. c c  dnorm   = norm routine, either user-supplied or blas dnrm2. c c  itrmks  = termination flag; values have the following meanings: c              0 => normal termination: acceptable step found. c              1 => J*v failure in nitjv. c              2 => P(inverse)*v failure in nitjv. c              3 => acceptable step not found in iksmax BiCGSTAB iterations. c              4 => BiCGSTAB breakdown. c c             Note: On return, nitsol terminates if itrmks is 1 or 2. c             If itrmks is 3 or 4, nitsol may terminate or continue. c             In this event, the step returned is a meaningful inexact c             Newton step only if the residual norm has been reduced. c             A decision on termination/continuation is made in nitdrv c             according to whether there is sufficient residual norm c             reduction, even though the desired inexact Newton condition c             may not hold. c c ------------------------------------------------------------------------- c c Subroutines required by this and all called routines: c c    user supplied: f, jacv c c    nitsol routines: nitjv, nitfd c c    blas routines: daxpy, dcopy, dscal c c    lapack routine:  dlamch c c    user supplied or blas: dinpr, dnorm c c    explanation: In nitsol, dinpr and dnorm are set to either the blas c    ddot and dnrm2 routines or the user-supplied usrnpr and usrnrm c    routines. c c This subroutine called by: nitdrv c c Subroutines called by this subroutine: daxpy, dcopy, dscal, dinpr, dlamch, c    dnorm, nitjv c c Common block: c c************************************************************************* c c <<<<<<<<<<<<<<<<<<<<< TAKEN FROM `nitprint.h` >>>>>>>>>>>>>>>>>>>>>>>>> c c Include these declaratinos and common blocks directly so that the c include files are not needed in isoft. c integer iplvl , ipunit common / nitprint / iplvl , ipunit c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number, e.g., ipunit = 6 => standard output. c              NOTE: If ipunit = 0 on input, then it is set to 6. c c************************************************************************* c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number. c c ------------------------------------------------------------------------ c double precision abstol , alpha , beta , omega , $ rho , rhomns , tau , temp integer i , istb , itask , itrmjv double precision dlamch external dlamch c double precision sfmin data sfmin / 0.0d0 / c ------------------------------------------------------------------------ c c  Initialize sfmin only on first entry. c if ( sfmin . eq . 0.0d0 ) sfmin = dlamch ( 's' ) c ------------------------------------------------------------------------ c If finite-differences are used to evaluate J*v products (ijacv= 0), then c ijacv is set to -1 within this subroutine to signal to nitjv that the c order of the finite-difference formula is to be determined by ifdord. c The original value ijacv= 0 is restored on return. c ------------------------------------------------------------------------ if ( ijacv . eq . 0 ) ijacv = - 1 c ------------------------------------------------------------------------ c Set the stopping tolerance, initialize the step, etc. c ------------------------------------------------------------------------ c************************************************************************* c c     Do not set the step to 0, as it contains an initial guess at the c     solution. c c************************************************************************* CC      do 10 i = 1, n CC         step(i) = 0.d0 CC 10   continue istb = 0 c c ------------------------------------------------------------------------ c Set up r and rtil. c ------------------------------------------------------------------------ CC      call dcopy(n,fcur,1,r,1) CC      temp = -1.d0 CC      call dscal(n,temp,r,1) c************************************************************************* c c     Because the initial step is not zero, the residual must include an c     evaluation of the left-hand-side.. c c************************************************************************* itask = 0 if ( ijacv . eq . 0 ) ijacv = - 1 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , $ itask , nfe , njve , nrpre , step , r , rwork1 , rwork2 , dnorm , $ itrmjv ) if ( ijacv . eq . - 1 ) ijacv = 0 if ( itrmjv . gt . 0 ) then itrmks = 1 go to 900 endif do 25 i = 1 , n r ( i ) = - fcur ( i ) - r ( i ) 25 continue rsnrm = dnorm ( n , r , 1 ) fcnrm = rsnrm abstol = eta * rsnrm call dcopy ( n , r , 1 , rtil , 1 ) c c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 3 ) then write ( ipunit , * ) write ( ipunit , 800 ) eta endif 800 format ( 'nitstb:  eta =' , 1 pd10 . 3 ) if ( iplvl . ge . 4 ) then write ( ipunit , 810 ) write ( ipunit , * ) write ( ipunit , 820 ) istb , rsnrm endif 810 format ( 'nitstb:  BiCGSTAB iteration no. (parts a and b)' , $ ' linear residual norm, ' ) 820 format ( 5 x , i4 , 5 x , 1 pd10 . 3 ) c ------------------------------------------------------------------------ c Top of the iteration loop. c ------------------------------------------------------------------------ 100 continue istb = istb + 1 nli = nli + 1 c ------------------------------------------------------------------------ c Perform the first \"half-iteration\". c ------------------------------------------------------------------------ rho = dinpr ( n , rtil , 1 , r , 1 ) if ( istb . eq . 1 ) then call dcopy ( n , r , 1 , p , 1 ) else if ( abs ( rhomns ) . lt . sfmin * abs ( rho ) ) then itrmks = 4 goto 900 else beta = ( rho / rhomns ) * ( alpha / omega ) call daxpy ( n , - omega , v , 1 , p , 1 ) call dscal ( n , beta , p , 1 ) call daxpy ( n , 1.d0 , r , 1 , p , 1 ) endif endif if ( irpre . eq . 0 ) then call dcopy ( n , p , 1 , phat , 1 ) else itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , p , phat , $ rwork1 , rwork2 , dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then itrmks = 2 go to 900 endif endif itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , phat , v , $ rwork1 , rwork2 , dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then itrmks = 1 go to 900 endif tau = dinpr ( n , rtil , 1 , v , 1 ) if ( abs ( tau ) . lt . sfmin * abs ( rho ) ) then itrmks = 4 goto 900 else alpha = rho / tau endif call daxpy ( n , - alpha , v , 1 , r , 1 ) call daxpy ( n , alpha , phat , 1 , step , 1 ) rsnrm = dnorm ( n , r , 1 ) c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 4 ) then write ( ipunit , 830 ) istb , rsnrm 830 format ( 5 x , i4 , '.a' , 3 x , 1 pd10 . 3 ) endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Test for termination. c ------------------------------------------------------------------------ if ( rsnrm . le . abstol ) then itrmks = 0 go to 900 endif c ------------------------------------------------------------------------ c Perform the second \"half-iteration\". c ------------------------------------------------------------------------ if ( irpre . eq . 0 ) then call dcopy ( n , r , 1 , phat , 1 ) else itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , r , phat , $ rwork1 , rwork2 , dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then itrmks = 2 go to 900 endif endif itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , phat , t , $ rwork1 , rwork2 , dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then itrmks = 1 go to 900 endif tau = dnorm ( n , t , 1 ) tau = tau * tau temp = dinpr ( n , t , 1 , r , 1 ) if ( tau . le . sfmin * abs ( temp ) ) then itrmks = 4 goto 900 else omega = temp / tau endif if ( abs ( omega ) . lt . sfmin * abs ( alpha ) ) then itrmks = 4 go to 900 endif call daxpy ( n , - omega , t , 1 , r , 1 ) call daxpy ( n , omega , phat , 1 , step , 1 ) rsnrm = dnorm ( n , r , 1 ) c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 4 ) then write ( ipunit , 840 ) istb , rsnrm 840 format ( 5 x , i4 , '.b' , 3 x , 1 pd10 . 3 ) endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Test for termination. c ------------------------------------------------------------------------ if ( rsnrm . le . abstol ) then itrmks = 0 go to 900 endif if ( istb . ge . iksmax ) then itrmks = 3 go to 900 endif c ------------------------------------------------------------------------ c If continuing, update and return to the top of the iteration loop. c ------------------------------------------------------------------------ rhomns = rho go to 100 c ------------------------------------------------------------------------ c Bottom of the iteration loop. c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c All returns made here. c ------------------------------------------------------------------------ 900 continue c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 3 ) then write ( ipunit , * ) if ( itrmks . ne . 1 . and . itrmks . ne . 2 ) then write ( ipunit , 850 ) itrmks , rsnrm 850 format ( 'nitstb:  itrmks =' , i2 , '   final lin. res. norm =' , $ 1 pd10 . 3 ) else write ( ipunit , 860 ) itrmks 860 format ( 'nitstb: itrmks:' , i4 ) endif endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c If ijacv = -1, then restore it to the original value ijacv = 0. c ------------------------------------------------------------------------ if ( ijacv . eq . - 1 ) ijacv = 0 return end"},{"title":"nitgm2.f – ISOFT","tags":"","loc":"sourcefile/nitgm2.f.html","text":"Contents Subroutines nitgm2 Source Code nitgm2.f Source Code c ------------------------------------------------------------------------ c c This is nitgm2, a copy of the GMRES routine in the NITSOL package. It c has been modified so that it will take an initial guess of the solution. c c ------------------------------------------------------------------------ subroutine nitgm2 ( n , xcur , fcur , step , eta , f , jacv , rpar , $ ipar , ijacv , irpre , iksmax , iresup , ifdord , nfe , njve , $ nrpre , nli , kdmax , kdmaxp1 , vv , rr , svbig , svsml , w , rwork , $ rsnrm , dinpr , dnorm , itrmks ) implicit none integer n , ipar ( * ), ijacv , irpre , iksmax , iresup , ifdord , nfe , $ njve , nrpre , nli , kdmax , kdmaxp1 , itrmks double precision xcur ( n ), fcur ( n ), fcnrm , step ( n ), eta , rpar ( * ), $ vv ( n , kdmaxp1 ), rr ( kdmax , kdmax ), svbig ( kdmax ), svsml ( kdmax ), $ w ( kdmax ), rwork ( n ), rsnrm , dinpr , dnorm external f , jacv , dinpr , dnorm c ------------------------------------------------------------------------ c c This is nitgm v0.3, the GMRES routine for determining (trial) inexact c Newton steps. This implementation is the \"simpler\" Gram-Schmidt GMRES c implementation from L. Zhou and H. F. Walker, \"A simpler GMRES,\" c J. Numerical Lin. Alg. Appl., 1 (1994), pp. 571-581. c c ------------------------------------------------------------------------ c c Explanation: c c  n       = dimension of the problem. c c  xcur    = vector of length n, current approximate solution. c c  fcur    = vector of length n, value of f at xcur. c c************************************************************************* c c FCNRM is no longer an argument, as it needs to be calculated from the c residual, which isn't known until a little way into this routine. It c could be calculated by the calling routine, but that would mean doing c the calculation twice. c c************************************************************************* c c  step    = vector of length n, (trial) step. c c  eta     = relative residual reduction factor. c c  f       = name of user-supplied subroutine for evaluating the function c            the zero of which is sought; this routine has the form c c                  subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c           where xcur is the array containing the current x value, fcur c           is f(xcur) on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmf is an integer termination flag.  The meaning of c           itrmf is as follows: c             0 => normal termination; desired function value calculated. c             1 => failure to produce f(xcur). c c  jacv    = name of user-supplied subroutine for evaluating J*v or c            P(inverse)*v, where J is the Jacobian of f and P is a c            right preconditioning operator. If neither analytic J*v c            evaluations nor right preconditioning is used, this can c            be a dummy subroutine; if right preconditioning is used but c            not analytic J*v evaluations, this need only evaluate c            P(inverse)*v. The form is c c            subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) c c            where xcur and fcur are vectors of length n containing the c            current x and f values, ijob is an integer flag indicating c            which product is desired, v is a vector of length n to be c            multiplied, z is a vector of length n containing the desired c            product on output, rpar and ipar are, respectively, real c            and integer parameter/work arrays for use by the subroutine, c            and itrmjv is an integer termination c            flag. The meaning of ijob is as follows: c              0 => z = J*v c              1 => z = P(inverse)*v c            The meaning of itrmjv is as follows: c              0 => normal termination; desired product evaluated. c              1 => failure to produce J*v. c              2 => failure to produce P(inverse)*v. c            This subroutine is called only from nitjv, and is always c            called with v .ne. z. c c  rpar    = real parameter/work array passed to the f and jacv routines. c c  ipar    = integer parameter/work array passed to the f and jacv routines. c c  ijacv   = flag for determining method of J*v evaluation. c              0 => finite-difference evaluation (default). c              1 => analytic evaluation. c c  irpre   = flag for right preconditioning. c              0 => no right preconditioning c              1 => right preconditioning c c  iksmax  = maximum allowable number of GMRES iterations. c c  iresup  = residual update flag; on GMRES restarts, the residual is c            updated as follows: c               0 => linear combination (default) c               1 => direct evaluation c            The first is cheap (one n-vector saxpy) but may lose c            accuracy with extreme residual reduction; the second c            retains accuracy better but costs one J*v product c c  ifdord  = order of the finite-difference formula (sometimes) used on c            GMRES restarts when J*v products are evaluated using finite- c            differences. When ijacv = 0 on input to nitsol, ifdord is set c            to 1, 2, or 4 in nitsol; otherwise, it is irrelevant. When c            ijacv = 0 on input to this subroutine, the precise meaning is c            as follows: c c            With GMRES, ifdord matters only if iresup = 1, in which case c            it determines the order of the finite-difference formula used c            in evaluating the initial residual at each GMRES restart c            (default 2). If iresup = 1 and ijacv = 0 on input to this c            subroutine, then ijacv is temporarily reset to -1 at each c            restart below to force a finite-difference evaluation of order c            ifdord. NOTE: This only affects initial residuals at restarts; c            first-order differences are always used within each GMRES c            cycle. Using higher-order differences at restarts only should c            give the same accuracy as if higher-order differences were c            used throughout; see K. Turner and H. F. Walker, \"Efficient c            high accuracy solutions with GMRES(m),\" SIAM J. Sci. Stat. c            Comput., 13 (1992), pp. 815--825. c c  nfe     = number of function evaluations. c c  njve    = number of J*v evaluations. c c  nrpre   = number of P(inverse)*v evaluations. c c  nli     = number of linear iterations. c c  kdmax   = maximum Krylov subspace dimension; default 10. c c  kdmaxp1 = kdmax + 1. c c  vv      = n x (kdmax+1) matrix for storage of Krylov basis in GMRES; c            on return, the residual vector is contained in the first c            column. c c  rr      = kdmax x kdmax matrix for storage of triangular matrix in GMRES. c c  svbig   = vector of length kdmax for storage of estimate of singular c            vector of rr with largest singular value. c c  svsml   = vector of length kdmax for storage of estimate of singular c            vector of rr with smallest singular value. c c  w       = vector of length kdmax, contains right-hand side of c            triangular system and least-squares residual norm in GMRES. c c  rwork   = vector of length n, work array. c c  rsnrm   = GMRES residual norm on return. c c  dinpr   = inner-product routine, either user-supplied or blas ddot. c c  dnorm   = norm routine, either user-supplied or blas dnrm2. c c  itrmks  = termination flag; values have the following meanings: c              0 => normal termination: acceptable step found. c              1 => J*v failure in nitjv. c              2 => P(inverse)*v failure in nitjv. c              3 => acceptable step not found in iksmax GMRES iterations. c              4 => insufficient residual norm reduction over a cycle c                   of kdmax steps (stagnation) before an acceptable step c                   has been found. c              5 => dangerous ill-conditioning detected before an acceptable c                   step has been found. c c             Note: On return, nitsol terminates if itrmks is 1 or 2. If c             itrmks is 3, 4, or 5, nitsol may terminate or continue. In c             this event, a meaningful inexact Newton step is returned, c             even though the desired inexact Newton condition may not c             hold, and a decision on termination/continuation is made c             in nitdrv according to whether there is sufficient residual c             norm reduction. c c ------------------------------------------------------------------------- c c Subroutines required by this and all called routines: c c    user supplied: f, jacv c c    nitsol routines: nitjv, nitfd c c    lapack routine: dlaic1, dlamch c c    blas routines: daxpy, dcopy, dscal c c    user supplied or blas: dinpr, dnorm c c    explanation: In nitsol, dinpr and dnorm are set to either the blas c    ddot and dnrm2 routines or the user-supplied usrnpr and usrnrm c    routines. c c This subroutine called by: nitdrv c c Subroutines called by this subroutine: daxpy, dcopy, dscal, dlaic1, c    dlamch, dinpr, dnorm, nitjv c c Common block: c c************************************************************************* c c <<<<<<<<<<<<<<<<<<<<< TAKEN FROM `nitprint.h` >>>>>>>>>>>>>>>>>>>>>>>>> c c Include these declaratinos and common blocks directly so that the c include files are not needed in isoft. c integer iplvl , ipunit common / nitprint / iplvl , ipunit c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number, e.g., ipunit = 6 => standard output. c              NOTE: If ipunit = 0 on input, then it is set to 6. c c************************************************************************* c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number. c c ------------------------------------------------------------------------ c double precision abstol , big , cs , cndmax , epsmach , rsnrm0 , $ sestpr , small , sn , temp integer i , igm , ijob , itask , itrmjv , kd , kdp1 , ncall double precision dlamch external dlamch c ------------------------------------------------------------------------ c ------------------------------------------------------------------------ data ncall / 0 / save ncall , cndmax , epsmach c ------------------------------------------------------------------------ c Initialize. c ------------------------------------------------------------------------ if ( ncall . eq . 0 ) then epsmach = 2.0d0 * dlamch ( 'e' ) ncall = 1 cndmax = 1.d0 / ( 10 0.d0 * epsmach ) endif c************************************************************************* c c     Do not set the step to 0, as it contains an initial guess at the c     solution. c c************************************************************************* CC      do 20 i = 1, n CC         step(i) = 0.d0 CC 20   continue igm = 0 c ------------------------------------------------------------------------ c Place the normalized initial residual in the first column of the vv array. c ------------------------------------------------------------------------ c************************************************************************* c c     Because the initial step is not zero, the residual must include an c     evaluation of the left-hand-side.. c c************************************************************************* CC      call dcopy(n, fcur, 1, vv(1,1), 1) itask = 0 if ( ijacv . eq . 0 ) ijacv = - 1 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , step , vv ( 1 , 1 ), $ rwork , vv ( 1 , 2 ), dnorm , itrmjv ) if ( ijacv . eq . - 1 ) ijacv = 0 if ( itrmjv . gt . 0 ) then itrmks = 1 go to 900 endif do 20 i = 1 , n vv ( i , 1 ) = - fcur ( i ) - vv ( i , 1 ) 20 continue fcnrm = dnorm ( n , vv ( 1 , 1 ), 1 ) temp = 1.d0 / fcnrm call dscal ( n , temp , vv ( 1 , 1 ), 1 ) c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 3 ) then write ( ipunit , * ) write ( ipunit , 800 ) eta endif 800 format ( 'nitgm:  eta =' , 1 pd10 . 3 ) if ( iplvl . ge . 4 ) then write ( ipunit , 810 ) write ( ipunit , * ) write ( ipunit , 820 ) igm , fcnrm endif 810 format ( 'nitgm:  GMRES iteration no., linear residual norm, ' , $ 'condition no. estimate' ) 820 format ( 5 x , i4 , 2 ( 5 x , 1 pd10 . 3 )) c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Set the stopping tolerance, etc. c ------------------------------------------------------------------------ rsnrm0 = fcnrm abstol = eta * rsnrm0 c ------------------------------------------------------------------------ c Top of the outer GMRES loop. c ------------------------------------------------------------------------ 100 continue kd = 0 rsnrm = 1.d0 c ------------------------------------------------------------------------ c Top of the inner GMRES loop. c ------------------------------------------------------------------------ 200 continue kd = kd + 1 kdp1 = kd + 1 nli = nli + 1 igm = igm + 1 c ------------------------------------------------------------------------ c Evaluate J*(kd-th Krylov subspace basis vector) in vv(.,kdp1). c Note: rwork can be used for both work arrays in this call because c the second is not referenced within nitjv. c ------------------------------------------------------------------------ if ( irpre . eq . 0 ) then itask = 0 else itask = 1 endif call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , vv ( 1 , kd ), vv ( 1 , kdp1 ), $ rwork , rwork , dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then if ( itrmjv . eq . 1 ) itrmks = 1 if ( itrmjv . eq . 2 ) itrmks = 2 go to 900 endif c ------------------------------------------------------------------------ c Do modified Gram-Schmidt. c ------------------------------------------------------------------------ do 210 i = 2 , kd rr ( i - 1 , kd ) = dinpr ( n , vv ( 1 , i ), 1 , vv ( 1 , kdp1 ), 1 ) call daxpy ( n , - rr ( i - 1 , kd ), vv ( 1 , i ), 1 , vv ( 1 , kdp1 ), 1 ) 210 continue rr ( kd , kd ) = dnorm ( n , vv ( 1 , kdp1 ), 1 ) c ------------------------------------------------------------------------ c Update the estimates of the largest and smallest singular values. c ------------------------------------------------------------------------ if ( kd . eq . 1 ) then big = rr ( 1 , 1 ) small = big svbig ( 1 ) = 1.d0 svsml ( 1 ) = 1.d0 else ijob = 1 call dlaic1 ( ijob , kd - 1 , svbig , big , rr ( 1 , kd ), rr ( kd , kd ), $ sestpr , sn , cs ) big = sestpr call dscal ( kd - 1 , sn , svbig , 1 ) svbig ( kd ) = cs ijob = 2 call dlaic1 ( ijob , kd - 1 , svsml , small , rr ( 1 , kd ), rr ( kd , kd ), $ sestpr , sn , cs ) small = sestpr call dscal ( kd - 1 , sn , svsml , 1 ) svsml ( kd ) = cs endif c ------------------------------------------------------------------------ c Terminate if the estimated condition number is too great. c ------------------------------------------------------------------------ if ( big . ge . small * cndmax ) then if ( kd . eq . 1 ) then itrmks = 5 go to 900 else kdp1 = kd kd = kd - 1 call daxpy ( n , w ( kd ), vv ( 1 , kdp1 ), 1 , vv ( 1 , 1 ), 1 ) go to 300 endif endif c ------------------------------------------------------------------------ c Normalize vv(.,kdp1). c ------------------------------------------------------------------------ temp = 1.d0 / rr ( kd , kd ) call dscal ( n , temp , vv ( 1 , kdp1 ), 1 ) c ------------------------------------------------------------------------ c Update w and the residual norm by rsnrm <- rsnrm*dsin(dacos(w(kd)/rsnrm). c ------------------------------------------------------------------------ w ( kd ) = dinpr ( n , vv ( 1 , 1 ), 1 , vv ( 1 , kdp1 ), 1 ) temp = max ( min ( w ( kd ) / rsnrm , 1.0D0 ), - 1.0d0 ) rsnrm = rsnrm * dsin ( dacos ( temp )) c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 4 ) then write ( ipunit , 820 ) igm , rsnrm * rsnrm0 , big / small c         if (kd .eq. kdmax) write(ipunit,*) endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Test for termination of the inner loop. c ------------------------------------------------------------------------ if ( ( rsnrm0 * rsnrm . le . abstol ) . or . ( kd . eq . kdmax ) . or . $ ( igm . ge . iksmax ) ) go to 300 c ------------------------------------------------------------------------ c If not terminating the inner loop, update the residual vector c and go to the top of the inner loop. c ------------------------------------------------------------------------ call daxpy ( n , - w ( kd ), vv ( 1 , kdp1 ), 1 , vv ( 1 , 1 ), 1 ) go to 200 c ------------------------------------------------------------------------ c Bottom of inner loop. c ------------------------------------------------------------------------ 300 continue c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 4 ) then write ( ipunit , * ) endif c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Compute the solution: c ------------------------------------------------------------------------ c c ------------------------------------------------------------------------ c Use svbig for storage of the original components of w. c ------------------------------------------------------------------------ call dcopy ( kd , w , 1 , svbig , 1 ) c ------------------------------------------------------------------------ c Overwrite w with the solution of the upper triangular system. c ------------------------------------------------------------------------ do 310 i = kd , 1 , - 1 w ( i ) = w ( i ) / rr ( i , i ) if ( i . gt . 1 ) call daxpy ( i - 1 , - w ( i ), rr ( 1 , i ), 1 , w , 1 ) 310 continue c ------------------------------------------------------------------------ c Now form the linear combination to accumulate the correction in c the work vector. c ------------------------------------------------------------------------ call dcopy ( n , vv ( 1 , 1 ), 1 , rwork , 1 ) call dscal ( n , w ( 1 ), rwork , 1 ) if ( kd . gt . 1 ) then call daxpy ( kd - 1 , w ( 1 ), svbig , 1 , w ( 2 ), 1 ) do 320 i = 2 , kd call daxpy ( n , w ( i ), vv ( 1 , i ), 1 , rwork , 1 ) 320 continue endif c ------------------------------------------------------------------------ c If iresup .eq. 0, then update the residual vector by linear c combination. This frees vv(.,kdp1) for use as a work array. c ------------------------------------------------------------------------ if ( iresup . eq . 0 ) then call daxpy ( n , - svbig ( kd ), vv ( 1 , kdp1 ), 1 , vv ( 1 , 1 ), 1 ) endif c ------------------------------------------------------------------------ c If right preconditioning is used, overwrite c correction <-- P(inverse)*correction, using vv(.,kdp1) as a work array. c Note: vv(.,kdp1) can be used for both work arrays in this call because c the second is not referenced within nitjv. c ------------------------------------------------------------------------ if ( irpre . gt . 0 ) then itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , rwork , rwork , $ vv ( 1 , kdp1 ), vv ( 1 , kdp1 ), dnorm , itrmjv ) if ( itrmjv . gt . 0 ) then itrmks = 2 go to 900 endif endif c ------------------------------------------------------------------------ c Update the step. This frees rwork for use as a work array. c ------------------------------------------------------------------------ call daxpy ( n , rsnrm0 , rwork , 1 , step , 1 ) c ------------------------------------------------------------------------ c If iresup .eq. 1, then update the residual vector by direct evaluation, c using rwork and vv(.,kdp1) as work arrays. Note: Two distinct work c arrays are needed in this call because both are referenced within nitjv c if the J*step product is evaluated with a finite-difference of order c two or higher. If finite-differences are used (ijacv= 0), then ijacv c is temporarily set to -1 to signal to nitjv that the order of the c finite-difference formula is to be determined by ifdord. c ------------------------------------------------------------------------ if ( iresup . eq . 1 ) then itask = 0 if ( ijacv . eq . 0 ) ijacv = - 1 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , $ ifdord , itask , nfe , njve , nrpre , step , vv ( 1 , 1 ), $ rwork , vv ( 1 , kdp1 ), dnorm , itrmjv ) if ( ijacv . eq . - 1 ) ijacv = 0 if ( itrmjv . gt . 0 ) then itrmks = 1 go to 900 endif do 330 i = 1 , n vv ( i , 1 ) = - fcur ( i ) - vv ( i , 1 ) 330 continue endif c ------------------------------------------------------------------------ c Test for termination. c ------------------------------------------------------------------------ if ( rsnrm0 * rsnrm . le . abstol ) then itrmks = 0 go to 900 endif if ( igm . ge . iksmax ) then itrmks = 3 go to 900 endif if ( big . ge . small * cndmax ) then itrmks = 5 go to 900 endif temp = dfloat ( kd ) * dlog ( abstol / ( rsnrm0 * rsnrm )) / $ dlog ( rsnrm / ( 1.d0 + 1 0.d0 * epsmach )) if ( temp . ge . 100 0.d0 * dfloat ( iksmax - igm )) then itrmks = 4 go to 900 endif c ------------------------------------------------------------------------ c If not terminating, then normalize the initial residual, etc., and c return to the top of the outer loop. c ------------------------------------------------------------------------ if ( iresup . eq . 0 ) then rsnrm0 = rsnrm0 * rsnrm temp = 1.d0 / rsnrm else rsnrm0 = dnorm ( n , vv ( 1 , 1 ), 1 ) temp = 1.d0 / rsnrm0 endif call dscal ( n , temp , vv ( 1 , 1 ), 1 ) go to 100 c ------------------------------------------------------------------------ c All returns made here. c ------------------------------------------------------------------------ 900 continue if ( itrmks . ne . 1 . and . itrmks . ne . 2 ) then if ( iresup . eq . 0 ) then call dscal ( n , rsnrm0 , vv ( 1 , 1 ), 1 ) rsnrm = rsnrm0 * rsnrm else rsnrm = dnorm ( n , vv ( 1 , 1 ), 1 ) endif endif c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 3 ) then if ( itrmks . ne . 1 . and . itrmks . ne . 2 ) then write ( ipunit , 830 ) itrmks , rsnrm 830 format ( 'nitgm:  itrmks =' , i2 , '    final lin. res. norm =' , $ 1 pd10 . 3 ) else write ( ipunit , 840 ) itrmks 840 format ( 'nitgm: itrmks:' , i4 ) endif endif c ------------------------------------------------------------------------ return end"},{"title":"glacier.F90 – ISOFT","tags":"","loc":"sourcefile/glacier.f90.html","text":"This file depends on sourcefile~~glacier.f90~~EfferentGraph sourcefile~glacier.f90 glacier.F90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~glacier.f90->sourcefile~nitsol.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~glacier.f90~~AfferentGraph sourcefile~glacier.f90 glacier.F90 sourcefile~ice_shelf.f90 ice_shelf.F90 sourcefile~ice_shelf.f90->sourcefile~glacier.f90 sourcefile~cryosphere.f90 cryosphere.F90 sourcefile~cryosphere.f90->sourcefile~glacier.f90 sourcefile~ice_sheet.f90 ice_sheet.F90 sourcefile~ice_sheet.f90->sourcefile~glacier.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules glacier_mod Source Code glacier.F90 Source Code ! !  glacier.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module glacier_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides an abstract type to represent large masses of ice, such ! as ice sheets and ice shelves. ! use iso_fortran_env , only : r8 => real64 !use foodie, only: integrand use factual_mod , only : scalar_field , vector_field use nitsol_mod !, only: nitsol, dummy_jacv, ddot, dnrm2 use hdf5 , only : hid_t use penf , only : str use logger_mod , only : logger => master_logger implicit none private character ( len = 12 ), parameter , public :: hdf_type_attr = 'glacier_type' type , abstract , public :: glacier !* Author: Christopehr MacMackin !  Date: April 2016 ! ! An abstract data type which represents large masses of ice, such ! as ice shelves and ice sheets. ! contains procedure ( get_scalar ), deferred :: ice_thickness !! Returns the thickness of the ice in the glacier across the domain. procedure ( get_r8 ), deferred :: ice_density !! Returns the density of the ice, which is assumed to be uniform. procedure ( get_r8 ), deferred :: ice_temperature !! Returns the temperature of the ice, which is assumed to be uniform. procedure ( get_residual ), deferred :: residual !! Computes the residual of the system of equations describing the !! glacier. procedure ( precond ), deferred :: precondition !! Applies a preconditioner to the passed state vector. procedure ( solve_vel ), deferred :: solve_velocity !! Solves for the velocity field using the current thickness. procedure ( setter ), deferred :: update !! Sets the state of the glacier. procedure ( time_setter ), deferred :: set_time !! Sets the time record for this glacier. procedure ( get_i ), deferred :: data_size !! Returns the number of elements in the glacier's state vector procedure ( get_r81d ), deferred :: state_vector !! Returns the glacier's state vector, a 1D array with all necessary !! data to describe its state. procedure ( read_dat ), deferred :: read_data !! Read the glacier data from an HDF5 file on the disc. procedure ( write_dat ), deferred :: write_data !! Writes the data describing the glacier to the disc as an HDF5 file. procedure ( t_step ), deferred :: time_step !! Calculates the appropriate time step for integration. procedure ( assign_ice ), private , deferred :: assign !! Copies the data from one glacier into another. This is only !! needed due to a bug in gfortran which means that the !! intrinsic assignment for glacier types is not using the !! appropriate defined assignment for the field components. generic :: assignment ( = ) => assign procedure :: integrate => glacier_integrate !! Performs a time-step of the integration, taking the state of !! the glacier to the specified time using the provided !! melt-rate data. procedure :: integrate_layers => glacier_integrate_layers !! Dummy routine which can be over-ridden to integrate internal !! layers of the glacier to the specified time. end type glacier abstract interface function get_scalar ( this ) result ( property ) import :: glacier import :: scalar_field class ( glacier ), intent ( in ) :: this class ( scalar_field ), pointer :: property !! The value of whatever property of the glacier is being returned. end function get_scalar !$    function get_vector(this) result(property) !$      import :: glacier !$      import :: vector_field !$      class(glacier), intent(in)       :: this !$      class(vector_field), allocatable :: property !$        !! The value of whatever property of the glacier is being returned. !$    end function get_vector pure function get_r8 ( this ) result ( property ) import :: glacier import :: r8 class ( glacier ), intent ( in ) :: this real ( r8 ) :: property !! The value of whatever property of the glacier is being returned. end function get_r8 function get_residual ( this , previous_states , melt_rate , & basal_drag_parameter , water_density ) result ( residual ) import :: glacier import :: scalar_field import :: r8 class ( glacier ), intent ( in ) :: this class ( glacier ), dimension (:), intent ( in ) :: previous_states !! The states of the glacier in the previous time steps. The !! first element of the array should be the most recent. The !! default implementation will only make use of the most !! recent state, but the fact that this is an array allows !! overriding methods to use older states for higher-order !! integration methods. class ( scalar_field ), intent ( in ) :: melt_rate !! Thickness of the ice above the glacier class ( scalar_field ), intent ( in ) :: basal_drag_parameter !! A paramter, e.g. coefficient of friction, needed to !! calculate the drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier real ( r8 ), dimension (:), allocatable :: residual !! The residual of the system of equations describing the !! glacier end function get_residual function precond ( this , previous_states , melt_rate , & basal_drag_parameter , water_density , & delta_state ) result ( preconditioned ) import :: glacier import :: scalar_field import :: r8 class ( glacier ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: previous_states !! The states of the glacier in the previous time steps. The !! first element of the array should be the most recent. The !! default implementation will only make use of the most !! recent state, but the fact that this is an array allows !! overriding methods to use older states for higher-order !! integration methods. class ( scalar_field ), intent ( in ) :: melt_rate !! Thickness of the ice above the glacier class ( scalar_field ), intent ( in ) :: basal_drag_parameter !! A paramter, e.g. coefficient of friction, needed to !! calculate the drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier real ( r8 ), dimension (:), intent ( in ) :: delta_state !! The change to the state vector which is being !! preconditioned. real ( r8 ), dimension (:), allocatable :: preconditioned !! The result of applying the preconditioner to `delta_state`. end function precond subroutine solve_vel ( this , basal_drag , success ) import :: glacier import :: scalar_field class ( glacier ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: basal_drag !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. logical , intent ( out ) :: success !! True if the integration is successful, false otherwise end subroutine solve_vel function get_r81d ( this ) result ( state_vector ) import :: glacier import :: r8 class ( glacier ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector of the glacier end function get_r81d subroutine setter ( this , state_vector ) import :: glacier import :: r8 class ( glacier ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! glacier. end subroutine setter subroutine time_setter ( this , time ) import :: glacier import :: r8 class ( glacier ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time !! The time at which the glacier is in the present state. end subroutine time_setter pure function get_i ( this ) result ( property ) import :: glacier class ( glacier ), intent ( in ) :: this integer :: property !! The value of whatever property of the glacier is being returned. end function get_i subroutine read_dat ( this , file_id , group_name , error ) import :: glacier import :: hid_t class ( glacier ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group from which the data !! will be read. character ( len =* ), intent ( in ) :: group_name !! The name of the group in the HDF5 file from which to read !! glacier's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. end subroutine read_dat subroutine write_dat ( this , file_id , group_name , error ) import :: glacier import :: hid_t class ( glacier ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! glacier's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. end subroutine write_dat function t_step ( this ) import :: r8 import :: glacier class ( glacier ), intent ( in ) :: this real ( r8 ) :: t_step !! A time step which will allow integration of the ice shelf !! without causing numerical instability. end function t_step subroutine assign_ice ( this , rhs ) import :: glacier class ( glacier ), intent ( out ) :: this class ( glacier ), intent ( in ) :: rhs end subroutine assign_ice end interface #ifdef DEBUG #undef pure #undef elemental #endif abstract interface pure function thickness_func ( location ) result ( thickness ) !* Author: Chris MacMackin !  Date: April 2016 ! ! Abstract interface for function providing the [[glacier]] thickness ! when a concrete object is being instantiated. ! import :: r8 real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the thickness real ( r8 ) :: thickness !! The thickness of the glacier at `location` end function thickness_func pure function velocity_func ( location ) result ( velocity ) !* Author: Chris MacMackin !  Date: July 2016 ! ! Abstract interface for function providing the [[glacier]] velocity ! when a concrete object is being instantiated. ! import :: r8 real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the thickness real ( r8 ), dimension (:), allocatable :: velocity !! The velocity vector of the ice in the glacier at `location` end function velocity_func end interface #ifdef DEBUG #define pure #define elemental #endif public :: thickness_func , velocity_func contains subroutine glacier_integrate ( this , old_states , basal_melt , basal_drag , & water_density , time , success ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Integrates the glacier's state to `time`. This is done using the ! NITSOL package of iterative Krylov solvers. If a different ! algorithm for the integration is desired, then this method may ! be overridden in the concrete implementations of the glacier ! type. ! class ( glacier ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: old_states !! Previous states of the glacier, with the most recent one !! first. class ( scalar_field ), intent ( in ) :: basal_melt !! The melt rate that the bottom of the glacier experiences !! during this time step. class ( scalar_field ), intent ( in ) :: basal_drag !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier. real ( r8 ), intent ( in ) :: time !! The time to which the glacier should be integrated logical , intent ( out ) :: success !! True if the integration is successful, false otherwise logical :: first_call integer , save :: nval , kdmax = 20 real ( r8 ), dimension (:), allocatable :: state integer , dimension ( 10 ) :: input integer , dimension ( 6 ) :: info real ( r8 ), dimension (:), allocatable , save :: work real ( r8 ), dimension ( 1 ) :: real_param integer , dimension ( 1 ) :: int_param integer :: flag call basal_melt % guard_temp (); call basal_drag % guard_temp () first_call = . true . nval = this % data_size () if ( allocated ( work )) then if ( size ( work ) < nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 )) then deallocate ( work ) allocate ( work ( nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 ))) end if else allocate ( work ( nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 ))) end if state = this % state_vector () call this % set_time ( time ) input = 0 input ( 4 ) = kdmax input ( 5 ) = 1 input ( 9 ) = - 1 input ( 10 ) = 3 etafixed = 0.3_r8 #ifdef DEBUG call logger % debug ( 'glacier%integrate' , 'Calling NITSOL (nonlinear solver)' ) #endif call nitsol ( nval , state , nitsol_residual , nitsol_precondition , & 1.e-10_r8 * nval , 1.e-10_r8 * nval , input , info , work , & real_param , int_param , flag , ddot , dnrm2 ) call this % update ( state ) !!$    if (flag == 6 .and. input(9) > -1) then !!$      input(9) = -1 !!$      call logger%trivia('glacier%integrate','Backtracking failed in NITSOL '// & !!$                         'at simulation time '//str(time)//'. Trying again '//  & !!$                         'without backtracking.') !!$      call nitsol(nval, state, nitsol_residual, nitsol_precondition, & !!$                  1.e-7_r8, 1.e-7_r8, input, info, work, real_param, & !!$                  int_param, flag, ddot, dnrm2) !!$    end if #ifdef DEBUG call logger % debug ( 'glacier%integrate' , 'NITSOL required ' // & trim ( str ( info ( 5 ))) // ' nonlinear iterations ' // & 'and ' // trim ( str ( info ( 1 ))) // ' function calls.' ) #endif select case ( flag ) case ( 0 ) call logger % trivia ( 'glacier%integrate' , 'Integrated glacier to time ' // & trim ( str ( time ))) success = . true . case ( 1 ) call logger % error ( 'glacier%integrate' , 'Reached maximum number of' // & ' iterations integrating glacier' ) success = . false . !case(5) !  call logger%debug('glacier%integrate','Solution diverging. Trying '// & !                    'again with backtracking.') !  state = old_states(1)%state_vector() !  input(9) = 0 !  call nitsol(nval, state, nitsol_residual, nitsol_precondition, & !              1.e-7_r8, 1.e-7_r8, input, info, work, real_param, & !              int_param, flag, ddot, dnrm2) !  call this%update(state) !  if (flag == 0) then !    call logger%trivia('glacier%integrate','Integrated glacier to time '// & !                       trim(str(time))) !    success = .true. !  else !    call logger%error('glacier%integrate','NITSOL failed when integrating'// & !                      ' glacier with error code '//trim(str(flag))) !    success = .false. !  end if case default call logger % error ( 'glacier%integrate' , 'NITSOL failed when integrating' // & ' glacier with error code ' // trim ( str ( flag ))) success = . false . end select if ( success ) then call this % integrate_layers ( old_states , time , success ) end if call basal_melt % clean_temp (); call basal_drag % clean_temp () contains subroutine nitsol_residual ( n , xcur , fcur , rpar , ipar , itrmf ) !! A routine matching the interface expected by NITSOL which !! returns the residual for the glacier. integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( out ) :: fcur !! Array of length `n` containing f(xcur) on output real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array integer , intent ( out ) :: itrmf !! Termination flag. 0 means normal termination, 1 means !! failure to produce f(xcur) logical :: success ! If this is the first call of this routine then the ! basal_surface object will already be in the same state as ! reflected in xcur if ( first_call ) then first_call = . false . else call this % update ( xcur ( 1 : n )) end if call this % solve_velocity ( basal_drag , success ) if (. not . success ) then itrmf = 1 return end if fcur ( 1 : n ) = this % residual ( old_states , basal_melt , basal_drag , water_density ) !print*, fcur(1:n) itrmf = 0 end subroutine nitsol_residual subroutine nitsol_precondition ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! A subroutine matching the interface expected by NITSOL, which !! acts as a preconditioner. integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of lenght `n` containing the current $x$ value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of lenght `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flat indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce $J\\vec{v}$, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} if ( ijob /= 1 ) then itrmjv = 0 return end if z ( 1 : n ) = this % precondition ( old_states , basal_melt , basal_drag , & water_density , v ( 1 : n )) itrmjv = 0 end subroutine nitsol_precondition end subroutine glacier_integrate subroutine glacier_integrate_layers ( this , old_states , time , success ) !* Author: Chris MacMackin !  Date: September 2018 ! ! Dummy routine which does nothing. ! class ( glacier ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: old_states !! Previous states of the glacier, with the most recent one !! first. real ( r8 ), intent ( in ) :: time !! The time to which the glacier should be integrated logical , intent ( out ) :: success !! True if the integration is successful, false otherwise continue end subroutine glacier_integrate_layers end module glacier_mod"},{"title":"transverse_coefficients.f90 – ISOFT","tags":"","loc":"sourcefile/transverse_coefficients.f90.html","text":"Contents Modules transverse_coefficients_mod Source Code transverse_coefficients.f90 Source Code ! !  transverse_coefficients.F90 !  This file is part of ISOFT. ! !  Copyright 2018 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module transverse_coefficients_mod !* Author: Chris MacMackin !  Date: July 2018 !  License: GPLv3 ! ! Provides functions to calculate the coefficients for the ! horizontally-integrated [asymmetric_plume] from the basal slope of ! the ice shelf. This module just provides the interface. The ! implmentation is automatically generated by the Python script ! XXXXXXXX based on various parameter choices, approximating the ! coefficients using interpolation. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field implicit none interface module function alpha_du ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{DU} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)dy  for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_du end function alpha_du module function alpha_du2 ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{DU&#94;2} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)&#94;2dy  for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_du2 end function alpha_du2 module function alpha_d2 ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{D&#94;2} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_D(y)&#94;2dy  for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_d2 end function alpha_d2 module function alpha_dv ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{DV} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_D(y)f_V(y)dy  for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_dv end function alpha_dv module function alpha_duv ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{DUV} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)f_V(y)dy  for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_duv end function alpha_duv module function alpha_uvecu ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{|\\vec{U}|U} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_{|\\vec{U}|}(y)f_U(y)dy  for the given ! shelf slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_uvecu end function alpha_uvecu module function alpha_uvecv ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{|\\vec{U}|V} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_{|\\vec{U}|}(y)f_V(y)dy  for the given ! shelf slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_uvecv end function alpha_uvecv module function alpha_dus ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{DUS} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)f_S(y)dy  for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_dus end function alpha_dus module function alpha_dut ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{DUT} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)f_T(y)dy  for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_dut end function alpha_dut module function alpha_uvect ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{|\\vec{U}|T} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_{|\\vec{U}|}(y)f_{T}(y)dy  for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_uvect end function alpha_uvect module function alpha_ds ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{DS} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_D(y)f_S(y)dy  for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_ds end function alpha_ds module function alpha_dt ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\alpha_{DT} = \\frac{1}{\\Delta ! y}\\int&#94;{y_2}_{y_1}f_D(y)f_T(y)dy  for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_dt end function alpha_dt module function alpha_ds_t ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\tilde{\\alpha}_{DS} = \\frac{1}{\\Delta ! y\\alpha_{D&#94;2}}\\int&#94;{y_2}_{y_1}f_D(y)&#94;2f_S(y)dy  for the ! given shelf slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_ds end function alpha_ds_t module function alpha_dt_t ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of  \\tilde{\\alpha}_{DT} = \\frac{1}{\\Delta ! y\\alpha_{D&#94;2}}\\int&#94;{y_2}_{y_1}f_D(y)&#94;2f_T(y)dy  for the ! given shelf slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: alpha_dt_t end function alpha_dt_t module function f_d ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of $f_D(y_2)$ for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: f_d end function f_d module function f_u ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of $f_U(y_2)$ for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: f_u end function f_u module function f_v ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of $f_V(y_2)$ for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: f_v end function f_v module function f_s ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of $f_S(y_2)$ for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: f_s end function f_s module function f_t ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of $f_T(y_2)$ for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: f_t end function f_t module function f_u_p ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of $f'_U(y_2)$ for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: f_u_p end function f_u_p module function f_v_p ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of $f'_V(y_2)$ for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: f_v_p end function f_v_p module function f_s_p ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of $f'_S(y_2)$ for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: f_s_p end function f_s_p module function f_t_p ( b_x ) !* Author: Chris MacMackin !  Date: July 2018 ! ! Interpolates the value of $f'_T(y_2)$ for the given shelf ! slope. ! class ( scalar_field ), intent ( in ) :: b_x class ( scalar_field ), pointer :: f_t_p end function f_t_p end interface interface subroutine splev ( t , n , c , k , x , y , m , e , ier ) !* Author: P. Dierck ! !  Subroutine splev evaluates in a number of points x(i),i=1,2,...,m !  a spline s(x) of degree k, given in its b-spline representation. import :: r8 real ( r8 ), dimension ( * ), intent ( in ) :: t !! Array, length n, which contains the position of the knots. integer , intent ( in ) :: n !! Integer, giving the total number of knots of s(x). real ( r8 ), dimension ( * ), intent ( in ) :: c !! Array, length n, which contains the b-spline coefficients. integer , intent ( in ) :: k !! Integer, giving the degree of s(x). real ( r8 ), dimension ( * ), intent ( in ) :: x !! Array, length m, which contains the points where s(x) must !! be evaluated. real ( r8 ), dimension ( * ), intent ( out ) :: y !! Array, length m, giving the value of s(x) at the different !! points. integer , intent ( in ) :: m !! Integer, giving the number of points where s(x) must be !! evaluated. integer , intent ( in ) :: e !! integer, if 0 the spline is extrapolated from the end !! spans for points not in the support, if 1 the spline !! evaluates to zero for those points, if 2 ier is set to !! 1 and the subroutine returns, and if 3 the spline evaluates !! to the value of the nearest boundary point. integer , intent ( out ) :: ier !! Error flag: !! !! - ier = 0: normal return !! - ier = 1: argument out of bounds and e == 2 !! - ier =10: invalid input data (see restrictions) end subroutine splev end interface private :: splev end module transverse_coefficients_mod"},{"title":"asymmetric_plume.F90 – ISOFT","tags":"","loc":"sourcefile/asymmetric_plume.f90.html","text":"This file depends on sourcefile~~asymmetric_plume.f90~~EfferentGraph sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~entrainment.f90 entrainment.F90 sourcefile~asymmetric_plume.f90->sourcefile~entrainment.f90 sourcefile~plume_boundary.f90 plume_boundary.F90 sourcefile~asymmetric_plume.f90->sourcefile~plume_boundary.f90 sourcefile~coriolis_block.f90 coriolis_block.F90 sourcefile~asymmetric_plume.f90->sourcefile~coriolis_block.f90 sourcefile~ode_solvers.f90 ode_solvers.f90 sourcefile~asymmetric_plume.f90->sourcefile~ode_solvers.f90 sourcefile~dallaston2015_melt.f90 dallaston2015_melt.F90 sourcefile~asymmetric_plume.f90->sourcefile~dallaston2015_melt.f90 sourcefile~jenkins1991_entrainment.f90 jenkins1991_entrainment.F90 sourcefile~asymmetric_plume.f90->sourcefile~jenkins1991_entrainment.f90 sourcefile~melt_relationship.f90 melt_relationship.F90 sourcefile~asymmetric_plume.f90->sourcefile~melt_relationship.f90 sourcefile~uniform.f90 uniform.F90 sourcefile~asymmetric_plume.f90->sourcefile~uniform.f90 sourcefile~simple_plume.f90 simple_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~simple_plume.f90 sourcefile~averaged_linear_eos.f90 averaged_linear_eos.F90 sourcefile~asymmetric_plume.f90->sourcefile~averaged_linear_eos.f90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~asymmetric_plume.f90->sourcefile~boundary_types.f90 sourcefile~upstream_plume.f90 upstream_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~upstream_plume.f90 sourcefile~basal_surface.f90 basal_surface.F90 sourcefile~asymmetric_plume.f90->sourcefile~basal_surface.f90 sourcefile~ambient.f90 ambient.F90 sourcefile~asymmetric_plume.f90->sourcefile~ambient.f90 sourcefile~pseudospectral_block.f90 pseudospectral_block.F90 sourcefile~asymmetric_plume.f90->sourcefile~pseudospectral_block.f90 sourcefile~equation_of_state.f90 equation_of_state.F90 sourcefile~asymmetric_plume.f90->sourcefile~equation_of_state.f90 sourcefile~linear_eos.f90 linear_eos.F90 sourcefile~asymmetric_plume.f90->sourcefile~linear_eos.f90 sourcefile~plume_boundary.f90->sourcefile~boundary_types.f90 sourcefile~coriolis_block.f90->sourcefile~pseudospectral_block.f90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~ode_solvers.f90->sourcefile~nitsol.f90 sourcefile~dallaston2015_melt.f90->sourcefile~melt_relationship.f90 sourcefile~jenkins1991_entrainment.f90->sourcefile~entrainment.f90 sourcefile~uniform.f90->sourcefile~ambient.f90 sourcefile~simple_plume.f90->sourcefile~plume_boundary.f90 sourcefile~simple_plume.f90->sourcefile~boundary_types.f90 sourcefile~averaged_linear_eos.f90->sourcefile~equation_of_state.f90 sourcefile~upstream_plume.f90->sourcefile~plume_boundary.f90 sourcefile~upstream_plume.f90->sourcefile~boundary_types.f90 sourcefile~rksuite_90.f90 rksuite_90.f90 sourcefile~upstream_plume.f90->sourcefile~rksuite_90.f90 sourcefile~uniform_gradient_field.f90 uniform_gradient_field.f90 sourcefile~upstream_plume.f90->sourcefile~uniform_gradient_field.f90 sourcefile~basal_surface.f90->sourcefile~nitsol.f90 sourcefile~linear_eos.f90->sourcefile~equation_of_state.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules asymmetric_plume_mod Source Code asymmetric_plume.F90 Source Code ! !  asymmetric_plume.f90 !  This file is part of ISOFT. ! !  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module asymmetric_plume_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides a concrete implementation of the [[basal_surface(type)]] data type, ! representing a buoyant plume beneath an ice shelf. ! use iso_fortran_env , only : r8 => real64 use basal_surface_mod , only : basal_surface , hdf_type_attr use factual_mod , only : scalar_field , vector_field , cheb1d_scalar_field , & cheb1d_vector_field , uniform_scalar_field , & uniform_vector_field use ode_solvers_mod , only : quasilinear_solve use entrainment_mod , only : abstract_entrainment use melt_relationship_mod , only : abstract_melt_relationship use plume_boundary_mod , only : plume_boundary use upstream_plume_mod , only : upstream_plume_boundary use boundary_types_mod , only : free_boundary , dirichlet , neumann use ambient_mod , only : ambient_conditions use equation_of_state_mod , only : equation_of_state use jenkins1991_entrainment_mod , only : jenkins1991_entrainment use dallaston2015_melt_mod , only : dallaston2015_melt use uniform_ambient_mod , only : uniform_ambient_conditions use simple_plume_boundary_mod , only : simple_plume_boundary use pseudospectral_block_mod , only : pseudospec_block use coriolis_block_mod , only : coriolis_block use linear_eos_mod , only : linear_eos use ave_linear_eos_mod , only : ave_linear_eos use hdf5 use h5lt use logger_mod , only : logger => master_logger use penf , only : str implicit none private character ( len = 10 ), parameter , public :: hdf_type_name = 'asym_plume' character ( len = 9 ), parameter , public :: hdf_thickness = 'thickness' character ( len = 8 ), parameter , public :: hdf_velocity = 'velocity' character ( len = 11 ), parameter , public :: hdf_temperature = 'temperature' character ( len = 8 ), parameter , public :: hdf_salinity = 'salinity' character ( len = 5 ), parameter , public :: hdf_delta = 'delta' character ( len = 2 ), parameter , public :: hdf_nu = 'nu' character ( len = 2 ), parameter , public :: hdf_mu = 'mu' character ( len = 5 ), parameter , public :: hdf_r = 'r_val' character ( len = 3 ), parameter , public :: hdf_phi = 'phi' type , public :: plume_shape !* Author: Christopher MacMackin !  Date: August 2018 ! ! A type containing the data necessary to specify the transverse ! shape of the plume. All variables in the plume are assumed to be ! seperable with the form D(x,y) = f_D2(y)\\hat{D}(x), U(x,y) ! = f_U2(y)\\hat{U}(x), etc. The magnitude of the velocity does ! not necessary take the form |\\vec{U}| = \\sqrt{U&#94;2 + V&#94;2} and ! is treated as an independent seperable variable |\\vec{U}| = ! f_{|\\vec{U}|}(y)\\widehat{|\\vec{U}|}(x). The transverse ! functions f_{D}(y), f_U2(y), etc. have all been ! normalised over the integration width y_1 to y_2. ! ! @Note that a number of variables are definied using the ! averaging operator  \\overline{A} = \\frac{1}{y_2 - y_1} ! \\int&#94;{y_2}_{y_1} A(y) dy.  ! real ( r8 ) :: f_D1 = 1.0_r8 !! f_D2(y_1) real ( r8 ) :: f_D2 = 1.0_r8 !! f_D2(y_2) real ( r8 ) :: f_U1 = 1.0_r8 !! f_U2(y_1) real ( r8 ) :: f_U2 = 1.0_r8 !! f_U2(y_2) real ( r8 ) :: f_V1 = 1.0_r8 !! f_V2(y_1) real ( r8 ) :: f_V2 = 1.0_r8 !! f_V2(y_2) real ( r8 ) :: f_S1 = 1.0_r8 !! f_S2(y_1) real ( r8 ) :: f_S2 = 1.0_r8 !! f_S2(y_2) real ( r8 ) :: f_T1 = 1.0_r8 !! f_T2(y_1) real ( r8 ) :: f_T2 = 1.0_r8 !! f_T2(y_2) real ( r8 ) :: f_Up = 0.0_r8 !! df_U2(y_2)/dy real ( r8 ) :: f_Vp = 0.0_r8 !! df_V2(y_2)/dy real ( r8 ) :: f_Sp = 0.0_r8 !! df_S2(y_2)/dy real ( r8 ) :: f_Tp = 0.0_r8 !! df_T2(y_2)/dy real ( r8 ) :: a_DU = 1.0_r8 !! \\alpha_{DU} = \\overline{f_D2 f_U2}  real ( r8 ) :: a_DV = 1.0_r8 !! \\alpha_{DV} = \\overline{f_D2 f_V2}  real ( r8 ) :: a_DU2 = 1.0_r8 !! \\alpha_{DU&#94;2} = \\overline{f_D2 f_U2&#94;2}  real ( r8 ) :: a_DUV = 1.0_r8 !! \\alpha_{DUV} = \\overline{f_D2 f_U2 f_V2}  real ( r8 ) :: a_D2 = 1.0_r8 !! \\alpha_{D&#94;2} = \\overline{f_D2&#94;2} real ( r8 ) :: a_UabsU = 1.0_r8 !! \\alpha_{|\\vec{U}|U} = \\overline{f_{|\\vec{U}|} f_U2 real ( r8 ) :: a_UabsV = 1.0_r8 !! \\alpha_{|\\vec{U}|V} = \\overline{f_{|\\vec{U}|} f_V2 real ( r8 ) :: a_DUS = 1.0_r8 !! \\alpha_{DUS} = \\overline{f_D2 f_U2 f_S2}  real ( r8 ) :: a_DUT = 1.0_r8 !! \\alpha_{DUT} = \\overline{f_D2 f_U2 f_T2}  real ( r8 ) :: a_UabsT = 1.0_r8 !! \\alpha_{|\\vec{U}|T} = \\overline{f_{|\\vec{U}|} f_T2 real ( r8 ) :: a_DS = 1.0_r8 !! \\alpha_{DS} = \\overline{f_D2 f_S2}  real ( r8 ) :: a_DT = 1.0_r8 !! \\alpha_{DT} = \\overline{f_D2 f_T2}  real ( r8 ) :: a_DS_t = 1.0_r8 !! \\tilde{\\alpha}_{DS} = \\overline{f_D2 f_S2}/\\alpha_{D&#94;2}  real ( r8 ) :: a_DT_t = 1.0_r8 !! \\tilde{\\alpha}_{DT} = \\overline{f_D2 f_T2}/\\alpha_{D&#94;2}  end type plume_shape type , extends ( basal_surface ), public :: asym_plume !* Author: Christopher MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[basal_surface(type)]] ! abstract data type, representing the buoyant plume beneath an ! ice shelf, which has been horizontally integrated over width ! \\Delta y = y_2 - y_1 in the y-direction. Transverse ! variation is assumed to be seperable, with variables having the ! form D(x,y) = f_D2(y)\\hat{D}(x), U(x,y) = ! f_U2(y)\\hat{U}(x). The shape of the transverse functions are ! described using the [[plume_shape(type)]] type. ! private type ( cheb1d_scalar_field ) :: thickness !! The thickness of the plume type ( cheb1d_vector_field ) :: velocity !! The velocity of the plume type ( cheb1d_vector_field ) :: velocity_dx !! The derivative of the velocity field type ( cheb1d_scalar_field ) :: temperature !! The temperature of the plume type ( cheb1d_scalar_field ) :: temperature_dx !! The derivative of the temperature of the plume type ( cheb1d_scalar_field ) :: salinity !! The salinity of the plume type ( cheb1d_scalar_field ) :: salinity_dx !! The derivative of the salinity of the plume class ( abstract_entrainment ), allocatable :: entrainment_formulation !! An object which provides the parameterisation for entrainment !! of water into the plume. class ( abstract_melt_relationship ), allocatable :: melt_formulation !! An object which provides the parameterisation for melting, !! salt, and heat fluxes from the plume to the ice. class ( ambient_conditions ), allocatable :: ambient_conds !! An object specifying the temperature and salinity of the !! ambient ocean at its interface with the plume. class ( equation_of_state ), allocatable , public :: eos !! An object specifying the equation of state relating the plume !! water's density to its temperature and salinity. class ( plume_boundary ), allocatable :: boundaries !! An object specifying the boundary conditions for the plume. real ( r8 ) :: delta !! The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real ( r8 ), public :: nu !! The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real ( r8 ) :: mu !! The dimensionless ratio \\mu \\equiv \\frac{\\C_dx_0}{D_0} real ( r8 ) :: r_val !! The dimensionless ratio of the ocean water density to the !! density of the overlying ice shelf. real ( r8 ), public :: phi !! The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} type ( plume_shape ), public :: shape !! The coefficients describing the transverse shape of the !! plume. real ( r8 ) :: dy !! The width \\Delta y = y_2-y_1 over which the plume has !! been horizontally averaged. real ( r8 ) :: time !! The time at which the ice shelf is in this state integer :: thickness_size !! The number of data values in the thickness field integer :: velocity_size !! The number of data values in the velocity field integer :: temperature_size !! The number of data values in the temperature field integer :: salinity_size !! the number of data values in the salinity field integer :: vel_dims !! The number of vector dimensions for the velocity logical , dimension ( 7 ) :: lower_bounds = . false . !! Which variables have boundary conditions at the grounding !! line. logical , dimension ( 7 ) :: upper_bounds = . false . !! Which variables have boundary conditions at the calving !! front. type ( pseudospec_block ) :: precond !! A pseudospectral differentiation block which can be used for !! preconditioning. type ( coriolis_block ) :: vel_precond !! A representation of the operation on the plume velocity terms !! which can be used for preconditioning. contains procedure :: initialise => asym_plume_initialise procedure :: basal_melt => asym_plume_melt procedure :: basal_drag_parameter => asym_plume_drag_parameter procedure :: water_density => asym_plume_water_density procedure :: update => asym_plume_update procedure :: data_size => asym_plume_data_size procedure :: state_vector => asym_plume_state_vector procedure :: read_data => asym_plume_read_data procedure :: write_data => asym_plume_write_data procedure :: solve => asym_plume_solve end type asym_plume abstract interface #ifdef DEBUG #undef pure #undef elemental #endif pure function scalar_func ( location ) result ( scalar ) !* Author: Chris MacMackin !  Date: April 2016 ! ! Abstract interface for function providing the initial values ! for the scalar properties of an [[asym_plume(type)]] object ! when it is being instantiated. ! import :: r8 real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the property real ( r8 ) :: scalar !! The value of the scalar quantity at `location` end function scalar_func pure function velocity_func ( location ) result ( vector ) !* Author: Chris MacMackin !  Date: April 2016 ! ! Abstract interface for function providing the ! [[asym_plume(type)]] velocity when an object is being ! instantiated. ! import :: r8 real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the thickness real ( r8 ), dimension (:), allocatable :: vector !! The velocity vector of the water in the plume at `location` end function velocity_func #ifdef DEBUG #define pure #define elemental #endif end interface contains subroutine asym_plume_initialise ( this , domain , resolution , & thickness , velocity , temperature , & salinity , shape , entrainment_formulation , & melt_formulation , ambient_conds , eos , & boundaries , delta , nu , mu , r_val , phi , dy ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Instantiates an [[asym_plume(type)]] object with initial ! coniditions provided by the arguments.At present only a 1D model ! is supported. If information is provided for higher dimensions ! then it will be ignored. ! class ( asym_plume ), intent ( out ) :: this !! A plume object with its domain and initial conditions set according !! to the arguments of the constructor function. real ( r8 ), dimension (:,:), intent ( in ) :: domain !! An array containing the upper and lower limits of the domain for !! the plume. The first index represents the dimension for which the !! boundaries apply. If the second index is 1 then it corresponds to !! the lower bound. If the second index is 2 then it corresponds to !! the upper bound. integer , dimension (:), intent ( in ) :: resolution !! The number of data points in each dimension procedure ( scalar_func ) :: thickness !! A function which calculates the initial value of the thickness of !! the plume at a given location. procedure ( velocity_func ) :: velocity !! A function which calculates the initial value of the velocity !! (vector) of the water at a given location in a plume. procedure ( scalar_func ) :: temperature !! A function which calculates the initial value of the temperature of !! the plume at a given location. procedure ( scalar_func ) :: salinity !! A function which calculates the initial value of the salinity of !! the plume at a given location. type ( plume_shape ), optional , intent ( in ) :: shape !! An object with components describing the transverse profile !! of the plume. Default is a plume that is uniform in the !! transverse direction. class ( abstract_entrainment ), allocatable , optional , & intent ( inout ) :: entrainment_formulation !! An object which calculates entrainment into the plume. Will !! be unallocated on exit. Defaults to that used by Jenkins !! (1991) with the coefficient $E_0 = 1$. class ( abstract_melt_relationship ), allocatable , optional , & intent ( inout ) :: melt_formulation !! An object which calculates melting and the resulting thermal !! transfer into/out of the plume. Will be unallocated on !! exit. Defaults to that used by Dallaston et al. (2015), !! scaled to be consistent with the nondimensionalisation used !! here. class ( ambient_conditions ), allocatable , optional , & intent ( inout ) :: ambient_conds !! An object specifying the salinity and temperature of the !! ambient ocean. Will be unallocated on exit. Defaults to !! uniform ambient salinity and temperature, both of which are !! set to 0 (as temperature and salinity are measured relative !! to some reference value). class ( equation_of_state ), allocatable , optional , & intent ( inout ) :: eos !! An object specifying the equation of state for the water in !! the plume. Will be unallocated on exit. Defaults to !! linearised equation of state with no temperature dependence !! and a haline contraction coefficient of 1. The reference !! density is set to be 1 in the dimensionless units when !! salinity and temeprature are 0. class ( plume_boundary ), allocatable , optional , & intent ( inout ) :: boundaries !! An object providing the boundary conditions for the !! plume. Will be unallocated on exit. Defaults to those used by !! Dallaston et al. (2015). real ( r8 ), optional , intent ( in ) :: delta !! The dimensionless ratio \\delta \\equiv !! \\frac{D_0}{h_0}. Defaults to 0.036. real ( r8 ), optional , intent ( in ) :: nu !! The dimensionless ratio \\nu \\equiv !! \\frac{\\kappa_0}{x_0U_o}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: mu !! The dimensionless ratio \\mu \\equiv !! \\frac{C_dx_0}{D_0}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: r_val !! The dimensionless ratio of the water density to the ice shelf !! density,  r = \\rho_0/\\rho_i.  Defaults to 1.12. real ( r8 ), optional , intent ( in ) :: phi !! The inverse Rossby number, \\Phi \\equiv !! \\frac{fx_0}{U_0}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: dy !! The width over which the plume has been averaged. Defualts to 1. integer :: i , btype_l , btype_u , bdepth_l , bdepth_u this % vel_dims = size ( velocity ([ 0._r8 ])) this % thickness = cheb1d_scalar_field ( resolution ( 1 ), thickness , domain ( 1 , 1 ), domain ( 1 , 2 )) this % velocity = cheb1d_vector_field ( resolution ( 1 ), velocity , domain ( 1 , 1 ), domain ( 1 , 2 ), this % vel_dims - 1 ) this % temperature = cheb1d_scalar_field ( resolution ( 1 ), temperature , domain ( 1 , 1 ), domain ( 1 , 2 )) this % salinity = cheb1d_scalar_field ( resolution ( 1 ), salinity , domain ( 1 , 1 ), domain ( 1 , 2 )) this % thickness_size = this % thickness % raw_size () this % velocity_size = this % velocity % raw_size () this % temperature_size = this % temperature % raw_size () this % salinity_size = this % salinity % raw_size () this % velocity_dx = this % velocity % d_dx ( 1 ) this % salinity_dx = this % salinity % d_dx ( 1 ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( present ( shape )) this % shape = shape if ( present ( entrainment_formulation )) then call move_alloc ( entrainment_formulation , this % entrainment_formulation ) else allocate ( jenkins1991_entrainment :: this % entrainment_formulation ) end if if ( present ( melt_formulation )) then call move_alloc ( melt_formulation , this % melt_formulation ) else allocate ( dallaston2015_melt :: this % melt_formulation ) end if if ( present ( ambient_conds )) then call move_alloc ( ambient_conds , this % ambient_conds ) else allocate ( uniform_ambient_conditions :: this % ambient_conds ) end if if ( present ( eos )) then call move_alloc ( eos , this % eos ) else allocate ( linear_eos :: this % eos ) end if if ( present ( boundaries )) then call move_alloc ( boundaries , this % boundaries ) else allocate ( simple_plume_boundary :: this % boundaries ) end if if ( present ( delta )) then this % delta = delta else this % delta = 0.036_r8 end if if ( present ( nu )) then this % nu = nu else this % nu = 0.0_r8 end if if ( present ( mu )) then this % mu = mu else this % mu = 0.0_r8 end if if ( present ( r_val )) then this % r_val = r_val else this % r_val = 1.12_r8 end if if ( present ( phi )) then this % phi = phi else this % phi = 0.0_r8 end if if ( present ( dy )) then this % dy = dy else this % dy = 1.0_r8 end if this % time = 0.0_r8 ! Initialise preconditioner this % precond = pseudospec_block ( this % thickness ) ! Store information on boundary conditions call this % boundaries % thickness_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % thickness_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower thickness boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper thickness boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if #endif select case ( btype_l ) case ( free_boundary ) case ( dirichlet ) this % lower_bounds ( 1 ) = . true . case default error stop ( 'Only free, and Dirichlet boundary conditions ' // & 'supported for asym_plume thickness.' ) end select select case ( btype_u ) case ( free_boundary ) case ( dirichlet ) this % upper_bounds ( 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for asym_plume.' ) end select call this % boundaries % velocity_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % velocity_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower velocity boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper velocity boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 2 ) call this % boundaries % temperature_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % temperature_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower temperature boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper temperature boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 4 ) call this % boundaries % salinity_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % salinity_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower salinity boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper salinity boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 6 ) if ( this % phi /= 0._r8 ) then associate ( velbound => btype_l , dvelbound => btype_u ) if ( this % lower_bounds ( 2 )) then velbound = - 1 else if ( this % upper_bounds ( 2 )) then velbound = 1 end if if ( this % lower_bounds ( 3 )) then dvelbound = - 1 else if ( this % upper_bounds ( 3 )) then dvelbound = 1 end if this % vel_precond = coriolis_block ( this % phi , this % nu , velbound , & dvelbound , 1 , this % thickness ) end associate end if #ifdef DEBUG call logger % debug ( 'asym_plume' , 'Initialised new ice shelf object.' ) #endif contains subroutine set_preconditioners ( ltype , utype , comp_id ) integer , intent ( in ) :: ltype , utype , comp_id select case ( ltype ) case ( free_boundary ) case ( dirichlet ) this % lower_bounds ( comp_id ) = . true . case ( neumann ) this % lower_bounds ( comp_id + 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for asym_plume.' ) end select select case ( utype ) case ( free_boundary ) case ( dirichlet ) this % upper_bounds ( comp_id ) = . true . case ( neumann ) this % upper_bounds ( comp_id + 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for asym_plume.' ) end select end subroutine set_preconditioners end subroutine asym_plume_initialise function asym_plume_melt ( this ) result ( melt ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the melt rate at the bottom of the ice ! shelf due to interaction with the plume. ! class ( asym_plume ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate at the base of the ice shelf. melt => this % melt_formulation % melt_rate () #ifdef DEBUG call logger % debug ( 'asym_plume%melt' , 'Returned melt rate.' ) #endif end function asym_plume_melt function asym_plume_drag_parameter ( this ) result ( drag ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns a quantity which may be necessary to determine ! the frictional drag the plume exerts on the bottom of the ice ! shelf. The plume would actually tend to exert no drag on the bottom ! of the ice shelf, but this method is present so that there is a ! consistent interface with the [[ground(type)]] data type. ! class ( asym_plume ), intent ( in ) :: this class ( scalar_field ), pointer :: drag !! The melt rate at the base of the ice sheet. type ( uniform_scalar_field ) :: dummy call dummy % allocate_scalar_field ( drag ) drag = uniform_scalar_field ( 0.0_r8 ) call drag % set_temp () #ifdef DEBUG call logger % debug ( 'asym_plume%drag_parameter' , 'Returned plume drag parameter.' ) #endif end function asym_plume_drag_parameter function asym_plume_water_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the density of the plume water beneath the ice ! shelf. The density of this water would vary depending on how much ! saline ambient water has been entrained into the plume versus how ! much fresh water has been released due to melting. However, the ! Boussinesq approximation is used here and only a single reference ! density is returned. ! ! @NOTE Based on my approach to non-dimensionalisation, I'm pretty ! sure the density should always be 1, making this method ! unneccessary. ! class ( asym_plume ), intent ( in ) :: this real ( r8 ) :: density !! The density of the water at the base of the ice sheet. density = 1.0_r8 #ifdef DEBUG call logger % debug ( 'asym_plume%water_density' , 'Plume has average density ' // & trim ( str ( density )) // '.' ) #endif end function asym_plume_water_density subroutine asym_plume_update ( this , state_vector , ice_thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the plume from its state vector. The state ! vector is a real array containing the value of each of the plume's ! properties at each of the locations on the grid used in discretization. ! class ( asym_plume ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! plume. class ( scalar_field ), optional , intent ( in ) :: ice_thickness !! The ice thickness which, if present, will be used to update !! the calculation of the melt rate. integer :: i !TODO: Add some assertion-like checks that the state vector is the right size call this % thickness % set_from_raw ( state_vector ( 1 : this % thickness_size )) i = 1 + this % thickness_size call this % velocity % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % velocity_dx % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % temperature % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % temperature_dx % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % salinity % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) i = i + this % salinity_size call this % salinity_dx % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) if ( present ( ice_thickness )) then call this % melt_formulation % solve_for_melt ( this % velocity , & - ice_thickness / this % r_val , & this % temperature , & this % salinity , & this % thickness , & this % time ) end if #ifdef DEBUG call logger % debug ( 'asym_plume%update' , 'Updated state of plume.' ) #endif end subroutine asym_plume_update function asym_plume_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the plume's state vector. ! This is the size of the vector returned by ! [[asym_plume(type):state_vector]] and taken as an argument by ! [[plume(type):update]]. ! class ( asym_plume ), intent ( in ) :: this integer :: asym_plume_data_size !! The number of elements in the plume's state vector. asym_plume_data_size = this % thickness % raw_size () + this % velocity % raw_size () + & this % velocity_dx % raw_size () + this % temperature % raw_size () + & this % temperature_dx % raw_size () + this % salinity % raw_size () + & this % salinity_dx % raw_size () #ifdef DEBUG call logger % debug ( 'asym_plume%data_size' , 'Plume shelf has ' // & trim ( str ( asym_plume_data_size )) // ' elements ' // & 'in its state vector.' ) #endif end function asym_plume_data_size function asym_plume_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the plume. ! This takes the form of a 1D array. ! class ( asym_plume ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the plume. state_vector = [ this % thickness % raw (), this % velocity % raw (), & this % velocity_dx % raw (), this % temperature % raw (), & this % temperature_dx % raw (), this % salinity % raw (), & this % salinity_dx % raw ()] #ifdef DEBUG call logger % debug ( 'asym_plume%state_vector' , 'Returning state vector ' // & 'for plume.' ) #endif end function asym_plume_state_vector subroutine asym_plume_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the plume object from an HDF file in the ! specified group. This sets the thickness, velocity, temperature, ! salinity dataset, and parameter values. ! class ( asym_plume ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err real ( r8 ), dimension ( 1 ) :: param character ( len = 50 ) :: base_type ret_err = 0 call h5gopen_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % error ( 'asym_plume%read_data' , 'Could not open HDF group \"' // & group_name // '\", so no IO performed.' ) return end if call h5ltget_attribute_string_f ( file_id , group_name , hdf_type_attr , & base_type , error ) if ( trim ( base_type ) /= hdf_type_name ) then call logger % error ( 'asym_plume%read_data' , 'Trying to read data from ' // & 'basal_surface of type other than plume.' ) error = - 1 return end if !call h5ltget_attribute_double_f(file_id, group_name, hdf_delta, & !                                param, error) !this%delta = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_nu, & !                                param, error) !this%nu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_mu, & !                                param, error) !this%mu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_r, & !                                param, error) !this%r_val = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_phi, & !                                param, error) !this%phi = param(1) !if (error /= 0) then !  call logger%warning('plume%read_data','Error code '//     & !                      trim(str(error))//' returned when '//  & !                      'reading attributes from HDF group '// & !                      group_name) !  ret_err = error !end if call this % thickness % read_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume thickness field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % read_hdf ( group_id , hdf_velocity , error ) this % velocity_dx = this % velocity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume velocity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % read_hdf ( group_id , hdf_temperature , error ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume temperature field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % read_hdf ( group_id , hdf_salinity , error ) this % salinity_dx = this % salinity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume salinity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err call logger % trivia ( 'asym_plume%read_data' , 'Read plume data from HDF group ' // & group_name ) end subroutine asym_plume_read_data subroutine asym_plume_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the plume object to an HDF file in the ! specified group. This will consist of a thickness, a velocity, a ! temperature, and a salinity dataset. ! class ( asym_plume ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err ret_err = 0 call h5gcreate_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned ' // & 'when creating HDF group \"' // group_name // '\"' ) call logger % error ( 'asym_plume%write_data' , 'Data IO not performed for plume' ) return end if call h5ltset_attribute_string_f ( file_id , group_name , hdf_type_attr , & hdf_type_name , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_delta , & [ this % delta ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_nu , & [ this % nu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_mu , & [ this % mu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_r , & [ this % r_val ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_phi , & [ this % phi ], 1_size_t , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing attribute to HDF group ' // & group_name ) ret_err = error end if call this % thickness % write_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume thickness field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % write_hdf ( group_id , hdf_velocity , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume velocity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % write_hdf ( group_id , hdf_temperature , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume temperature field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % write_hdf ( group_id , hdf_salinity , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume salinity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err #ifdef DEBUG call logger % debug ( 'asym_plume%write_data' , 'Wrote plume data to HDF group ' // & group_name ) #endif end subroutine asym_plume_write_data subroutine asym_plume_solve ( this , ice_thickness , ice_density , ice_temperature , & time , success ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Solves the state of the plume for the specified ice properties, ! at the specified time. This is done using the a ! quasilinearisation method and a GMRES iterative linear solver. ! class ( asym_plume ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: ice_thickness !! Thickness of the ice above the basal surface real ( r8 ), intent ( in ) :: ice_density !! The density of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: ice_temperature !! The temperature of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: time !! The time to which the basal surface should be solved logical , intent ( out ) :: success !! True if the solver is successful, false otherwise real ( r8 ), dimension (:), allocatable :: solution real ( r8 ) :: residual integer , dimension ( 5 ) :: info integer :: flag class ( scalar_field ), pointer :: b call ice_thickness % guard_temp () b => - ice_thickness / this % r_val call b % guard_temp () select type ( bound => this % boundaries ) class is ( upstream_plume_boundary ) call bound % calculate ( time , non_diff_terms , b ) class default call bound % set_time ( time ) end select solution = this % state_vector () #ifdef DEBUG call logger % debug ( 'asym_plume%solve' , 'Calling QLM ODE solver' ) #endif call quasilinear_solve ( L , f , jac_prod , solution , 1 , residual , flag , info , & 1.e-9_r8 * size ( solution ), precond = preconditioner , & iter_max = 100 , krylov_dim = 85 , gmres_iter_max = 5000 ) call this % update ( solution ) #ifdef DEBUG call logger % debug ( 'plume%solve' , 'QLM solver required ' // & trim ( str ( info ( 5 ))) // ' nonlinear iterations ' // & 'and ' // trim ( str ( info ( 1 ) + info ( 2 ))) // & ' function calls.' ) #endif select case ( flag ) case ( 0 ) call logger % trivia ( 'asym_plume%solver' , 'Solved plume at time ' // trim ( str ( time ))) success = . true . this % time = time case ( 1 ) call logger % warning ( 'asym_plume%solver' , 'Plume solver stagnated with ' // & 'residual of ' // trim ( str ( residual ))) success = . false . case ( 2 ) call logger % error ( 'asym_plume%solver' , 'Reached maximum number of ' // & 'iterations solving plume' ) success = . false . case ( 3 ) call logger % error ( 'asym_plume%solver' , 'Plume solution began to diverge.' ) success = . false . case default call logger % error ( 'asym_plume%solve' , 'QLM solver failed for plume with ' // & 'error code ' // trim ( str ( flag ))) success = . false . end select call ice_thickness % clean_temp (); call b % clean_temp () contains function L ( v ) !! The linear differentiation operator real ( r8 ), dimension (:), intent ( in ) :: v !! The state vector for the system of differential equations real ( r8 ), dimension ( size ( v )) :: L integer :: st , en , btype_l , btype_u , bdepth_l , bdepth_u type ( cheb1d_scalar_field ) :: scalar_tmp , ctmp ( 2 ) type ( cheb1d_vector_field ) :: vector_tmp type ( cheb1d_vector_field ) :: coriolis call this % update ( v ) ! Thickness scalar_tmp = this % thickness % d_dx ( 1 ) call this % boundaries % thickness_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % thickness_bound_info ( 1 , btype_u , bdepth_u ) if ( this % lower_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % thickness % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % thickness % get_boundary ( 1 , 1 )) end if st = 1 en = st + this % thickness_size - 1 L ( st : en ) = scalar_tmp % raw () ! Velocity vector_tmp = this % velocity % d_dx ( 1 ) - this % velocity_dx if ( this % lower_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % velocity_size - 1 L ( st : en ) = vector_tmp % raw () if ( this % phi /= 0._r8 ) then ctmp ( 1 ) = - this % phi * this % shape % a_DV / ( this % nu * this % shape % a_DU ) & * this % velocity % component ( 2 ) ctmp ( 2 ) = this % phi * this % shape % a_DU / ( this % nu * this % shape % a_DV ) & * this % velocity % component ( 1 ) coriolis = ctmp vector_tmp = this % velocity_dx % d_dx ( 1 ) - coriolis else vector_tmp = this % velocity_dx % d_dx ( 1 ) end if if ( this % lower_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % velocity_size - 1 L ( st : en ) = vector_tmp % raw () !     print*,vector_tmp%raw() ! Temperature scalar_tmp = this % temperature % d_dx ( 1 ) - this % temperature_dx if ( this % lower_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % temperature_size - 1 L ( st : en ) = scalar_tmp % raw () scalar_tmp = this % temperature_dx % d_dx ( 1 ) if ( this % lower_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % temperature_size - 1 L ( st : en ) = scalar_tmp % raw () ! Salinity scalar_tmp = this % salinity % d_dx ( 1 ) - this % salinity_dx if ( this % lower_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % salinity_size - 1 L ( st : en ) = scalar_tmp % raw () scalar_tmp = this % salinity_dx % d_dx ( 1 ) if ( this % lower_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % salinity_size - 1 L ( st : en ) = scalar_tmp % raw () end function L subroutine non_diff_terms ( D , Uvec , T , S , b , DU_x , DUU_x , DUT_x , DUS_x ) !! Computes the values of (DU)_x, (DU\\vec{U})_x, !! (DUT)_x, (DUS)_x, when diffusion is not !! included. This should be able to handle uniform field types, !! for use in an ODE solver when integrating near the boundary. class ( scalar_field ), intent ( in ) :: D !! The plume thickness class ( vector_field ), intent ( in ) :: Uvec !! The plume velocity class ( scalar_field ), intent ( in ) :: T !! The plume temperature class ( scalar_field ), intent ( in ) :: S !! The plume salinity class ( scalar_field ), intent ( in ) :: b !! The debth of the base of the ice shelf class ( scalar_field ), intent ( out ) :: DU_x !! The derivative of the product DU class ( vector_field ), intent ( out ) :: DUU_x !! The derivative of the product DUU class ( scalar_field ), intent ( out ) :: DUT_x !! The derivative of the product DUT class ( scalar_field ), intent ( out ) :: DUS_x !! The derivative of the product DUS class ( scalar_field ), pointer :: m , rho_b , rho_t , e , S_a , U , V , & T_a , rho_a , rho_x , Unorm class ( scalar_field ), allocatable , dimension (:) :: tmp type ( cheb1d_vector_field ) :: coriolis call D % guard_temp (); call Uvec % guard_temp (); call T % guard_temp () call S % guard_temp (); call b % guard_temp () S_a => this % ambient_conds % ambient_salinity ( b , time ) T_a => this % ambient_conds % ambient_temperature ( b , time ) select type ( eos => this % eos ) class is ( ave_linear_eos ) rho_b => eos % water_density_ave1 ( T , S ) rho_t => eos % water_density_ave2 ( T , S ) class default rho_b => eos % water_density ( T , S ) rho_t => rho_b end select U => Uvec % component ( 1 ) V => Uvec % component ( 2 ) call S_a % guard_temp (); call T_a % guard_temp (); call rho_b % guard_temp () call rho_t % guard_temp (); call U % guard_temp (); call V % guard_temp () rho_a => this % eos % water_density ( T_a , S_a ) call rho_a % guard_temp () e => this % entrainment_formulation % entrainment_rate ( Uvec , D , b , rho_a - rho_b , time ) call e % guard_temp () call this % melt_formulation % solve_for_melt ( Uvec , b , T , S , D , time ) m => this % melt_formulation % melt_rate () call m % guard_temp () associate ( f_D1 => this % shape % f_D1 , f_D2 => this % shape % f_D2 , & f_U2 => this % shape % f_U2 , f_V2 => this % shape % f_V2 , & f_S1 => this % shape % f_S1 , f_S2 => this % shape % f_S2 , & f_T1 => this % shape % f_T1 , f_T2 => this % shape % f_T2 , & a_DU => this % shape % a_DU , a_DU2 => this % shape % a_DU2 , & a_DUV => this % shape % a_DUV , a_DUS => this % shape % a_DUS , & a_DUT => this % shape % a_DUT , a_D2 => this % shape % a_D2 , & a_DV => this % shape % a_DV , a_UabsU => this % shape % a_UabsU , & a_UabsV => this % shape % a_UabsV , dy => this % dy ) DU_x = ( e + m - f_D2 * D * f_V2 * V / dy ) / a_DU if ( this % melt_formulation % has_heat_terms ()) then DUT_x = ( e * T_a - f_D2 * D * f_V2 * V * f_T2 * T / dy - & this % melt_formulation % heat_equation_terms ()) / a_DUT else DUT_x = ( e * T_a - f_D2 * D * f_V2 * V * f_T2 * T / dy ) / a_DUT end if if ( this % melt_formulation % has_salt_terms ()) then DUS_x = ( e * S_a - f_D2 * D * f_V2 * V * f_S2 * S / dy - & this % melt_formulation % salt_equation_terms ()) / a_DUS else DUS_x = ( e * S_a - f_D2 * D * f_V2 * V * f_S2 * S / dy ) / a_DUS end if Unorm => Uvec % norm () call Unorm % guard_temp () select type ( Uvec ) class is ( uniform_vector_field ) rho_x => this % eos % water_density_derivative ( T , ( DUT_x - DU_x * T ) / ( D * U ), & S , ( DUS_x - DU_x * S ) / ( D * U ), 1 ) call rho_x % guard_temp () allocate ( tmp ( this % vel_dims ), mold = D ) tmp ( 1 ) = ( D * ( rho_a - rho_b ) * b % d_dx ( 1 ) & - 2._r8 * D * this % delta * a_D2 * ( rho_a - rho_t ) * DU_x / U & + 0.5 * this % delta * a_D2 * D ** 2 * rho_x & - this % mu * a_UabsU * Unorm * U & + this % phi * a_DV * D * V & - f_D2 * D * f_U2 * U * f_V2 * V / dy ) / & ( a_DU2 - this % delta * a_D2 * D * ( rho_a - rho_t ) / U ** 2 ) if ( this % vel_dims > 1 ) then ! Use entrainment and melt as work-arrays to hold the ! upper and lower boundary density values. Should be able ! to just multiply the function results directly, but ! there's a compiler bug. call e % clean_temp (); call m % clean_temp () e => this % eos % water_density ( f_T2 * T , f_S2 * S ) m => this % eos % water_density ( f_T1 * T , f_S1 * S ) call e % guard_temp (); call m % guard_temp () tmp ( 2 ) = (( f_D2 ** 2 * ( e - rho_a ) - f_D1 ** 2 * ( m - rho_a )) * & 0.5_r8 * this % delta / dy * D ** 2 - this % mu * a_UabsV * Unorm * V & - a_DU * this % phi * D * U - f_D2 * D * f_V2 ** 2 * V ** 2 / dy ) / a_DUV end if DUU_x = tmp call rho_x % clean_temp () class default allocate ( tmp ( this % vel_dims ), mold = D ) tmp ( 1 ) = b % d_dx ( 1 ) tmp ( 1 ) = ( D * ( rho_a - rho_b ) * b % d_dx ( 1 ) & - a_D2 * D * ( rho_a - rho_t ) * this % delta * D % d_dx ( 1 ) & + 0.5_r8 * a_D2 * this % delta * D ** 2 * rho_t % d_dx ( 1 ) & - this % mu * a_UabsU * U * Unorm & - f_D2 * D * f_V2 * V * f_U2 * U / dy ) / a_DU2 if ( this % vel_dims > 1 ) then ! Use entrainment and melt as work-arrays to hold the ! upper and lower boundary density values. Should be able ! to just multiply the function results directly, but ! there's a compiler bug. call e % clean_temp (); call m % clean_temp () e => this % eos % water_density ( f_T2 * T , f_S2 * S ) m => this % eos % water_density ( f_T1 * T , f_S1 * S ) call e % guard_temp (); call m % guard_temp () tmp ( 2 ) = (( f_D2 ** 2 * ( e - rho_a ) - f_D1 ** 2 * ( m - rho_a )) * & 0.5_r8 * this % delta / dy * D ** 2 - this % mu * a_UabsV * V * Unorm & - f_D2 * D * f_V2 ** 2 * V ** 2 / dy ) / a_DUV end if DUU_x = tmp end select call Unorm % clean_temp () end associate call e % clean_temp (); call S_a % clean_temp (); call T_a % clean_temp () call rho_b % clean_temp (); call m % clean_temp (); call rho_a % clean_temp () call rho_t % clean_temp (); call U % clean_temp (); call V % clean_temp () call D % clean_temp (); call Uvec % clean_temp (); call T % clean_temp () call S % clean_temp (); call b % clean_temp () end subroutine non_diff_terms function f ( v ) !! The nonlinear operator real ( r8 ), dimension (:,:), intent ( in ) :: v !! The state vector for the system of differential equations, !! and its derivatives. Column i represents the i-1 !! derivative. real ( r8 ), dimension ( size ( v , 1 )) :: f call this % update ( v (:, 1 )) call nonlinear ( f , . false .) end function f function jac_prod ( v , dv ) !! The product of the Jacobian of the nonlienar operator at v, !! multiplying dv. real ( r8 ), dimension (:,:), intent ( in ) :: v !! The state vector for the system of differential equations, !! and its derivatives. Column i represents the i-1 !! derivative. real ( r8 ), dimension (:,:), intent ( in ) :: dv !! The state vector for the system of differential equations, !! and its derivatives, to be multiplied by the !! Jacobian. Column i represents the i-1 derivative. real ( r8 ), dimension ( size ( v , 1 )) :: jac_prod type ( cheb1d_scalar_field ) :: stmp type ( cheb1d_vector_field ) :: vtmp integer :: i call this % update ( v (:, 1 )) call stmp % assign_meta_data ( this % thickness ) call vtmp % assign_meta_data ( this % velocity ) call stmp % set_from_raw ( dv ( 1 : this % thickness_size , 1 )) call this % thickness % set_derivative ( stmp ) i = 1 + this % thickness_size call vtmp % set_from_raw ( dv ( i : i + this % velocity_size - 1 , 1 )) call this % velocity % set_derivative ( vtmp ) i = i + this % velocity_size call vtmp % set_from_raw ( dv ( i : i + this % velocity_size - 1 , 1 )) call this % velocity_dx % set_derivative ( vtmp ) i = i + this % velocity_size call stmp % set_from_raw ( dv ( i : i + this % temperature_size - 1 , 1 )) call this % temperature % set_derivative ( stmp ) i = i + this % temperature_size call stmp % set_from_raw ( dv ( i : i + this % temperature_size - 1 , 1 )) call this % temperature_dx % set_derivative ( stmp ) i = i + this % temperature_size call stmp % set_from_raw ( dv ( i : i + this % salinity_size - 1 , 1 )) call this % salinity % set_derivative ( stmp ) i = i + this % salinity_size call stmp % set_from_raw ( dv ( i : i + this % salinity_size - 1 , 1 )) call this % salinity_dx % set_derivative ( stmp ) call nonlinear ( jac_prod , . true .) call this % thickness % unset_derivative () call this % velocity % unset_derivative () call this % velocity_dx % unset_derivative () call this % temperature % unset_derivative () call this % temperature_dx % unset_derivative () call this % salinity % unset_derivative () call this % salinity_dx % unset_derivative () end function jac_prod subroutine nonlinear ( f , deriv ) real ( r8 ), dimension (:), intent ( out ) :: f logical , intent ( in ) :: deriv !! If true, return Jacobian product, otherwise return result !! of nonlienar operator. integer :: st , en type ( cheb1d_scalar_field ) :: scalar_tmp , D_x , D_nd , S_nd , T_nd type ( cheb1d_scalar_field ), allocatable , dimension (:) :: vtmp type ( cheb1d_vector_field ) :: vector_tmp , U_nd class ( scalar_field ), pointer :: U , V , U_x , V_x ! Use same or similar notation for variables as used in equations associate ( D => this % thickness , Uvec => this % velocity , & Uvec_x => this % velocity_dx , S => this % salinity , & S_x => this % salinity_dx , T => this % temperature , & T_x => this % temperature_dx , mf => this % melt_formulation , & h => ice_thickness , delta => this % delta , nu => this % nu , & mu => this % mu , r => this % r_val , bounds => this % boundaries ,& a_DU2 => this % shape % a_DU2 , a_DUV => this % shape % a_DUV , & a_DUS => this % shape % a_DUS , a_DUT => this % shape % a_DUT , & a_DU => this % shape % a_DU , a_DV => this % shape % a_DV , & a_DS => this % shape % a_DS , a_DT => this % shape % a_DT , & f_D2 => this % shape % f_D2 , f_Up => this % shape % f_Up , & f_Vp => this % shape % f_Vp , f_Sp => this % shape % f_Sp , & f_Tp => this % shape % f_Tp , dy => this % dy ) call non_diff_terms ( D , Uvec , T , S , b , D_nd , U_nd , T_nd , S_nd ) U => this % velocity % component ( 1 ) U_x => this % velocity_dx % component ( 1 ) call U % guard_temp (); call U_x % guard_temp () if ( this % vel_dims > 1 ) then V => this % velocity % component ( 2 ) V_x => this % velocity_dx % component ( 2 ) call V % guard_temp (); call V_x % guard_temp () end if ! Thickness scalar_tmp = ( D_nd - D * U_x ) / U D_x = scalar_tmp if ( this % lower_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % thickness_bound ( - 1 )) end if if ( this % upper_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % thickness_bound ( 1 )) end if st = 1 en = st + this % thickness_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () ! Velocity vector_tmp = 0._r8 * Uvec if ( this % lower_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( - 1 )) end if if ( this % upper_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( 1 )) end if st = en + 1 en = st + this % velocity_size - 1 if ( deriv ) then vector_tmp = vector_tmp % get_derivative () end if f ( st : en ) = vector_tmp % raw () allocate ( vtmp ( this % vel_dims ), mold = D ) vtmp ( 1 ) = ( a_DU2 * ( 2._r8 * D * U * U_x + D_x * U ** 2 - U_nd % component ( 1 )) & - nu * a_DU * D_x * U_x - nu * f_D2 * D * f_Up * U / dy ) / ( nu * a_DU * D ) if ( this % vel_dims > 1 ) then vtmp ( 2 ) = ( a_DUV * ( D * U * V_x + D * U_x * V + D_x * U * V - U_nd % component ( 2 )) & - nu * a_DV * D_x * V_x - nu * f_D2 * D * f_Vp * V / dy ) / ( nu * a_DV * D ) end if vector_tmp = vtmp if ( this % lower_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( - 1 )) end if if ( this % upper_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( 1 )) end if st = en + 1 en = st + this % velocity_size - 1 if ( deriv ) then vector_tmp = vector_tmp % get_derivative () end if f ( st : en ) = vector_tmp % raw () ! Temperature scalar_tmp = uniform_scalar_field ( 0._r8 ) if ( this % lower_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( - 1 )) end if if ( this % upper_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( 1 )) end if st = en + 1 en = st + this % temperature_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () scalar_tmp = ( a_DUT * ( D * U * T_x + D * U_x * T + D_x * U * T - T_nd ) - & nu * a_DT * D_x * T_x - nu * f_D2 * D * f_Tp * T / dy ) / ( nu * a_DT * D ) if ( this % lower_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( - 1 )) end if if ( this % upper_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () ! Salinity scalar_tmp = uniform_scalar_field ( 0._r8 ) if ( this % lower_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( - 1 )) end if if ( this % upper_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () scalar_tmp = ( a_DUS * ( D * U * S_x + D * U_x * S + D_x * U * S - S_nd ) - & nu * a_DS * D_x * S_x - nu * f_D2 * D * f_Sp * S / dy ) / ( nu * a_DS * D ) if ( this % lower_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( - 1 )) end if if ( this % upper_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () call U % clean_temp (); call U_x % clean_temp () if ( this % vel_dims > 0 ) then call V % clean_temp (); call V_x % clean_temp () end if end associate end subroutine nonlinear function preconditioner ( v , state , L_op , f_op , fcur , rhs ) !! The preconditioner, which approximates an inverse of `L`. real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be preconditioned. real ( r8 ), dimension (:,:), intent ( in ) :: state !! The current state vector for the system of differential !! equations, and its derivatives. Column i represents the !! i-1 derivative. procedure ( L ) :: L_op !! The linear, left-hand-side of the ODE being solved. procedure ( f ) :: f_op !! The nonlinear, right-hand-side of the ODE being solved. real ( r8 ), dimension (:), intent ( in ) :: fcur !! The result of `f(u)` real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being !! preconditioned. real ( r8 ), dimension ( size ( v )) :: preconditioner !! The result of applying the preconditioner. integer :: st , en , ust , uen , pst , pen integer :: bloc , i real ( r8 ) :: nu type ( asym_plume ) :: v_plume type ( cheb1d_scalar_field ) :: scalar_tmp type ( cheb1d_vector_field ) :: vector_tmp , tmp2 class ( scalar_field ), pointer :: U , U_x v_plume % thickness_size = this % thickness_size call v_plume % thickness % assign_meta_data ( this % thickness ) v_plume % velocity_size = this % velocity_size call v_plume % velocity % assign_meta_data ( this % velocity ) call v_plume % velocity_dx % assign_meta_data ( this % velocity_dx ) v_plume % temperature_size = this % temperature_size call v_plume % temperature % assign_meta_data ( this % temperature ) call v_plume % temperature_dx % assign_meta_data ( this % temperature_dx ) v_plume % salinity_size = this % salinity_size call v_plume % salinity % assign_meta_data ( this % salinity ) call v_plume % salinity_dx % assign_meta_data ( this % salinity_dx ) call v_plume % update ( v ) nu = this % nu bloc = get_bound_loc ( 1 ) v_plume % thickness = this % precond % solve_for ( v_plume % thickness , bloc , & v_plume % thickness % get_boundary ( 1 , 1 ), - 1 ) st = 1 en = st + this % thickness_size - 1 preconditioner ( st : en ) = v_plume % thickness % raw () bloc = get_bound_loc ( 3 ) v_plume % velocity_dx = this % precond % solve_for ( v_plume % velocity_dx , bloc , & v_plume % velocity_dx % get_boundary ( 1 , 1 ), - 1 ) bloc = get_bound_loc ( 2 ) vector_tmp = v_plume % velocity + v_plume % velocity_dx v_plume % velocity = this % precond % solve_for ( vector_tmp , bloc , & v_plume % velocity % get_boundary ( 1 , 1 ), - 1 ) st = en + 1 en = st + this % velocity_size - 1 preconditioner ( st : en ) = v_plume % velocity % raw () st = en + 1 en = st + this % velocity_size - 1 preconditioner ( st : en ) = v_plume % velocity_dx % raw () ! Precondition T_x terms before T st = en + 1 en = st + this % temperature_size - 1 pst = st pen = en bloc = get_bound_loc ( 5 ) v_plume % temperature_dx = this % precond % solve_for ( v_plume % temperature_dx , bloc , & v_plume % temperature_dx % get_boundary ( 1 , 1 ), - 1 ) st = en + 1 en = st + this % temperature_size - 1 preconditioner ( st : en ) = v_plume % temperature_dx % raw () bloc = get_bound_loc ( 4 ) v_plume % temperature = this % precond % solve_for ( v_plume % temperature + & v_plume % temperature_dx , bloc , v_plume % temperature % get_boundary ( 1 , 1 ), - 1 ) preconditioner ( pst : pen ) = v_plume % temperature % raw () ! Precondition S_x terms before S st = en + 1 en = st + this % salinity_size - 1 pst = st pen = en bloc = get_bound_loc ( 7 ) v_plume % salinity_dx = this % precond % solve_for ( v_plume % salinity_dx , bloc , & v_plume % salinity_dx % get_boundary ( 1 , 1 ), - 1 ) st = en + 1 en = st + this % temperature_size - 1 preconditioner ( st : en ) = v_plume % salinity_dx % raw () bloc = get_bound_loc ( 6 ) v_plume % salinity = this % precond % solve_for ( v_plume % salinity + v_plume % salinity_dx , bloc , & v_plume % salinity % get_boundary ( 1 , 1 ), - 1 ) preconditioner ( pst : pen ) = v_plume % salinity % raw () end function preconditioner integer function get_bound_loc ( component_id ) integer :: component_id if ( this % lower_bounds ( component_id )) then get_bound_loc = - 1 else if ( this % upper_bounds ( component_id )) then get_bound_loc = 1 else get_bound_loc = 0 end if end function get_bound_loc end subroutine asym_plume_solve end module asymmetric_plume_mod"},{"title":"ambient.F90 – ISOFT","tags":"","loc":"sourcefile/ambient.f90.html","text":"Files dependent on this one sourcefile~~ambient.f90~~AfferentGraph sourcefile~ambient.f90 ambient.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~ambient.f90 sourcefile~uniform.f90 uniform.F90 sourcefile~asymmetric_plume.f90->sourcefile~uniform.f90 sourcefile~uniform.f90->sourcefile~ambient.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~ambient.f90 sourcefile~static_plume.f90->sourcefile~uniform.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~ambient.f90 sourcefile~plume.f90->sourcefile~uniform.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ambient_mod Source Code ambient.F90 Source Code ! !  ambient.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module ambient_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides an abstract derived type which can be subtyped in order to ! specify the temperature and salinity of the ambient ocean. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field implicit none private type , abstract , public :: ambient_conditions !* Author: Chris MacMackin !  Date: April 2016 ! ! An abstract type to which procedures for getting the ambient ocean ! conditions are to be specified. The descendent types can contain ! whatever data is needed to compute the result. ! contains procedure ( get_property ), deferred :: ambient_temperature !! Returns the ambient ocean temperature procedure ( get_property ), deferred :: ambient_salinity !! Returns the ambient ocean temperature end type ambient_conditions abstract interface function get_property ( this , depth , t ) result ( property ) import :: r8 import :: ambient_conditions import :: scalar_field class ( ambient_conditions ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: depth !! A field containing the depths at which the ambient conditions !! are to be calculated. real ( r8 ), intent ( in ) :: t !! The time at which the ambient conditions are to be calculated. class ( scalar_field ), pointer :: property !! A field containing the ambient conditions at the depth specified !! for each location. end function get_property end interface end module ambient_mod"},{"title":"linear_eos.F90 – ISOFT","tags":"","loc":"sourcefile/linear_eos.f90.html","text":"This file depends on sourcefile~~linear_eos.f90~~EfferentGraph sourcefile~linear_eos.f90 linear_eos.F90 sourcefile~equation_of_state.f90 equation_of_state.F90 sourcefile~linear_eos.f90->sourcefile~equation_of_state.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~linear_eos.f90~~AfferentGraph sourcefile~linear_eos.f90 linear_eos.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~linear_eos.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~linear_eos.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~linear_eos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules linear_eos_mod Source Code linear_eos.F90 Source Code ! !  linear_eos.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module linear_eos_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides an abstract derived type which can be subtyped in order to ! implement an equation of state. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , uniform_scalar_field use equation_of_state_mod , only : equation_of_state implicit none private real ( r8 ), parameter :: absolute_zero = - 27 3.15_r8 type , extends ( equation_of_state ), public :: linear_eos !* Author: Chris MacMackin !  Date: April 2016 ! ! A linearised implementation of the equation of state, of the ! form  \\rho = \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)].  ! private real ( r8 ) :: ref_rho = 1.0_r8 !! The density for the temperature and salinity about which the !! equation of state was linearised, \\rho_0. real ( r8 ) :: ref_t = 0.0_r8 !! The temperature about which the equation of state was !! linearised, T_0. real ( r8 ) :: ref_s = 0.0_r8 !! The salinity about which the equation of state was !! linearised, S_0. real ( r8 ) :: beta_t = 0.0_r8 !! The thermal contraction coefficient, \\beta_T. real ( r8 ) :: beta_s = 1.0_r8 !! The haline contraction coefficient, \\beta_S. contains procedure :: water_density => linear_water_density procedure :: water_density_derivative => linear_water_deriv procedure :: haline_contraction => linear_haline_contraction procedure :: thermal_contraction => linear_thermal_contraction end type linear_eos interface linear_eos module procedure constructor end interface linear_eos contains pure function constructor ( ref_rho , ref_t , ref_s , beta_t , beta_s ) result ( this ) real ( r8 ), intent ( in ) :: ref_rho !! The density for the temperature and salinity about which the !! equation of state was linearised, \\rho_0. real ( r8 ), intent ( in ) :: ref_t !! The temperature about which the equation of state was !! linearised, T_0. real ( r8 ), intent ( in ) :: ref_s !! The salinity about which the equation of state was !! linearised, S_0. real ( r8 ), intent ( in ) :: beta_t !! The thermal contraction coefficient, \\beta_T. real ( r8 ), intent ( in ) :: beta_s !! The haline contraction coefficient, \\beta_S. type ( linear_eos ) :: this this % ref_rho = ref_rho this % ref_t = ref_t this % ref_s = ref_s this % beta_t = beta_t this % beta_s = beta_s end function constructor function linear_water_density ( this , temperature , salinity ) result ( density ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Calculates the density of the water from the temperature and ! salinity, using a linear equatino of state,  \\rho = ! \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)].  class ( linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call salinity % allocate_scalar_field ( density ) density = this % ref_rho * ( 1.0_r8 - this % beta_t * ( temperature - this % ref_t ) & + this % beta_s * ( salinity - this % ref_s )) call temperature % clean_temp (); call salinity % clean_temp () call density % set_temp () end function linear_water_density function linear_water_deriv ( this , temperature , d_temperature , salinity , & d_salinity , dir ) result ( d_density ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Calculates the derivative of the water density from the ! temperature and salinity, using a linear equatino of state,  ! \\rho = \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)].  class ( linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: d_temperature !! A field containing the derivative of the temperature of the !! water, in teh same direction as `dir` class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), intent ( in ) :: d_salinity !! A field containing the derivative of the salinity of the !! water, in the same direction as `dir` integer , intent ( in ) :: dir !! The direction in which to take the derivative class ( scalar_field ), pointer :: d_density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call d_temperature % guard_temp (); call d_salinity % guard_temp () call salinity % allocate_scalar_field ( d_density ) d_density = this % ref_rho * ( this % beta_s * d_salinity - this % beta_t * d_temperature ) call temperature % clean_temp (); call salinity % clean_temp () call d_temperature % clean_temp (); call d_salinity % clean_temp () call d_density % set_temp () end function linear_water_deriv function linear_haline_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: June 2017 ! ! Returns the haline contraction coefficient. ! class ( linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( this % ref_rho * this % beta_s ) end function linear_haline_contraction function linear_thermal_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: June 2017 ! ! Returns the thermal contraction coefficient. ! class ( linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( this % ref_rho * this % beta_t ) end function linear_thermal_contraction end module linear_eos_mod"},{"title":"rootfind.f90 – ISOFT","tags":"","loc":"sourcefile/rootfind.f90.html","text":"Contents Modules rootfind Source Code rootfind.f90 Source Code ! !  rootfind.f90 !  This file is part of ISOFT. ! !  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! MODULE rootfind !! author: Chris MacMackin !! !! Provides subroutines implementing various root-finding algorithms, !! as well as a global bracket finder. CONTAINS PURE SUBROUTINE bis_secant ( error , fnctn , maxerr , maxsteps , & steps , xcur , xleft , xright ) !! A root finder using the hybrid bisection-secant algorithm. !! Returns a computed value of the root within xleft and xright !! once error < maxerr or has run maximum number of iterations. IMPLICIT NONE interface pure function fnctn ( x ) !! The Fortran function for which the root will be !! found. Must take only one real argument, return a !! real argument. real ( 8 ), intent ( in ) :: x real ( 8 ) :: fnctn end function fnctn end interface integer , intent ( in ) :: maxsteps !! An integer value for the maximum number of iterations !! applied to the algorithm before terminating. real ( 8 ), intent ( in ) :: maxerr !! A real value which specifies the the maximum allowable !! error in the computed root. The subroutine terminates !! once the error passes below this level. real ( 8 ), intent ( inout ) :: xleft !! A real value specifying lower bound within which to !! search for root. real ( 8 ), intent ( inout ) :: xright !! A real value specifying upper bound within which to !! search for root. integer , intent ( out ) :: steps !! Returns the number of iterations needed before error !! falls below maxerr (or returns maxsteps if that many !! iterations occur first). real ( 8 ), intent ( out ) :: error !! A real variable in which an estimate of the error in the !! computed root will be stored and returned. real ( 8 ), intent ( out ) :: xcur !! A real variable in which the computed value of the root !! will be returned. ! Other variables: REAL ( 8 ) :: dfxcur , & fxcur , & fxleft , & fxprev1 , & fxright , & xnext , & xprev1 !------------------------------------------------------------------! ! Initialize variables fxleft = fnctn ( xleft ) fxright = fnctn ( xright ) dfxcur = 0.d0 fxcur = 0.d0 fxprev1 = 0.d0 xnext = 0.d0 xprev1 = 0.d0 ! Check that there is a root bracketed by 'xleft' and 'xright' IF ( fxleft * fxright > 0.0d0 ) THEN error stop ( 'No root in specified interval.' ) END IF ! Initialize variables) xcur = xleft fxcur = fxleft xprev1 = xright fxprev1 = fxright ! Iterate until root converges or reach 'maxsteps' DO steps = 1 , maxsteps ! If not 1st iteration, update variables for next iteration IF ( steps /= 1 ) THEN fxprev1 = fxcur fxcur = fnctn ( xcur ) IF ( fxleft * fxcur < 0.d0 ) THEN xright = xcur fxright = fxcur ELSE xleft = xcur fxleft = fxcur END IF END IF ! Compute a secant and use to find 'xnext' dfxcur = ( fxcur - fxprev1 ) / ( xcur - xprev1 ) xnext = xcur - fxcur / dfxcur ! If this 'xnext' value is outside of left or right bounds, ! instead use a bisection to find 'xnext' IF ( ( xnext < xleft ) . OR . ( xnext > xright ) ) THEN xnext = 5.d-1 * ( xleft + xright ) END IF ! Estimate error in approximating root and update variables error = ABS ( xnext - xcur ) xprev1 = xcur xcur = xnext ! If error less than tolerance, return IF ( error < maxerr ) RETURN END DO ! If reached maximum iterations, print a warning message error stop ( 'No solution found in specified number of steps.' ) END SUBROUTINE bis_secant SUBROUTINE global_bis_sec ( dx , error , fnctn , maxerr , & maxsteps , numroots , roots , steps , & verbose , xmax , xmin ) !! A subroutine which finds the values of all roots of a !! function (or as many as will fit into the provided arrays) !! within a given range of values. This subroutine uses the !! hybrid bisection-secant root-finding algorithm. IMPLICIT NONE interface pure function fnctn ( x ) !! The Fortran function for which the root will be !! found. Must take only one real argument, return a !! real argument. real ( 8 ), intent ( in ) :: x real ( 8 ) :: fnctn end function fnctn end interface ! Input and output variables: integer , intent ( in ) :: maxsteps !! An integer value for the maximum number of iterations !! applied to the algorithm before terminating. logical , intent ( in ) :: verbose !! A logical variable which specifies whether to print !! progress to stdout as brackets found and at each !! iteration as root found. Also says whether to print a !! warning if 'dx' set to 'dxmin' during 'globrack' routine !! and if maximum number of iterations reached while finding !! root. real ( 8 ), intent ( in ) :: maxerr !! A real value which specifies the the maximum allowable !! error in the computed root. The subroutine terminates !! once the error passes below this level. real ( 8 ), intent ( in ) :: xmax !! The upper limit of the range on which the subroutine will !! search for roots and brackets. real ( 8 ), intent ( in ) :: xmin !! The lower limit of the range on which the subroutine will !! search for roots and brackets. real ( 8 ), intent ( inout ) :: dx !! The initial size of increment to use when examining !! function.  Minimum interval will be 0.01 of this. integer , intent ( out ) :: numroots !! An integer value which will return the number of roots !! for which brackets were found. A negative number !! indicates that an error occurred. integer , intent ( out ), dimension (:) :: steps !! An integer array in which the number of iterations needed !! before error falls below maxerr for each root is stored !! and returned. real ( 8 ), intent ( out ), dimension (:) :: error !! A real array in which an estimate of the error in each !! computed root will be stored and returned. real ( 8 ), intent ( out ), dimension (:) :: roots !! A real array in which the computed values of each root !! will be returned. ! Other variables: INTEGER :: counter = 0 , & maxroots = 0 REAL ( 8 ), DIMENSION (:,:), ALLOCATABLE :: brackets !------------------------------------------------------------------! ! Maximum number of roots is given by the size of the smallest ! of the arrays 'error', 'roots', and 'steps' (of course, if ! it is written properly then the calling program should have ! made these all the same size) maxroots = MIN ( SIZE ( error ), SIZE ( roots ), SIZE ( steps )) ALLOCATE ( brackets ( 2 , maxroots )) brackets = 0.d0 ! Get the sets of bracket pairs for the roots of 'fnctn', using ! the 'globrack' subroutine CALL global_brackets ( brackets , dx , fnctn , numroots , verbose , & xmax , xmin ) ! For each bracket pair, find the enclosed root using the ! 'biscnt' subroutine DO counter = 1 , numroots CALL bis_secant ( error ( counter ), fnctn , maxerr , maxsteps , & steps ( counter ), roots ( counter ), & brackets ( 1 , counter ), brackets ( 2 , counter )) END DO RETURN END SUBROUTINE global_bis_sec SUBROUTINE global_brackets ( brackets , dx , fnctn , numroots , & verbose , xmax , xmin ) !! A global bracket finder. For a given function it finds values !! on each side of each of the function's roots within a given !! range. IMPLICIT NONE interface pure real ( 8 ) function fnctn ( x ) !!The Fortran function for which the brackets will be !! found. Must take only one real argument, return a !! real argument. real ( 8 ), intent ( in ) :: x end function fnctn end interface ! Input and output variables: logical , intent ( in ) :: verbose !! A logical variable which specifies whether to print to !! stdout any bracket values which are found and warning !! messages when 'dx' set to 'dxmin'. real ( 8 ), intent ( in ) :: xmax !! The upper limit of the range on which the subroutine will !! search for roots and brackets. real ( 8 ), intent ( in ) :: xmin !! The lower limit of the range on which the subroutine will !! search for roots and brackets. real ( 8 ), intent ( inout ) :: dx !! The initial size of increment to use when examining !! function.  Minimum interval will be 0.01 of this. integer , intent ( out ) :: numroots !! An integer value which will return the number of roots !! for which brackets were found. A negative number !! indicates that an error occurred. real ( 8 ), intent ( out ), dimension (:,:) :: brackets !! A 2 by n real array in which the left and right brackets !! will be stored and returned. Will find up to n sets of !! brackets. ! Other variables: REAL ( 8 ) :: dfdx = 0.d0 , & dfdxh = 0.d0 , & dldx = 0.d0 , & dldxh = 0.d0 , & dxmin = 0.d0 , & dxh = 0.d0 , & fleft = 0.d0 , & fmid = 0.d0 , & fright = 0.d0 , & scaleval = 0.d0 , & xleft = 0.d0 , & xright = 0.d0 , & xmid = 0.d0 !------------------------------------------------------------------! ! Check if passed array is big enough to hold returned data IF ( SIZE ( brackets , 1 ) < 2 ) THEN numroots = - 1 WRITE ( 0 , 2000 ) RETURN END IF ! Initialize variables dxmin = 1.d-2 * dx numroots = 0 xleft = xmin fleft = fnctn ( xmin ) ! Repeat this loop until have traversed range [xmin:xmax], or ! until brackets array is filled DO WHILE ( xleft <= xmax ) ! Make sure that xright <= xmax dx = MIN ( dx , xmax - xmin ) ! Get values and derivatives for next step along the ! function xright = xleft + dx fright = fnctn ( xright ) scaleval = MAX ( 1.0d0 , ABS ( xleft )) / MAX ( ABS ( fleft ), & ABS ( fright )) dfdx = scaleval * ( fright - fleft ) / dx dldx = SIGN ( 1.0d0 , dfdx ) * SQRT ( 1.0d0 + dfdx ** 2.d0 ) ! Find derivative of secant length (called 'dldx' when found ! above) at midpoint between 'xleft' and 'xright' ('dldxh'). ! If difference between 'dldx' and 'dldxh' is too great, ! reduce 'dx' and repeat. DO dxh = 5 d - 1 * dx xmid = xleft + dxh fmid = fnctn ( xmid ) dfdxh = scaleval * ( fmid - fleft ) / dxh dldxh = SIGN ( 1.0d0 , dfdxh ) * SQRT ( 1.0d0 + dfdxh ** 2 ) IF ( ( ABS ( dldx - dldxh ) > 5.d-1 * ABS ( dldx ) ) & . AND . ( dxh > dxmin ) ) THEN dx = dxh xright = xmid fright = fmid dldx = dldxh ELSE EXIT END IF END DO ! If difference between 'dldx' and 'dldxh' is too small, ! make step-size larger for next iteration IF ( ABS ( dldx - dldxh ) < 1.d-1 * ABS ( dldx ) ) THEN dx = 1.5d0 * dx ! If diference between 'dldx' and 'dldxh' is too small, but ! can't go smaller without falling below 'dxmin', set 'dx = ! dxmin' and print warning message ELSE IF ( ( ABS ( dldx - dldxh ) > 5.d-1 * ABS ( dldx ) ) & . AND . ( dxh < dxmin ) ) THEN dx = dxmin xright = xleft + dx fright = fnctn ( xright ) IF ( verbose . EQV . . TRUE . ) WRITE ( 6 , 2010 ) dxmin END IF ! Otherwise keep 'dx' the same (no action needs to be taken) ! If the signs of 'fleft' and 'fright' are opposite, and if ! signs of 'fright' and the derivative of 'fnctn(xleft)' are ! the same, then 'xleft' and 'xright' bracket a root IF ( ( fleft * fright < 0 ) . AND . ( fright * ( fleft - & fnctn ( xleft - dxmin ) ) > 0 ) ) THEN numroots = numroots + 1 brackets ( 1 : 2 , numroots ) = ( / xleft , xright / ) IF ( verbose . EQV . . TRUE . ) WRITE ( 6 , 2020 ) xleft , xright ! If have filled 'brackets', then leave loop IF ( numroots >= SIZE ( brackets , 2 ) ) EXIT END IF ! Update variables for next iteration xleft = xright fleft = fright END DO !--------------------------------------------------------------! !                    Write format statements                   ! !--------------------------------------------------------------! 2000 FORMAT ( 'GLOBRACK: ERROR: Passed array too small to hold ' ,& 'returned values. Must have at least 2 columns.' ) 2010 FORMAT ( 'GLOBRACK: WARNING: Value of dx set to minimum ' & , 'value: ' , 1 PG22 . 15 ) 2020 FORMAT ( 'GLOBRACK: Found root bracketed by ' , 1 PG22 . 15 , & ' and' , / , & 'GLOBRACK: ' , 1 PG22 . 15 ) !--------------------------------------------------------------! RETURN END SUBROUTINE global_brackets !==================================================================! !                  E N D    S U B R O U T I N E :                  ! !                  G L O B A L _ B R A C K E T S                   ! !==================================================================! END MODULE rootfind"},{"title":"static_plume.F90 – ISOFT","tags":"","loc":"sourcefile/static_plume.f90.html","text":"This file depends on sourcefile~~static_plume.f90~~EfferentGraph sourcefile~static_plume.f90 static_plume.F90 sourcefile~entrainment.f90 entrainment.F90 sourcefile~static_plume.f90->sourcefile~entrainment.f90 sourcefile~plume_boundary.f90 plume_boundary.F90 sourcefile~static_plume.f90->sourcefile~plume_boundary.f90 sourcefile~ode_solvers.f90 ode_solvers.f90 sourcefile~static_plume.f90->sourcefile~ode_solvers.f90 sourcefile~dallaston2015_melt.f90 dallaston2015_melt.F90 sourcefile~static_plume.f90->sourcefile~dallaston2015_melt.f90 sourcefile~jenkins1991_entrainment.f90 jenkins1991_entrainment.F90 sourcefile~static_plume.f90->sourcefile~jenkins1991_entrainment.f90 sourcefile~melt_relationship.f90 melt_relationship.F90 sourcefile~static_plume.f90->sourcefile~melt_relationship.f90 sourcefile~uniform.f90 uniform.F90 sourcefile~static_plume.f90->sourcefile~uniform.f90 sourcefile~simple_plume.f90 simple_plume.F90 sourcefile~static_plume.f90->sourcefile~simple_plume.f90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~static_plume.f90->sourcefile~boundary_types.f90 sourcefile~upstream_plume.f90 upstream_plume.F90 sourcefile~static_plume.f90->sourcefile~upstream_plume.f90 sourcefile~basal_surface.f90 basal_surface.F90 sourcefile~static_plume.f90->sourcefile~basal_surface.f90 sourcefile~ambient.f90 ambient.F90 sourcefile~static_plume.f90->sourcefile~ambient.f90 sourcefile~pseudospectral_block.f90 pseudospectral_block.F90 sourcefile~static_plume.f90->sourcefile~pseudospectral_block.f90 sourcefile~equation_of_state.f90 equation_of_state.F90 sourcefile~static_plume.f90->sourcefile~equation_of_state.f90 sourcefile~linear_eos.f90 linear_eos.F90 sourcefile~static_plume.f90->sourcefile~linear_eos.f90 sourcefile~plume_boundary.f90->sourcefile~boundary_types.f90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~ode_solvers.f90->sourcefile~nitsol.f90 sourcefile~dallaston2015_melt.f90->sourcefile~melt_relationship.f90 sourcefile~jenkins1991_entrainment.f90->sourcefile~entrainment.f90 sourcefile~uniform.f90->sourcefile~ambient.f90 sourcefile~simple_plume.f90->sourcefile~plume_boundary.f90 sourcefile~simple_plume.f90->sourcefile~boundary_types.f90 sourcefile~upstream_plume.f90->sourcefile~plume_boundary.f90 sourcefile~upstream_plume.f90->sourcefile~boundary_types.f90 sourcefile~rksuite_90.f90 rksuite_90.f90 sourcefile~upstream_plume.f90->sourcefile~rksuite_90.f90 sourcefile~uniform_gradient_field.f90 uniform_gradient_field.f90 sourcefile~upstream_plume.f90->sourcefile~uniform_gradient_field.f90 sourcefile~basal_surface.f90->sourcefile~nitsol.f90 sourcefile~linear_eos.f90->sourcefile~equation_of_state.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules static_plume_mod Source Code static_plume.F90 Source Code ! !  plume.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module static_plume_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides a concrete implementation of the [[basal_surface(type)]] ! data type, representing a buoyant plume beneath an ice shelf. This ! implementation does not evolve the plume. ! use iso_fortran_env , only : r8 => real64 use basal_surface_mod , only : basal_surface , hdf_type_attr use factual_mod , only : scalar_field , vector_field , cheb1d_scalar_field , & cheb1d_vector_field , uniform_scalar_field , & uniform_vector_field use ode_solvers_mod , only : quasilinear_solve use entrainment_mod , only : abstract_entrainment use melt_relationship_mod , only : abstract_melt_relationship use plume_boundary_mod , only : plume_boundary use upstream_plume_mod , only : upstream_plume_boundary use boundary_types_mod , only : free_boundary , dirichlet , neumann use ambient_mod , only : ambient_conditions use equation_of_state_mod , only : equation_of_state use jenkins1991_entrainment_mod , only : jenkins1991_entrainment use dallaston2015_melt_mod , only : dallaston2015_melt use uniform_ambient_mod , only : uniform_ambient_conditions use simple_plume_boundary_mod , only : simple_plume_boundary use pseudospectral_block_mod , only : pseudospec_block use linear_eos_mod , only : linear_eos use hdf5 use h5lt use logger_mod , only : logger => master_logger use penf , only : str implicit none private character ( len = 9 ), parameter , public :: hdf_type_name = 'plume' character ( len = 9 ), parameter , public :: hdf_thickness = 'thickness' character ( len = 8 ), parameter , public :: hdf_velocity = 'velocity' character ( len = 11 ), parameter , public :: hdf_temperature = 'temperature' character ( len = 8 ), parameter , public :: hdf_salinity = 'salinity' character ( len = 5 ), parameter , public :: hdf_delta = 'delta' character ( len = 2 ), parameter , public :: hdf_nu = 'nu' character ( len = 2 ), parameter , public :: hdf_mu = 'mu' character ( len = 5 ), parameter , public :: hdf_r = 'r_val' character ( len = 3 ), parameter , public :: hdf_phi = 'phi' type , extends ( basal_surface ), public :: static_plume !* Author: Christopher MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[basal_surface(type)]] ! abstract data type, representing the buoyant plume beneath an ! ice shelf, but unchanging in time. It keeps the values assigned ! at creation or with the [[static_plume:write_data]] method. It ! is useful if you want to uncouple the ice shelf from the plume. ! private type ( cheb1d_scalar_field ) :: thickness !! The thickness of the plume type ( cheb1d_vector_field ) :: velocity !! The velocity of the plume type ( cheb1d_vector_field ) :: velocity_dx !! The derivative of the velocity field type ( cheb1d_scalar_field ) :: temperature !! The temperature of the plume type ( cheb1d_scalar_field ) :: temperature_dx !! The derivative of the temperature of the plume type ( cheb1d_scalar_field ) :: salinity !! The salinity of the plume type ( cheb1d_scalar_field ) :: salinity_dx !! The derivative of the salinity of the plume class ( abstract_entrainment ), allocatable :: entrainment_formulation !! An object which provides the parameterisation for entrainment !! of water into the plume. class ( abstract_melt_relationship ), allocatable :: melt_formulation !! An object which provides the parameterisation for melting, !! salt, and heat fluxes from the plume to the ice. class ( ambient_conditions ), allocatable :: ambient_conds !! An object specifying the temperature and salinity of the !! ambient ocean at its interface with the plume. class ( equation_of_state ), allocatable , public :: eos !! An object specifying the equation of state relating the plume !! water's density to its temperature and salinity. class ( plume_boundary ), allocatable :: boundaries !! An object specifying the boundary conditions for the plume. real ( r8 ) :: delta !! The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real ( r8 ), public :: nu !! The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real ( r8 ) :: mu !! The dimensionless ratio \\mu \\equiv \\frac{C_dx_0}{D_0} real ( r8 ) :: r_val !! The dimensionless ratio of the ocean water density to the !! density of the overlying ice shelf. real ( r8 ), public :: phi !! The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} real ( r8 ) :: time !! The time at which the ice shelf is in this state integer :: thickness_size !! The number of data values in the thickness field integer :: velocity_size !! The number of data values in the velocity field integer :: temperature_size !! The number of data values in the temperature field integer :: salinity_size !! the number of data values in the salinity field logical , dimension ( 7 ) :: lower_bounds = . false . !! Which variables have boundary conditions at the grounding !! line. logical , dimension ( 7 ) :: upper_bounds = . false . !! Which variables have boundary conditions at the calving !! front. type ( pseudospec_block ) :: precond !! A pseudospectral differentiation block which can be used for !! preconditioning. contains procedure :: initialise => static_plume_initialise procedure :: basal_melt => static_plume_melt procedure :: basal_drag_parameter => static_plume_drag_parameter procedure :: water_density => static_plume_water_density procedure :: update => static_plume_update procedure :: data_size => static_plume_data_size procedure :: state_vector => static_plume_state_vector procedure :: read_data => static_plume_read_data procedure :: write_data => static_plume_write_data procedure :: solve => static_plume_solve end type static_plume abstract interface #ifdef DEBUG #undef pure #undef elemental #endif pure function scalar_func ( location ) result ( scalar ) !* Author: Chris MacMackin !  Date: April 2016 ! ! Abstract interface for function providing the initial values ! for the scalar properties of a [[static_plume(type)]] object when it ! is being instantiated. ! import :: r8 real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the property real ( r8 ) :: scalar !! The value of the scalar quantity at `location` end function scalar_func pure function velocity_func ( location ) result ( vector ) !* Author: Chris MacMackin !  Date: April 2016 ! ! Abstract interface for function providing the [[plume(type)]] velocity ! when an object is being instantiated. ! import :: r8 real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the thickness real ( r8 ), dimension (:), allocatable :: vector !! The velocity vector of the water in the plume at `location` end function velocity_func #ifdef DEBUG #define pure #define elemental #endif end interface contains subroutine static_plume_initialise ( this , domain , resolution , thickness , velocity , & temperature , salinity , entrainment_formulation , & melt_formulation , ambient_conds , eos , boundaries , & delta , nu , mu , r_val , phi ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Instantiates a [[plume(type)]] object with initial coniditions ! provided by the arguments.At present only a 1D model is ! supported. If information is provided for higher dimensions then ! it will be ignored. ! class ( static_plume ), intent ( out ) :: this !! A plume object with its domain and initial conditions set according !! to the arguments of the constructor function. real ( r8 ), dimension (:,:), intent ( in ) :: domain !! An array containing the upper and lower limits of the domain for !! the plume. The first index represents the dimension for which the !! boundaries apply. If the second index is 1 then it corresponds to !! the lower bound. If the second index is 2 then it corresponds to !! the upper bound. integer , dimension (:), intent ( in ) :: resolution !! The number of data points in each dimension procedure ( scalar_func ) :: thickness !! A function which calculates the initial value of the thickness of !! the plume at a given location. procedure ( velocity_func ) :: velocity !! A function which calculates the initial value of the velocity !! (vector) of the water at a given location in a plume. procedure ( scalar_func ) :: temperature !! A function which calculates the initial value of the temperature of !! the plume at a given location. procedure ( scalar_func ) :: salinity !! A function which calculates the initial value of the salinity of !! the plume at a given location. class ( abstract_entrainment ), allocatable , optional , & intent ( inout ) :: entrainment_formulation !! An object which calculates entrainment into the plume. Will !! be unallocated on exit. Defaults to that used by Jenkins !! (1991) with the coefficient $E_0 = 1$. class ( abstract_melt_relationship ), allocatable , optional , & intent ( inout ) :: melt_formulation !! An object which calculates melting and the resulting thermal !! transfer into/out of the plume. Will be unallocated on !! exit. Defaults to that used by Dallaston et al. (2015), !! scaled to be consistent with the nondimensionalisation used !! here. class ( ambient_conditions ), allocatable , optional , & intent ( inout ) :: ambient_conds !! An object specifying the salinity and temperature of the !! ambient ocean. Will be unallocated on exit. Defaults to !! uniform ambient salinity and temperature, both of which are !! set to 0 (as temperature and salinity are measured relative !! to some reference value). class ( equation_of_state ), allocatable , optional , & intent ( inout ) :: eos !! An object specifying the equation of state for the water in !! the plume. Will be unallocated on exit. Defaults to !! linearised equation of state with no temperature dependence !! and a haline contraction coefficient of 1. The reference !! density is set to be 1 in the dimensionless units when !! salinity and temeprature are 0. class ( plume_boundary ), allocatable , optional , & intent ( inout ) :: boundaries !! An object providing the boundary conditions for the !! plume. Will be unallocated on exit. Defaults to those used by !! Dallaston et al. (2015). real ( r8 ), optional , intent ( in ) :: delta !! The dimensionless ratio \\delta \\equiv !! \\frac{D_0}{h_0}. Defaults to 0.036. real ( r8 ), optional , intent ( in ) :: nu !! The dimensionless ratio \\nu \\equiv !! \\frac{\\kappa_0}{x_0U_o}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: mu !! The dimensionless ratio \\mu \\equiv !! \\frac{\\C_dx_0}{D_0}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: r_val !! The dimensionless ratio of the water density to the ice shelf !! density,  r = \\rho_0/\\rho_i.  Defaults to 1.12. real ( r8 ), optional , intent ( in ) :: phi !! The inverse Rossby number, \\Phi \\equif !! \\frac{fx_0}{U_0}. Defaults to 0. integer :: i , btype_l , btype_u , bdepth_l , bdepth_u i = size ( velocity ([ 0._r8 ])) this % thickness = cheb1d_scalar_field ( resolution ( 1 ), thickness , domain ( 1 , 1 ), domain ( 1 , 2 )) this % velocity = cheb1d_vector_field ( resolution ( 1 ), velocity , domain ( 1 , 1 ), domain ( 1 , 2 ), i - 1 ) this % temperature = cheb1d_scalar_field ( resolution ( 1 ), temperature , domain ( 1 , 1 ), domain ( 1 , 2 )) this % salinity = cheb1d_scalar_field ( resolution ( 1 ), salinity , domain ( 1 , 1 ), domain ( 1 , 2 )) this % thickness_size = this % thickness % raw_size () this % velocity_size = this % velocity % raw_size () this % temperature_size = this % temperature % raw_size () this % salinity_size = this % salinity % raw_size () this % velocity_dx = this % velocity % d_dx ( 1 ) this % salinity_dx = this % salinity % d_dx ( 1 ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( present ( entrainment_formulation )) then call move_alloc ( entrainment_formulation , this % entrainment_formulation ) else allocate ( jenkins1991_entrainment :: this % entrainment_formulation ) end if if ( present ( melt_formulation )) then call move_alloc ( melt_formulation , this % melt_formulation ) else allocate ( dallaston2015_melt :: this % melt_formulation ) end if if ( present ( ambient_conds )) then call move_alloc ( ambient_conds , this % ambient_conds ) else allocate ( uniform_ambient_conditions :: this % ambient_conds ) end if if ( present ( eos )) then call move_alloc ( eos , this % eos ) else allocate ( linear_eos :: this % eos ) end if if ( present ( boundaries )) then call move_alloc ( boundaries , this % boundaries ) else allocate ( simple_plume_boundary :: this % boundaries ) end if if ( present ( delta )) then this % delta = delta else this % delta = 0.036_r8 end if if ( present ( nu )) then this % nu = nu else this % nu = 0.0_r8 end if if ( present ( mu )) then this % mu = mu else this % mu = 0.0_r8 end if if ( present ( r_val )) then this % r_val = r_val else this % r_val = 1.12_r8 end if if ( present ( phi )) then this % phi = phi else this % phi = 0.0_r8 end if this % time = 0.0_r8 #ifdef DEBUG call logger % debug ( 'static_plume' , 'Initialised new ice shelf object.' ) #endif end subroutine static_plume_initialise function static_plume_melt ( this ) result ( melt ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the melt rate at the bottom of the ice ! shelf due to interaction with the plume. ! class ( static_plume ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate at the base of the ice shelf. melt => this % melt_formulation % melt_rate () end function static_plume_melt function static_plume_drag_parameter ( this ) result ( drag ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns a quantity which may be necessary to determine ! the frictional drag the plume exerts on the bottom of the ice ! shelf. The plume would actually tend to exert no drag on the bottom ! of the ice shelf, but this method is present so that there is a ! consistent interface with the [[ground(type)]] data type. ! class ( static_plume ), intent ( in ) :: this class ( scalar_field ), pointer :: drag !! The melt rate at the base of the ice sheet. type ( uniform_scalar_field ) :: dummy call dummy % allocate_scalar_field ( drag ) drag = uniform_scalar_field ( 0.0_r8 ) call drag % set_temp () #ifdef DEBUG call logger % debug ( 'static_plume%drag_parameter' , 'Returned plume drag parameter.' ) #endif end function static_plume_drag_parameter function static_plume_water_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the density of the plume water beneath the ice ! shelf. The density of this water would vary depending on how much ! saline ambient water has been entrained into the plume versus how ! much fresh water has been released due to melting. However, the ! Boussinesq approximation is used here and only a single reference ! density is returned. ! ! @NOTE Based on my approach to non-dimensionalisation, I'm pretty ! sure the density should always be 1, making this method ! unneccessary. ! class ( static_plume ), intent ( in ) :: this real ( r8 ) :: density !! The density of the water at the base of the ice sheet. density = 1.0_r8 #ifdef DEBUG call logger % debug ( 'static_plume%water_density' , 'static_plume has average density ' // & trim ( str ( density )) // '.' ) #endif end function static_plume_water_density subroutine static_plume_update ( this , state_vector , ice_thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the plume from its state vector. The state ! vector is a real array containing the value of each of the plume's ! properties at each of the locations on the grid used in discretization. ! class ( static_plume ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! plume. class ( scalar_field ), optional , intent ( in ) :: ice_thickness !! The ice thickness which, if present, will be used to update !! the calculation of the melt rate. integer :: i !TODO: Add some assertion-like checks that the state vector is the right size call this % thickness % set_from_raw ( state_vector ( 1 : this % thickness_size )) i = 1 + this % thickness_size call this % velocity % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % velocity_dx % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % temperature % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % temperature_dx % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % salinity % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) i = i + this % salinity_size call this % salinity_dx % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) if ( present ( ice_thickness )) then call this % melt_formulation % solve_for_melt ( this % velocity , & - ice_thickness / this % r_val , & this % temperature , & this % salinity , & this % thickness , & this % time ) end if #ifdef DEBUG call logger % debug ( 'static_plume%update' , 'Updated state of plume.' ) #endif end subroutine static_plume_update function static_plume_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the plume's state vector. ! This is the size of the vector returned by ! [[static_plume(type):state_vector]] and taken as an argument by ! [[static_plume(type):update]]. ! class ( static_plume ), intent ( in ) :: this integer :: static_plume_data_size !! The number of elements in the plume's state vector. static_plume_data_size = this % thickness % raw_size () + this % velocity % raw_size () + & this % velocity_dx % raw_size () + this % temperature % raw_size () + & this % temperature_dx % raw_size () + this % salinity % raw_size () + & this % salinity_dx % raw_size () #ifdef DEBUG call logger % debug ( 'static_plume%data_size' , 'static_plume shelf has ' // & trim ( str ( static_plume_data_size )) // ' elements ' // & 'in its state vector.' ) #endif end function static_plume_data_size function static_plume_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the plume. ! This takes the form of a 1D array. ! class ( static_plume ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the plume. state_vector = [ this % thickness % raw (), this % velocity % raw (), & this % velocity_dx % raw (), this % temperature % raw (), & this % temperature_dx % raw (), this % salinity % raw (), & this % salinity_dx % raw ()] #ifdef DEBUG call logger % debug ( 'static_plume%state_vector' , 'Returning state vector ' // & 'for plume.' ) #endif end function static_plume_state_vector subroutine static_plume_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the plume object from an HDF file in the ! specified group. This sets the thickness, velocity, temperature, ! salinity dataset, and parameter values. ! class ( static_plume ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err real ( r8 ), dimension ( 1 ) :: param character ( len = 50 ) :: base_type ret_err = 0 call h5gopen_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % error ( 'static_plume%read_data' , 'Could not open HDF group \"' // & group_name // '\", so no IO performed.' ) return end if call h5ltget_attribute_string_f ( file_id , group_name , hdf_type_attr , & base_type , error ) if ( trim ( base_type ) /= hdf_type_name ) then call logger % error ( 'static_plume%read_data' , 'Trying to read data from ' // & 'basal_surface of type other than plume.' ) error = - 1 return end if !call h5ltget_attribute_double_f(file_id, group_name, hdf_delta, & !                                param, error) !this%delta = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_nu, & !                                param, error) !this%nu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_mu, & !                                param, error) !this%mu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_r, & !                                param, error) !this%r_val = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_phi, & !                                param, error) !this%phi = param(1) !if (error /= 0) then !  call logger%warning('static_plume%read_data','Error code '//     & !                      trim(str(error))//' returned when '//  & !                      'reading attributes from HDF group '// & !                      group_name) !  ret_err = error !end if call this % thickness % read_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume thickness field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % read_hdf ( group_id , hdf_velocity , error ) this % velocity_dx = this % velocity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'static_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume velocity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % read_hdf ( group_id , hdf_temperature , error ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'static_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume temperature field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % read_hdf ( group_id , hdf_salinity , error ) this % salinity_dx = this % salinity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'static_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume salinity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err call logger % trivia ( 'static_plume%read_data' , 'Read plume data from HDF group ' // & group_name ) end subroutine static_plume_read_data subroutine static_plume_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the plume object to an HDF file in the ! specified group. This will consist of a thickness, a velocity, a ! temperature, and a salinity dataset. ! class ( static_plume ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err ret_err = 0 call h5gcreate_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned ' // & 'when creating HDF group \"' // group_name // '\"' ) call logger % error ( 'static_plume%write_data' , 'Data IO not performed for plume' ) return end if call h5ltset_attribute_string_f ( file_id , group_name , hdf_type_attr , & hdf_type_name , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_delta , & [ this % delta ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_nu , & [ this % nu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_mu , & [ this % mu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_r , & [ this % r_val ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_phi , & [ this % phi ], 1_size_t , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing attribute to HDF group ' // & group_name ) ret_err = error end if call this % thickness % write_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume thickness field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % write_hdf ( group_id , hdf_velocity , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume velocity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % write_hdf ( group_id , hdf_temperature , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume temperature field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % write_hdf ( group_id , hdf_salinity , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume salinity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err #ifdef DEBUG call logger % debug ( 'static_plume%write_data' , 'Wrote plume data to HDF group ' // & group_name ) #endif end subroutine static_plume_write_data subroutine static_plume_solve ( this , ice_thickness , ice_density , ice_temperature , & time , success ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Would normally solve, but for this static implementation of the ! plume it does nothing. ! class ( static_plume ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: ice_thickness !! Thickness of the ice above the basal surface real ( r8 ), intent ( in ) :: ice_density !! The density of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: ice_temperature !! The temperature of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: time !! The time to which the basal surface should be solved logical , intent ( out ) :: success !! True if the solver is successful, false otherwise call ice_thickness % guard_temp () this % time = time call this % melt_formulation % solve_for_melt ( this % velocity , & - ice_thickness / this % r_val , & this % temperature , & this % salinity , & this % thickness , & time ) success = . true . call ice_thickness % clean_temp () end subroutine static_plume_solve end module static_plume_mod"},{"title":"cryosphere.F90 – ISOFT","tags":"","loc":"sourcefile/cryosphere.f90.html","text":"This file depends on sourcefile~~cryosphere.f90~~EfferentGraph sourcefile~cryosphere.f90 cryosphere.F90 sourcefile~meta.f90 meta.F90 sourcefile~cryosphere.f90->sourcefile~meta.f90 sourcefile~glacier.f90 glacier.F90 sourcefile~cryosphere.f90->sourcefile~glacier.f90 sourcefile~basal_surface.f90 basal_surface.F90 sourcefile~cryosphere.f90->sourcefile~basal_surface.f90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~cryosphere.f90->sourcefile~nitsol.f90 sourcefile~glacier.f90->sourcefile~nitsol.f90 sourcefile~basal_surface.f90->sourcefile~nitsol.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules cryosphere_mod Source Code cryosphere.F90 Source Code ! !  cryosphere.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module cryosphere_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides a data structure representing a system of ice sheets and/or ice ! shelves, as well as the ground and/or ocean which they interact with. This ! is the fundamental data type of the ISOFT software suite. ! use iso_fortran_env , only : r8 => real64 !use foodie, only: integrand use basal_surface_mod , only : basal_surface use glacier_mod , only : glacier use meta_mod use hdf5 use h5lt use logger_mod , only : logger => master_logger use penf , only : str use nitsol_mod , only : iplvl implicit none private ! Names for objects and attributes in HDF output character ( len = 12 ), parameter , public :: hdf_glacier = 'glacier' character ( len = 18 ), parameter , public :: hdf_basal = 'basal_surface' character ( len = 13 ), parameter , public :: hdf_version = 'isoft_version' character ( len = 23 ), parameter , public :: hdf_comp_time = 'binary_compilation_time' character ( len = 16 ), parameter , public :: hdf_write_time = 'data_output_time' character ( len = 15 ), parameter , public :: hdf_simulation_time = 'simulation_time' character ( len = 25 ), parameter , public :: hdf_crash_file = & 'isoft_termination_dump.h5' type , public :: cryosphere !* Author: Christopher MacMackin !  Date: April 2016 ! ! A data structure representing glaciers, either as ice shelves or ! (eventually) ice sheets. It will allow coupled systems of ! glaciers as well as different basal couplings with the ocean or ! ground. This type is a subclass of the ! [FOODIE](https://github.com/Fortran-FOSS-Programmers/FOODIE) ! [integrand](http://fortran-foss-programmers.github.io/FOODIE/type/integrand.html), ! allowing it to take advantage of that set of integration ! libraries for evolution in time. ! private class ( glacier ), allocatable :: ice !! A model for the ice shelf or ice sheet class ( basal_surface ), allocatable :: sub_ice !! A model for the ground or ocean underneath the ice real ( r8 ) :: time !! The time in the simulation logical :: first_integration !! Indicates whether the cryosphere has been integrated before !! or not. real ( r8 ) :: dt_factor = 1.0_r8 !! A factor by which to reduce the time step real ( r8 ) :: min_dt_factor = 1 e - 3_r8 !! The smallest time step reduction to allow logical :: performing_time_step !! True if in the process of trying to get a time-step to !! successfully integrate. contains procedure :: initialise procedure :: time_step procedure :: reduce_time_step procedure :: increase_time_step procedure :: state_vector procedure :: integrate procedure :: read_data procedure :: read_ice procedure :: read_sub_ice procedure :: write_data procedure :: get_time end type cryosphere contains subroutine initialise ( this , ice , sub_ice ) !* Author: Christopher MacMackin !  Date: November 2016 ! ! Initialise a cryosphere object from the provided ! components. This object will model the evolution of a ! glacier/ice shelf/ice sheet and its surroundings. ! class ( cryosphere ), intent ( out ) :: this class ( glacier ), allocatable , intent ( inout ) :: ice !! An object modelling the ice sheet or shelf component of this !! system. Will be deallocated on return. class ( basal_surface ), allocatable , intent ( inout ) :: sub_ice !! An object modelling the component of this system beneath the !! ice. Will be deallocated on return. call move_alloc ( ice , this % ice ) call move_alloc ( sub_ice , this % sub_ice ) this % time = 0.0_r8 this % first_integration = . true . #ifdef DEBUG call logger % debug ( 'cryosphere' , 'Instantiated new cryosphere object.' ) #endif end subroutine initialise function time_step ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Calculates an appropriate time step with which to integrate the ! cryosphere so as not to cause numerical instability. ! class ( cryosphere ), intent ( inout ) :: this real ( r8 ) :: time_step time_step = this % dt_factor * this % ice % time_step () end function time_step subroutine reduce_time_step ( this ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Reuces the time step by a factor of 2, unless doing so would ! take it below the minimum value. ! class ( cryosphere ), intent ( inout ) :: this real ( r8 ) :: new_factor new_factor = 0.7_r8 * this % dt_factor if ( new_factor < this % min_dt_factor ) then this % dt_factor = this % min_dt_factor call logger % warning ( 'cryosphere%reduce_time_step' , 'Attempting to ' // & 'reduce time step factor below minimum value ' // & 'of ' // trim ( str ( this % min_dt_factor ))) else this % dt_factor = new_factor end if #ifdef DEBUG call logger % debug ( 'cryosphere%reduce_time_step' , 'Reducing time ' // & 'step by factor of ' // trim ( str ( this % dt_factor ))) #endif end subroutine reduce_time_step subroutine increase_time_step ( this ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Increases the time step by a factor of 2, unless doing so would ! take it above the maximum. ! class ( cryosphere ), intent ( inout ) :: this this % dt_factor = min ( 1.2_r8 * this % dt_factor , 1._r8 ) #ifdef DEBUG call logger % debug ( 'cryosphere%increase_time_step' , 'Reducing time ' // & 'step by factor of ' // trim ( str ( this % dt_factor ))) #endif end subroutine increase_time_step function state_vector ( this ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Returns the state vector for the current state of the ! cryosphere. This takes the form of a 1D array. This routine is ! mainly useful for unit-testing. ! class ( cryosphere ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector state_vector = [ this % ice % state_vector (), this % sub_ice % state_vector ()] end function state_vector subroutine integrate ( this , time ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Integrates the cryosphere forward until the specified `time` is ! reached. ! class ( cryosphere ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time !! The time to which to integrate the cryosphere class ( glacier ), dimension (:), allocatable :: old_glaciers logical :: success , past_fail real ( r8 ) :: t , old_t , dt real ( r8 ), allocatable , dimension (:) :: sub_state past_fail = . false . if ( time <= this % time ) then call logger % warning ( 'cryosphere%integrate' , 'Request made to ' // & 'integrate cryosphere to earlier time ' // & 'than present state. No action taken.' ) return end if ! Normally the plume should be solved at the end of the previous ! iteration, but in the first iteration obviously there hasn't ! been a chance for this to happen yet. if ( this % first_integration ) then ! As I am integrating only semi-implicitly and solving the plume ! for the current (rather than future) state, I think I should ! pass the current time. I only *think* that this is correct, ! however. call this % sub_ice % solve ( this % ice % ice_thickness (), this % ice % ice_density (), & this % ice % ice_temperature (), this % time , success ) this % first_integration = . false . if (. not . success ) then call logger % fatal ( 'cryosphere%integrate' , 'Failed to solve plume ' // & 'with initial ice configuration. Writing ' // & 'cryosphere state to file \"' // hdf_crash_file // '\".' ) call this % write_data ( hdf_crash_file ) error stop end if end if allocate ( old_glaciers ( 1 ), mold = this % ice ) old_t = this % time dt = this % time_step () if ( dt < 0.5_r8 * ( time - this % time )) then t = old_t + dt else if ( t + dt > time ) then t = time else t = 0.5_r8 * ( time + old_t ) end if do while ( t <= time ) old_glaciers ( 1 ) = this % ice call this % ice % integrate ( old_glaciers , this % sub_ice % basal_melt (), & this % sub_ice % basal_drag_parameter (), & this % sub_ice % water_density (), t , success ) if ( past_fail ) then call this % write_data ( 'isoft_post_failure.h5' ) past_fail = . false . end if if (. not . success ) then this % ice = old_glaciers ( 1 ) if ( this % dt_factor > this % min_dt_factor ) then call logger % warning ( 'cryosphere%integrate' , 'Failure in nonlinear ' // & 'solver. Reducing time step and trying again.' ) call this % reduce_time_step () dt = this % time_step () if ( dt < 0.5_r8 * ( time - old_t )) then t = old_t + dt else if ( old_t + dt > time ) then t = time else t = 0.5_r8 * ( time + old_t ) end if cycle else call logger % fatal ( 'cryosphere%integrate' , 'Failed to integrate ' // & 'glacier to time ' // trim ( str ( t )) // '! Writing ' // & 'cryosphere state to file \"' // hdf_crash_file // '\".' ) call this % write_data ( hdf_crash_file ) iplvl = 2 t = min ( old_t + this % ice % time_step (), time , 0.5_r8 * ( time + old_t )) call this % ice % integrate ( old_glaciers , this % sub_ice % basal_melt (), & this % sub_ice % basal_drag_parameter (), & this % sub_ice % water_density (), t , success ) error stop end if end if ! Solve the plume so that it is ready for use in the next step of ! the time integration. sub_state = this % sub_ice % state_vector () call this % sub_ice % solve ( this % ice % ice_thickness (), this % ice % ice_density (), & this % ice % ice_temperature (), t , success ) if ( success ) then call logger % trivia ( 'cryosphere%integrate' , 'Successfully integrated ' // & 'cryosphere to time ' // trim ( str ( t ))) else call this % write_data ( 'isoft_failed_state.h5' ) this % ice = old_glaciers ( 1 ) call this % sub_ice % update ( sub_state , this % ice % ice_thickness ()) if ( this % dt_factor > this % min_dt_factor ) then call logger % warning ( 'cryosphere%integrate' , 'Failure in plume ' // & 'solver. Reducing time step and trying again.' ) call this % reduce_time_step () dt = this % time_step () if ( dt < 0.5_r8 * ( time - old_t )) then t = old_t + dt else if ( old_t + dt > time ) then t = time else t = 0.5_r8 * ( time + old_t ) end if call this % write_data ( 'isoft_pre_failure.h5' ) past_fail = . true . cycle else call logger % fatal ( 'cryosphere%integrate' , 'Failed to solve plume ' // & 'at time ' // trim ( str ( t )) // '! Writing cryosphere ' // & 'state to file \"' // hdf_crash_file // '\".' ) call this % write_data ( hdf_crash_file ) error stop end if end if call this % increase_time_step () if ( t >= time ) exit old_t = t dt = this % time_step () if ( dt < 0.5_r8 * ( time - t )) then t = t + dt else if ( t + dt > time ) then t = time else t = 0.5_r8 * ( time + t ) end if this % time = old_t end do this % time = time call logger % info ( 'cryosphere%integrate' , 'Successfully integrated ' // & 'cryosphere to time ' // trim ( str ( t ))) end subroutine integrate subroutine read_data ( this , infile , set_time ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Reads the data describing the cryosphere from an HDF5 file on ! the disc. `h5open_f` must have been called once prior to using ! this method. After the method has been used, `h5close_f` must be ! called once before the end of the program. ! class ( cryosphere ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: infile !! The file from which to read the data describing the state of the !! cryosphere logical , optional , intent ( in ) :: set_time !! If present and `.true.` then set the simulation time of the !! cryosphere to be the same as that in the HDF file. Otherwise, !! leave it unchanged. logical :: set_t integer ( hid_t ) :: file_id , error_code character ( len = 50 ) :: string real ( r8 ), dimension ( 1 ) :: sim_time if ( present ( set_time )) then set_t = set_time else set_t = . false . end if call h5fopen_f ( infile , H5F_ACC_RDONLY_F , file_id , error_code ) if ( error_code /= 0 ) then call logger % fatal ( 'cryosphere%read_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'opening HDF5 file ' // infile ) error stop end if ! Read any whole-system data... call h5ltget_attribute_string_f ( file_id , '/' , hdf_version , string , error_code ) if ( trim ( string ) /= version ()) then call logger % warning ( 'cryosphere%read_data' , 'Reading HDF data produced ' // & 'by different ISOFT version: ' // version ()) end if call h5ltget_attribute_double_f ( file_id , '/' , hdf_simulation_time , sim_time , & error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'reading attributes from HDF5 file ' // infile ) end if ! Call for subobjects call this % ice % read_data ( file_id , hdf_glacier , error_code ) call this % sub_ice % read_data ( file_id , hdf_basal , error_code ) ! Close the file call h5fclose_f ( file_id , error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'closing HDF5 file ' // infile ) end if ! Set the time, if necessary if ( set_t ) then this % time = sim_time ( 1 ) call this % ice % set_time ( this % time ) call logger % info ( 'cryosphere%read_data' , 'Read cryosphere data ' // & 'from HDF file ' // infile // ', with simulation ' // & 'time ' // trim ( str ( this % time ))) else call logger % info ( 'cryosphere%read_data' , 'Read cryosphere data from ' // & 'HDF file ' // infile ) end if end subroutine read_data subroutine read_ice ( this , infile , set_time ) !* Author: Christopher MacMackin !  Date: December 2017 ! ! Reads the data describing the ice component of the cryosphere ! from an HDF5 file on the disc. Data on anything below the ice is ! ignored. `h5open_f` must have been called once prior to using ! this method. After the method has been used, `h5close_f` must be ! called once before the end of the program. ! class ( cryosphere ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: infile !! The file from which to read the data describing the state of the !! cryosphere logical , optional , intent ( in ) :: set_time !! If present and `.true.` then set the simulation time of the !! cryosphere to be the same as that in the HDF file. Otherwise, !! leave it unchanged. logical :: set_t integer ( hid_t ) :: file_id , error_code character ( len = 50 ) :: string real ( r8 ), dimension ( 1 ) :: sim_time if ( present ( set_time )) then set_t = set_time else set_t = . false . end if call h5fopen_f ( infile , H5F_ACC_RDONLY_F , file_id , error_code ) if ( error_code /= 0 ) then call logger % fatal ( 'cryosphere%read_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'opening HDF5 file ' // infile ) error stop end if ! Read any whole-system data... call h5ltget_attribute_string_f ( file_id , '/' , hdf_version , string , error_code ) if ( trim ( string ) /= version ()) then call logger % warning ( 'cryosphere%read_ice' , 'Reading HDF data produced ' // & 'by different ISOFT version: ' // version ()) end if call h5ltget_attribute_double_f ( file_id , '/' , hdf_simulation_time , sim_time , & error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'reading attributes from HDF5 file ' // infile ) end if ! Call for subobjects call this % ice % read_data ( file_id , hdf_glacier , error_code ) ! Close the file call h5fclose_f ( file_id , error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'closing HDF5 file ' // infile ) end if ! Set the time, if necessary if ( set_t ) then this % time = sim_time ( 1 ) call this % ice % set_time ( this % time ) call logger % info ( 'cryosphere%read_ice' , 'Read cryosphere data ' // & 'from HDF file ' // infile // ', with simulation ' // & 'time ' // trim ( str ( this % time ))) else call logger % info ( 'cryosphere%read_ice' , 'Read cryosphere data from ' // & 'HDF file ' // infile ) end if end subroutine read_ice subroutine read_sub_ice ( this , infile , set_time ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Reads the data describing the part of the cryosphere beneath the ! ice from an HDF5 file on the disc. Data on the ice itself is ! ignored. `h5open_f` must have been called once prior to using ! this method. After the method has been used, `h5close_f` must be ! called once before the end of the program. ! class ( cryosphere ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: infile !! The file from which to read the data describing the state of the !! cryosphere logical , optional , intent ( in ) :: set_time !! If present and `.true.` then set the simulation time of the !! cryosphere to be the same as that in the HDF file. Otherwise, !! leave it unchanged. logical :: set_t integer ( hid_t ) :: file_id , error_code character ( len = 50 ) :: string real ( r8 ), dimension ( 1 ) :: sim_time if ( present ( set_time )) then set_t = set_time else set_t = . false . end if call h5fopen_f ( infile , H5F_ACC_RDONLY_F , file_id , error_code ) if ( error_code /= 0 ) then call logger % fatal ( 'cryosphere%read_sub_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'opening HDF5 file ' // infile ) error stop end if ! Read any whole-system data... call h5ltget_attribute_string_f ( file_id , '/' , hdf_version , string , error_code ) if ( trim ( string ) /= version ()) then call logger % warning ( 'cryosphere%read_sub_ice' , 'Reading HDF data produced ' // & 'by different ISOFT version: ' // version ()) end if call h5ltget_attribute_double_f ( file_id , '/' , hdf_simulation_time , sim_time , & error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_sub_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'reading attributes from HDF5 file ' // infile ) end if ! Call for subobjects call this % sub_ice % read_data ( file_id , hdf_basal , error_code ) ! Close the file call h5fclose_f ( file_id , error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_sub_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'closing HDF5 file ' // infile ) end if ! Set the time, if necessary if ( set_t ) then this % time = sim_time ( 1 ) call this % ice % set_time ( this % time ) call logger % info ( 'cryosphere%read_sub_ice' , 'Read cryosphere data ' // & 'from HDF file ' // infile // ', with simulation ' // & 'time ' // trim ( str ( this % time ))) else call logger % info ( 'cryosphere%read_sub_ice' , 'Read cryosphere data from ' // & 'HDF file ' // infile ) end if end subroutine read_sub_ice subroutine write_data ( this , outfile ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Writes the data describing the cryosphere to the disc as an HDF5 ! file. `h5open_f` must have been called once prior to using this ! method. After the method has been used, `h5close_f` must be ! called once before the end of the program. ! class ( cryosphere ), intent ( in ) :: this character ( len =* ), intent ( in ) :: outfile !! The file to which to write the data describing the state of the !! cryosphere integer ( hid_t ) :: file_id , error_code call h5fcreate_f ( outfile , H5F_ACC_TRUNC_F , file_id , error_code ) if ( error_code /= 0 ) then call logger % error ( 'cryosphere%write_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'creating HDF5 file ' // outfile ) return end if ! Write any whole-system data... call h5ltset_attribute_string_f ( file_id , '/' , hdf_version , version (), error_code ) call h5ltset_attribute_string_f ( file_id , '/' , hdf_comp_time , compile_time (), & error_code ) call h5ltset_attribute_string_f ( file_id , '/' , hdf_write_time , current_time (), & error_code ) call h5ltset_attribute_double_f ( file_id , '/' , hdf_simulation_time ,[ this % time ], & 1_size_t , error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%write_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'writing attributes to HDF5 file ' // outfile ) end if ! Call for subobjects call this % ice % write_data ( file_id , hdf_glacier , error_code ) call this % sub_ice % write_data ( file_id , hdf_basal , error_code ) call h5fclose_f ( file_id , error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%write_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'closing HDF5 file ' // outfile ) end if #ifdef DEBUG call logger % debug ( 'cryosphere%write_data' , 'Wrote cryosphere data to ' // & 'HDF file ' // outfile // ' at simulation time ' // & trim ( str ( this % time ))) #endif end subroutine write_data pure function get_time ( this ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Returns the current time of the cryosphere system. ! class ( cryosphere ), intent ( in ) :: this real ( r8 ) :: get_time get_time = this % time end function get_time end module cryosphere_mod"},{"title":"melt_relationship.F90 – ISOFT","tags":"","loc":"sourcefile/melt_relationship.f90.html","text":"Files dependent on this one sourcefile~~melt_relationship.f90~~AfferentGraph sourcefile~melt_relationship.f90 melt_relationship.F90 sourcefile~dallaston2015_melt.f90 dallaston2015_melt.F90 sourcefile~dallaston2015_melt.f90->sourcefile~melt_relationship.f90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~melt_relationship.f90 sourcefile~asymmetric_plume.f90->sourcefile~dallaston2015_melt.f90 sourcefile~one_equation_melt.f90 one_equation_melt.F90 sourcefile~one_equation_melt.f90->sourcefile~melt_relationship.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~melt_relationship.f90 sourcefile~static_plume.f90->sourcefile~dallaston2015_melt.f90 sourcefile~averaged_one_equation_melt.f90 averaged_one_equation_melt.f90 sourcefile~averaged_one_equation_melt.f90->sourcefile~melt_relationship.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~melt_relationship.f90 sourcefile~plume.f90->sourcefile~dallaston2015_melt.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules melt_relationship_mod Source Code melt_relationship.F90 Source Code ! !  melt_relationship.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module melt_relationship_mod !* Author: Christopher MacMackin !  Date: October 2016 !  License: GPLv3 ! ! Provides an abstract data type to model melting of an ice shelf into a ! vertically integrated plume. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field implicit none private type , abstract , public :: abstract_melt_relationship !* Author: Christopher MacMackin !  Date: October 2016 ! ! An abstract data type for calculating melting of an ice shelf into ! a vertically integrated [[plume(type)]]. The melt rate, as well as ! effect on termperature and salinity, are calculated by calling ! [[abstract_melt_relationship(type):solve_for_melt]] and then accessed ! using [[abstract_melt_relationship(type):melt_rate]], ! [[abstract_melt_relationship(type):heat_equation_terms]], ! [[abstract_melt_relationship(type):salt_equation_terms]]. ! contains procedure ( solve ), deferred :: solve_for_melt procedure ( get_scalar ), deferred :: salt_equation_terms !! Returns the terms this melt formulation contributes to the !! salt equation, after they have been solved for using !! [[abstract_melt_relationship(type):solve_for_melt]]. procedure ( get_scalar ), deferred :: heat_equation_terms !! Returns the terms this melt formulation contributes to the !! heat equation, after they have been solved for using !! [[abstract_melt_relationship(type):solve_for_melt]]. procedure ( get_scalar ), deferred :: melt_rate !! Returns the melt rate calculated using this formulation, !! after it has been solved for using !! [[abstract_melt_relationship(type):solve_for_melt]]. procedure ( has_terms ), deferred :: has_heat_terms !! Whether this formulation of melting contributes any terms to !! a plume's heat equation. procedure ( has_terms ), deferred :: has_salt_terms !! Whether this formulation of melting contributes any terms to !! a plume's salinity equation. end type abstract_melt_relationship abstract interface subroutine solve ( this , velocity , pressure , temperature , salinity , & plume_thickness , time ) import :: abstract_melt_relationship import :: scalar_field import :: vector_field import :: r8 class ( abstract_melt_relationship ), intent ( inout ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: pressure !! The water pressure at the interface where the melting occurs. class ( scalar_field ), intent ( in ) :: temperature !! The temperature of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: salinity !! The salinity of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: plume_thickness !! The thickness of the plume into which fluid is melting. real ( r8 ), intent ( in ), optional :: time !! The time at which the melting is being solved for. If not !! present then assumed to be same as previous value passed. end subroutine solve function get_scalar ( this ) result ( property ) import :: abstract_melt_relationship import :: scalar_field class ( abstract_melt_relationship ), intent ( in ) :: this class ( scalar_field ), pointer :: property !! The value of whatever property is being returned. end function get_scalar pure function has_terms ( this ) import :: abstract_melt_relationship class ( abstract_melt_relationship ), intent ( in ) :: this logical :: has_terms !! Whether this formulation of melting contributes terms to !! the heat or salinity equations. end function has_terms end interface end module melt_relationship_mod"},{"title":"glacier_boundary.F90 – ISOFT","tags":"","loc":"sourcefile/glacier_boundary.f90.html","text":"This file depends on sourcefile~~glacier_boundary.f90~~EfferentGraph sourcefile~glacier_boundary.f90 glacier_boundary.F90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~glacier_boundary.f90->sourcefile~boundary_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~glacier_boundary.f90~~AfferentGraph sourcefile~glacier_boundary.f90 glacier_boundary.F90 sourcefile~dallaston2015_glacier.f90 dallaston2015_glacier.F90 sourcefile~dallaston2015_glacier.f90->sourcefile~glacier_boundary.f90 sourcefile~seasonal_glacier.f90 seasonal_glacier.F90 sourcefile~seasonal_glacier.f90->sourcefile~glacier_boundary.f90 sourcefile~ice_shelf.f90 ice_shelf.F90 sourcefile~ice_shelf.f90->sourcefile~glacier_boundary.f90 sourcefile~ice_shelf.f90->sourcefile~dallaston2015_glacier.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules glacier_boundary_mod Source Code glacier_boundary.F90 Source Code ! !  glacier_boundary.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module glacier_boundary_mod !* Author: Christopher MacMackin !  Date: September 2016 !  License: GPLv3 ! ! Provides an abstract derived type which can be subtyped in order to ! specify the boundary conditions for glacier types. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field use boundary_types_mod , only : free_boundary implicit none private type , public :: glacier_boundary !* Author: Chris MacMackin !  Date: September 2016 ! ! A type in which procedures for getting the boundary conditions ! of glaciers are to be specified. The descendent types can ! contain whatever data is needed to compute the result. It ! provides the routine ! [[glacier_boundary(type):boundary_residuals]] to return an ! array with the residuals representing deviation from satisfying ! the conditions. This can then be appended to a ! [[glacier(type)]]'s residual array. ! ! When specifying boundary conditions in this way, it becomes ! necessary not to include the residual of the plume data at some ! location(s). Typically this would be adjacent to the boundaries ! being prescribed. In order to accomplish this, routines are ! provided which return arrays indicating at which boundaries data ! should be omitted and how much. These should be passed as ! arguments for the field methods to get and set the field's raw ! data. ! ! This class effectively provides free boundary conditions. It's ! type-bound procedures should be overridden to provide case-specific ! conditions. ! contains procedure :: thickness_lower_bound => bound_array !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the thickness !! field. procedure :: thickness_upper_bound => bound_array !! Returns a 1D array which should be passed as the !! `exclude_upper_bound`/`provide_upper_bound` argument when !! getting or setting the raw representation of the thickness !! field. procedure :: velocity_lower_bound => bound_array !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: velocity_upper_bound => bound_array !! Returns a 1D array which should be passed as the !! `exclude_upper_bound`/`provide_upper_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: thickness_lower_type => bound_type !! Returns an array indicating what type of boundary conditions !! apply for thickness at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: thickness_upper_type => bound_type !! Returns an array indicating what type of boundary conditions !! apply for thickness at the upper boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_lower_type => bound_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_upper_type => bound_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the upper boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: boundary_residuals !! Returns an array consisting of the difference between the !! required boundary values and those which actually exist. The !! order in which these are listed is as follows: lower !! thickness boundary, upper thickness boundary, lower velocity !! boundary, and upper velocity boundary. end type glacier_boundary abstract interface end interface contains pure function bound_array ( this ) !* Author: Chris MacMackin !  Date: September 2016 ! ! Default implementation of the method getting lower and upper ! boundary information, which is then passed to the methods for ! getting and setting raw representations of fields. It returns a ! 1D array of length 2, indicating free boundaries (the raw data ! should represent all cells contained in the field, not excluding ! any near the boundaries). ! class ( glacier_boundary ), intent ( in ) :: this integer , dimension ( 2 ) :: bound_array bound_array = 0 end function bound_array function boundary_residuals ( this , thickness , velocity , viscosity , t ) & result ( residuals ) !* Author: Chris MacMackin !  Date: September 2016 ! ! Default implementation of the ! [[glacier_boundary(type):boundary_residuals]] ! method. It returns a zero-length array, effectively indicating free ! boundaries. ! class ( glacier_boundary ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: thickness !! A field containing the thickness of the glacier class ( vector_field ), intent ( in ) :: velocity !! A field containing the flow velocity of the glacier class ( scalar_field ), intent ( in ) :: viscosity !! A field containing the viscosity of the ice in the glacier. real ( r8 ), intent ( in ) :: t !! The time at which the boundary conditions are to be !! calculated. real ( r8 ), allocatable , dimension (:) :: residuals !! An array containing the difference between the required !! boundary values and those which are actually present. They !! are stored in the order: lower thickness boundary, upper !! thickness boundary, lower velocity boundary, and upper !! velocity boundary. allocate ( residuals ( 0 )) end function boundary_residuals pure function bound_type ( this ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Default implementation of the methods getting the boundary types ! for a glacier.  It returns an array which indicates free ! boundaries. ! class ( glacier_boundary ), intent ( in ) :: this integer , dimension (:), allocatable :: bound_type bound_type = [ free_boundary , free_boundary ] end function bound_type end module glacier_boundary_mod"},{"title":"nittfq2.f – ISOFT","tags":"","loc":"sourcefile/nittfq2.f.html","text":"Contents Subroutines nittfq2 Source Code nittfq2.f Source Code c ------------------------------------------------------------------------ c c This is nittfq2, a copy of the TFQMR routine in the NITSOL package. It c has been modified so that it will take an initial guess of the solution. c c ------------------------------------------------------------------------ subroutine nittfq2 ( n , xcur , fcur , step , eta , f , jacv , rpar , ipar , $ ijacv , irpre , iksmax , ifdord , nfe , njve , nrpre , nli , r , rcgs , $ rtil , d , p , q , u , v , y , rwork1 , rwork2 , rsnrm , dinpr , dnorm , $ itrmks ) implicit none integer ifdord , ijacv , iksmax , irpre , itrmks , n , nfe , njve , & nrpre , nli integer ipar ( * ) double precision eta , fcnrm , rsnrm double precision d ( n ), fcur ( n ), p ( n ), q ( n ), rcgs ( n ), r ( n ), & rpar ( * ), rtil ( n ), rwork1 ( n ), rwork2 ( n ), step ( n ), & u ( n ), v ( n ), xcur ( n ), y ( n ) double precision dinpr , dnorm external f , jacv , dinpr , dnorm c ------------------------------------------------------------------------ c c This is nittfq v0.1, the TFQMR routine for determining (trial) inexact c Newton steps. The original reference is R. W. Freund, \"A Transpose-Free c Quasi-Minimal Residual Algorithm for Non-Hermitian Linear Systems\", c SIAM J. Sci. Comput., 14 (1993), pp. 470-482.  The implementation here c is based on the right preconditioned algorithm that appears in c J. N. Shadid and R. S. Tuminaro, \"A Comparison of Preconditioned c Nonsymmetric Krylov Methods on a Large-Scale MIMD Machine\", SIAM J. c Sci. Comput., 15 (1994), pp. 440-459. c c ------------------------------------------------------------------------ c c Explanation: c c  n       = dimension of the problem. c c  xcur    = vector of length n, current approximate solution. c c  fcur    = vector of length n, value of f at xcur. c c************************************************************************* c c FCNRM is no longer an argument, as it needs to be calculated from the c residual, which isn't known until a little way into this routine. It c could be calculated by the calling routine, but that would mean doing c the calculation twice. c c************************************************************************* c c  step    = vector of length n, (trial) step. c c  eta     = relative residual reduction factor. c c  f      = name of user-supplied subroutine for evaluating the function c           the zero of which is sought; this routine has the form c c                 subroutine f(n, xcur, fcur, rpar, ipar, itrmf) c c           where xcur is the array containing the current x value, fcur c           is f(xcur) on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmf is an integer termination flag.  The meaning of c           itrmf is as follows: c             0 => normal termination; desired function value calculated. c             1 => failure to produce f(xcur). c c  jacv   = name of user-supplied subroutine for evaluating J*v or c           P(inverse)*v, where J is the Jacobian of f and P is a c           right preconditioning operator. If neither analytic J*v c           evaluations nor right preconditioning is used, this can c           be a dummy subroutine; if right preconditioning is used but c           not analytic J*v evaluations, this need only evaluate c           P(inverse)*v. The form is c c           subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) c c           where xcur and fcur are vectors of length n containing the c           current x and f values, ijob is an integer flag indicating c           which product is desired, v is a vector of length n to be c           multiplied, z is a vector of length n containing the desired c           product on output, rpar and ipar are, respectively, real c           and integer parameter/work arrays for use by the subroutine, c           and itrmjv is an integer termination c           flag. The meaning of ijob is as follows: c             0 => z = J*v c             1 => z = P(inverse)*v c           The meaning of itrmjv is as follows: c             0 => normal termination; desired product evaluated. c             1 => failure to produce J*v. c             2 => failure to produce P(inverse)*v. c           This subroutine is called only from nitjv, and is always c           called with v .ne. z. c c  rpar    = real parameter/work array passed to the f and jacv routines. c c  ipar    = integer parameter/work array passed to the f and jacv routines. c c  ijacv   = flag for determining method of J*v evaluation. c              0 => finite-difference evaluation (default). c              1 => analytic evaluation. c c  irpre   = flag for right preconditioning. c              0 => no right preconditioning c              1 => right preconditioning c c  iksmax  = maximum allowable number of TFQMR iterations. c c  ifdord  = order of the finite-difference formula used in BiCGSTAB c            when J*v products are evaluated using finite-differences. c            When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or c            4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on c            input to this subroutine, ifdord determines the order of the c            finite-difference formula used at each BiCGSTAB iteration c            (default 1). In this case, ijacv is set to -1 below to c            signal to nitjv that the order of the finite-difference c            formula is to be determined by ifdord. The original value c            ijacv = 0 is restored on return. c c  nfe     = number of function evaluations. c c  njve    = number of J*v evaluations. c c  nrpre   = number of P(inverse)*v evaluations. c c  nli     = number of linear iterations. c c  r       = residual vector (for the QMR process) c c  rcgs    = residual vector (of the underlying CGS process) c c  rtil    = 'shadow' residual vector used in bi-orthogonalization c c  d       = vector used in TFQMR c c  p       = vector used in TFQMR c c  q       = vector used in TFQMR c c  u       = vector used in TFQMR c c  v       = vector used in TFQMR c c  y       = vector used in TFQMR c c  rwork1  = work vector, passed on to nitjv c c  rwork2  = work vector, passed on to nitjv c c  rsnrm   = TFQMR residual norm on return. c c  dinpr   = inner-product routine, either user-supplied or blas ddot. c c  dnorm   = norm routine, either user-supplied or blas dnrm2. c c  itrmks  = termination flag; values have the following meanings: c              0 => normal termination: acceptable step found. c              1 => J*v failure in nitjv. c              2 => P(inverse)*v failure in nitjv. c              3 => acceptable step not found in iksmax TFQMR iterations. c              4 => TFQMR breakdown. c              5 => floating point error (the underlying CGS iteration c                   has probably blown up) c c             Note: On return, nitsol terminates if itrmks is 1 or 2. c             If itrmks is 3 or 4, nitsol may terminate or continue. c             In this event, the step returned is a meaningful inexact c             Newton step only if the residual norm has been reduced. c             A decision on termination/continuation is made in nitdrv c             according to whether there is sufficient residual norm c             reduction, even though the desired inexact Newton condition c             may not hold. c c ------------------------------------------------------------------------- c  Subroutines required by this and all called routines: c    user supplied:  nitjv c    nitsol routines: none c    BLAS routines- dcopy, daxpy, dscal, dswap c    LAPACK routines - dlamch c    user supplied or BLAS:  dinpr, dnorm c    explanation: In nitsol, dinpr and dnorm are set to either the BLAS c    ddot and dnrm2 routines or the user-supplied routines. c This subroutine called by: nitdrv c Subroutines called by this subroutine: daxpy, dcopy, dscal, dswap, dinpr, c    dlamch, dnorm, nitjv, dlamch c Common block: c c************************************************************************* c c <<<<<<<<<<<<<<<<<<<<< TAKEN FROM `nitprint.h` >>>>>>>>>>>>>>>>>>>>>>>>> c c Include these declaratinos and common blocks directly so that the c include files are not needed in isoft. c integer iplvl , ipunit common / nitprint / iplvl , ipunit c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number, e.g., ipunit = 6 => standard output. c              NOTE: If ipunit = 0 on input, then it is set to 6. c c************************************************************************* c c If diagnostic information is desired, include this common block in the c main program and set iplvl and ipunit according to the following: c c     iplvl = 0 => no printout c           = 1 => iteration numbers and F-norms c           = 2 => ... + some stats, step norms, and linear model norms c           = 3 => ... + some Krylov solver and backtrack information c           = 4 => ... + more Krylov solver and backtrack information c c     ipunit = printout unit number. c  Parameters- double precision zero , one parameter ( zero = 0.0d0 , one = 1.0d0 ) c  Local variables- integer i integer itask integer itrmjv integer itfq integer k double precision alpha double precision abstol double precision beta double precision c double precision cgsnorm double precision qmreta double precision omega double precision rho double precision rho_old double precision sigma double precision t double precision tau double precision theta character * 2 ab ( 0 : 1 ) data ab / '.a' , '.b' / double precision sfmin data sfmin / zero / c  External subroutines- double precision dlamch external daxpy external dcopy external dlamch external dscal external dswap external nitjv c  Intrinsics- intrinsic abs intrinsic dble intrinsic sqrt c  Start of executable code- c  Initialize sfmin only on first entry. if ( sfmin . eq . zero ) sfmin = dlamch ( 's' ) c If finite-differences are used to evaluate J*v products (ijacv= 0), then c ijacv is set to -1 within this subroutine to signal to nitjv that the c order of the finite-difference formula is to be determined by ifdord. c The original value ijacv= 0 is restored on return. if ( ijacv . eq . 0 ) ijacv = - 1 c Set the stopping tolerance, initialize the step, etc. c************************************************************************* c c     Do not set the step to 0, as it contains an initial guess at the c     solution. c c************************************************************************* CC      do 10 i = 1, n CC         step(i) = zero CC 10   continue itfq = 0 c c  Initialize residual and work vectors. c c************************************************************************* c c     Because the initial step is not zero, the residual must include an c     evaluation of the left-hand-side.. c c************************************************************************* itask = 0 if ( ijacv . eq . 0 ) ijacv = - 1 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , $ itask , nfe , njve , nrpre , step , rcgs , rwork1 , rwork2 , dnorm , $ itrmjv ) if ( ijacv . eq . - 1 ) ijacv = 0 if ( itrmjv . gt . 0 ) then itrmks = 1 go to 900 endif do 25 i = 1 , n rcgs ( i ) = - fcur ( i ) - rcgs ( i ) 25 continue rsnrm = dnorm ( n , rcgs , 1 ) fcnrm = rsnrm abstol = eta * rsnrm c ------------------------------------------------------------------------ c For printing: if ( iplvl . ge . 3 ) then write ( ipunit , * ) write ( ipunit , 800 ) eta endif if ( iplvl . ge . 4 ) then write ( ipunit , 810 ) write ( ipunit , * ) write ( ipunit , 820 ) itfq , rsnrm endif c  Choice here is rtil = r. call dcopy ( n , rcgs , 1 , rtil , 1 ) if ( irpre . eq . 0 ) then call dcopy ( n , rcgs , 1 , p , 1 ) else itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , rcgs , p , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 2 goto 900 endif endif call dcopy ( n , p , 1 , u , 1 ) rho = dinpr ( n , rcgs , 1 , rtil , 1 ) do 20 i = 1 , n d ( i ) = zero 20 continue itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , p , v , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 1 goto 900 end if alpha = zero omega = fcnrm tau = omega theta = zero qmreta = zero c  Start iterations. 100 continue itfq = itfq + 1 nli = nli + 1 sigma = dinpr ( n , rtil , 1 , v , 1 ) c  If sigma = 0 we have a serious breakdown.  We check this condition c  by trying to detect whether division by sigma causes an overflow. if ( abs ( sigma ) . lt . sfmin * abs ( rho ) ) then itrmks = 4 goto 900 else alpha = rho / sigma endif c  Need Pv for calculation of q.  First store result in q, then c  swap some vectors to cast calculation of q as a SAXPY. if ( irpre . eq . 0 ) then call dcopy ( n , v , 1 , q , 1 ) else itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , v , q , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 2 goto 900 endif endif call dcopy ( n , u , 1 , y , 1 ) call dswap ( n , q , 1 , u , 1 ) call daxpy ( n , - alpha , u , 1 , q , 1 ) call dcopy ( n , y , 1 , u , 1 ) c  Update residual. do 30 i = 1 , n y ( i ) = u ( i ) + q ( i ) 30 continue itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , y , v , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 1 goto 900 end if call daxpy ( n , - alpha , v , 1 , rcgs , 1 ) cgsnorm = dnorm ( n , rcgs , 1 ) c  Check for cgsnorm = NaN. if ( cgsnorm . ne . cgsnorm ) then itrmks = 5 goto 900 endif c  QMR section. do 60 k = 0 , 1 c  Use weighting strategy from (5.11) of Freund reference. t = qmreta * theta ** 2 t = t / alpha if ( k . eq . 0 ) then do 40 i = 1 , n d ( i ) = u ( i ) + t * d ( i ) 40 continue omega = sqrt ( omega * cgsnorm ) else if ( k . eq . 1 ) then do 50 i = 1 , n d ( i ) = q ( i ) + t * d ( i ) 50 continue omega = cgsnorm endif theta = omega / tau c = one / sqrt ( one + theta ** 2 ) tau = tau * theta * c qmreta = alpha * c ** 2 c For printing: if ( iplvl . ge . 4 . and . tau . gt . abstol ) then write ( ipunit , 830 ) itfq , ab ( k ), tau , '     (estimated)' endif call daxpy ( n , qmreta , d , 1 , step , 1 ) c  Convergence check.  Do a cheap test to save on Jacobi-vector products. c  In case residual history is requested by iplvl, we must calculate c  the QMR residual from scratch.  Note termination is always determined c  by the smoothed residual, calculated from scratch. if ( tau . le . abstol ) then itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , & ifdord , itask , nfe , njve , nrpre , step , r , rwork1 , & rwork2 , dnorm , itrmjv ) c  This calculation of the QMR residual is off by a factor c  of -1, but we don't care until we return from this routine. call daxpy ( n , one , fcur , 1 , r , 1 ) rsnrm = dnorm ( n , r , 1 ) c For printing: if ( iplvl . ge . 4 ) then write ( ipunit , 830 ) itfq , ab ( k ), rsnrm , '  (from scratch)' endif c  Check for rsnrm = NaN. if ( rsnrm . ne . rsnrm ) then itrmks = 5 goto 900 endif c  If rsnrm is small enough, exit. if ( rsnrm . lt . abstol ) then itrmks = 0 goto 900 endif endif 60 continue rho_old = rho rho = dinpr ( n , rtil , 1 , rcgs , 1 ) c  If rho_old = 0 we have a serious breakdown.  We check this condition c  by trying to detect whether division by rho_old causes an overflow. if ( abs ( rho_old ) . lt . sfmin * abs ( rho ) ) then itrmks = 4 goto 900 else beta = rho / rho_old endif if ( irpre . eq . 0 ) then call dcopy ( n , rcgs , 1 , v , 1 ) else itask = 2 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , rcgs , v , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 2 goto 900 endif endif call daxpy ( n , beta , q , 1 , v , 1 ) call dcopy ( n , v , 1 , u , 1 ) call daxpy ( n , beta , p , 1 , q , 1 ) call daxpy ( n , beta , q , 1 , v , 1 ) call dcopy ( n , v , 1 , p , 1 ) itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , ifdord , & itask , nfe , njve , nrpre , p , v , rwork1 , rwork2 , & dnorm , itrmjv ) if ( itrmjv . ne . 0 ) then itrmks = 1 goto 900 end if if ( itfq . ge . iksmax ) then itrmks = 3 goto 900 end if c  Do again goto 100 c  All returns made here. 900 continue c  If residual hasn't been updated, force c  computation of residual from scratch. if ( rsnrm . eq . fcnrm ) then itask = 0 call nitjv ( n , xcur , fcur , f , jacv , rpar , ipar , ijacv , & ifdord , itask , nfe , njve , nrpre , step , r , rwork1 , & rwork2 , dnorm , itrmjv ) call daxpy ( n , one , fcur , 1 , r , 1 ) rsnrm = dnorm ( n , r , 1 ) if ( rsnrm . le . abstol ) itrmks = 0 end if c  Correct residual before returning. call dscal ( n , - one , r , 1 ) c If ijacv = -1, then restore it to the original value ijacv = 0. if ( ijacv . eq . - 1 ) ijacv = 0 c For printing: if ( iplvl . ge . 3 ) then write ( ipunit , * ) if ( itrmks . ne . 1 . and . itrmks . ne . 2 ) then write ( ipunit , 840 ) itrmks , rsnrm else write ( ipunit , 850 ) itrmks endif endif return 800 format ( 'nittfq:  eta =' , 1 pd10 . 3 ) 810 format ( 'nittfq:  TFQMR iteration no. (parts a and b),' , & ' linear residual norm' ) 820 format ( 5 x , i4 , 5 x , 1 pd10 . 3 ) 830 format ( 5 x , i4 , a2 , 3 x , 1 pd10 . 3 , a16 ) 840 format ( 'nittfq:  itrmks =' , i2 , '   final lin. res. norm =' , & 1 pd10 . 3 ) 850 format ( 'nittfq: itrmks:' , i4 ) c  End of nittfq. end"},{"title":"boundary_types.f90 – ISOFT","tags":"","loc":"sourcefile/boundary_types.f90.html","text":"Files dependent on this one sourcefile~~boundary_types.f90~~AfferentGraph sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~plume_boundary.f90 plume_boundary.F90 sourcefile~plume_boundary.f90->sourcefile~boundary_types.f90 sourcefile~glacier_boundary.f90 glacier_boundary.F90 sourcefile~glacier_boundary.f90->sourcefile~boundary_types.f90 sourcefile~finite_difference_block.f90 finite_difference_block.F90 sourcefile~finite_difference_block.f90->sourcefile~boundary_types.f90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~boundary_types.f90 sourcefile~asymmetric_plume.f90->sourcefile~plume_boundary.f90 sourcefile~simple_plume.f90 simple_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~simple_plume.f90 sourcefile~upstream_plume.f90 upstream_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~upstream_plume.f90 sourcefile~ice_shelf.f90 ice_shelf.F90 sourcefile~ice_shelf.f90->sourcefile~boundary_types.f90 sourcefile~ice_shelf.f90->sourcefile~glacier_boundary.f90 sourcefile~dallaston2015_glacier.f90 dallaston2015_glacier.F90 sourcefile~ice_shelf.f90->sourcefile~dallaston2015_glacier.f90 sourcefile~jacobian_block.f90 jacobian_block.F90 sourcefile~ice_shelf.f90->sourcefile~jacobian_block.f90 sourcefile~simple_plume.f90->sourcefile~boundary_types.f90 sourcefile~simple_plume.f90->sourcefile~plume_boundary.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~boundary_types.f90 sourcefile~static_plume.f90->sourcefile~plume_boundary.f90 sourcefile~static_plume.f90->sourcefile~simple_plume.f90 sourcefile~static_plume.f90->sourcefile~upstream_plume.f90 sourcefile~dallaston2015_seasonal.f90 dallaston2015_seasonal.F90 sourcefile~dallaston2015_seasonal.f90->sourcefile~boundary_types.f90 sourcefile~dallaston2015_seasonal.f90->sourcefile~plume_boundary.f90 sourcefile~dallaston2015_glacier.f90->sourcefile~boundary_types.f90 sourcefile~dallaston2015_glacier.f90->sourcefile~glacier_boundary.f90 sourcefile~upstream_plume.f90->sourcefile~boundary_types.f90 sourcefile~upstream_plume.f90->sourcefile~plume_boundary.f90 sourcefile~seasonal_glacier.f90 seasonal_glacier.F90 sourcefile~seasonal_glacier.f90->sourcefile~boundary_types.f90 sourcefile~seasonal_glacier.f90->sourcefile~glacier_boundary.f90 sourcefile~jacobian_block.f90->sourcefile~boundary_types.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~boundary_types.f90 sourcefile~plume.f90->sourcefile~plume_boundary.f90 sourcefile~plume.f90->sourcefile~simple_plume.f90 sourcefile~plume.f90->sourcefile~upstream_plume.f90 sourcefile~preconditioner.f90 preconditioner.F90 sourcefile~preconditioner.f90->sourcefile~jacobian_block.f90 sourcefile~ice_sheet.f90 ice_sheet.F90 sourcefile~ice_sheet.f90->sourcefile~jacobian_block.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules boundary_types_mod Source Code boundary_types.f90 Source Code ! !  boundary_types.f90 !  This file is part of ISOFT. ! !  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module boundary_types_mod !* Author: Christopher MacMackin !  Date: January 2017 !  License: GPLv3 ! ! Provides parameters which can be used to represent different types ! of boundary conditions. ! implicit none private integer , parameter , public :: free_boundary = - 1 !! Indicates that the solution may take any value at the boundary. integer , parameter , public :: dirichlet = 0 !! Indicates that the value of the solution at this boundary is !! prescribed. integer , parameter , public :: neumann = 1 !! Indicates that the first derivative of the solution at this !! boundary is prescribed. integer , parameter , public :: cauchy = 5 !! Indicates that the value of the solution and its first !! derivative are both prescribed at this boundary. integer , parameter , public :: robin = 6 !! Indicates that the linear combination of the solution's value !! and first derivative is prescribed at this boundary. end module boundary_types_mod"},{"title":"averaged_linear_eos.F90 – ISOFT","tags":"","loc":"sourcefile/averaged_linear_eos.f90.html","text":"This file depends on sourcefile~~averaged_linear_eos.f90~~EfferentGraph sourcefile~averaged_linear_eos.f90 averaged_linear_eos.F90 sourcefile~equation_of_state.f90 equation_of_state.F90 sourcefile~averaged_linear_eos.f90->sourcefile~equation_of_state.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~averaged_linear_eos.f90~~AfferentGraph sourcefile~averaged_linear_eos.f90 averaged_linear_eos.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~averaged_linear_eos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ave_linear_eos_mod Source Code averaged_linear_eos.F90 Source Code ! !  averaged_linear_eos.f90 !  This file is part of ISOFT. ! !  Copyright 2019 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module ave_linear_eos_mod !* Author: Christopher MacMackin !  Date: August 2018 !  License: GPLv3 ! ! Provides an abstract derived type which can be subtyped in order to ! implement an equation of state. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , uniform_scalar_field use equation_of_state_mod , only : equation_of_state implicit none private real ( r8 ), parameter :: absolute_zero = - 27 3.15_r8 type , extends ( equation_of_state ), public :: ave_linear_eos !* Author: Chris MacMackin !  Date: August 2018 ! ! A linearised implementation of the equation of state which has ! been horizontally-integrated. The basic equation of stateis  ! \\rho(x,y) = \\rho_0[1-\\beta_T(T(x,y)-T_0) + ! \\beta_S(S(x,y)-S_0)].  ! private real ( r8 ) :: ref_rho = 1.0_r8 !! The density for the temperature and salinity about which the !! equation of state was linearised, \\rho_0. real ( r8 ) :: ref_t = 0.0_r8 !! The temperature about which the equation of state was !! linearised, T_0. real ( r8 ) :: ref_s = 0.0_r8 !! The salinity about which the equation of state was !! linearised, S_0. real ( r8 ) :: beta_t = 0.0_r8 !! The thermal contraction coefficient, \\beta_T. real ( r8 ) :: beta_s = 1.0_r8 !! The haline contraction coefficient, \\beta_S. real ( r8 ) :: a_DS = 1.0_r8 !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{D}f_S dy,  where f_{D}(y) and !! f_S(y) are the shapes of the variables D and S in !! the transverse direction. real ( r8 ) :: a_DT = 1.0_r8 !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{D}f_T dy,  where f_{D}(y) and !! f_T(y) are the shapes of the variables D and T in !! the transverse direction. real ( r8 ) :: a_DS_t = 1.0_r8 !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\tilde{\\alpha}_{DS} = !! \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S !! dy,  where f_{D}(y) and f_S(y) are the shapes of !! the variables D and S in the transverse direction and !! \\alpha_{D&#94;2} = \\frac{1}{y_2 - !! y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. real ( r8 ) :: a_DT_t = 1.0_r8 !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\tilde{\\alpha}_{DT} = !! \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T !! dy,  where f_{D}(y) and f_T(y) are the shapes of !! the variables D and T in the transverse direction and !! \\alpha_{D&#94;2} = \\frac{1}{y_2 - !! y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. contains procedure :: water_density => linear_water_density procedure :: water_density_ave1 => linear_water_density_ave1 procedure :: water_density_ave2 => linear_water_density_ave2 procedure :: water_density_derivative => linear_water_deriv procedure :: haline_contraction => linear_haline_contraction procedure :: thermal_contraction => linear_thermal_contraction end type ave_linear_eos interface ave_linear_eos module procedure constructor end interface ave_linear_eos contains pure function constructor ( ref_rho , ref_t , ref_s , beta_t , beta_s , a_DS , & a_DT , a_DS_t , a_DT_t ) result ( this ) real ( r8 ), intent ( in ) :: ref_rho !! The density for the temperature and salinity about which the !! equation of state was linearised, \\rho_0. real ( r8 ), intent ( in ) :: ref_t !! The temperature about which the equation of state was !! linearised, T_0. real ( r8 ), intent ( in ) :: ref_s !! The salinity about which the equation of state was !! linearised, S_0. real ( r8 ), intent ( in ) :: beta_t !! The thermal contraction coefficient, \\beta_T. real ( r8 ), intent ( in ) :: beta_s !! The haline contraction coefficient, \\beta_S. real ( r8 ), intent ( in ), optional :: a_DS !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{D}f_S dy,  where f_{D}(y) and !! f_S(y) are the shapes of the variables D and S in !! the transverse direction. Defualt value is 1. real ( r8 ), intent ( in ), optional :: a_DT !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{D}f_T dy,  where f_{D}(y) and !! f_T(y) are the shapes of the variables D and T in !! the transverse direction. Defualt value is 1. real ( r8 ), intent ( in ), optional :: a_DS_t !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\tilde{\\alpha}_{DS} = !! \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S !! dy,  where f_{D}(y) and f_S(y) are the shapes of !! the variables D and S in the transverse direction and !! \\alpha_{D&#94;2} = \\frac{1}{y_2 - !! y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. real ( r8 ), intent ( in ), optional :: a_DT_t !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\tilde{\\alpha}_{DT} = !! \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T !! dy,  where f_{D}(y) and f_T(y) are the shapes of !! the variables D and T in the transverse direction and !! \\alpha_{D&#94;2} = \\frac{1}{y_2 - !! y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. type ( ave_linear_eos ) :: this this % ref_rho = ref_rho this % ref_t = ref_t this % ref_s = ref_s this % beta_t = beta_t this % beta_s = beta_s if ( present ( a_DS )) this % a_DS = a_DS if ( present ( a_DT )) this % a_DT = a_DT if ( present ( a_DS_t )) this % a_DS_t = a_DS_t if ( present ( a_DT_t )) this % a_DT_t = a_DT_t end function constructor function linear_water_density ( this , temperature , salinity ) result ( density ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Calculates the density of the water from the temperature and ! salinity, using a linear equation of state,  \\rho(x,y) = ! \\rho_0[1-\\beta_T(T(x,y)-T_0) + \\beta_S(S(x,y)-S_0)].  class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call salinity % allocate_scalar_field ( density ) density = this % ref_rho * ( 1.0_r8 - this % beta_t * ( temperature - this % ref_t ) & + this % beta_s * ( salinity - this % ref_s )) call temperature % clean_temp (); call salinity % clean_temp () call density % set_temp () end function linear_water_density function linear_water_density_ave1 ( this , temperature , salinity ) result ( density ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Calculates one form of the horizontally-averaged density of the ! water from the temperature and salinity, using a linear equation ! of state,  \\bar{rho}(x) = ! \\rho_0[1-\\beta_T(\\alpha_{DT}T(x)-T_0) + ! \\beta_S(\\alpha_{DS}S(x)-S_0)].  class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call salinity % allocate_scalar_field ( density ) density = this % ref_rho * ( 1.0_r8 - this % beta_t * ( this % a_DT * temperature - this % ref_t ) & + this % beta_s * ( this % a_DS * salinity - this % ref_s )) call temperature % clean_temp (); call salinity % clean_temp () call density % set_temp () end function linear_water_density_ave1 function linear_water_density_ave2 ( this , temperature , salinity ) result ( density ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Calculates another form of the horizontally-averaged density of ! the water from the temperature and salinity, using a linear ! equation of state,  \\tilde{\\rho}(x) = ! \\rho_0[1-\\beta_T(\\tilde{\\alpha}_{DT}T(x)-T_0) + ! \\beta_S(\\tilde{\\alpha}_{DS}S(x)-S_0)].  class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call salinity % allocate_scalar_field ( density ) density = this % ref_rho * ( 1.0_r8 - this % beta_t * ( temperature - this % ref_t ) & + this % beta_s * ( salinity - this % ref_s )) call temperature % clean_temp (); call salinity % clean_temp () call density % set_temp () end function linear_water_density_ave2 function linear_water_deriv ( this , temperature , d_temperature , salinity , & d_salinity , dir ) result ( d_density ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Calculates the derivative of the average water density from the ! temperature and salinity, using a linear equation of state with ! the second type of averaging,  \\tilde{\\rho} = ! \\rho_0[1-\\beta_T(\\tilde{\\alpha}_{DT}T-T_0) + ! \\beta_S(\\tilde{\\alpha}_{DS}S-S_0)].  class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: d_temperature !! A field containing the derivative of the temperature of the !! water, in teh same direction as `dir` class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), intent ( in ) :: d_salinity !! A field containing the derivative of the salinity of the !! water, in the same direction as `dir` integer , intent ( in ) :: dir !! The direction in which to take the derivative class ( scalar_field ), pointer :: d_density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call d_temperature % guard_temp (); call d_salinity % guard_temp () call salinity % allocate_scalar_field ( d_density ) d_density = this % ref_rho * ( this % a_DS_t * this % beta_s * d_salinity - & this % a_DT_t * this % beta_t * d_temperature ) call temperature % clean_temp (); call salinity % clean_temp () call d_temperature % clean_temp (); call d_salinity % clean_temp () call d_density % set_temp () end function linear_water_deriv function linear_haline_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Returns the haline contraction coefficient. ! class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( this % ref_rho * this % beta_s ) end function linear_haline_contraction function linear_thermal_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Returns the thermal contraction coefficient. ! class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( this % ref_rho * this % beta_t ) end function linear_thermal_contraction end module ave_linear_eos_mod"},{"title":"ice_shelf.F90 – ISOFT","tags":"","loc":"sourcefile/ice_shelf.f90.html","text":"This file depends on sourcefile~~ice_shelf.f90~~EfferentGraph sourcefile~ice_shelf.f90 ice_shelf.F90 sourcefile~viscosity.f90 viscosity.F90 sourcefile~ice_shelf.f90->sourcefile~viscosity.f90 sourcefile~glacier.f90 glacier.F90 sourcefile~ice_shelf.f90->sourcefile~glacier.f90 sourcefile~newtonian_viscosity.f90 newtonian_viscosity.F90 sourcefile~ice_shelf.f90->sourcefile~newtonian_viscosity.f90 sourcefile~glacier_boundary.f90 glacier_boundary.F90 sourcefile~ice_shelf.f90->sourcefile~glacier_boundary.f90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~ice_shelf.f90->sourcefile~nitsol.f90 sourcefile~dallaston2015_glacier.f90 dallaston2015_glacier.F90 sourcefile~ice_shelf.f90->sourcefile~dallaston2015_glacier.f90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~ice_shelf.f90->sourcefile~boundary_types.f90 sourcefile~jacobian_block.f90 jacobian_block.F90 sourcefile~ice_shelf.f90->sourcefile~jacobian_block.f90 sourcefile~glacier.f90->sourcefile~nitsol.f90 sourcefile~newtonian_viscosity.f90->sourcefile~viscosity.f90 sourcefile~glacier_boundary.f90->sourcefile~boundary_types.f90 sourcefile~dallaston2015_glacier.f90->sourcefile~glacier_boundary.f90 sourcefile~dallaston2015_glacier.f90->sourcefile~boundary_types.f90 sourcefile~jacobian_block.f90->sourcefile~boundary_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ice_shelf_mod Source Code ice_shelf.F90 Source Code ! !  ice_shelf.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module ice_shelf_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides a concrete implementation of the [[glacier]] type, using ! a vertically integrated model of an ice shelf. ! use iso_fortran_env , only : r8 => real64 !use foodie, only: integrand use glacier_mod , only : glacier , thickness_func , velocity_func , hdf_type_attr use factual_mod , only : scalar_field , vector_field , cheb1d_scalar_field , & cheb1d_vector_field , maxval , minval , abs use viscosity_mod , only : abstract_viscosity use newtonian_viscosity_mod , only : newtonian_viscosity use glacier_boundary_mod , only : glacier_boundary use dallaston2015_glacier_boundary_mod , only : dallaston2015_glacier_boundary use jacobian_block_mod , only : jacobian_block use boundary_types_mod use nitsol_mod use hdf5 use h5lt use logger_mod , only : logger => master_logger use penf , only : str implicit none private character ( len = 9 ), parameter , public :: hdf_type_name = 'ice_shelf' character ( len = 9 ), parameter , public :: hdf_thickness = 'thickness' character ( len = 8 ), parameter , public :: hdf_velocity = 'velocity' character ( len = 6 ), parameter , public :: hdf_lambda = 'lambda' character ( len = 4 ), parameter , public :: hdf_zeta = 'zeta' character ( len = 3 ), parameter , public :: hdf_chi = 'chi' character ( len = 10 ), parameter , public :: hdf_n_kappa = 'num_kappas' character ( len = 15 ), parameter , public :: hdf_kappa = '(\"kappa_\",i0.4)' type , extends ( glacier ), public :: ice_shelf !* Author: Chris MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[glacier]] type, using a vertically ! integrated model of an ice shelf. This model is 1-dimensional only. ! private type ( cheb1d_scalar_field ) :: thickness !! Thickness of ice shelf, h type ( cheb1d_vector_field ) :: velocity !! Flow velocity of ice shelf, \\vec{u} type ( cheb1d_scalar_field ) :: eta !! Viscosity of the ice, \\eta type ( cheb1d_scalar_field ), dimension (:), allocatable :: kappa !! Taylor coefficients for the vertical structure of a !! Lagrangian tracer representing englacial layers/internal !! reflectors. real ( r8 ) :: lambda !! The dimensionless ratio !! $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real ( r8 ) :: chi !! The dimensionless ratio \\chi \\equiv !! \\frac{\\rho_igh_0x_0}{2\\eta_0u_0} \\left(1 - !! \\frac{\\rho_i}{\\rho_o}\\right) real ( r8 ) :: zeta !! The dimensionless ratio \\zeta \\equiv !! \\frac{\\rho_iu_0x_0}{\\eta_0}, corresponding to the Reynolds !! number. Currently unused. real ( r8 ) :: courant !! The Courant number to use when calculating the time step. class ( abstract_viscosity ), allocatable :: viscosity_law !! An object representing the model used for ice viscosity. class ( glacier_boundary ), allocatable :: boundaries !! An object specifying the boundary conditions for the ice !! shelf. real ( r8 ) :: max_dt !! The maximu  allowable time step real ( r8 ) :: time !! The time at which the ice shelf is in this state. integer :: thickness_size !! The number of data values in the thickness field. integer :: velocity_size !! The number of data values in the velocity field. integer :: boundary_start !! The number of data values needed to represent the boundary !! conditions. integer :: thickness_lower_bound_size !! The number of data values needed to represent the lower !! boundary conditions for thickness. integer :: thickness_upper_bound_size !! The number of data values needed to represent the upper !! boundary conditions for thickness. integer :: velocity_lower_bound_size !! The number of data values needed to represent the lower !! boundary conditions for velocity. integer :: velocity_upper_bound_size !! The number of data values needed to represent the upper !! boundary conditions for thickness. type ( jacobian_block ) :: thickness_jacobian !! A representation of the Jacobian for the ice shelf thickness. type ( jacobian_block ) :: velocity_jacobian !! A representation of the Jacobian for the ice shelf velocity. logical :: stale_eta !! Indicates whether the viscosity needs updating. logical :: stale_jacobian !! Indicates if the Jacobians are stale and in need of updating. contains procedure :: initialise => shelf_initialise procedure :: ice_thickness => shelf_thickness !$    procedure :: ice_velocity => shelf_velocity procedure :: ice_density => shelf_density procedure :: ice_temperature => shelf_temperature procedure :: residual => shelf_residual procedure :: update => shelf_update procedure :: precondition => shelf_precondition procedure :: set_time => shelf_set_time procedure :: data_size => shelf_data_size procedure :: state_vector => shelf_state_vector procedure :: kappa_vector => shelf_kappa_vector procedure :: read_data => shelf_read_data procedure :: write_data => shelf_write_data procedure :: time_step => shelf_time_step procedure :: solve_velocity => shelf_solve_velocity !    procedure :: integrate => shelf_integrate procedure , private :: assign => shelf_assign procedure :: integrate_layers => ice_shelf_integrate_layers end type ice_shelf !  interface ice_shelf !    module procedure constructor !  end interface ice_shelf abstract interface pure function kappa_init_func ( n , location ) result ( kappa ) !* Author: Chris MacMackin !  Date: September 2018 ! ! Abstract interface for function providing the Taylor ! coefficients describing the distribution of internal ! reflectors within an ice shelf. ! import :: r8 integer , intent ( in ) :: n !! The index of the Taylor coefficient being calculated real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the coefficient real ( r8 ) :: kappa !! The value of coefficient `n` at `location` end function kappa_init_func end interface contains subroutine shelf_initialise ( this , domain , resolution , thickness , velocity , & temperature , viscosity_law , boundaries , lambda , & chi , zeta , courant , max_dt , kappa , n_kappa ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Initialises an [[ice_shelf]] object with initial conditions provided ! by the arguments. At present only a 1D model is supported. If ! information is provided for higher dimensions then it will be ignored. ! class ( ice_shelf ), intent ( out ) :: this real ( r8 ), dimension (:,:), intent ( in ) :: domain !! An array containing the upper and lower limits of the domain for !! the ice shelf. The first index represents the dimension for which !! the boundaries apply. If the second index is 1 then it corresponds !! to the lower bound. If the second index is 2 then it corresponds to !! the upper bound. integer , dimension (:), intent ( in ) :: resolution !! The number of data points in each dimension. procedure ( thickness_func ) :: thickness !! A function which calculates the initial value of the thickness of !! the ice shelf at a given location. procedure ( velocity_func ) :: velocity !! A function which calculates the initial value of the velocity !! (vector) of the ice at a given location in an ice shelf. real ( r8 ), intent ( in ), optional :: temperature !! The temperature of the ice in the ice shelf. class ( abstract_viscosity ), allocatable , optional , & intent ( inout ) :: viscosity_law !! An object which calculates the viscosity of the ice. If not !! specified, then Glen's law will be used with $n=3$. Will be !! unallocated on return. class ( glacier_boundary ), allocatable , optional , & intent ( inout ) :: boundaries !! An object specifying the boundary conditions for the ice !! shelf. Will be unallocated on return. real ( r8 ), intent ( in ), optional :: lambda !! The dimensionless ratio !! $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_ih_0u_0}$. real ( r8 ), intent ( in ), optional :: chi !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}\\left(1 - !! \\frac{\\rho_i}{\\rho_0}\\right)$. real ( r8 ), intent ( in ), optional :: zeta !! The dimensionless ratio $\\zeta \\equiv !! \\frac{\\rho_iu_0x_0}{\\eta_0}$, corresponding to the Reynolds !! number. Currently this is unused and always treated as 0. real ( r8 ), intent ( in ), optional :: courant !! The Courant number to use when calculating the time !! step. Defaults to 100. Too large a value will pose !! difficulties for the nonlinear solver, while too small a !! value can be numerically unstable. Typically, smaller values !! are needed for lower resolution. real ( r8 ), intent ( in ), optional :: max_dt !! The maximum allowable time step. This defaults to 1\\times !! 10&#94;{99} (effectively no maximum). procedure ( kappa_init_func ), optional :: kappa !! A function which specifies the initial values of the Taylor !! coefficients describing the vertical distribution of internal !! reflectors within the ice. The initial conditions at the !! grounding line will provide the boundary conditions there !! throughout the simulation. If this parameter is not provided !! then these layers will not be included in the !! integration. Both this parameter and `n_kappa` must be !! specified for the calculation to take place. integer , optional , intent ( in ) :: n_kappa !! The number of Taylor coefficients used to describe internal !! reflectors. If not provided then these reflectors will not be !! included in the integration. Both this parameter and `kappa` !! must be specified for the calculation to take place. integer :: n integer , dimension (:), allocatable :: lower , upper this % thickness = cheb1d_scalar_field ( resolution ( 1 ), thickness , domain ( 1 , 1 ), & domain ( 1 , 2 )) this % velocity = cheb1d_vector_field ( resolution ( 1 ), velocity , domain ( 1 , 1 ), & domain ( 1 , 2 )) this % eta = cheb1d_scalar_field ( resolution ( 1 ), lower_bound = domain ( 1 , 1 ), & upper_bound = domain ( 1 , 2 )) this % thickness_size = this % thickness % raw_size () this % velocity_size = this % velocity % raw_size () if ( present ( kappa ) . and . present ( n_kappa )) then allocate ( this % kappa ( n_kappa )) do n = 1 , n_kappa this % kappa ( n ) = cheb1d_scalar_field ( resolution ( 1 ), kappa_func , domain ( 1 , 1 ), & domain ( 1 , 2 )) end do end if if ( present ( temperature )) then continue ! This doesn't do anything at the moment else continue ! Again, doesn't do anything at the moment end if if ( present ( viscosity_law )) then call move_alloc ( viscosity_law , this % viscosity_law ) else allocate ( newtonian_viscosity :: this % viscosity_law ) end if if ( present ( boundaries )) then call move_alloc ( boundaries , this % boundaries ) else allocate ( dallaston2015_glacier_boundary :: this % boundaries ) end if if ( present ( lambda )) then this % lambda = lambda else this % lambda = 0.37_r8 end if if ( present ( chi )) then this % chi = chi else this % chi = 4.0_r8 end if if ( present ( zeta )) then this % zeta = zeta else this % zeta = 1.3e-11_r8 end if if ( present ( courant )) then this % courant = courant else this % courant = 1 e2_r8 end if if ( present ( max_dt )) then this % max_dt = max_dt else this % max_dt = 1 e99_r8 end if lower = this % boundaries % thickness_lower_bound () upper = this % boundaries % thickness_upper_bound () this % thickness_lower_bound_size = this % thickness_size & - this % thickness % raw_size ( lower ) this % thickness_upper_bound_size = this % thickness_size & - this % thickness % raw_size ( upper ) lower = this % boundaries % velocity_lower_bound () upper = this % boundaries % velocity_upper_bound () this % velocity_lower_bound_size = this % velocity_size & - this % velocity % raw_size ( lower ) this % velocity_upper_bound_size = this % velocity_size & - this % velocity % raw_size ( upper ) this % boundary_start = this % thickness_size + this % velocity_size + 1 & - this % thickness_lower_bound_size & - this % thickness_upper_bound_size & - this % velocity_lower_bound_size & - this % velocity_upper_bound_size this % time = 0.0_r8 this % stale_eta = . true . this % stale_jacobian = . true . #ifdef DEBUG call logger % debug ( 'ice_shelf' , 'Initialised new ice shelf object' ) #endif contains pure function kappa_func ( location ) result ( thickness ) !* Author: Chris MacMackin !  Date: April 2016 ! ! Wrapper around user-provided `kappa` routine, converting it to ! the form needed to initialise field-types. ! real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the thickness real ( r8 ) :: thickness !! The thickness of the glacier at `location` thickness = kappa ( n , location ) end function kappa_func end subroutine shelf_initialise function shelf_thickness ( this ) result ( thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the thickness of the ice shelf across its domain. ! class ( ice_shelf ), intent ( in ) :: this class ( scalar_field ), pointer :: thickness !! The ice thickness. call this % thickness % allocate_scalar_field ( thickness ) thickness = this % thickness #ifdef DEBUG call logger % debug ( 'ice_shelf%thickness' , 'Returned ice shelf thickness' ) #endif end function shelf_thickness function shelf_velocity ( this ) result ( velocity ) !* Author: Christopher MacMackin !  Date: July 2016 ! ! Returns the velocity of the ice shelf across its domain. ! class ( ice_shelf ), intent ( in ) :: this class ( vector_field ), pointer :: velocity !! The ice velocity. call this % velocity % allocate_vector_field ( velocity ) velocity = this % velocity #ifdef DEBUG call logger % debug ( 'ice_shelf%velocity' , 'Returned ice shelf velocity' ) #endif end function shelf_velocity pure function shelf_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the density of the ice in the shelf, which is assumed to be ! uniform across its domain. ! ! @NOTE Based on my approach to non-dimensionalisation, I'm pretty ! sure the density should always be 1, making this method ! unneccessary. ! class ( ice_shelf ), intent ( in ) :: this real ( r8 ) :: density !! The ice density. density = 1.0_r8 / 1.12_r8 !TODO: Will probably want to change this at some point #ifdef DEBUG call logger % debug ( 'ice_shelf%density' , 'Ice shelf has density ' // & trim ( str ( density )) // '.' ) #endif end function shelf_density pure function shelf_temperature ( this ) result ( temperature ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the density of the ice in the shelf, which is assumed to be ! uniform across its domain. ! class ( ice_shelf ), intent ( in ) :: this real ( r8 ) :: temperature !! The ice density. temperature = - 1 5.0_r8 !TODO: Will probably want to change this at some point. #ifdef DEBUG call logger % debug ( 'ice_shelf%temperature' , 'Ice shelf has temperature ' // & trim ( str ( temperature ))) #endif end function shelf_temperature function shelf_residual ( this , previous_states , melt_rate , & basal_drag_parameter , water_density ) result ( residual ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the residual when the current state of the glacier is run ! through the system of equations describing it. The residual takes the ! form of a 1D array, with each element respresenting the residual for ! one of the equations in the system. ! class ( ice_shelf ), intent ( in ) :: this class ( glacier ), dimension (:), intent ( in ) :: previous_states !! The states of the glacier in the previous time steps. The !! first element of the array should be the most recent. The !! default implementation will only make use of the most recent !! state, but the fact that this is an array allows potential !! other implementations to use older states for higher-order !! integration methods. class ( scalar_field ), intent ( in ) :: melt_rate !! Thickness of the ice above the glacier. class ( scalar_field ), intent ( in ) :: basal_drag_parameter !! A paramter, e.g. coefficient of friction, needed to calculate the !! drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier. real ( r8 ), dimension (:), allocatable :: residual !! The residual of the system of equations describing the glacier. type ( cheb1d_scalar_field ) :: scalar_tmp integer :: start , finish , bounds_start , bounds_finish integer , dimension (:), allocatable :: lower , upper real ( r8 ), dimension (:), allocatable :: bounds logical :: success call melt_rate % guard_temp (); call basal_drag_parameter % guard_temp () allocate ( residual ( this % data_size ())) start = 1 ! Use same or similar notation for variables as in equations select type ( previous_states ) class is ( ice_shelf ) associate ( h => this % thickness , h_old => previous_states ( 1 )% thickness , & uvec => this % velocity , m => melt_rate , eta => this % eta , & lambda => this % lambda , t_old => previous_states ( 1 )% time ) ! Boundary conditions if ( this % stale_eta ) then bounds = this % boundaries % boundary_residuals ( h , uvec , & this % viscosity_law % ice_viscosity ( uvec , this % ice_temperature (), & this % time ), this % time ) else bounds = this % boundaries % boundary_residuals ( h , uvec , eta , this % time ) end if ! Continuity equation scalar_tmp = ( h - h_old ) / ( this % time - t_old ) + . div .( h * uvec ) + lambda * m lower = this % boundaries % thickness_lower_bound () upper = this % boundaries % thickness_upper_bound () ! TODO: Figure out how to make this independent of order which ! values are stored in the field finish = start + this % thickness_upper_bound_size - 1 bounds_start = this % thickness_lower_bound_size + 1 bounds_finish = this % thickness_lower_bound_size & + this % thickness_upper_bound_size residual ( start : finish ) = bounds ( bounds_start : bounds_finish ) start = finish + 1 finish = start + scalar_tmp % raw_size ( lower , upper ) - 1 residual ( start : finish ) = scalar_tmp % raw ( lower , upper ) start = finish + 1 finish = start + this % thickness_lower_bound_size - 1 bounds_start = 1 bounds_finish = this % thickness_lower_bound_size residual ( start : finish ) = bounds ( bounds_start : bounds_finish ) start = finish + 1 end associate class default call logger % fatal ( 'ice_shelf%residual' , 'Type other than `ice_shelf` ' // & 'passed to `ice_shelf` object as a previous state.' ) error stop end select call melt_rate % clean_temp (); call basal_drag_parameter % clean_temp () #ifdef DEBUG call logger % debug ( 'ice_shelf%residual' , 'Calculated residual of ice shelf.' ) #endif end function shelf_residual subroutine shelf_update ( this , state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the ice shelf from its state vector. The state ! vector is a real array containing the value of each of the ice shelf's ! properties at each of the locations on the grid used in discretization. ! class ( ice_shelf ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! glacier. !TODO: Add some assertion-like checks that the state vector is the right size call this % thickness % set_from_raw ( state_vector ( 1 : this % thickness_size )) this % stale_jacobian = . true . #ifdef DEBUG call logger % debug ( 'ice_shelf%update' , 'Updated state of ice shelf.' ) #endif end subroutine shelf_update function shelf_precondition ( this , previous_states , melt_rate , & basal_drag_parameter , water_density , & delta_state ) result ( preconditioned ) !* Author: Chris MacMackin !  Date: January 2016 ! ! Provides a preconditioner for the nonlinear solver trying to ! bring the residual to zero. The Jacobian is approximated as a ! block matrix, where each block is a tridiagonal matrix using a ! finite difference method for differentiation. ! class ( ice_shelf ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: previous_states !! The states of the glacier in the previous time steps. The !! first element of the array should be the most recent. The !! default implementation will only make use of the most !! recent state, but the fact that this is an array allows !! overriding methods to use older states for higher-order !! integration methods. class ( scalar_field ), intent ( in ) :: melt_rate !! Thickness of the ice above the glacier class ( scalar_field ), intent ( in ) :: basal_drag_parameter !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier real ( r8 ), dimension (:), intent ( in ) :: delta_state !! The change to the state vector which is being preconditioned. real ( r8 ), dimension (:), allocatable :: preconditioned !! The result of applying the preconditioner to `delta_state`. type ( cheb1d_scalar_field ) :: delta_h integer :: i , sl , el , su , eu integer , dimension (:), allocatable :: boundary_locations real ( r8 ) :: delta_t call melt_rate % guard_temp (); call basal_drag_parameter % guard_temp () allocate ( preconditioned ( size ( delta_state ))) select type ( previous_states ) class is ( ice_shelf ) delta_t = this % time - previous_states ( 1 )% time class default call logger % fatal ( 'ice_shelf%precondition' , 'Type other than `ice_shelf` ' // & 'passed to `ice_shelf` object as a previous state.' ) error stop end select call delta_h % assign_meta_data ( this % thickness ) call delta_h % set_from_raw ( delta_state ) associate ( jac => this % thickness_jacobian , uvec => this % velocity ) if ( this % stale_jacobian ) then sl = this % thickness_size - this % thickness_lower_bound_size + 1 el = this % thickness_size su = 1 eu = this % thickness_upper_bound_size boundary_locations = [( i , i = sl , el ), ( i , i = su , eu )] jac = jacobian_block ( uvec % component ( 1 ), 1 , boundary_locs = boundary_locations ) & + 1._r8 / delta_t this % stale_jacobian = . false . end if delta_h = jac % solve_for ( delta_h ) end associate preconditioned = delta_h % raw () call melt_rate % clean_temp (); call basal_drag_parameter % clean_temp () #ifdef DEBUG call logger % debug ( 'ice_shelf%precondition' , 'Applied preconditioner for ice shelf.' ) #endif end function shelf_precondition subroutine shelf_set_time ( this , time ) !* Author: Christopher MacMackin !  Date: November 2016 ! ! Sets the time information held by the ice shelf object. This is ! the time at which the ice sheet is in its current state. ! class ( ice_shelf ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time !! The time at which the glacier is in the present state. this % time = time #ifdef DEBUG call logger % debug ( 'ice_shelf%set_time' , 'Updating time for ice shelf to ' // & trim ( str ( time ))) #endif end subroutine shelf_set_time pure function shelf_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the ice shelf's state vector. ! This is the size of the vector returned by [[ice_shelf:residual]] ! and [[ice_shelf:state_vector]] and taken as an argument by ! [[ice_shelf:update]]. ! class ( ice_shelf ), intent ( in ) :: this integer :: shelf_data_size !! The number of elements in the ice shelf's state vector. shelf_data_size = this % thickness_size #ifdef DEBUG call logger % debug ( 'ice_shelf%data_size' , 'Ice shelf has ' // & trim ( str ( shelf_data_size )) // ' elements ' // & 'in its state vector.' ) #endif end function shelf_data_size function shelf_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the ice shelf. ! This takes the form of a 1D array. ! class ( ice_shelf ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the ice shelf. state_vector = this % thickness % raw () #ifdef DEBUG call logger % debug ( 'ice_shelf%state_vector' , 'Returning state vector ' // & 'for ice shelf.' ) #endif end function shelf_state_vector function shelf_kappa_vector ( this ) result ( kappa_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the a vector representing the current state of the ! internal reflectors in the ice shelf.  This takes the form of a ! 1D array. The routien is only used for debugging purposes. ! class ( ice_shelf ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: kappa_vector !! The state vector describing the ice shelf. integer :: i if ( allocated ( this % kappa )) then allocate ( kappa_vector ( this % thickness_size * size ( this % kappa ))) do i = 1 , size ( this % kappa ) kappa_vector (( i - 1 ) * this % thickness_size + 1 : this % thickness_size * i ) = this % kappa ( i )% raw () end do end if #ifdef DEBUG call logger % debug ( 'ice_shelf%state_vector' , 'Returning state vector ' // & 'for ice shelf.' ) #endif end function shelf_kappa_vector subroutine shelf_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the ice shelf object from the specified group ! in an HDF5 file. This sets the thickness, the velocity, and ! parameter values. ! class ( ice_shelf ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err , i , nkap real ( r8 ), dimension ( 1 ) :: param integer , dimension ( 1 ) :: iparam character ( len = 20 ) :: fieldname character ( len = 50 ) :: ice_type ret_err = 0 call h5gopen_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % error ( 'ice_shelf%read_data' , 'Could not open HDF group \"' // & group_name // '\", so no IO performed.' ) return end if call h5ltget_attribute_string_f ( file_id , group_name , hdf_type_attr , & ice_type , error ) if ( trim ( ice_type ) /= hdf_type_name ) then call logger % error ( 'ice_shelf%read_data' , 'Trying to read data from ' // & 'glacier of type other than ice_shelf.' ) error = - 1 return end if call h5ltget_attribute_double_f ( file_id , group_name , hdf_lambda , & param , error ) this % lambda = param ( 1 ) call h5ltget_attribute_double_f ( file_id , group_name , hdf_chi , & param , error ) this % chi = param ( 1 ) call h5ltget_attribute_double_f ( file_id , group_name , hdf_zeta , & param , error ) this % zeta = param ( 1 ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading attributes from HDF group ' // & group_name ) ret_err = error end if call h5ltget_attribute_int_f ( file_id , group_name , hdf_n_kappa , & iparam , error ) if ( error /= 0 ) then ! For backwards compatibility, don't crash if this attribute is ! not present. Instead just realise there is no internal layer ! data in the HDF file. nkap = 0 else nkap = iparam ( 1 ) end if call this % thickness % read_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when reading ' // & 'ice shelf thickness field from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % read_hdf ( group_id , hdf_velocity , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading ice shelf velocity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if if ( nkap > 0 ) allocate ( this % kappa ( nkap )) do i = 1 , nkap write ( fieldname , hdf_kappa ) i call this % kappa ( i )% read_hdf ( group_id , fieldname , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when reading ' // & 'ice shelf kappa field from HDF file' ) if ( ret_err == 0 ) ret_err = error end if end do call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err #ifdef DEBUG call logger % debug ( 'ice_shelf%read_data' , 'Read ice shelf data from ' // & 'HDF group ' // group_name ) #endif end subroutine shelf_read_data subroutine shelf_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the ice shelf object to an HDF file in the ! specified group. This will consist of a thickness and a velocity ! dataset. ! class ( ice_shelf ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err , i , nkap character ( len = 20 ) :: fieldname ret_err = 0 call h5gcreate_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'creating HDF group \"' // group_name // '\"' ) call logger % error ( 'ice_shelf%write_data' , 'Data IO not performed for ' // & 'ice shelf' ) return end if if ( allocated ( this % kappa )) then nkap = size ( this % kappa ) else nkap = 0 end if call h5ltset_attribute_string_f ( file_id , group_name , hdf_type_attr , & hdf_type_name , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_lambda , & [ this % lambda ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_chi , & [ this % chi ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_zeta , & [ this % zeta ], 1_size_t , error ) call h5ltset_attribute_int_f ( file_id , group_name , hdf_n_kappa , & [ nkap ], 1_size_t , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing attribute to HDF group ' // & group_name ) ret_err = error end if call this % thickness % write_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when writing ' // & 'ice shelf thickness field to HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % write_hdf ( group_id , hdf_velocity , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing ice shelf velocity field ' // & 'to HDF file' ) if ( ret_err == 0 ) ret_err = error end if do i = 1 , nkap write ( fieldname , hdf_kappa ) i call this % kappa ( i )% write_hdf ( group_id , trim ( fieldname ), error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing ice shelf kappa field ' // & 'to HDF file' ) if ( ret_err == 0 ) ret_err = error end if end do call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err call logger % trivia ( 'ice_shelf%write_data' , 'Wrote ice shelf data to ' // & 'HDF group ' // group_name ) end subroutine shelf_write_data function shelf_time_step ( this ) result ( dt ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Calculates the time step for integrating the ice shelf, using ! the CFL condition. ! class ( ice_shelf ), intent ( in ) :: this class ( scalar_field ), pointer :: u , dx1 class ( vector_field ), pointer :: dx real ( r8 ) :: dt !! The time-step to use u => this % velocity % component ( 1 ) dx => this % velocity % grid_spacing () dx1 => dx % component ( 1 ) call dx1 % guard_temp () dt = min ( minval ( abs ( this % courant * dx1 / u )), this % max_dt ) call dx1 % clean_temp () call logger % trivia ( 'ice_shelf%time_step' , 'Calculated time step of ' // & trim ( str ( dt )) // ' using Courant number of ' // & trim ( str ( this % courant ))) end function shelf_time_step subroutine shelf_solve_velocity ( this , basal_drag , success ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Computes the ice shelf velocity at the current time with the ! current ice thickness. ! class ( ice_shelf ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: basal_drag !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. logical , intent ( out ) :: success !! True if the integration is successful, false otherwise integer , save :: nval , kdmax = 20 real ( r8 ), dimension (:), allocatable :: state integer , dimension ( 10 ) :: input integer , dimension ( 6 ) :: info real ( r8 ), dimension (:), allocatable , save :: work real ( r8 ), dimension ( 1 ) :: real_param integer , dimension ( 1 ) :: int_param integer :: flag call basal_drag % guard_temp () nval = this % velocity % raw_size () if ( allocated ( work )) then if ( size ( work ) < nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 )) then deallocate ( work ) allocate ( work ( nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 ))) end if else allocate ( work ( nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 ))) end if input = 0 input ( 4 ) = kdmax input ( 5 ) = 1 input ( 9 ) = - 1 input ( 10 ) = 3 state = this % velocity % raw () call nitsol ( nval , state , nitsol_residual , nitsol_precondition , & 1.e-10_r8 * nval , 1.e-10_r8 * nval , input , info , work , & real_param , int_param , flag , ddot , dnrm2 ) call this % velocity % set_from_raw ( state ) this % eta = this % viscosity_law % ice_viscosity ( this % velocity , this % ice_temperature (), & this % time ) this % stale_jacobian = . true . select case ( flag ) case ( 0 ) call logger % trivia ( 'ice_shelf%solve_velocity' , 'Found ice velocity at time ' // & trim ( str ( this % time ))) success = . true . case ( 1 ) call logger % error ( 'ice_shelf%solve_velocity' , 'Reached maximum number of' // & ' iterations finding ice velocity' ) success = . false . case default call logger % error ( 'ice_shelf%solve_velocity' , 'NITSOL failed when finding' // & ' ice velocity with error code ' // trim ( str ( flag ))) success = . false . end select call basal_drag % clean_temp () contains subroutine nitsol_residual ( n , xcur , fcur , rpar , ipar , itrmf ) !! A routine matching the interface expected by NITSOL which !! returns the residual for the glacier. integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( out ) :: fcur !! Array of length `n` containing f(xcur) on output real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array integer , intent ( out ) :: itrmf !! Termination flag. 0 means normal termination, 1 means !! failure to produce f(xcur) type ( cheb1d_scalar_field ) :: scalar_tmp integer :: start , finish , bounds_start , bounds_finish integer , dimension (:), allocatable :: lower , upper real ( r8 ), dimension (:), allocatable :: bounds call this % velocity % set_from_raw ( xcur ) this % stale_jacobian = . true . associate ( h => this % thickness , uvec => this % velocity , chi => this % chi , & zeta => this % zeta , eta => this % eta ) eta = this % viscosity_law % ice_viscosity ( uvec , this % ice_temperature (), & this % time ) bounds = this % boundaries % boundary_residuals ( h , uvec , eta , this % time ) scalar_tmp = uvec % component ( 1 ) scalar_tmp = 4.0_r8 * eta * h * scalar_tmp % d_dx ( 1 ) scalar_tmp = - 2.0_r8 * chi * h * h % d_dx ( 1 ) + scalar_tmp % d_dx ( 1 ) lower = this % boundaries % velocity_lower_bound () upper = this % boundaries % velocity_upper_bound () ! TODO: Figure out how to make this independent of order which ! values are stored in the field start = 1 finish = start + this % velocity_upper_bound_size - 1 bounds_start = this % thickness_lower_bound_size & + this % thickness_upper_bound_size & + this % velocity_lower_bound_size + 1 bounds_finish = bounds_start + this % velocity_upper_bound_size - 1 fcur ( start : finish ) = bounds ( bounds_start : bounds_finish ) start = finish + 1 finish = start + scalar_tmp % raw_size ( lower , upper ) - 1 fcur ( start : finish ) = scalar_tmp % raw ( lower , upper ) start = finish + 1 finish = start + this % velocity_lower_bound_size - 1 bounds_start = this % thickness_lower_bound_size & + this % thickness_upper_bound_size + 1 bounds_finish = bounds_start + this % velocity_lower_bound_size - 1 fcur ( start : finish ) = bounds ( bounds_start : bounds_finish ) end associate itrmf = 0 end subroutine nitsol_residual subroutine nitsol_precondition ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! A subroutine matching the interface expected by NITSOL, which !! acts as a preconditioner. integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of lenght `n` containing the current $x$ value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of lenght `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flat indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce $J\\vec{v}$, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} type ( cheb1d_scalar_field ) :: delta_u , tmp integer :: i , sl , el , su , eu integer , dimension ( 2 ) :: upper_type , lower_type integer , dimension (:), allocatable :: boundary_types , boundary_locations real ( r8 ) :: eta_val if ( ijob /= 1 ) then itrmjv = 0 return end if call delta_u % assign_meta_data ( this % velocity ) call delta_u % set_from_raw ( v ) sl = this % velocity_size - this % velocity_lower_bound_size + 1 el = this % velocity_size su = 1 eu = this % velocity_upper_bound_size boundary_locations = [( i , i = sl , el ), ( i , i = su , eu )] upper_type = this % boundaries % velocity_upper_type () lower_type = this % boundaries % velocity_lower_type () boundary_types = [( lower_type ( 1 ), i = sl , el ), ( upper_type ( 1 ), i = su , eu )] associate ( h => this % thickness , chi => this % chi , zeta => this % zeta , & jac => this % velocity_jacobian , eta => this % eta ) if ( this % stale_jacobian ) then ! Mathematically, it should be 4._r8*eta*h which I pass, but ! this sometimes results in an ill-conditioned Jacobian (for ! reasons I'm not clear on). If eta ~ 1 then turns out I get ! good results just ignoring it. select type ( visc => this % viscosity_law ) class is ( newtonian_viscosity ) eta_val = eta % get_element ( 1 ) if ( eta_val <= 0._r8 ) eta_val = 1._r8 jac = jacobian_block ( 4._r8 * eta * h , 1 , 1 , boundary_locs = boundary_locations , & boundary_types = boundary_types ) class default jac = jacobian_block ( 4._r8 * h , 1 , 1 , boundary_locs = boundary_locations , & boundary_types = boundary_types ) end select this % stale_jacobian = . false . end if delta_u = jac % solve_for ( delta_u ) z ( 1 : n ) = delta_u % raw () end associate itrmjv = 0 end subroutine nitsol_precondition end subroutine shelf_solve_velocity subroutine shelf_integrate ( this , old_states , basal_melt , basal_drag , & water_density , time , success ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Integrates the glacier's state forward to `time`. This is done ! using an explicit method for the thickness and a Newton's solver ! for velocity. ! class ( ice_shelf ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: old_states !! Previous states of the glacier, with the most recent one !! first. class ( scalar_field ), intent ( in ) :: basal_melt !! The melt rate that the bottom of the glacier experiences !! during this time step. class ( scalar_field ), intent ( in ) :: basal_drag !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier. real ( r8 ), intent ( in ) :: time !! The time to which the glacier should be integrated logical , intent ( out ) :: success !! True if the integration is successful, false otherwise associate ( h => this % thickness , uvec => this % velocity , m => basal_melt , & lambda => this % lambda , chi => this % chi , zeta => this % zeta , & t_old => this % time ) this % thickness = this % thickness - ( time - t_old ) * ( lambda * m + . div .( h * uvec )) end associate end subroutine shelf_integrate subroutine shelf_assign ( this , rhs ) !* Author: Chris MacMackin !  Date: February 2017 ! ! Copies the data from one ice shelf into another. This is only ! needed due to a bug in gfortran which means that the intrinsic ! assignment for glacier types is not using the appropriate ! defined assignment for the field components. ! ! It does not assign the Jacobian object as it would take up quite ! a bit of extra space and it is unlikely that it would ever be ! needed without first having to be recalculated. ! class ( ice_shelf ), intent ( out ) :: this class ( glacier ), intent ( in ) :: rhs !! The ice shelf to be assigned to this one. select type ( rhs ) class is ( ice_shelf ) this % thickness = rhs % thickness this % velocity = rhs % velocity this % eta = rhs % eta this % lambda = rhs % lambda this % chi = rhs % chi this % zeta = rhs % zeta this % courant = rhs % courant this % max_dt = rhs % max_dt allocate ( this % viscosity_law , source = rhs % viscosity_law ) allocate ( this % boundaries , source = rhs % boundaries ) this % time = rhs % time this % thickness_size = rhs % thickness_size this % velocity_size = rhs % velocity_size this % boundary_start = rhs % boundary_start this % thickness_lower_bound_size = rhs % thickness_lower_bound_size this % thickness_upper_bound_size = rhs % thickness_upper_bound_size this % velocity_lower_bound_size = rhs % velocity_lower_bound_size this % velocity_upper_bound_size = rhs % velocity_upper_bound_size this % stale_jacobian = . true . this % stale_eta = . true . if ( allocated ( rhs % kappa )) then allocate ( this % kappa ( size ( rhs % kappa ))) this % kappa = rhs % kappa end if class default call logger % fatal ( 'ice_shelf%assign' , 'Type other than `ice_shelf` ' // & 'requested to be assigned.' ) error stop end select #ifdef DEBUG call logger % debug ( 'ice_shelf%assign' , 'Copied ice shelf data.' ) #endif end subroutine shelf_assign subroutine ice_shelf_integrate_layers ( this , old_states , time , success ) !* Author: Chris MacMackin !  Date: September 2018 ! ! Integrate the Taylor coefficients representing the vertical ! structure of internal reflectors forward to the specified ! time. This is done using an implicit method, with the resulting ! linear system solved using GMRES. ! class ( ice_shelf ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: old_states !! Previous states of the ice_shelf, with the most recent one !! first. real ( r8 ), intent ( in ) :: time !! The time to which the ice_shelf should be integrated logical , intent ( out ) :: success !! True if the integration is successful, false otherwise integer :: n , flag real ( r8 ), dimension (:), allocatable :: solution real ( r8 ) :: dt , resid type ( jacobian_block ) :: precond_block if (. not . allocated ( this % kappa )) return select type ( old_states ) class is ( ice_shelf ) dt = time - old_states ( 1 )% time do n = 1 , size ( this % kappa ) solution = this % kappa ( n )% raw () precond_block = jacobian_block ( dt * this % velocity % component ( 1 ), 1 , & boundary_locs = [ this % thickness_size ], & boundary_types = [ dirichlet ], & coef = real ( - n , r8 )) + 1._r8 call gmres_solve ( solution , operator , old_states ( 1 )% kappa ( n )% raw (), resid , & flag , precond = preconditioner , krylov_dim = 40 ) call this % kappa ( n )% set_from_raw ( solution ) if ( flag /= 0 ) then call logger % error ( 'ice_shelf%integrate_layers' , 'GMRES solver ' // & 'returned with error code ' // str ( flag )) success = . false . return end if call this % kappa ( n )% set_from_raw ( solution ) end do class default call logger % fatal ( 'ice_shelf%integrate_layers' , 'Type other than `ice_shelf` ' // & 'passed to `ice_shelf` object as a previous state.' ) error stop end select contains function operator ( v , xcur , rhs , rpar , ipar , success ) real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be multiplied real ( r8 ), dimension (:), intent ( in ) :: xcur !! Array containing the current estimate of the independent !! variables in the linear system. This may not be needed, but !! is provided just in case. real ( r8 ), dimension (:), intent ( in ) :: rhs !! Array containing the right hand side of the linear !! system. This may not be needed, but is provided just in !! case. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array logical , intent ( out ) :: success !! Indicates whether operation was completed succesfully real ( r8 ), dimension ( size ( xcur )) :: operator !! Result of the operation type ( cheb1d_scalar_field ) :: kappa class ( scalar_field ), pointer :: tmp call kappa % assign_meta_data ( this % kappa ( n )) call kappa % set_from_raw ( v ) tmp => dt * this % velocity . dot . (. grad . kappa ) kappa = ( 1._r8 - n * dt * (. div . this % velocity )) * kappa + tmp operator = kappa % raw () operator ( this % thickness_size ) = v ( this % thickness_size ) success = . true . end function operator function preconditioner ( v , xcur , rhs , rpar , ipar , success ) real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be multiplied real ( r8 ), dimension (:), intent ( in ) :: xcur !! Array containing the current estimate of the independent !! variables in the linear system. This may not be needed, but !! is provided just in case. real ( r8 ), dimension (:), intent ( in ) :: rhs !! Array containing the right hand side of the linear !! system. This may not be needed, but is provided just in !! case. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array logical , intent ( out ) :: success !! Indicates whether operation was completed succesfully real ( r8 ), dimension ( size ( xcur )) :: preconditioner !! Result of the operation type ( cheb1d_scalar_field ) :: tmp call tmp % assign_meta_data ( this % kappa ( n )) call tmp % set_from_raw ( v ) tmp = precond_block % solve_for ( tmp ) preconditioner = tmp % raw () success = . true . end function preconditioner end subroutine ice_shelf_integrate_layers end module ice_shelf_mod"},{"title":"specfun.f90 – ISOFT","tags":"","loc":"sourcefile/specfun.f90.html","text":"Contents Modules specfun_mod Source Code specfun.f90 Source Code module specfun_mod !! Author: William Cody and Laura Stoltz !! !! SPECFUN is a FORTRAN90 library which evaluates certain special !! functions, by William Cody and Laura Stoltz. !! !! In particular, SPECFUN can evaluate the I, J, K and Y Bessel !! functions, of orders 0, 1, or arbitrary positive integer order N, !! or for any positive non-integer order (an unusual feature). !! !! Routines are also available for the Gamma function, the logarithm !! of the Gamma function, the exponential integrals, the error !! function, the Psi function, and Dawson's integral. !! !! The original, true, correct (FORTRAN77) version of SPECFUN is !! available through NETLIB: !! http://www.netlib.org/specfun/index.html\". !! !! @NOTE The routines used to calculate the real exponential integral !! have been slightly modified so that they have the `elemental` !! attribute. To do this, I needed to enclose them in a module. I was !! having some issues compiling the module (the compiler didn't seem !! to see the `r8_gamma` function and thus didn't correctly apply !! name-mangling). To avoid these, I just deleted everything that I !! didn't need. contains elemental subroutine calcei ( arg , result , jint ) !*****************************************************************************80 ! !! CALCEI computes various exponential integrals. ! !  Discussion: ! !    This routine computes the exponential integrals Ei(x), !    E1(x), and  exp(-x)*Ei(x) for real arguments x where ! !           integral (from t=-oo to t=x) (exp(t)/t),  x > 0, !    Ei(x) = !          -integral (from t=-x to t=+oo) (exp(t)/t),  x < 0, ! !    and where the first integral is a principal value integral. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    03 April 2007 ! !  Author: ! !    Original FORTRAN77 version by William Cody. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    William Cody, Henry Thacher, !    Rational Chebyshev Approximations for the Exponential !    Integral E1(x), !    Mathematics of Computation, !    Volume 22, Number 103, July 1968, pages 641-649. ! !    William Cody, Henry Thacher, !    Chebyshev Approximations for the Exponential !    Integral Ei(x), !    Mathematics of Computation, !    Volume 23, Number 106, April 1969, pages 289-303. ! !  Parameters: ! !    Input, real ( kind = 8 ) ARG, the argument.  The argument must not !    be zero.  If JINT = 2, then the argument must be strictly positive. ! !    Output, real ( kind = 8 ) RESULT, the value of the function, !    which depends on the input value of JINT: !    1, RESULT = EI ( ARG ); !    2, RESULT = EONE ( ARG ); !    3, RESULT = EXPEI ( ARG ). ! !    Input, integer ( kind = 4 ) JINT, chooses the function to be computed. !    1, Ei(x); !    2, -Ei(-x); !    3, exp(-x)*Ei(x). ! implicit none real ( kind = 8 ), intent ( in ) :: arg real ( kind = 8 ) ei real ( kind = 8 ) frac integer ( kind = 4 ) i integer ( kind = 4 ), intent ( in ) :: jint real ( kind = 8 ) px ( 10 ) real ( kind = 8 ) qx ( 10 ) real ( kind = 8 ), intent ( out ) :: result real ( kind = 8 ) sump real ( kind = 8 ) sumq real ( kind = 8 ) t real ( kind = 8 ) w real ( kind = 8 ) x real ( kind = 8 ) xmx0 real ( kind = 8 ) y real ( kind = 8 ) ysq ! !  Mathematical constants !  EXP40 = exp(40) !  X0 = zero of Ei !  X01/X11 + X02 = zero of Ei to extra precision ! real ( kind = 8 ), parameter :: p037 = 0.037D+00 real ( kind = 8 ), parameter :: three = 3.0D+00 real ( kind = 8 ), parameter :: six = 6.0D+00 real ( kind = 8 ), parameter :: two4 = 2 4.0D+00 real ( kind = 8 ), parameter :: fourty = 4 0.0D+00 real ( kind = 8 ), parameter :: exp40 = 2.3538526683701998541D+17 real ( kind = 8 ), parameter :: x01 = 38 1.5D+00 real ( kind = 8 ), parameter :: x11 = 102 4.0D+00 real ( kind = 8 ), parameter :: x02 = - 5.1182968633365538008D-05 real ( kind = 8 ), parameter :: x0 = 3.7250741078136663466D-01 ! !  Machine-dependent constants ! real ( kind = 8 ), parameter :: xinf = 1.79d+308 real ( kind = 8 ), parameter :: xmax = 71 6.351d0 real ( kind = 8 ), parameter :: xbig = 70 1.84d0 ! !  Coefficients  for -1.0 <= X < 0.0 ! real ( kind = 8 ), dimension ( 7 ), parameter :: a = & [ 1.1669552669734461083368d2 , 2.1500672908092918123209d3 , & 1.5924175980637303639884d4 , 8.9904972007457256553251d4 , & 1.5026059476436982420737d5 , - 1.4815102102575750838086d5 , & 5.0196785185439843791020d0 ] real ( kind = 8 ), dimension ( 6 ), parameter :: b = & [ 4.0205465640027706061433d1 , 7.5043163907103936624165d2 , & 8.1258035174768735759855d3 , 5.2440529172056355429883d4 , & 1.8434070063353677359298d5 , 2.5666493484897117319268d5 ] ! !  Coefficients for -4.0 <= X < -1.0 ! real ( kind = 8 ), dimension ( 9 ), parameter :: c = & [ 3.828573121022477169108d-1 , 1.107326627786831743809d+1 , & 7.246689782858597021199d+1 , 1.700632978311516129328d+2 , & 1.698106763764238382705d+2 , 7.633628843705946890896d+1 , & 1.487967702840464066613d+1 , 9.999989642347613068437d-1 , & 1.737331760720576030932d-8 ] real ( kind = 8 ), dimension ( 9 ), parameter :: d = & [ 8.258160008564488034698d-2 , 4.344836335509282083360d+0 , & 4.662179610356861756812d+1 , 1.775728186717289799677d+2 , & 2.953136335677908517423d+2 , 2.342573504717625153053d+2 , & 9.021658450529372642314d+1 , 1.587964570758947927903d+1 , & 1.000000000000000000000d+0 ] ! !  Coefficients for X < -4.0 ! real ( kind = 8 ), dimension ( 10 ), parameter :: e = & [ 1.3276881505637444622987d+2 , 3.5846198743996904308695d+4 , & 1.7283375773777593926828d+5 , 2.6181454937205639647381d+5 , & 1.7503273087497081314708d+5 , 5.9346841538837119172356d+4 , & 1.0816852399095915622498d+4 , 1.0611777263550331766871d03 , & 5.2199632588522572481039d+1 , 9.9999999999999999087819d-1 ] real ( kind = 8 ), dimension ( 10 ), parameter :: f = & [ 3.9147856245556345627078d+4 , 2.5989762083608489777411d+5 , & 5.5903756210022864003380d+5 , 5.4616842050691155735758d+5 , & 2.7858134710520842139357d+5 , 7.9231787945279043698718d+4 , & 1.2842808586627297365998d+4 , 1.1635769915320848035459d+3 , & 5.4199632588522559414924d+1 , 1.0d0 ] ! !  Coefficients for rational approximation to ln(x/a), |1-x/a| < .1 ! real ( kind = 8 ), dimension ( 4 ), parameter :: plg = & [ - 2.4562334077563243311d+01 , 2.3642701335621505212d+02 , & - 5.4989956895857911039d+02 , 3.5687548468071500413d+02 ] real ( kind = 8 ), dimension ( 4 ), parameter :: qlg = & [ - 3.5553900764052419184d+01 , 1.9400230218539473193d+02 , & - 3.3442903192607538956d+02 , 1.7843774234035750207d+02 ] ! !  Coefficients for  0.0 < X < 6.0, !  ratio of Chebyshev polynomials ! real ( kind = 8 ), dimension ( 10 ), parameter :: p = & [ - 1.2963702602474830028590d01 , - 1.2831220659262000678155d03 , & - 1.4287072500197005777376d04 , - 1.4299841572091610380064d06 , & - 3.1398660864247265862050d05 , - 3.5377809694431133484800d08 , & 3.1984354235237738511048d08 , - 2.5301823984599019348858d10 , & 1.2177698136199594677580d10 , - 2.0829040666802497120940d11 ] real ( kind = 8 ), dimension ( 10 ), parameter :: q = & [ 7.6886718750000000000000d01 , - 5.5648470543369082846819d03 , & 1.9418469440759880361415d05 , - 4.2648434812177161405483d06 , & 6.4698830956576428587653d07 , - 7.0108568774215954065376d08 , & 5.4229617984472955011862d09 , - 2.8986272696554495342658d10 , & 9.8900934262481749439886d10 , - 8.9673749185755048616855d10 ] ! !  J-fraction coefficients for 6.0 <= X < 12.0 ! real ( kind = 8 ), dimension ( 10 ), parameter :: r = & [ - 2.645677793077147237806d00 , - 2.378372882815725244124d00 , & - 2.421106956980653511550d01 , 1.052976392459015155422d01 , & 1.945603779539281810439d01 , - 3.015761863840593359165d01 , & 1.120011024227297451523d01 , - 3.988850730390541057912d00 , & 9.565134591978630774217d00 , 9.981193787537396413219d-1 ] real ( kind = 8 ), dimension ( 9 ), parameter :: s = & [ 1.598517957704779356479d-4 , 4.644185932583286942650d00 , & 3.697412299772985940785d02 , - 8.791401054875438925029d00 , & 7.608194509086645763123d02 , 2.852397548119248700147d01 , & 4.731097187816050252967d02 , - 2.369210235636181001661d02 , & 1.249884822712447891440d00 ] ! !  J-fraction coefficients for 12.0 <= X < 24.0 ! real ( kind = 8 ), dimension ( 10 ), parameter :: p1 = & [ - 1.647721172463463140042d00 , - 1.860092121726437582253d01 , & - 1.000641913989284829961d01 , - 2.105740799548040450394d01 , & - 9.134835699998742552432d-1 , - 3.323612579343962284333d01 , & 2.495487730402059440626d01 , 2.652575818452799819855d01 , & - 1.845086232391278674524d00 , 9.999933106160568739091d-1 ] real ( kind = 8 ), dimension ( 9 ), parameter :: q1 = & [ 9.792403599217290296840d01 , 6.403800405352415551324d01 , & 5.994932325667407355255d01 , 2.538819315630708031713d02 , & 4.429413178337928401161d01 , 1.192832423968601006985d03 , & 1.991004470817742470726d02 , - 1.093556195391091143924d01 , & 1.001533852045342697818d00 ] ! !  J-fraction coefficients for  24 <= X. ! real ( kind = 8 ), dimension ( 10 ), parameter :: p2 = & [ 1.75338801265465972390d02 , - 2.23127670777632409550d02 , & - 1.81949664929868906455d01 , - 2.79798528624305389340d01 , & - 7.63147701620253630855d00 , - 1.52856623636929636839d01 , & - 7.06810977895029358836d00 , - 5.00006640413131002475d00 , & - 3.00000000320981265753d00 , 1.00000000000000485503d00 ] real ( kind = 8 ), dimension ( 9 ), parameter :: q2 = & [ 3.97845977167414720840d04 , 3.97277109100414518365d00 , & 1.37790390235747998793d02 , 1.17179220502086455287d02 , & 7.04831847180424675988d01 , - 1.20187763547154743238d01 , & - 7.99243595776339741065d00 , - 2.99999894040324959612d00 , & 1.99999999999048104167d00 ] x = arg if ( x == 0.0D+00 ) then ei = - xinf if ( jint == 2 ) then ei = - ei end if ! !  Calculate EI for negative argument or for E1. ! else if ( x < 0.0D+00 . or . jint == 2 ) then y = abs ( x ) if ( y <= 1.0D+00 ) then sump = a ( 7 ) * y + a ( 1 ) sumq = y + b ( 1 ) do i = 2 , 6 sump = sump * y + a ( i ) sumq = sumq * y + b ( i ) end do ei = log ( y ) - sump / sumq if ( jint == 3 ) then ei = ei * exp ( y ) end if else if ( y <= 4.0D+00 ) then w = 1.0D+00 / y sump = c ( 1 ) sumq = d ( 1 ) do i = 2 , 9 sump = sump * w + c ( i ) sumq = sumq * w + d ( i ) end do ei = - sump / sumq if ( jint /= 3 ) then ei = ei * exp ( - y ) end if else if ( xbig < y . and . jint < 3 ) then ei = 0.0D+00 else w = 1.0D+00 / y sump = e ( 1 ) sumq = f ( 1 ) do i = 2 , 10 sump = sump * w + e ( i ) sumq = sumq * w + f ( i ) end do ei = - w * ( 1.0D+00 - w * sump / sumq ) if ( jint /= 3 ) then ei = ei * exp ( - y ) end if end if end if if ( jint == 2 ) then ei = - ei end if ! !  To improve conditioning, rational approximations are expressed !  in terms of Chebyshev polynomials for 0 <= X < 6, and in !  continued fraction form for larger X. ! else if ( x < six ) then t = x + x t = t / three - 2.0D+00 px ( 1 ) = 0.0D+00 qx ( 1 ) = 0.0D+00 px ( 2 ) = p ( 1 ) qx ( 2 ) = q ( 1 ) do i = 2 , 9 px ( i + 1 ) = t * px ( i ) - px ( i - 1 ) + p ( i ) qx ( i + 1 ) = t * qx ( i ) - qx ( i - 1 ) + q ( i ) end do sump = 0.5D+00 * t * px ( 10 ) - px ( 9 ) + p ( 10 ) sumq = 0.5D+00 * t * qx ( 10 ) - qx ( 9 ) + q ( 10 ) frac = sump / sumq xmx0 = ( x - x01 / x11 ) - x02 if ( p037 <= abs ( xmx0 ) ) then ei = log ( x / x0 ) + xmx0 * frac if ( jint == 3 ) then ei = exp ( - x ) * ei end if ! !  Special approximation to ln(X/X0) for X close to X0. ! else y = xmx0 / ( x + x0 ) ysq = y * y sump = plg ( 1 ) sumq = ysq + qlg ( 1 ) do i = 2 , 4 sump = sump * ysq + plg ( i ) sumq = sumq * ysq + qlg ( i ) end do ei = ( sump / ( sumq * ( x + x0 ) ) + frac ) * xmx0 if ( jint == 3 ) then ei = exp ( - x ) * ei end if end if else if ( x < 1 2.0D+00 ) then frac = 0.0D+00 do i = 1 , 9 frac = s ( i ) / ( r ( i ) + x + frac ) end do ei = ( r ( 10 ) + frac ) / x if ( jint /= 3 ) then ei = ei * exp ( x ) end if else if ( x <= two4 ) then frac = 0.0D+00 do i = 1 , 9 frac = q1 ( i ) / ( p1 ( i ) + x + frac ) end do ei = ( p1 ( 10 ) + frac ) / x if ( jint /= 3 ) then ei = ei * exp ( x ) end if else if ( xmax <= x . and . jint < 3 ) then ei = xinf else y = 1.0D+00 / x frac = 0.0D+00 do i = 1 , 9 frac = q2 ( i ) / ( p2 ( i ) + x + frac ) end do frac = p2 ( 10 ) + frac ei = y + y * y * frac if ( jint /= 3 ) then if ( x <= xmax - two4 ) then ei = ei * exp ( x ) ! !  Calculation reformulated to avoid premature overflow. ! else ei = ( ei * exp ( x - fourty ) ) * exp40 end if end if end if end if result = ei return end elemental function ei ( x ) !*****************************************************************************80 ! !! EI evaluates the exponential integral Ei(X). ! !  Discussion: ! !    This routine computes approximate values for the !    exponential integral Ei(x), where x is real. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    03 April 2007 ! !  Author: ! !    Original FORTRAN77 version by William Cody. !    FORTRAN90 version by John Burkardt. ! !  Parameters: ! !    Input, real ( kind = 8 ) X, the argument of the function. ! !    Output, real ( kind = 8 ) EI, the value of the function. ! implicit none real ( kind = 8 ) ei integer ( kind = 4 ) jint real ( kind = 8 ) result real ( kind = 8 ), intent ( in ) :: x jint = 1 call calcei ( x , result , jint ) ei = result return end end module specfun_mod"},{"title":"uniform_gradient_field.f90 – ISOFT","tags":"","loc":"sourcefile/uniform_gradient_field.f90.html","text":"Files dependent on this one sourcefile~~uniform_gradient_field.f90~~AfferentGraph sourcefile~uniform_gradient_field.f90 uniform_gradient_field.f90 sourcefile~upstream_plume.f90 upstream_plume.F90 sourcefile~upstream_plume.f90->sourcefile~uniform_gradient_field.f90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~upstream_plume.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~upstream_plume.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~upstream_plume.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules uniform_gradient_field_mod Source Code uniform_gradient_field.f90 Source Code ! !  uniform_gradient_field.f90 !  This file is part of ISOFT. ! !  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module uniform_gradient_field_mod !* Author: Chris MacMackin !  Date: July 2017 !  License: GPLv3 ! ! Provides an extension of the uniform field type which also appears ! to have a uniform gradient. This was written to allow some of the ! same code used when solving the plume in a Runge-Kutta solver, ! where I pass in uniform fields rather than ones using a Chebyshev ! grid. ! use iso_fortran_env , only : r8 => real64 use utils_mod , only : is_nan use factual_mod , only : scalar_field , vector_field , uniform_scalar_field , & uniform_vector_field , get_tol implicit none private type , extends ( uniform_scalar_field ), public :: uniform_gradient_field !* Author: Chris MacMackin !  Date: July 2017 ! ! A type of uniform field which also has a uniform gradient. Of ! course, this is impossible in practice, but it can be useful for ! tricking certain routines into working properly. Ideally a whole ! new derived type would be created which just holds the value and ! gradient at a single point, but the emphasis is on getting ! something quickly. Note that the gradient is not propagated ! across operations--the result of all overloaded operators is ! just a normal uniform field with no gradient. ! real ( r8 ), dimension (:), allocatable :: grad !! The values of the gradient in each direction. contains private procedure , public :: d_dx => uniform_gradient_d_dx !! \\frac{\\partial&#94;n}{\\partial x_i&#94;n}({\\rm field}) procedure :: gradient => uniform_gradient_gradient !! \\nabla {\\rm field} procedure :: is_equal => uniform_gradient_is_equal !! Checks fields are equal within a tolerance procedure :: assign_field => uniform_gradient_assign !! {\\rm field} = {\\rm field} end type uniform_gradient_field interface uniform_gradient_field module procedure constructor end interface uniform_gradient_field contains function constructor ( val , grad ) result ( this ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Creates a new scalar field with a uniform value across all of ! space but a non-zero gradient. ! real ( r8 ), intent ( in ) :: val !! The value of the field real ( r8 ), dimension (:), intent ( in ) :: grad !! An array in which the `i`th element contains the gradient in !! the _i_th direction. Directions corresponding to values of !! `i` greater than the size of the array are taken to have a !! gradient of zero. type ( uniform_gradient_field ) :: this !! A scalar field initated based on teh arguments of this !! function. this % uniform_scalar_field = uniform_scalar_field ( val ) this % grad = grad end function constructor function uniform_gradient_d_dx ( this , dir , order ) result ( res ) !* Author: Chris MacMackin !  Date: July 2017 ! ! \\frac{\\partial&#94;{\\rm order}}{\\partial x_{\\rm dir}&#94;{\\rm order}}{\\rm field} ! class ( uniform_gradient_field ), intent ( in ) :: this integer , intent ( in ) :: dir !! Direction in which to differentiate integer , optional , intent ( in ) :: order !! Order of the derivative, default = 1 class ( scalar_field ), pointer :: res integer :: ord call this % guard_temp () call this % allocate_scalar_field ( res ) if ( present ( order )) then ord = order else ord = 1 end if select type ( res ) class is ( uniform_scalar_field ) if ( ord == 1 ) then if ( dir > 0 . and . dir <= size ( this % grad )) then res = uniform_scalar_field ( this % grad ( dir )) else res = uniform_scalar_field ( 0.0_r8 ) end if else res = uniform_scalar_field ( 0.0_r8 ) end if class default error stop ( 'Non-uniform_gradient_field type allocated by ' // & '`allocate_scalar_field` routine.' ) end select call res % set_temp () ! Shouldn't need to call this, but for some ! rason being set as non-temporary when ! assignment subroutine returns. call this % clean_temp () end function uniform_gradient_d_dx function uniform_gradient_gradient ( this ) result ( res ) !* Author: Chris MacMackin !  Date: July 2017 ! ! \\nabla{\\rm field} ! class ( uniform_gradient_field ), intent ( in ) :: this class ( vector_field ), pointer :: res !! The result of this operation call this % guard_temp () call this % allocate_vector_field ( res ) select type ( res ) class is ( uniform_vector_field ) res = uniform_vector_field ( this % grad ) class default error stop ( 'Non-uniform_vector_field type allocated by ' // & '`allocate_vector_field` routine.' ) end select call this % clean_temp () end function uniform_gradient_gradient impure elemental subroutine uniform_gradient_assign ( this , rhs ) !* Author: Chris MacMackin !  Date: July 2017 ! ! {\\rm field} = {\\rm field} ! class ( uniform_gradient_field ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: rhs call rhs % guard_temp () select type ( rhs ) class is ( uniform_gradient_field ) this % uniform_scalar_field = rhs % uniform_scalar_field if ( allocated ( rhs % grad )) then this % grad = rhs % grad else if ( allocated ( this % grad )) then deallocate ( this % grad ) end if call this % unset_temp () class is ( uniform_scalar_field ) this % uniform_scalar_field = rhs if ( allocated ( this % grad )) deallocate ( this % grad ) call this % unset_temp () class default error stop ( 'Assigning incompatible type to uniform_gradient_field' ) end select call rhs % clean_temp () end subroutine uniform_gradient_assign logical function uniform_gradient_is_equal ( this , rhs ) result ( iseq ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Evaluates whether two scalar fields are equal within a tolerance, ! specified by `set_tol`. ! class ( uniform_gradient_field ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: rhs real ( r8 ) :: normalization integer :: i call this % guard_temp (); call rhs % guard_temp () iseq = . true . select type ( rhs ) class is ( uniform_gradient_field ) iseq = ( this % uniform_scalar_field == rhs % uniform_scalar_field ) do i = 1 , size ( this % grad ) if (. not . iseq ) return normalization = abs ( this % grad ( i )) if ( normalization < get_tol ()) normalization = 1.0_r8 iseq = iseq . and .( (( this % grad ( i ) - rhs % grad ( i )) / normalization < & get_tol ()) . or . ( is_nan ( this % grad ( i )). and . & is_nan ( rhs % grad ( i ))) ) end do class default iseq = ( rhs == this ) end select call this % clean_temp (); call rhs % clean_temp () end function uniform_gradient_is_equal end module uniform_gradient_field_mod"},{"title":"viscosity.F90 – ISOFT","tags":"","loc":"sourcefile/viscosity.f90.html","text":"Files dependent on this one sourcefile~~viscosity.f90~~AfferentGraph sourcefile~viscosity.f90 viscosity.F90 sourcefile~glens_law.f90 glens_law.F90 sourcefile~glens_law.f90->sourcefile~viscosity.f90 sourcefile~ice_shelf.f90 ice_shelf.F90 sourcefile~ice_shelf.f90->sourcefile~viscosity.f90 sourcefile~newtonian_viscosity.f90 newtonian_viscosity.F90 sourcefile~ice_shelf.f90->sourcefile~newtonian_viscosity.f90 sourcefile~ice_sheet.f90 ice_sheet.F90 sourcefile~ice_sheet.f90->sourcefile~viscosity.f90 sourcefile~newtonian_viscosity.f90->sourcefile~viscosity.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules viscosity_mod Source Code viscosity.F90 Source Code ! !  viscosity.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module viscosity_mod !* Author: Christopher MacMackin !  Date: October 2016 !  License: GPLv3 ! ! Provides an abstract data type to model viscosity into a ! vertically integrated plume. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field implicit none private type , abstract , public :: abstract_viscosity !* Author: Christopher MacMackin !  Date: October 2016 ! ! An abstract data type for calculating viscosity of a vertically ! integrated [[glacier(type)]]. ! contains procedure ( get_viscosity ), deferred :: ice_viscosity !! Returns the viscosity for the ice. end type abstract_viscosity abstract interface function get_viscosity ( this , velocity , temperature , time ) result ( property ) import :: abstract_viscosity import :: vector_field import :: scalar_field import :: r8 class ( abstract_viscosity ), intent ( in ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the ice for which the velocity is !! being calculated real ( r8 ), intent ( in ) :: temperature !! The temperature of the ice for which viscosity is being !! calculated. real ( r8 ), intent ( in ), optional :: time !! The time at which the viscosity is being calculated. If not !! present then assumed to be same as previous value passed. class ( scalar_field ), pointer :: property !! The value of the viscosity end function get_viscosity end interface end module viscosity_mod"},{"title":"basal_surface.F90 – ISOFT","tags":"","loc":"sourcefile/basal_surface.f90.html","text":"This file depends on sourcefile~~basal_surface.f90~~EfferentGraph sourcefile~basal_surface.f90 basal_surface.F90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~basal_surface.f90->sourcefile~nitsol.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~basal_surface.f90~~AfferentGraph sourcefile~basal_surface.f90 basal_surface.F90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~basal_surface.f90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~basal_surface.f90 sourcefile~cryosphere.f90 cryosphere.F90 sourcefile~cryosphere.f90->sourcefile~basal_surface.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~basal_surface.f90 sourcefile~ground.f90 ground.F90 sourcefile~ground.f90->sourcefile~basal_surface.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules basal_surface_mod Source Code basal_surface.F90 Source Code ! !  basal_surface.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module basal_surface_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides an abstract data type to model the ground or ocean below ! the glacier. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field use nitsol_mod , only : nitsol , dummy_jacv , ddot , dnrm2 , iplvl , dnrm2 use hdf5 implicit none private character ( len = 10 ), parameter , public :: hdf_type_attr = 'basal_type' type , abstract , public :: basal_surface !* Author: Christopher MacMackin !  Date: April 2016 ! ! An abstract data type which represents whatever lies below a [[glacier]]. ! This could be the ground, a plume, or a fully dynamic ocean model. ! Methods are available to provide the coupling information between the ! [[glacier]] and the basal surface. ! contains procedure ( get_scalar ), deferred :: basal_melt !! Returns the basal melt rate. procedure ( get_scalar ), deferred :: basal_drag_parameter !! Returns a value which may be needed to calculate basal drag, !! such as the coefficient of friction. procedure ( get_real ), deferred :: water_density !! Density of the water at the basal surface. procedure ( setter ), deferred :: update !! Sets the state of the basal surface procedure ( get_i ), deferred :: data_size !! Returns the number of elements in the basal surface's state !! vector procedure ( get_r81d ), deferred :: state_vector !! Returns the basal surface's state vector, a 1D array with all !! necessary data to describe its state. procedure ( read_dat ), deferred :: read_data !! Read the basal surface data from an HDF5 file on the disc. procedure ( write_dat ), deferred :: write_data !! Writes the data describing the basal surface to the disc as !! an HDF5 file. procedure ( surface_solve ), deferred :: solve !! Solves for the state of the basal surface given a particular !! ice shelf geometry. end type basal_surface abstract interface function get_scalar ( this ) result ( property ) import :: basal_surface import :: scalar_field class ( basal_surface ), intent ( in ) :: this class ( scalar_field ), pointer :: property !! The value of whatever property of the basal surface is being !! returned. end function get_scalar function get_real ( this ) result ( property ) import :: basal_surface import :: r8 class ( basal_surface ), intent ( in ) :: this real ( r8 ) :: property !! The value of whatever property of the basal surface is being !! returned. end function get_real function get_r81d ( this ) result ( state_vector ) import :: basal_surface import :: r8 class ( basal_surface ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector of the basal surface end function get_r81d subroutine setter ( this , state_vector , ice_thickness ) import :: basal_surface import :: scalar_field import :: r8 class ( basal_surface ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! basal surface. class ( scalar_field ), optional , intent ( in ) :: ice_thickness !! The ice thickness which, if present, will be used to update !! the calculation of the melt rate and/or drag parameter. end subroutine setter subroutine time_setter ( this , time ) import :: basal_surface import :: r8 class ( basal_surface ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time !! The time at which the basal surface is in the present state. end subroutine time_setter function get_i ( this ) result ( property ) import :: basal_surface class ( basal_surface ), intent ( in ) :: this integer :: property !! The value of whatever property of the basal surface is being !! returned. end function get_i subroutine read_dat ( this , file_id , group_name , error ) import :: basal_surface import :: hid_t class ( basal_surface ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group from which the data !! will be read. character ( len =* ), intent ( in ) :: group_name !! The name of the group in the HDF5 file from which to read !! basal surface's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. end subroutine read_dat subroutine write_dat ( this , file_id , group_name , error ) import :: basal_surface import :: hid_t class ( basal_surface ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! basal surface's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. end subroutine write_dat subroutine surface_solve ( this , ice_thickness , ice_density , & ice_temperature , time , success ) import :: basal_surface import :: scalar_field import :: r8 class ( basal_surface ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: ice_thickness !! Thickness of the ice above the basal surface real ( r8 ), intent ( in ) :: ice_density !! The density of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: ice_temperature !! The temperature of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: time !! The time to which the basal surface should be solved logical , intent ( out ) :: success !! True if the solver is successful, false otherwise end subroutine surface_solve end interface end module basal_surface_mod"},{"title":"preconditioner.F90 – ISOFT","tags":"","loc":"sourcefile/preconditioner.f90.html","text":"This file depends on sourcefile~~preconditioner.f90~~EfferentGraph sourcefile~preconditioner.f90 preconditioner.F90 sourcefile~jacobian_block.f90 jacobian_block.F90 sourcefile~preconditioner.f90->sourcefile~jacobian_block.f90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~jacobian_block.f90->sourcefile~boundary_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules preconditioner_mod Source Code preconditioner.F90 Source Code ! !  preconditioner.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module preconditioner_mod !* Author: Christopher MacMackin !  Date: December 2016 !  License: GPLv3 ! ! Provides a type for preconditioning fields in an iterative ! solver using Picard iteration. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field , maxval , abs use logger_mod , only : logger => master_logger use penf , only : str use jacobian_block_mod , only : jacobian_block implicit none private type , public :: preconditioner !* Author: Chris MacMackin !  Date: December 2016 ! ! Uses Picard iterations to apply the inverse Jacobian of a system ! to a vector, to low accuracy. Rather than directly computing the ! inverse Jacobian, it is more efficient to approximate it. If ! d is the vector being preconditioned, and z is the ! result of applying the preconditioner, then  z = J&#94;{-1}d ! \\Rightarrow Jz = d. Thus, the preconditioner can be applied by ! approximately solving this system for z. Linearising J, ! this system can be solved efficiently using Picard iteration. ! ! Say that the Jacobian is an n\\times n system of blocks of ! the sort implemented in the [[jacobian_block]] type (each ! labeled as J_{j,k}) and that the vector being preconditioned ! constists of n scalar fields (d_j). Then m&#94;{th} ! estimate of the solution for the j&#94;{th} field in the ! preconditioned vector (z&#94;m_j) is the solution to  ! J_{j,j}z&#94;m_j = d_j - \\sum_{\\substack{k=1\\ k\\ne j}}&#94;n ! J_{j,k}z&#94;{m-1}_k.  Depending on the type of fields being used ! and the direction in which derivatives are being taken, ! J_{j,j} may be tridiaganol, meaning it can be solved ! efficiently. <!--Otherwise, it can be approximated that  ! J_{j,j}z&#94;m_j = \\left(\\frac{\\partial F}{\\partial x_i} + ! F\\Delta_i\\right)z&#94;{m} \\simeq \\frac{\\partial F}{\\partial ! x_i}z&#94;m_j + F\\frac{\\partial z&#94;{m-1}_j}{\\partial x_i}.  The ! first term in this approximation corresponds to a diagonal ! matrix (which can be solved trivially), while the second term is ! known and can be subtracted from the right-hand-side of the ! linear system.--> ! private real ( r8 ) :: tolerance = 1.e-3_r8 integer :: max_iterations = 20 contains procedure :: apply => preconditioner_apply end type preconditioner interface preconditioner module procedure constructor end interface contains function constructor ( tolerance , max_iterations ) result ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Create a preconditioner object with the desired tolerance and ! maximum number of iterations. ! real ( r8 ), optional , intent ( in ) :: tolerance !! The tolerance within which to apply the inverse Jacobian. !! Defaults to 0.001. integer , optional , intent ( in ) :: max_iterations !! The maximum number of iterations to use when applying the !! preconditioner. Defaults to 20. type ( preconditioner ) :: this if ( present ( tolerance )) this % tolerance = tolerance if ( present ( max_iterations )) this % max_iterations = max_iterations end function constructor subroutine preconditioner_apply ( this , jacobian , vector , estimate ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Use Picard iteration to approximately multiply the state vector ! by the inverse Jacobian. The details for this procedure are in ! the documentation of the [[preconditioner(type)]] type. ! class ( preconditioner ), intent ( in ) :: this class ( jacobian_block ), dimension (:,:), intent ( inout ) :: jacobian !! An n\\times n matrix approximating the Jacobian for which !! the preconditioner is used. class ( scalar_field ), dimension (:), intent ( in ) :: vector !! A vector of size n which is to be preconditioned. class ( scalar_field ), dimension (:), intent ( inout ) :: estimate !! On entry, an initial guess for the preconditioned vector. On !! exit, the iteratively determined value of the preconditioned !! vector. character ( len = 77 ), parameter :: success_format = '(\"Picard solver ' // & 'converged with error of \",es12.5,\" after \",i2,\" iterations.\")' character ( len = 77 ), parameter :: failure_format = '(\"Picard solver ' // & 'reached maximum (\",i3,\") iterations, with error \",es12.5,\".\")' integer , parameter :: msg_len = 72 class ( scalar_field ), dimension (:), allocatable :: prev_estimate integer :: i , j , k , n real ( r8 ) :: max_err , old_max_err class ( scalar_field ), allocatable :: tmp_field logical :: first character ( len = msg_len ) :: msg #ifdef DEBUG call logger % debug ( 'preconditioner_apply' , 'Entering function `precondition`.' ) #endif call vector % guard_temp (); call estimate % guard_temp () n = size ( vector ) allocate ( prev_estimate ( n ), mold = estimate ) allocate ( tmp_field , mold = vector ( 1 )) #ifdef DEBUG if ( size ( jacobian , 1 ) /= size ( jacobian , 2 )) then error stop ( 'Jacobian is not a square matrix.' ) end if if ( size ( jacobian , 1 ) /= size ( vector )) then error stop ( 'Vector is of different size than Jacobian.' ) end if if ( size ( estimate ) /= size ( vector )) then error stop ( 'Estimate is of different size than vector.' ) end if #endif ! Until reached maximum number of iterations... do i = 1 , this % max_iterations ! For each row of the Jacobian, solve for the diagonal block, ! with off-diagonal blocks applied to the previous guess and ! subtracted from the right-hand-side. max_err = 0._r8 prev_estimate = estimate do j = 1 , n first = . true . do k = 1 , n if ( k == j ) cycle if ( first ) then first = . false . tmp_field = jacobian ( j , k ) * estimate ( k ) else tmp_field = tmp_field + jacobian ( j , k ) * estimate ( k ) end if end do estimate ( j ) = jacobian ( j , j )% solve_for ( vector ( j ) - tmp_field ) max_err = max ( max_err , & maxval ( abs ( ( estimate ( j ) - prev_estimate ( j )) / ( prev_estimate ( j ) + 1 e - 10_r8 ) ))) end do ! If difference between result and previous guess is less than ! the tolerance, stop iterations if ( max_err < this % tolerance ) then write ( msg , success_format ) max_err , i #ifdef DEBUG call logger % debug ( 'preconditioner%apply' , msg ) call logger % debug ( 'preconditioner%apply' , 'Exiting function `precondition`.' ) #endif call vector % clean_temp (); call estimate % clean_temp () return end if if ( i > 1 . and . old_max_err <= max_err ) then call logger % trivia ( 'preconditioner%apply' , 'Iterations diverging. Exiting ' // & 'and returning previous iterate, with maximum error ' // & str ( old_max_err ) // '.' ) #ifdef DEBUG call logger % debug ( 'preconditioner%apply' , 'Exiting function `precondition`.' ) #endif estimate = prev_estimate call vector % clean_temp (); call estimate % clean_temp () return end if old_max_err = max_err end do write ( msg , failure_format ) this % max_iterations , max_err call logger % warning ( 'preconditioner%apply' , msg ) call vector % clean_temp (); call estimate % clean_temp () call logger % debug ( 'preconditioner%apply' , 'Exiting function `precondition`.' ) end subroutine preconditioner_apply end module preconditioner_mod"},{"title":"pseudospectral_block.F90 – ISOFT","tags":"","loc":"sourcefile/pseudospectral_block.f90.html","text":"Files dependent on this one sourcefile~~pseudospectral_block.f90~~AfferentGraph sourcefile~pseudospectral_block.f90 pseudospectral_block.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~pseudospectral_block.f90 sourcefile~coriolis_block.f90 coriolis_block.F90 sourcefile~asymmetric_plume.f90->sourcefile~coriolis_block.f90 sourcefile~coriolis_block.f90->sourcefile~pseudospectral_block.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~pseudospectral_block.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~pseudospectral_block.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pseudospectral_block_mod Source Code pseudospectral_block.F90 Source Code ! !  pseudospectral_block.f90 !  This file is part of ISOFT. ! !  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module pseudospectral_block_mod !* Author: Christopher MacMackin !  Date: march 2017 !  License: GPLv3 ! ! Provides a derived type which representes a finite difference ! matrix/operator. This can be useful for preconditioning problems ! which use a spectral discretisation. ! use iso_fortran_env , only : r8 => real64 use factual_mod !, only: abstract_field, scalar_field, vector_field use chebyshev_mod , only : collocation_points , integrate_1d use penf , only : str use logger_mod , only : logger => master_logger implicit none private integer , parameter :: no_extra_derivative = - 1 type , public :: pseudospec_block !* Author: Chris MacMackin !  Date: December 2016 ! ! A data type representing a matrix pseudospectral differentiation ! operator. It can be useful when preconditioning systems which ! use a spectral discretisation, if higher accuracy than finite ! difference is needed. It is inherently 1-D in its ! implementation. Note that multiplication of a field will simply ! call that field's differentiation operator, which may or may not ! use a pseudospectral method. ! private real ( r8 ), dimension (:), pointer :: xvals !! Coordinates of collocation points. contains private procedure :: pseudospec_block_solve_scalar procedure :: pseudospec_block_solve_vector generic , public :: solve_for => pseudospec_block_solve_scalar , & pseudospec_block_solve_vector end type pseudospec_block interface pseudospec_block module procedure constructor end interface pseudospec_block contains function constructor ( template ) result ( this ) !* Author: Chris MacMackin !  Date: September 2017 ! ! Builds a Chebyshsev pseudospectral differentiation matrix block ! which can be used to solve the inverse problem. The result can ! only be used with fields having the same grid as the template. ! class ( abstract_field ), intent ( in ) :: template !! A scalar field with the same grid as any fields passed as !! arguments to the [[pseudospec_block(type):solve_for]] method. type ( pseudospec_block ) :: this real ( r8 ), dimension (:,:), allocatable :: domain domain = template % domain () this % xvals => collocation_points ( template % elements () - 1 , domain ( 1 , 1 ), & domain ( 1 , 2 )) end function constructor function pseudospec_block_solve_scalar ( this , rhs , bound_loc , bound_val , & good_bound ) result ( solution ) !* Author: Chris MacMackin !  Date: September 2017 ! ! Solves the linear(ised) system represented by this finite ! difference block, for a given right hand side state vector ! (represented by a scalar field). ! ! @Warning Currently this is only implemented for a 1-D field. ! class ( pseudospec_block ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: rhs !! The right hand side of the linear(ised) system. integer , intent ( in ) :: bound_loc !! Which boundary is being set. The boundary will be the one !! normal to dimension of number `abs(boundary)`. If the !! argument is negative, then the lower boundary is returned. If !! positive, then the upper boundary is returned. class ( scalar_field ), intent ( in ) :: bound_val !! The value of the result at the specified boundary. integer , intent ( in ), optional :: good_bound !! If provided, indicates which boundary contains trusted !! information from which to calculate the power of the highest !! frequency mode. Defaults to the opposite of `bound_loc`. class ( scalar_field ), pointer :: solution real ( r8 ), dimension (:), allocatable :: sol_vector , bound_vec logical :: valid_bound integer :: bloc call rhs % guard_temp (); call bound_val % guard_temp () valid_bound = . true . select case ( bound_loc ) case ( 1 ) bloc = 1 case ( - 1 ) bloc = size ( this % xvals ) case default valid_bound = . false . !call logger%warning('pseudospec_block%solve_for', '1-D field does not '// & !                    'have boundary in dimension '//str(bound_loc)) end select sol_vector = rhs % raw () if ( valid_bound ) then bound_vec = bound_val % raw () call integrate_1d ( sol_vector , this % xvals , bloc , bound_vec ( 1 ), good_bound ) else call integrate_1d ( sol_vector , this % xvals , good_bound = good_bound ) end if #ifdef DEBUG call logger % debug ( 'pseudospec_block%solve_for' , & 'Successfully performed Chebyshev pseudospectral integration.' ) #endif call rhs % allocate_scalar_field ( solution ) call solution % unset_temp () call solution % assign_meta_data ( rhs ) call solution % set_from_raw ( sol_vector ) call rhs % clean_temp (); call bound_val % clean_temp () call solution % set_temp () end function pseudospec_block_solve_scalar function pseudospec_block_solve_vector ( this , rhs , bound_loc , bound_val , & good_bound ) result ( solution ) !* Author: Chris MacMackin !  Date: September 2017 ! ! Solves the linear(ised) system represented by this finite ! difference block, for a given right hand side state vector ! (represented by a vector field). ! ! @Warning Currently this is only implemented for a 1-D field. ! ! @Bug For some reason, calls to the `vector_dimensions()` method ! produce a segfault when `rhs` is ! `class(vector_field)`. Everything works fine if it is ! `class(cheb1d_vector_field)`, so this is used as a workaround. ! class ( pseudospec_block ), intent ( inout ) :: this class ( cheb1d_vector_field ), intent ( in ) :: rhs !! The right hand side of the linear(ised) system. integer , intent ( in ) :: bound_loc !! Which boundary is being set. The boundary will be the one !! normal to dimension of number `abs(boundary)`. If the !! argument is negative, then the lower boundary is returned. If !! positive, then the upper boundary is returned. class ( vector_field ), intent ( in ) :: bound_val !! The value of the result at the specified boundary. integer , intent ( in ), optional :: good_bound !! If provided, indicates which boundary contains trusted !! information from which to calculate the power of the highest !! frequency mode. Defaults to the opposite of `bound_loc`. class ( vector_field ), pointer :: solution real ( r8 ), dimension (:), allocatable :: sol_vector , bound_vec logical :: valid_bound integer :: bloc , n , i class ( scalar_field ), pointer :: bcomponent call rhs % guard_temp (); call bound_val % guard_temp () valid_bound = . true . n = size ( this % xvals ) select case ( bound_loc ) case ( 1 ) bloc = 1 case ( - 1 ) bloc = n case default valid_bound = . false . !call logger%warning('pseudospec_block%solve_for', '1-D field does not '// & !                    'have boundary in dimension '//str(bound_loc)) end select sol_vector = rhs % raw () call bound_val % allocate_scalar_field ( bcomponent ) call bcomponent % guard_temp () do i = 1 , rhs % vector_dimensions () bcomponent = bound_val % component ( i ) if ( valid_bound ) then bound_vec = bcomponent % raw () call integrate_1d ( sol_vector (( i - 1 ) * n + 1 : i * n ), this % xvals , & bloc , bound_vec ( 1 ), good_bound ) else call integrate_1d ( sol_vector (( i - 1 ) * n + 1 : i * n ), this % xvals , & good_bound = good_bound ) end if end do call bcomponent % clean_temp () #ifdef DEBUG call logger % debug ( 'pseudospec_block%solve_for' , & 'Successfully performed Chebyshev pseudospectral integration.' ) #endif call rhs % allocate_vector_field ( solution ) call solution % unset_temp () call solution % assign_meta_data ( rhs ) call solution % set_from_raw ( sol_vector ) call rhs % clean_temp (); call bound_val % clean_temp () call solution % set_temp () end function pseudospec_block_solve_vector end module pseudospectral_block_mod"},{"title":"jacobian_block.F90 – ISOFT","tags":"","loc":"sourcefile/jacobian_block.f90.html","text":"This file depends on sourcefile~~jacobian_block.f90~~EfferentGraph sourcefile~jacobian_block.f90 jacobian_block.F90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~jacobian_block.f90->sourcefile~boundary_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~jacobian_block.f90~~AfferentGraph sourcefile~jacobian_block.f90 jacobian_block.F90 sourcefile~preconditioner.f90 preconditioner.F90 sourcefile~preconditioner.f90->sourcefile~jacobian_block.f90 sourcefile~ice_shelf.f90 ice_shelf.F90 sourcefile~ice_shelf.f90->sourcefile~jacobian_block.f90 sourcefile~ice_sheet.f90 ice_sheet.F90 sourcefile~ice_sheet.f90->sourcefile~jacobian_block.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules jacobian_block_mod Source Code jacobian_block.F90 Source Code ! !  jacobian_block.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module jacobian_block_mod !* Author: Christopher MacMackin !  Date: December 2016 !  License: GPLv3 ! ! Provides a derived type which is useful for representing blocks in ! a Jacobian matrix. This follows the abstract calculus pattern, ! providing operators for matrix multiplication and for solving the ! linear(ised) system. See the documentation for the ! [[jacobian_block(type)]] type for more details. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field use boundary_types_mod , only : dirichlet , neumann use f95_lapack , only : la_gtsvx use penf , only : str use logger_mod , only : logger => master_logger implicit none private integer , parameter :: no_extra_derivative = - 1 type , public :: jacobian_block !* Author: Chris MacMackin !  Date: December 2016 ! ! A data type representing a submatrix of a ! Jacobian. Specifically, it represents the commonly occurring ! operation  \\frac{\\partial F}{\\partial x_i} + F\\Delta_i,  ! where  \\Delta_i  is the differentiation operator in the ! i-direction. Optionally, there can be an additional ! differentiation operator on the right-hand-side of this. ! ! This data type is useful when constructing a preconditioner. A ! preconditioner, A, should approximate the inverse Jacobian of ! a problem being solved. Rather than directly computing the ! inverse Jacobian, it is more efficient to approximate it. If ! d is the vector being preconditioned, and z is the ! result of applying the preconditioner, then  z = J&#94;{-1}d ! \\Rightarrow Jz = d. Thus, the preconditioner can be applied ! by approximately solving this system for z. Linearising ! J, this system can be solved efficiently using Picard ! iteration. ! ! Say that the Jacobian is an n\\times n system of these blocks ! (each labeled as J_{j,k}) and that the vector being ! preconditioned constists of n scalar fields (d_j). Then ! the m&#94;{th} estimate of the solution for the j&#94;{th} field ! in the preconditioned vector (z&#94;m_j) is the solution to  ! J_{j,j}z&#94;m_j = d_j - \\sum_{\\substack{k=1\\ k\\ne j}}&#94;n ! J_{j,k}z&#94;{m-1}_k.  Depending on the type of fields being used ! and the direction in which derivatives are being taken, ! J_{j,j} may be tridiaganol, meaning it can be solved ! efficiently. <!--Otherwise, it can be approximated that  ! J_{j,j}z&#94;m_j = \\left(\\frac{\\partial F}{\\partial x_i} + ! F\\Delta_i\\right)z&#94;{m} \\simeq \\frac{\\partial F}{\\partial ! x_i}z&#94;m_j + F\\frac{\\partial z&#94;{m-1}_j}{\\partial x_i}.  The ! first term in this approximation corresponds to a diagonal ! matrix (which can be solved trivially), while the second term is ! known and can be subtracted from the right-hand-side of the ! linear system.--> ! ! For this purpose, a type-bound multiplication operator is ! provided for the Jacobian block type, which can be used when ! evaluating the right hand side of the linear system. There is ! also a `solve_for` method, which takes as an argument the field ! representing the right hand side of the system. <!--Before ! applying the latter operator, the `update_estimate` method must ! be called. This allows for the term involving derivative of the ! current estimate of the solution to be subtracted from the ! right-hand-side of the linear system, in cases where the system ! can not be expressed as a tridiagonal matrix.--> ! ! Boundary conditions are a complicated issue. When constructing ! an instance of this type, locations in the raw field ! representation can be specified for which boundary conditions ! are given. By default these are all Dirichlet conditions, but ! this behaviour may be overridden to be Neumann conditions. Note ! that Neumann conditions result in approximately an order of ! magnitude lower accuracy. When using the Jacobian block for ! multiplation, the type of the boundary does not matter; the ! value at the boundary in the result will be set to 0 or to ! values produced by an optional user-provided function. When ! using the `solve_for` method, the tridiagonal matrix will be ! altered in the specified locations to reflect the correct ! boundary conditions. This effectively mimics the sorts of ! Jacobian rows typically produced by boundary conditions. ! private integer :: direction !! The direction in which any derivatives are taken. integer :: extra_derivative = no_extra_derivative !! The direction in which to apply a differentiation on the !! right-hand-side of the Jacobian block operator. Defaults !! none. class ( scalar_field ), allocatable :: contents !! The value, A, to which the Jacobian block operation is !! beiing applied. real ( r8 ) :: coef = 1._r8 !! Optional coefficient by which the the \\partial F/\\partial x !!  term in the operator will be multiplied. procedure ( jacobian_block_bounds ), pointer , nopass :: & get_boundaries !! A subroutine which determines the expected boundary conditions !! (and their location in the raw array) for the solution of the !! Jacobian block. class ( scalar_field ), allocatable :: derivative !! The cached derivative of `contents` real ( r8 ), dimension (:), allocatable :: diagonal !! The diagonal of the tridiagonal matrix representation of this !! block. real ( r8 ), dimension (:), allocatable :: super_diagonal !! The super-diagonal of the tridiagonal matrix representation !! of this block. real ( r8 ), dimension (:), allocatable :: sub_diagonal !! The sub-diagonal of the tridiagonal matrix representation of !! this block. real ( r8 ), dimension (:), allocatable :: l_multipliers !! Multipliers defining the L matrix in the LU factorisation of !! the tridiagonal matrix representation of this block. real ( r8 ), dimension (:), allocatable :: u_diagonal !! The diagonal of the U matrix in the LU factorisation of !! the tridiagonal matrix representation of this block. real ( r8 ), dimension (:), allocatable :: u_superdiagonal1 !! The first superdiagonal of the U matrix in the LU !! factorisation of the tridiagonal matrix representation of !! this block. real ( r8 ), dimension (:), allocatable :: u_superdiagonal2 !! The second superdiagonal of the U matrix in the LU !! factorisation of the tridiagonal matrix representation of !! this block. integer , dimension (:), allocatable :: pivots !! Pivot indicies from the LU factorisation of the tridiagonal !! matrix representation of this block. real ( r8 ), dimension (:), allocatable :: boundary_vals !! Expected boundary values for the solution to the Jacobian !! block. integer , dimension (:), allocatable :: boundary_locs !! Locations in the raw arrays which are used to specify !! boundary conditions. integer , dimension (:), allocatable :: boundary_types !! The types of boundary conditions, specified using the !! parameters found in [[boundary_types_mod]]. real ( r8 ) :: real_increment !! A scalar value which is to be added to this Jacobian block !! (i.e. to the diagonal). class ( scalar_field ), allocatable :: field_increment !! A scalar field which is to be added to this Jacobian block !! (i.e. to the diagonal). type ( jacobian_block ), pointer :: block_increment => null () !! Another Jacobian block which is to be added to this one integer :: has_increment = 0 !! Indicates whether or not there has been an increment added to !! this block. If not, then 0. If a scalar real value has been !! added, then 1. If a scalar value has been added, then 2. contains private procedure :: jacobian_block_multiply procedure :: jacobian_block_add_real procedure :: jacobian_block_add_field procedure :: jacobian_block_add_block procedure :: jacobian_block_assign procedure :: get_tridiag => jacobian_block_get_tridiag generic , public :: operator ( * ) => jacobian_block_multiply generic , public :: operator ( + ) => jacobian_block_add_real , & jacobian_block_add_field , & jacobian_block_add_block generic , public :: assignment ( = ) => jacobian_block_assign procedure , public :: solve_for => jacobian_block_solve end type jacobian_block interface jacobian_block module procedure constructor end interface jacobian_block contains function constructor ( source_field , direction , extra_derivative , & boundary_locs , boundary_types , & boundary_operations , coef ) result ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Build a block in a Jacobian matrix, with the form ! \\frac{\\partial F}{\\partial x_i} + F\\Delta_i, where F is ! a scalar field and \\Delta_i is the differentiation operator ! in the i-direction. Additionally, a further differentiation ! operator may be added to the right hand side of this matrix ! block.  Optional arguments allow for handling of boundary ! conditions. See the end of the documentation of the ! [[jacobian_block(type)]] type for a description of how boundary ! conditions are treated. ! class ( scalar_field ), intent ( in ) :: source_field !! A scalar field (F) making up this block of the Jacobian integer , intent ( in ) :: direction !! The direction in which field derivatives are taken. integer , intent ( in ), optional :: extra_derivative !! If present, specifies the direction of a differentiation !! operator to be added to the right hand side of this matrix !! block. integer , dimension (:), optional , intent ( in ) :: boundary_locs !! The locations in the raw representation of `rhs` for which !! boundary conditions are specified. Defaults to there being !! none. integer , dimension (:), optional , intent ( in ) :: boundary_types !! Integers specifying the type of boundary condition. The type !! of boundary condition corresponding to a given integer is !! specified in [[boundary_types_mod]]. Only Dirichlet and !! Neumann conditions are supported. Defaults to Dirichlet. The !! order in which they are stored must match that of !! `boundary_locs`. procedure ( jacobian_block_bounds ), optional :: boundary_operations !! A function specifying the values to place at the boundaries !! of the result when using the Jacobian block for !! multiplication. By default, all boundaries are set to 0. The !! order in which the resulting values are stored should match !! that of `boundary_locs`. real ( r8 ), optional , intent ( in ) :: coef !! An optional coefficient by which the the \\partial !! F/\\partial x  term in the operator will be !! multipled. Default value is 1. type ( jacobian_block ) :: this !! A new Jacobian block call source_field % guard_temp () allocate ( this % contents , mold = source_field ) allocate ( this % derivative , mold = source_field ) this % contents = source_field this % direction = direction this % derivative = this % contents % d_dx ( this % direction ) if ( present ( extra_derivative )) this % extra_derivative = extra_derivative if ( present ( coef )) this % coef = coef if ( present ( boundary_locs )) then this % boundary_locs = boundary_locs else allocate ( this % boundary_locs ( 0 )) end if if ( present ( boundary_types )) then this % boundary_types = boundary_types else allocate ( this % boundary_types ( size ( this % boundary_locs ))) this % boundary_types = dirichlet end if if ( present ( boundary_operations )) then this % get_boundaries => boundary_operations else this % get_boundaries => jacobian_block_bounds end if call source_field % clean_temp () #ifdef DEBUG call logger % debug ( 'jacobian_block' , 'Instantiated a Jacobian block object.' ) #endif end function constructor recursive function jacobian_block_multiply ( this , rhs ) result ( product ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Provides a matrix multiplication operator between a Jacobian ! block and a scalar field (which corresponds to a state vector). ! class ( jacobian_block ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: rhs !! A field corresponding to a state vector being multiplied by !! the Jacobian block. class ( scalar_field ), pointer :: product class ( scalar_field ), pointer :: tmp real ( r8 ), dimension (:), allocatable :: bounds integer :: i call rhs % guard_temp () call this % contents % allocate_scalar_field ( product ) call product % unset_temp () if ( this % extra_derivative == no_extra_derivative ) then select case ( this % has_increment ) case ( 0 ) product = this % coef * this % derivative * rhs + this % contents * rhs % d_dx ( this % direction ) case ( 1 ) product = ( this % coef * this % derivative + this % real_increment ) * rhs & + this % contents * rhs % d_dx ( this % direction ) case ( 2 ) product = ( this % coef * this % derivative + this % field_increment ) * rhs & + this % contents * rhs % d_dx ( this % direction ) case default error stop ( 'Invalid increment has been added.' ) end select else call rhs % allocate_scalar_field ( tmp ) call tmp % guard_temp () tmp = rhs % d_dx ( this % extra_derivative ) select case ( this % has_increment ) case ( 0 ) product = this % coef * this % derivative * tmp + this % contents * tmp % d_dx ( this % direction ) case ( 1 ) product = this % coef * this % derivative * tmp + this % contents * tmp % d_dx ( this % direction ) & + this % real_increment * rhs case ( 2 ) product = this % coef * this % derivative * tmp + this % contents * tmp % d_dx ( this % direction ) & + this % field_increment * rhs case default error stop ( 'Invalid increment has been added.' ) end select call tmp % clean_temp () end if if ( associated ( this % block_increment )) then product = product + this % block_increment * rhs end if call this % get_boundaries ( this % contents , this % derivative , rhs , & this % boundary_locs , this % boundary_types , & bounds ) do i = 1 , size ( this % boundary_locs ) call product % set_element ( this % boundary_locs ( i ), bounds ( i )) end do call rhs % clean_temp () #ifdef DEBUG call logger % debug ( 'jacobian_block%multiply' , 'Multiplied vector by ' // & 'Jacobian block.' ) #endif call product % set_temp () end function jacobian_block_multiply function jacobian_block_add_real ( this , rhs ) result ( sum ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Produces a Jacobian block which has been offset by some constant ! increment. ! ! @Warning This operation will overwrite any previous sums which ! have been performed to produce `this`. ! class ( jacobian_block ), intent ( in ) :: this real ( r8 ), intent ( in ) :: rhs !! A scalar which should be added to this block type ( jacobian_block ) :: sum sum = this sum % real_increment = rhs sum % has_increment = sum % has_increment + 1 #ifdef DEBUG call logger % debug ( 'jacobian_block%add' , 'Added real to a Jacobian block.' ) #endif end function jacobian_block_add_real function jacobian_block_add_field ( this , rhs ) result ( sum ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Produces a Jacobian block which has been offset by a scalar ! field. ! ! @Warning This operation will overwrite any previous sums which ! have been performed to produce `this`. ! class ( jacobian_block ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: rhs !! A scalar which should be added to this block type ( jacobian_block ) :: sum sum = this allocate ( sum % field_increment , mold = rhs ) sum % field_increment = rhs sum % has_increment = sum % has_increment + 2 #ifdef DEBUG call logger % debug ( 'jacobian_block%add' , 'Added field to a Jacobian block.' ) #endif end function jacobian_block_add_field function jacobian_block_add_block ( this , rhs ) result ( sum ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Produces a Jacobian block which is the sum of two existing ! blocks. Boundary conditions are set by the first operand ! (`this`). ! class ( jacobian_block ), intent ( in ) :: this class ( jacobian_block ), target , intent ( in ) :: rhs !! A second block which should be added to this block type ( jacobian_block ) :: sum sum = this sum % block_increment => rhs #ifdef DEBUG call logger % debug ( 'jacobian_block%add' , 'Added field to a Jacobian block.' ) #endif end function jacobian_block_add_block subroutine jacobian_block_assign ( this , rhs ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Copies the contents of the `rhs` Jacobian block into this ! one. It will safely deallocate any data necessary. ! class ( jacobian_block ), intent ( out ) :: this type ( jacobian_block ), intent ( in ) :: rhs this % direction = rhs % direction this % extra_derivative = rhs % extra_derivative allocate ( this % contents , mold = rhs % contents ) allocate ( this % derivative , mold = rhs % derivative ) this % contents = rhs % contents this % coef = rhs % coef this % derivative = rhs % derivative this % get_boundaries => rhs % get_boundaries if ( allocated ( rhs % diagonal )) then this % diagonal = rhs % diagonal this % super_diagonal = rhs % super_diagonal this % sub_diagonal = rhs % sub_diagonal this % l_multipliers = rhs % l_multipliers this % u_diagonal = rhs % u_diagonal this % u_superdiagonal1 = rhs % u_superdiagonal1 this % u_superdiagonal2 = rhs % u_superdiagonal2 this % pivots = rhs % pivots end if if ( allocated ( rhs % boundary_locs )) this % boundary_locs = rhs % boundary_locs if ( allocated ( rhs % boundary_types )) this % boundary_types = rhs % boundary_types this % real_increment = rhs % real_increment if ( allocated ( rhs % field_increment )) & allocate ( this % field_increment , source = rhs % field_increment ) if ( associated ( rhs % block_increment )) this % block_increment => rhs % block_increment this % has_increment = rhs % has_increment end subroutine jacobian_block_assign recursive subroutine jacobian_block_get_tridiag ( this , diagonal , subdiagonal , & superdiagonal ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Computes the tridiagonal matrix used to solve for this Jacobian block. ! class ( jacobian_block ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable , intent ( out ) :: diagonal real ( r8 ), dimension (:), allocatable , intent ( out ) :: subdiagonal real ( r8 ), dimension (:), allocatable , intent ( out ) :: superdiagonal integer :: n , i , pos class ( vector_field ), pointer :: grid logical :: use_cached class ( scalar_field ), allocatable , save :: cached_field_type real ( r8 ), dimension (:), allocatable , save :: cached_dx_c , & cached_dx2_uc , & cached_dx2_ud , & cached_dx2_dc real ( r8 ), save :: cached_upper_bound , & cached_lower_bound real ( r8 ), dimension (:), allocatable :: cont , deriv , diag , & subdiag , supdiag real ( r8 ), dimension (:,:), allocatable :: domain n = this % contents % raw_size () domain = this % contents % domain () ! Try to use cached copy of inverse grid spacing, if available and suitable if ( allocated ( cached_field_type )) then use_cached = same_type_as ( this % contents , cached_field_type ) . and . & abs ( domain ( 1 , 1 ) - cached_lower_bound ) < 1 e - 10 . and . & abs ( domain ( 1 , 2 ) - cached_upper_bound ) < 1 e - 10 . and . & n == size ( cached_dx_c ) else use_cached = . false . end if ! Construct an array containing the distance between grid ! points, if necessary if (. not . use_cached ) then if ( allocated ( cached_field_type )) then deallocate ( cached_field_type ) deallocate ( cached_dx_c ) deallocate ( cached_dx2_uc ) deallocate ( cached_dx2_dc ) deallocate ( cached_dx2_ud ) end if #ifdef DEBUG call logger % debug ( 'jacobian_block%get_tridiag' , 'Calculating and caching ' // & 'grid spacings.' ) #endif cached_lower_bound = domain ( 1 , 1 ) cached_upper_bound = domain ( 1 , 2 ) allocate ( cached_field_type , mold = this % contents ) allocate ( cached_dx_c ( n )) allocate ( cached_dx2_uc ( n - 1 )) allocate ( cached_dx2_dc ( n - 1 )) allocate ( cached_dx2_ud ( n )) call this % contents % allocate_vector_field ( grid ) grid = this % contents % grid_spacing () ! Use this array to temporarily hold the grid spacings cached_dx_c = grid % raw () ! Work out the upwinded grid spacings cached_dx2_uc ( 1 ) = cached_dx_c ( 1 ) do i = 2 , n - 1 cached_dx2_uc ( i ) = 2 * cached_dx_c ( i ) - cached_dx2_uc ( i - 1 ) end do ! Work out the inverse of the downwinded grid spacings cached_dx2_dc ( 1 : n - 2 ) = 1._r8 / cached_dx2_uc ( 1 : n - 2 ) cached_dx2_dc ( n - 1 ) = 1._r8 / cached_dx_c ( n ) ! Work out the -2 times product of the inverse up- and ! down-winded grid spacings cached_dx2_ud ( 1 ) = cached_dx2_uc ( 1 ) ** ( - 2 ) cached_dx2_ud ( 2 : n - 1 ) = - 2 * cached_dx2_dc ( 2 : n - 1 ) / cached_dx2_uc ( 1 : n - 2 ) cached_dx2_ud ( n ) = cached_dx2_dc ( n - 1 ) ** 2 ! Work out the inverse of product of the up-winded and ! centred grid spacings cached_dx2_uc ( 1 ) = - cached_dx2_uc ( 1 ) ** ( - 2 ) cached_dx2_uc ( 2 : n - 1 ) = 1._r8 / ( cached_dx2_uc ( 2 : n - 1 ) * cached_dx_c ( 2 : n - 1 )) ! Work out the inverse of the product of the down-winded and ! centred grid spacings cached_dx2_dc ( 1 : n - 2 ) = cached_dx2_dc ( 1 : n - 2 ) / cached_dx_c ( 2 : n - 1 ) cached_dx2_dc ( n - 1 ) = - cached_dx2_dc ( n - 1 ) ** 2 ! Work out half the inverse of the grid spacing cached_dx_c ( 2 : n - 1 ) = 0.5_r8 / cached_dx_c ( 2 : n - 1 ) cached_dx_c ( 1 ) = 1._r8 / cached_dx_c ( 1 ) cached_dx_c ( n ) = 1._r8 / cached_dx_c ( n ) end if cont = this % contents % raw () if ( this % extra_derivative == no_extra_derivative ) then ! Create the tridiagonal matrix when there is no additional ! differentiation operator on the RHS diagonal = this % coef * this % derivative % raw () select case ( this % has_increment ) case ( 0 ) continue case ( 1 ) diagonal = diagonal + this % real_increment case ( 2 ) diagonal = diagonal + this % field_increment % raw () case default error stop ( 'Invalid increment has been added.' ) end select diagonal ( 1 ) = diagonal ( 1 ) - cont ( 1 ) * cached_dx_c ( 1 ) diagonal ( n ) = diagonal ( n ) + cont ( n ) * cached_dx_c ( n ) superdiagonal = cont ( 1 : n - 1 ) * cached_dx_c ( 1 : n - 1 ) subdiagonal = - cont ( 2 : n ) * cached_dx_c ( 2 : n ) else if ( this % extra_derivative == this % direction ) then ! Create the tridiagonal matrix when the additional ! differentiation operator on the RHS operates in the same ! direction as the derivative of the contents. deriv = this % coef * this % derivative % raw () allocate ( diagonal ( n )) diagonal ( 2 : n - 1 ) = cont ( 2 : n - 1 ) * cached_dx2_ud ( 2 : n - 1 ) diagonal ( 1 ) = cont ( 1 ) * cached_dx2_ud ( 1 ) & - deriv ( 1 ) * cached_dx_c ( 1 ) diagonal ( n ) = cont ( n ) * cached_dx2_ud ( n ) & + deriv ( n ) * cached_dx_c ( n ) !print*,diagonal(10) select case ( this % has_increment ) case ( 0 ) continue case ( 1 ) diagonal = diagonal + this % real_increment case ( 2 ) diagonal = diagonal + this % field_increment % raw () case default error stop ( 'Invalid increment has been added.' ) end select allocate ( superdiagonal ( n - 1 )) superdiagonal ( 2 : n - 1 ) = cont ( 2 : n - 1 ) * cached_dx2_uc ( 2 : n - 1 ) & + deriv ( 2 : n - 1 ) * cached_dx_c ( 2 : n - 1 ) superdiagonal ( 1 ) = - 2 * cont ( 1 ) * cached_dx2_uc ( 1 ) & + deriv ( 1 ) * cached_dx_c ( 1 ) allocate ( subdiagonal ( n - 1 )) subdiagonal ( 1 : n - 2 ) = cont ( 2 : n - 1 ) * cached_dx2_dc ( 1 : n - 2 ) & - deriv ( 2 : n - 1 ) * cached_dx_c ( 2 : n - 1 ) subdiagonal ( n - 1 ) = - 2 * cont ( n ) * cached_dx2_dc ( n - 1 ) & - deriv ( n ) * cached_dx_c ( n ) else call logger % fatal ( 'jacobian_block%solve_for' , 'Currently no support ' // & 'for extra derivatives other than in the 1-direction' ) error stop end if if ( associated ( this % block_increment )) then call this % block_increment % get_tridiag ( diag , subdiag , supdiag ) diagonal = diagonal + diag subdiagonal = subdiagonal + subdiag superdiagonal = superdiagonal + supdiag end if ! Set the boundary conditions for this problem do i = 1 , size ( this % boundary_locs ) pos = this % boundary_locs ( i ) if ( this % boundary_types ( i ) == dirichlet ) then diagonal ( pos ) = 1._r8 if ( pos < n ) superdiagonal ( pos ) = 0._r8 if ( pos > 1 ) subdiagonal ( pos - 1 ) = 0._r8 else if ( this % boundary_types ( i ) == neumann ) then if ( pos == n ) then diagonal ( n ) = cached_dx_c ( n ) subdiagonal ( n - 1 ) = - cached_dx_c ( n ) else if ( pos == 1 ) then diagonal ( 1 ) = - cached_dx_c ( 1 ) superdiagonal ( 1 ) = cached_dx_c ( 1 ) else superdiagonal ( pos ) = cached_dx_c ( pos ) subdiagonal ( pos - 1 ) = cached_dx_c ( pos ) diagonal ( pos ) = 0._r8 end if else call logger % fatal ( 'jacobian_block%solve_for' , 'Boundary condition of ' // & 'type other than Dirichlet or Neumann encountered.' ) error stop end if end do #ifdef DEBUG call logger % debug ( 'jacobian_block%get_tridiag' , 'Constructed tridiagonal matrix.' ) #endif end subroutine jacobian_block_get_tridiag function jacobian_block_solve ( this , rhs ) result ( solution ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Solves the linear(ised) system represented by this Jacobian ! block, for a given right hand side state vector (represented by ! a scalar field). ! ! @Warning Currently this is only implemented for a 1-D field. The ! extra derivative must be in the direction along which the field ! varies. ! class ( jacobian_block ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: rhs !! The right hand side of the linear(ised) system. class ( scalar_field ), pointer :: solution real ( r8 ), dimension (:), allocatable :: sol_vector integer :: flag , n real ( r8 ) :: forward_err , & backward_err , & condition_num real ( r8 ), dimension (:), allocatable :: diag , subdiag , supdiag character ( len = 1 ) :: factor character ( len = :), allocatable :: msg call rhs % guard_temp () allocate ( sol_vector ( rhs % raw_size ())) ! Construct tridiagonal matrix for this operation, if necessary if (. not . allocated ( this % pivots )) then factor = 'N' ! Allocate the arrays used to hold the factorisation of the ! tridiagonal matrix call this % get_tridiag ( diag , subdiag , supdiag ) call move_alloc ( diag , this % diagonal ) call move_alloc ( subdiag , this % sub_diagonal ) call move_alloc ( supdiag , this % super_diagonal ) n = this % contents % raw_size () allocate ( this % l_multipliers ( n - 1 )) allocate ( this % u_diagonal ( n )) allocate ( this % u_superdiagonal1 ( n - 1 )) allocate ( this % u_superdiagonal2 ( n - 2 )) allocate ( this % pivots ( n )) else factor = 'F' end if !    print*,rhs%raw() call la_gtsvx ( this % sub_diagonal , this % diagonal , this % super_diagonal , & rhs % raw (), sol_vector , this % l_multipliers , this % u_diagonal , & this % u_superdiagonal1 , this % u_superdiagonal2 , this % pivots , & factor , 'N' , forward_err , backward_err , condition_num , & flag ) if ( flag /= 0 ) then msg = 'Tridiagonal matrix solver returned with flag ' // trim ( str ( flag )) !      print*,this%sub_diagonal !      print*, !      print*,this%diagonal !      print*, !      print*,this%super_diagonal CALL backtrace call logger % error ( 'jacobian_block%solve_for' , msg ) !print*,condition_num !      stop #ifdef DEBUG else msg = 'Tridiagonal matrix solver returned with estimated condition ' // & 'number ' // trim ( str ( condition_num )) call logger % debug ( 'jacobian_block%solve_for' , msg ) #endif end if call rhs % allocate_scalar_field ( solution ) call solution % unset_temp () call solution % assign_meta_data ( rhs ) call solution % set_from_raw ( sol_vector ) call rhs % clean_temp (); call solution % set_temp () end function jacobian_block_solve subroutine jacobian_block_bounds ( contents , derivative , rhs , & boundary_locs , boundary_types , & boundary_values ) !* Author: Chris MacMackin !  Date: January 2016 ! ! A default implementation of the `get_boundaries` procedure ! pointer for the `jacobian_block` type. It corresponds to setting ! all boundaries to 0 when multiplying a field by the Jacobian ! block. ! class ( scalar_field ), intent ( in ) :: contents !! The field used to construct the Jacobian block class ( scalar_field ), intent ( in ) :: derivative !! The first spatial derivative of the field used to construct !! the Jacobian block, in the direction specified class ( scalar_field ), intent ( in ) :: rhs !! The scalar field representing the vector being multiplied !! by Jacobian integer , dimension (:), allocatable , intent ( in ) :: boundary_locs !! The locations in the raw representation of `rhs` containing !! the boundaries. integer , dimension (:), allocatable , intent ( in ) :: boundary_types !! Integers specifying the type of boundary condition. The type !! of boundary condition corresponding to a given integer is !! specified in [[boundary_types_mod]]. Only Dirichlet and !! Neumann conditions are supported. The storage order must !! correspond to that of `boundary_locs`. real ( r8 ), dimension (:), allocatable , intent ( out ) :: boundary_values !! The values to go at the boundaries when multiplying a field !! by the Jacobian block. The storage order must be the same as !! for `boundary_locs`. allocate ( boundary_values ( size ( boundary_locs ))) boundary_values = 0._r8 end subroutine jacobian_block_bounds end module jacobian_block_mod"},{"title":"splev.f – ISOFT","tags":"","loc":"sourcefile/splev.f.html","text":"Contents Subroutines splev fpbspl Source Code splev.f Source Code subroutine splev ( t , n , c , k , x , y , m , e , ier ) c  subroutine splev evaluates in a number of points x(i),i=1,2,...,m c  a spline s(x) of degree k, given in its b-spline representation. c c  calling sequence: c     call splev(t,n,c,k,x,y,m,e,ier) c c  input parameters: c    t    : array,length n, which contains the position of the knots. c    n    : integer, giving the total number of knots of s(x). c    c    : array,length n, which contains the b-spline coefficients. c    k    : integer, giving the degree of s(x). c    x    : array,length m, which contains the points where s(x) must c           be evaluated. c    m    : integer, giving the number of points where s(x) must be c           evaluated. c    e    : integer, if 0 the spline is extrapolated from the end c           spans for points not in the support, if 1 the spline c           evaluates to zero for those points, if 2 ier is set to c           1 and the subroutine returns, and if 3 the spline evaluates c           to the value of the nearest boundary point. c c  output parameter: c    y    : array,length m, giving the value of s(x) at the different c           points. c    ier  : error flag c      ier = 0 : normal return c      ier = 1 : argument out of bounds and e == 2 c      ier =10 : invalid input data (see restrictions) c c  restrictions: c    m >= 1 c--    t(k+1) <= x(i) <= x(i+1) <= t(n-k) , i=1,2,...,m-1. c c  other subroutines required: fpbspl. c c  references : c    de boor c  : on calculating with b-splines, j. approximation theory c                 6 (1972) 50-62. c    cox m.g.   : the numerical evaluation of b-splines, j. inst. maths c                 applics 10 (1972) 134-149. c    dierckx p. : curve and surface fitting with splines, monographs on c                 numerical analysis, oxford university press, 1993. c c  author : c    p.dierckx c    dept. computer science, k.u.leuven c    celestijnenlaan 200a, b-3001 heverlee, belgium. c    e-mail : Paul.Dierckx@cs.kuleuven.ac.be c c  latest update : march 1987 c c++ pearu: 11 aug 2003 c++   - disabled cliping x values to interval [min(t),max(t)] c++   - removed the restriction of the orderness of x values c++   - fixed initialization of sp to double precision value c c  ..scalar arguments.. integer n , k , m , e , ier c  ..array arguments.. real * 8 t ( n ), c ( n ), x ( m ), y ( m ) c  ..local scalars.. integer i , j , k1 , l , ll , l1 , nk1 c++.. integer k2 c..++ real * 8 arg , sp , tb , te c  ..local array.. real * 8 h ( 20 ) c  .. c  before starting computations a data check is made. if the input data c  are invalid control is immediately repassed to the calling program. ier = 10 c--      if(m-1) 100,30,10 c++.. if ( m . lt . 1 ) go to 100 c..++ c--  10  do 20 i=2,m c--        if(x(i).lt.x(i-1)) go to 100 c--  20  continue ier = 0 c  fetch tb and te, the boundaries of the approximation interval. k1 = k + 1 c++.. k2 = k1 + 1 c..++ nk1 = n - k1 tb = t ( k1 ) te = t ( nk1 + 1 ) l = k1 l1 = l + 1 c  main loop for the different points. do 80 i = 1 , m c  fetch a new x-value arg. arg = x ( i ) c  check if arg is in the support if ( arg . lt . tb . or . arg . gt . te ) then if ( e . eq . 0 ) then goto 35 else if ( e . eq . 1 ) then y ( i ) = 0 goto 80 else if ( e . eq . 2 ) then ier = 1 goto 100 else if ( e . eq . 3 ) then if ( arg . lt . tb ) then arg = tb else arg = te endif endif endif c  search for knot interval t(l) <= arg < t(l+1) c++.. 35 if ( arg . ge . t ( l ) . or . l1 . eq . k2 ) go to 40 l1 = l l = l - 1 go to 35 c..++ 40 if ( arg . lt . t ( l1 ) . or . l . eq . nk1 ) go to 50 l = l1 l1 = l + 1 go to 40 c  evaluate the non-zero b-splines at arg. 50 call fpbspl ( t , n , k , arg , l , h ) c  find the value of s(x) at x=arg. sp = 0.0d0 ll = l - k1 do 60 j = 1 , k1 ll = ll + 1 sp = sp + c ( ll ) * h ( j ) 60 continue y ( i ) = sp 80 continue 100 return end c c c subroutine fpbspl ( t , n , k , x , l , h ) c  subroutine fpbspl evaluates the (k+1) non-zero b-splines of c  degree k at t(l) <= x < t(l+1) using the stable recurrence c  relation of de boor and cox. c  Travis Oliphant  2007 c    changed so that weighting of 0 is used when knots with c      multiplicity are present. c    Also, notice that l+k <= n and 1 <= l+1-k c      or else the routine will be accessing memory outside t c      Thus it is imperative that that k <= l <= n-k but this c      is not checked. c  .. c  ..scalar arguments.. real * 8 x integer n , k , l c  ..array arguments.. real * 8 t ( n ), h ( 20 ) c  ..local scalars.. real * 8 f , one integer i , j , li , lj c  ..local arrays.. real * 8 hh ( 19 ) c  .. one = 0.1d+01 h ( 1 ) = one do 20 j = 1 , k do 10 i = 1 , j hh ( i ) = h ( i ) 10 continue h ( 1 ) = 0.0d0 do 20 i = 1 , j li = l + i lj = li - j if ( t ( li ). ne . t ( lj )) goto 15 h ( i + 1 ) = 0.0d0 goto 20 15 f = hh ( i ) / ( t ( li ) - t ( lj )) h ( i ) = h ( i ) + f * ( t ( li ) - x ) h ( i + 1 ) = f * ( x - t ( lj )) 20 continue return end"},{"title":"coriolis_block.F90 – ISOFT","tags":"","loc":"sourcefile/coriolis_block.f90.html","text":"This file depends on sourcefile~~coriolis_block.f90~~EfferentGraph sourcefile~coriolis_block.f90 coriolis_block.F90 sourcefile~pseudospectral_block.f90 pseudospectral_block.F90 sourcefile~coriolis_block.f90->sourcefile~pseudospectral_block.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~coriolis_block.f90~~AfferentGraph sourcefile~coriolis_block.f90 coriolis_block.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~coriolis_block.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules coriolis_block_mod Source Code coriolis_block.F90 Source Code ! !  pseudospectral_block.f90 !  This file is part of ISOFT. ! !  Copyright 2018 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module coriolis_block_mod !* Author: Christopher MacMackin !  Date: march 2017 !  License: GPLv3 ! ! Provides a derived type which representes the operator acting on ! velocity and its derivative with the Coriolis force. This can be ! used for preconditioning in the [[plume]] solver. ! use iso_fortran_env , only : r8 => real64 use factual_mod !, only: abstract_field, scalar_field, vector_field use f95_lapack , only : la_gesvx use pseudospectral_block_mod , only : pseudospec_block use penf , only : str use logger_mod , only : logger => master_logger implicit none private character ( len = 1 ), parameter :: trans = 'N' !! The LAPACK parameter indicating not to operate on the transpose !! of the matrix when solving for boundary conditions. type ( uniform_scalar_field ) :: zero type , public :: coriolis_block !* Author: Chris MacMackin !  Date: January 2017 ! ! A data type representing a matrix operator for the momentum ! components of the linear parts plume equations, with the ! Coriolis force. It can be useful when preconditioning a the ! plume solver. It is inherently 1-D in its implementation, but ! has a transverse velocity component. ! ! This type solves the linear, coupled, differential equation !  \\frac{d}{dx} \\bm{Y} = \\bm{A}\\bm{Y} + \\bm{F}  ! where  \\bm{Y} = [U, V, U', V']&#94;{T} , !  \\bm{A} = \\begin{bmatrix} ! 0        & 0         & 1 & 0 \\\\ ! 0        & 0         & 0 & 1 \\\\ ! 0        & -\\Phi/\\nu & 0 & 0 \\\\ ! \\Phi/\\nu & 0         & 0 & 0 ! \\end{bmatrix}, !  ! and  \\bm{F}  is the input value to which this block is ! applied in the preconditioner. \\Phi is the dimensionless ! coriolis parameter, while \\nu is the eddy viscosity. ! ! The matrix \\bm{A} can be diagonalised by factoring it such ! that \\bm{A} = \\bm{V}\\bm{D}\\bm{V}&#94;{-1}, where \\bm{V} is a ! change of basis matrix with columns made up of the eigenvectors ! of \\bm{A} and \\bm{D} is a diagonal matrix made up of ! the corresponding eigenvalues. These have the values !  \\bm{V} = \\begin{bmatrix} ! \\tfrac{-1-i}{\\alpha} & \\tfrac{-1+i}{\\alpha} & \\tfrac{1-i}{\\alpha} & \\tfrac{1+i}{\\alpha} \\\\ ! \\tfrac{-1+i}{\\alpha} & \\tfrac{-1-i}{\\alpha} & \\tfrac{1+i}{\\alpha} & \\tfrac{1-i}{\\alpha} \\\\ ! i                    & -i                   & -i                  & i                   \\\\ ! 1                    & 1                    & 1                   & 1 ! \\end{bmatrix}, !  !  \\bm{D} = \\beta\\begin{bmatrix} ! -1-i & 0    & 0   & 0   \\\\ ! 0    & -1+i &     & 0   \\\\ ! 0    & 0    & 1-i & 0   \\\\ ! 0    & 0    & 0   & 1+i ! \\end{bmatrix}, !  !  \\bm{V}&#94;{-1} = \\frac{1}{4}\\begin{bmatrix} ! (-1+i)\\beta & -(1+i)\\beta & -i & 1 \\\\ ! (-1-i)\\beta & -(1-i)\\beta & i  & 1 \\\\ ! (1+i)\\beta  & (1-i)\\beta  & i  & 1 \\\\ ! (1-i)\\beta  & (1+i)\\beta  & -i & 1 ! \\end{bmatrix}, !  !  \\alpha = \\sqrt{\\frac{2\\Phi}{\\nu}}, \\quad \\beta = \\sqrt{\\frac{\\Phi}{2\\nu}}.  ! It can be shown that the solution to the differential equation is !  \\bm{Y} = \\bm{V}\\left(e&#94;{\\bm{D}x}\\bm{B} + !    e&#94;{\\bm{D}x}\\int_0&#94;{x}e&#94;{\\bm{D}x'}\\bm{V}&#94;{-1}\\bm{F}dx' \\right), ! where \\bm{B}\\in\\mathbb{R}&#94;{4} is a vector chosen to satisfy ! the boundary conditions on the system. It can be found by solving a ! 4×4 linear system. ! ! This type inherits ! private real ( r8 ), dimension ( 4 ) :: D_r !! Real component of the diagonal matrix, \\bm{D}, with only !! diagonal values stored real ( r8 ), dimension ( 4 ) :: D_i !! Imaginary component of the diagonal matrix, \\bm{D}, with !! only diagonal values stored type ( cheb1d_scalar_field ), dimension ( 4 , 4 ) :: emDxVinv_r !! Real component of e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1} type ( cheb1d_scalar_field ), dimension ( 4 , 4 ) :: emDxVinv_i !! Imaginary component of e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1} type ( cheb1d_scalar_field ), dimension ( 4 ) :: eDx_r !! Real component of e&#94;{\\bm{D}x}, with only diagonal values !! stored type ( cheb1d_scalar_field ), dimension ( 4 ) :: eDx_i !! Imaginary component of e&#94;{\\bm{D}x}, with only diagonal !! values stored real ( r8 ), dimension ( 4 , 4 ) :: V_r !! Real component of the change of basis matrix, \\bm{V} real ( r8 ), dimension ( 4 , 4 ) :: V_i !! Imaginary component of the change of basis matrix, \\bm{V} type ( pseudospec_block ) :: integrator !! A pseudospectral differentiation block which can be used to !! perform integration integer :: vel_bound_loc !! Location code for the velocity's boundary condition integer :: dvel_bound_loc !! Location code for the velocity derivative's boundary !! condition integer :: integrate_bound !! Location from which to perform the integration real ( r8 ), dimension ( 4 ) :: xbounds !! Boundary location for each component of the solution vector complex ( r8 ), dimension ( 4 , 4 ) :: bound_matrix !! Matrix for the system to solve in order to satisfy the !! boundary conditions complex ( r8 ), dimension ( 4 , 4 ) :: bound_matrix_scaled !! Matrix for the system to solve in order to satisfy the !! boundary conditions, which has been scaled by LAPACK95 !! to improve conditioning. complex ( r8 ), dimension ( 4 , 4 ) :: factored_matrix !! Factored matrix for the system to solve in order to satisfy !! the boundary conditions integer , dimension ( 4 ) :: pivots !! The pivots used in the factorisation of the matrix used to !! satisfy boundary conditions real ( r8 ), dimension ( 4 ) :: r_scales !! Row scale factors from equilibrating the bound_matrix real ( r8 ), dimension ( 4 ) :: c_scales !! Column scale factors from equilibrating the bound_matrix character ( len = 1 ) :: equed !! The method used to equilibrate bound_matrix integer :: int contains private procedure , public :: solve_for procedure :: assign generic , public :: assignment ( = ) => assign end type coriolis_block interface coriolis_block module procedure constructor end interface coriolis_block contains function constructor ( phi , nu , velbound , dvelbound , integrate_bound , template ) & result ( this ) !* Author: Chris MacMackin !  Date: January 2018 ! ! Builds a Coriolis block which can be used to solve the inverse ! problem for the linear components of the plume momentum ! equations. The result can only be used with fields having the ! same grid as the template. ! real ( r8 ), intent ( in ) :: phi !! The dimensionless coriolis parameter real ( r8 ), intent ( in ) :: nu !! The dimensionless eddy diffusivity integer , intent ( in ) :: velbound !! Location code for the velocity's boundary condition. 1 !! indicates upper boundary, -1 indicates lower boundary. integer , intent ( in ) :: dvelbound !! Location code for the velocity's boundary condition. 1 !! indicates upper boundary, -1 indicates lower boundary. integer , intent ( in ) :: integrate_bound !! Location code for the boundary to perform integrations !! from. This should be the opposite boundary from where !! boundary data is stored. class ( abstract_field ), intent ( in ) :: template !! A scalar field with the same grid as any fields passed as !! arguments to the [[pseudospec_block(type):solve_for]] method. type ( coriolis_block ) :: this type ( cheb1d_scalar_field ) :: xvals integer :: i , j , info real ( r8 ) :: alpha , beta , rcond , s real ( r8 ), dimension (:,:), allocatable :: domain complex ( r8 ), dimension ( 4 ) :: dummy_in complex ( r8 ), dimension ( 4 ) :: dummy_out character ( len = :), allocatable :: msg call template % guard_temp () zero = uniform_scalar_field ( 0._r8 ) this % integrator = pseudospec_block ( template ) domain = template % domain () this % vel_bound_loc = velbound this % dvel_bound_loc = dvelbound if ( velbound == 1 ) then this % xbounds ( 1 : 2 ) = domain ( 1 , 2 ) else if ( velbound == - 1 ) then this % xbounds ( 1 : 2 ) = domain ( 1 , 1 ) else call logger % fatal ( 'coriolis_block' , & 'Only boundary location codes 1 or -1 are accepted.' ) error stop end if if ( dvelbound == 1 ) then this % xbounds ( 3 : 4 ) = domain ( 1 , 2 ) else if ( dvelbound == - 1 ) then this % xbounds ( 3 : 4 ) = domain ( 1 , 1 ) else call logger % fatal ( 'coriolis_block' , & 'Only boundary location codes 1 or -1 are accepted.' ) error stop end if this % integrate_bound = integrate_bound xvals = cheb1d_scalar_field ( template % elements (), linear , domain ( 1 , 1 ), & domain ( 1 , 2 )) ! Compute the diagonal elements of \\bm{B} alpha = sqrt ( abs ( 2 * phi / nu )) beta = sqrt ( abs ( 0.5_r8 * phi / nu )) s = sign ( 1._r8 , phi ) this % D_r = [ - beta , - beta , beta , beta ] this % D_i = [ - beta , beta , - beta , beta ] ! Use the associations as temporary work arrays, prior to ! computing their actual values associate ( emDx_r => this % eDx_r , emDx_i => this % eDx_i , & Vinv_r => this % V_r , Vinv_i => this % V_i ) ! Compute e&#94;{-\\bm{D}x}. Need to do this in two steps to avoid a compiler bug emDx_i = [( exp ( - this % D_r ( i ) * xvals ), i = 1 , 4 )] emDx_r = [( emDx_i ( i ) * cos ( - this % D_i ( i ) * xvals ), i = 1 , 4 )] emDx_i = [( emDx_i ( i ) * sin ( - this % D_i ( i ) * xvals ), i = 1 , 4 )] ! Compute \\bm{V}&#94;{-1} Vinv_r = 0.25_r8 * reshape ([ - s * beta , - s * beta , s * beta , s * beta , & - beta , - beta , beta , beta , & 0._r8 , 0._r8 , 0._r8 , 0._r8 , & 1._r8 , 1._r8 , 1._r8 , 1._r8 ], & [ 4 , 4 ]) Vinv_i = 0.25_r8 * reshape ([ s * beta , - s * beta , s * beta , - s * beta , & - beta , beta , - beta , beta , & - s , s , s , - s , & 0._r8 , 0._r8 , 0._r8 , 0._r8 ], & [ 4 , 4 ]) ! Compute e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1} this % emDxVinv_r = reshape ([(( emDx_r ( i ) * Vinv_r ( i , j ) - emDx_i ( i ) * Vinv_i ( i , j ), & i = 1 , 4 ), j = 1 , 4 )], [ 4 , 4 ]) this % emDxVinv_i = reshape ([(( emDx_r ( i ) * Vinv_i ( i , j ) + emDx_i ( i ) * Vinv_r ( i , j ), & i = 1 , 4 ), j = 1 , 4 )], [ 4 , 4 ]) end associate ! Compute e&#94;{\\bm{D}x}. Need to do this in two steps to avoid a compiler bug this % eDx_i = [( exp ( this % D_r ( i ) * xvals ), i = 1 , 4 )] this % eDx_r = [( this % eDx_i ( i ) * cos ( this % D_i ( i ) * xvals ), i = 1 , 4 )] this % eDx_i = [( this % eDx_i ( i ) * sin ( this % D_i ( i ) * xvals ), i = 1 , 4 )] ! Compute \\bm{V} this % V_r = reshape ([ - s / alpha , - 1._r8 / alpha , 0._r8 , 1._r8 , & - s / alpha , - 1._r8 / alpha , 0._r8 , 1._r8 , & s / alpha , 1._r8 / alpha , 0._r8 , 1._r8 , & s / alpha , 1._r8 / alpha , 0._r8 , 1._r8 ], & [ 4 , 4 ]) this % V_i = reshape ([ - s / alpha , 1._r8 / alpha , s , 0._r8 , & s / alpha , - 1._r8 / alpha , - s , 0._r8 , & - s / alpha , 1._r8 / alpha , - s , 0._r8 , & s / alpha , - 1._r8 / alpha , s , 0._r8 ], & [ 4 , 4 ]) ! Construct and factor matrix used for satisfying boundary conditions dummy_in = [( 1 , 0 ), ( 0 , 1 ), ( 0.5 , 0.5 ), ( - 0.5 , 0.5 )] this % bound_matrix = reshape ([(( cmplx ( this % V_r ( i , j ), this % V_i ( i , j ), r8 ) * & exp ( cmplx ( this % D_r ( j ), this % D_i ( j ), r8 ) * & this % xbounds ( i )), i = 1 , 4 ), j = 1 , 4 )], [ 4 , 4 ]) this % bound_matrix_scaled = this % bound_matrix call la_gesvx ( this % bound_matrix_scaled , dummy_in , dummy_out , & this % factored_matrix , this % pivots , 'E' , trans , & this % equed , this % r_scales , this % c_scales , & rcond = rcond , info = info ) if ( info /= 0 ) then msg = 'Tridiagonal matrix solver returned with flag ' // str ( info ) call logger % error ( 'coriolis_block' , msg ) end if msg = 'Boundary matrix factored with estimated condition ' // & 'number ' // str ( 1._r8 / rcond ) call logger % trivia ( 'coriolis_block' , msg ) #ifdef DEBUG call logger % debug ( 'coriolis_block' , & 'Successfully constructed Coriolis preconditioner block.' ) #endif call template % clean_temp () contains pure function linear ( x ) result ( scalar ) real ( r8 ), dimension (:), intent ( in ) :: x !! The position at which this function is evaluated real ( r8 ) :: scalar scalar = x ( 1 ) end function linear end function constructor subroutine solve_for ( this , velocity , velocity_dx ) !* Author: Chris MacMackin !  Date: January 2018 ! ! Inverts the linear portions of the plume momentum equation with ! the provided data. This is done by solving the linear ODE ! described in the documentation for the [[coriolis_block]] ! type. The block object must first have been initialised using ! the constructor. ! ! @Warning Currently this is only implemented for a 1-D field. ! class ( coriolis_block ), intent ( inout ) :: this class ( vector_field ), intent ( inout ) :: velocity !! On input, the velocity value being preconditioned. On output, !! the preconditioned velocity. class ( vector_field ), intent ( inout ) :: velocity_dx !! On input, the velocity derivative being preconditioned. On !! output, the preconditioned velocity derivative. type ( cheb1d_scalar_field ), dimension ( 4 ) :: F , eDxC_r , eDxC_i , E_r , E_i integer :: i real ( r8 ), dimension ( 1 ) :: rtmp , ctmp real ( r8 ), dimension ( 4 ) :: bound_vals complex ( r8 ), dimension ( 4 ) :: rhs , B , C_bounds type ( cheb1d_scalar_field ) :: tmp integer :: info real ( r8 ) :: rcond call velocity % guard_temp (); call velocity_dx % guard_temp () ! Construct array of scalar matrices for easier manipulation F ( 1 ) = velocity % component ( 1 ) F ( 2 ) = velocity % component ( 2 ) F ( 3 ) = velocity_dx % component ( 1 ) F ( 4 ) = velocity_dx % component ( 2 ) ! Get boundary values tmp = F ( 1 )% get_boundary ( this % integrate_bound , 1 ) rtmp = tmp % raw () bound_vals ( 1 ) = rtmp ( 1 ) tmp = F ( 2 )% get_boundary ( this % integrate_bound , 1 ) rtmp = tmp % raw () bound_vals ( 2 ) = rtmp ( 1 ) tmp = F ( 3 )% get_boundary ( this % integrate_bound , 1 ) rtmp = tmp % raw () bound_vals ( 3 ) = rtmp ( 1 ) tmp = F ( 4 )% get_boundary ( this % integrate_bound , 1 ) rtmp = tmp % raw () bound_vals ( 4 ) = rtmp ( 1 ) ! If have boundary conditions at both boundaries, correct the ! input fields !    if (this%vel_bound_loc /= this%integrate_bound) then !      F(1) = this%integrator%solve_for(F(1), this%vel_bound_loc, zero) !      F(1) = F(1)%d_dx(1) !      F(2) = this%integrator%solve_for(F(2), this%vel_bound_loc, zero) !      F(2) = F(2)%d_dx(1) !    end if !    if (this%dvel_bound_loc /= this%integrate_bound) then !      F(3) = this%integrator%solve_for(F(3), this%dvel_bound_loc, zero) !      F(3) = F(3)%d_dx(1) !      F(4) = this%integrator%solve_for(F(4), this%dvel_bound_loc, zero) !      F(4) = F(4)%d_dx(1) !    end if ! Calculate e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1}\\bm{F}, aliasing variables ! which are not needed yet associate ( emDxVinvF_r => eDxC_r , emDxVinvF_i => eDxC_i , & M_r => this % emDxVinv_r , M_i => this % emDxVinv_i , & C_r => E_r , C_i => E_i ) emDxVinvF_r = [( M_r ( i , 1 ) * F ( 1 ) + M_r ( i , 2 ) * F ( 2 ) + M_r ( i , 3 ) * F ( 3 ) + & M_r ( i , 4 ) * F ( 4 ), i = 1 , 4 )] emDxVinvF_i = [( M_i ( i , 1 ) * F ( 1 ) + M_i ( i , 2 ) * F ( 2 ) + M_i ( i , 3 ) * F ( 3 ) + & M_i ( i , 4 ) * F ( 4 ), i = 1 , 4 )] ! Integrate e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1}\\bm{F} to get \\bm{C} C_r = [( this % integrator % solve_for ( emDxVinvF_r ( i ), this % integrate_bound , & zero ), i = 1 , 4 )] emDxVinvF_r ( 1 ) = C_r ( 4 )% d_dx ( 1 ) C_i = [( this % integrator % solve_for ( emDxVinvF_i ( i ), this % integrate_bound , & zero ), i = 1 , 4 )] ! Get the values of e&#94;{\\bm{D}x}\\bm{C} at the upper boundary do i = 1 , 4 tmp = C_r ( i )% get_boundary ( - this % integrate_bound , 1 ) rtmp = tmp % raw () tmp = C_i ( i )% get_boundary ( - this % integrate_bound , 1 ) ctmp = tmp % raw () C_bounds ( i ) = cmplx ( rtmp ( 1 ), ctmp ( 1 ), r8 ) end do ! Calculate e&#94;{\\bm{D}x}\\bm{C} eDxC_r = [( this % eDx_r ( i ) * C_r ( i ) - this % eDx_i ( i ) * C_i ( i ), i = 1 , 4 )] eDxC_i = [( this % eDx_r ( i ) * C_i ( i ) + this % eDx_i ( i ) * C_r ( i ), i = 1 , 4 )] end associate ! Compute RHS for the linear system satisfying the boundary conditions if ( this % vel_bound_loc == this % integrate_bound ) then rhs ( 1 : 2 ) = bound_vals ( 1 : 2 ) else rhs ( 1 : 2 ) = bound_vals ( 1 : 2 ) - matmul ( this % bound_matrix ( 1 : 2 ,:), & C_bounds ) end if if ( this % dvel_bound_loc == this % integrate_bound ) then rhs ( 3 : 4 ) = bound_vals ( 3 : 4 ) else rhs ( 3 : 4 ) = bound_vals ( 3 : 4 ) - matmul ( this % bound_matrix ( 3 : 4 ,:), & C_bounds ) end if ! Compute coefficients for inhomogeneous components of solution so ! that boundary conditions are satisfied call la_gesvx ( this % bound_matrix_scaled , rhs , B , this % factored_matrix , & this % pivots , 'F' , trans , this % equed , this % r_scales , & this % c_scales , info = i ) !print*,this%D_r !print*,this%D_i !print*,B ! Calculate \\bm{E} = e&#94;{\\bm{D}x}\\bm{B} + e&#94;{\\bm{D}x}\\bm{C} E_r = [( this % eDx_r ( i ) * real ( B ( i )) - this % eDx_i ( i ) * aimag ( B ( i )) + & eDxC_r ( i ), i = 1 , 4 )] E_i = [( this % eDx_i ( i ) * real ( B ( i )) + this % eDx_r ( i ) * aimag ( B ( i )) + & eDxC_i ( i ), i = 1 , 4 )] ! Transform back to proper basis to get proper solution F = [( this % V_r ( i , 1 ) * E_r ( 1 ) - this % V_i ( i , 1 ) * E_i ( 1 ) + & this % V_r ( i , 2 ) * E_r ( 2 ) - this % V_i ( i , 2 ) * E_i ( 2 ) + & this % V_r ( i , 3 ) * E_r ( 3 ) - this % V_i ( i , 3 ) * E_i ( 3 ) + & this % V_r ( i , 4 ) * E_r ( 4 ) - this % V_i ( i , 4 ) * E_i ( 4 ), i = 1 , 4 )] velocity = F ( 1 : 2 ) velocity_dx = F ( 3 : 4 ) call velocity % clean_temp (); call velocity_dx % clean_temp () end subroutine solve_for subroutine assign ( this , rhs ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Safely assigns the value of one coriolis block to another. ! class ( coriolis_block ), intent ( inout ) :: this class ( coriolis_block ), intent ( in ) :: rhs !! The value being assigned this % D_r = rhs % D_r this % D_i = rhs % D_i this % emDxVinv_r = rhs % emDxVinv_r this % emDxVinv_i = rhs % emDxVinv_i this % eDx_r = rhs % eDx_r this % eDx_i = rhs % eDx_i this % V_r = rhs % V_r this % V_i = rhs % V_i this % integrator = rhs % integrator this % vel_bound_loc = rhs % vel_bound_loc this % dvel_bound_loc = rhs % dvel_bound_loc this % integrate_bound = rhs % integrate_bound this % xbounds = rhs % xbounds this % bound_matrix = rhs % bound_matrix this % bound_matrix_scaled = rhs % bound_matrix_scaled this % factored_matrix = rhs % factored_matrix this % pivots = rhs % pivots this % r_scales = rhs % r_scales this % c_scales = rhs % c_scales this % equed = rhs % equed end subroutine assign end module coriolis_block_mod"},{"title":"ode_solvers.f90 – ISOFT","tags":"","loc":"sourcefile/ode_solvers.f90.html","text":"This file depends on sourcefile~~ode_solvers.f90~~EfferentGraph sourcefile~ode_solvers.f90 ode_solvers.f90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~ode_solvers.f90->sourcefile~nitsol.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~ode_solvers.f90~~AfferentGraph sourcefile~ode_solvers.f90 ode_solvers.f90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~ode_solvers.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~ode_solvers.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~ode_solvers.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ode_solvers_mod Source Code ode_solvers.f90 Source Code ! !  ode_solvers.f90 !  This file is part of ISOFT. ! !  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module ode_solvers_mod !* Author: Christopher MacMackin !  Date: March 2017 !  License: GPLv3 ! ! Provides routines to solve systems of ODEs. ! use iso_fortran_env , only : r8 => real64 use nitsol_mod , only : gmres_solve , dnrm2 , iplvl , tfqmr_solve , bicgstab_solve use logger_mod , only : logger => master_logger use penf , only : str implicit none abstract interface function L_intr ( u ) !! An interface for the (linear) left-hand-side of an ODE !! being solved by quasilinearisation. import :: r8 implicit none real ( r8 ), dimension (:), intent ( in ) :: u !! The state vector for the system of differential equations real ( r8 ), dimension ( size ( u )) :: L_intr end function L_intr function f_intr ( u ) !! An interface for the (nonlinear) right-hand-side of an ODE !! being solved by quasilinearisation. import :: r8 implicit none real ( r8 ), dimension (:,:), intent ( in ) :: u !! The state vector for the system of differential equations, !! and its derivatives. Column i represents the i-1 !! derivative. real ( r8 ), dimension ( size ( u , 1 )) :: f_intr end function f_intr function jac_intr ( u , du ) !! An interface for the product of the Jacobian of the !! (nonlinear) right-hand-side of an ODE and another vector. import :: r8 implicit none real ( r8 ), dimension (:,:), intent ( in ) :: u !! The state vector for the system of differential equations, !! and its derivatives, for which the Jacobian should be !! evaluated. Column i represents the i-1 derivative. real ( r8 ), dimension (:,:), intent ( in ) :: du !! The state vector for the system of differential equations, !! and its derivatives, which the Jacobian operates on. Column !! i represents the i-1 derivative. real ( r8 ), dimension ( size ( u , 1 )) :: jac_intr end function jac_intr function diff_intr ( u , n ) !! An interface for a function evaluating the derivative of the !! state vector. import :: r8 implicit none real ( r8 ), dimension (:), intent ( in ) :: u !! The state vector for the system of differential equations integer , intent ( in ) :: n !! The order of the derivative to take real ( r8 ), dimension ( size ( u )) :: diff_intr end function diff_intr function pre_intr ( v , u , L , f , fcur , rhs ) !! An interface for a preconditioner to be used with the !! quasilinearisation ODE solver. import :: r8 implicit none real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be preconditioned. real ( r8 ), dimension (:,:), intent ( in ) :: u !! The current state vector for the system of differential !! equations, and its derivatives. Column i represents the !! i-1 derivative. procedure ( L_intr ) :: L !! The linear, left-hand-side of the ODE being solved. procedure ( f_intr ) :: f !! The nonlinear, right-hand-side of the ODE being solved. real ( r8 ), dimension (:), intent ( in ) :: fcur !! The result of `f(u)` real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being !! preconditioned. real ( r8 ), dimension ( size ( v )) :: pre_intr !! The result of applying the preconditioner. end function pre_intr end interface contains subroutine quasilinear_solve ( L , f , jac_prod , solution , order , resid_norm , & flag , info , tol , precond , differentiate , & iter_max , gmres_iter_max , krylov_dim ) !* Author: Chris MacMackin !  Date: March 2017 ! ! This is an iterative method to solve nonlinear systems of ! ODEs. Consider  L&#94;{(n)}\\vec{u}(x) = \\vec{f}(\\vec{u}(x), ! \\vec{u}&#94;{(1)}(x), \\ldots, \\vec{u}&#94;{n-1}(x), x), \\qquad \\vec{u} ! \\in \\mathbb{R}&#94;{m}.  For a domain from  (0,b) , boundary ! conditions are specified by  g_k(\\vec{u}(0) = 0, ! \\vec{u}&#94;{(1)}(0), \\ldots, \\vec{u}&#94;{n-1}(0)), \\qquad k = 1, ! \\ldots, l   g_k(\\vec{u}(b), \\vec{u}&#94;{(1)}(b), \\ldots, ! \\vec{u}&#94;{n-1}(b)) = 0, \\qquad k = l+1, \\ldots, mn.  Here, ! L&#94;{(n)} is an nth order ordinary differential operator, ! and \\vec{f}, g_1, g_2, \\ldots, g_{nm} are nonlinear ! functions of \\vec{u}(x) and its first n-1 derivatives. ! ! With quasilinearisation method, we iterate according to  ! L&#94;{(n)}\\vec{u}_{r+1}(x) = \\vec{f}(\\vec{u}_r(x), ! \\vec{u}&#94;{(1)}_r(x), \\ldots, \\vec{u}&#94;{n-1}_r(x), x) + \\\\ ! \\qquad\\sum_{s=0}&#94;{n-1}\\vec{f}_{\\vec{u}&#94;{(s)}}(\\vec{u}_r(x), ! \\vec{u}&#94;{(1)}_r(x), \\ldots, \\vec{u}&#94;{n-1}_r(x), ! x)(\\vec{u}&#94;{(s)}_{r+1}(x) - \\vec{u}&#94;{(s)}_r(x)).  The boundary ! conditions are iterated according to  \\sum_{s=0}&#94;{n-1} ! g_{k,\\vec{u}&#94;{(s)}}(\\vec{u}_r(0), \\vec{u}&#94;{(1)}_r(0), \\ldots, ! \\vec{u}&#94;{n-1}_r(0), x)\\cdot(\\vec{u}&#94;{(s)}_{r+1}(0) - ! \\vec{u}&#94;{(s)}_r(0)) = 0, k=1,\\ldots,l and  \\sum_{s=0}&#94;{n-1} ! g_{k,\\vec{u}&#94;{(s)}}(\\vec{u}_r(b), \\vec{u}&#94;{(1)}_r(b), \\ldots, ! \\vec{u}&#94;{n-1}_r(b), x)\\cdot(\\vec{u}&#94;{(s)}_{r+1}(b) - ! \\vec{u}&#94;{(s)}_r(b)) = 0, k=l+1,\\ldots,mn. Here, ! \\vec{f}_{\\vec{u}&#94;{(s)}} is the derivative of \\vec{f} ! with respect to \\vec{u}&#94;{(s)} and is a tensor, while ! g_{k,\\vec{u}&#94;{(s)}} is the derivative of g_k with ! respect to \\vec{u}&#94;{(s)} and is a vector. ! ! The user must provide functions for L and ! \\vec{f}. Currently this implementation only handles linear ! boundary conditions, which remain the same between ! iterations. The boundary conditions should be handled in the ! functions passed as arguments. In most situations, a ! preconditioner will also be needed. A simple one is to ! approximate L&#94;{-1}. The derivatives of \\vec{f} and ! g_k are estimated using a finite-difference. ! !####Output parameters ! ! On output, the components of the `info` argument are as follows: ! !     info(1)   = nLe   (number of evaluations of `L`) !     info(2)   = nfe   (number of evaluations of `f`) !     info(3)   = nrpre (number of preconditioner evaluations) !     info(4)   = nli   (number of linear iterations) !     info(5)   = nni   (number of nonlinear iterations) ! procedure ( L_intr ) :: L !! A function providing the linear, left-hand-side of the ODE !! being solved. procedure ( f_intr ) :: f !! A function providing the nonlinear, right-hand-side of the !! ODE being solved. procedure ( jac_intr ) :: jac_prod !! A function providing the product of the Jacobian of the !! nonlinear, right-hand-side of the ODE being solved and !! another vector. real ( r8 ), dimension (:), intent ( inout ) :: solution !! On input, an estimate of the solution to the ODE. On output, !! the actual solution. integer , intent ( in ) :: order !! The order of the derivative taken by `L` real ( r8 ), intent ( out ) :: resid_norm !! Norm of the residual of the final solution. integer , intent ( out ) :: flag !! Status flag indicating whether the iterations ended succesfully. !! !!< 0: !!:    `|flag|` is [[gmres_solve]] return code !! !!0 !!:    Normal termination: acceptable solution found !! !!1 !!:    Convergence, but residual greater than required tolerance !! !!2 !!:    Solution did not converge within `iter_max` iterations !! !!3 !!:    Solution began to diverge !! !!4 !!:    No `diff` procedure provided when `order > 1` !! integer , dimension ( 5 ), intent ( out ), optional :: info !! Array containing various outputs; see above real ( r8 ), intent ( in ), optional :: tol !! The required reduction in the solution residual. Default is !! `size(solution) * 1e-8`. procedure ( pre_intr ), optional :: precond !! A right-preconditioner which may be used to improve !! convergence of the solution. procedure ( diff_intr ), optional :: differentiate !! A procedure which will evaluate the `n`th derivative of the !! state vector, when `n` is less than `order`. integer , intent ( in ), optional :: iter_max !! Maximum allowable number of quasilinearised !! iterations. Default is 15. integer , intent ( in ), optional :: gmres_iter_max !! Maximum allowable number of GMRES iterations. Default is !! 1000. integer , intent ( in ), optional :: krylov_dim !! Maximum Krylov subspace dimension; default 10. Larger values !! will allow for faster convergence (and in some cases be the !! difference between whether or not convergence is possible), !! but require more memory. integer :: npoints , itmax , gitmax , kdim real ( r8 ) :: eta , gmres_eta integer :: i , stagnant_iters , gmres_flag integer :: nlhs , nrpre , nli , tnlhs , tnrpre , tnli real ( r8 ) :: init_resid , old_resid , gmres_norm real ( r8 ), dimension ( size ( solution ), order ) :: u_prev real ( r8 ), dimension ( size ( solution )) :: f_prev , rhs tnlhs = 0 tnrpre = 0 tnli = 0 if (. not . present ( differentiate ) . and . order > 1 ) then flag = 3 call logger % error ( 'quasilinear_solve' , 'Did not provide routine ' // & 'to get derivative values.' ) return end if npoints = size ( solution ) if ( present ( tol )) then eta = tol else eta = 1.e-8_r8 * npoints end if if ( present ( iter_max )) then itmax = iter_max else itmax = 15 end if if ( present ( gmres_iter_max )) then gitmax = gmres_iter_max else gitmax = 1000 end if if ( present ( krylov_dim )) then kdim = krylov_dim else kdim = 10 end if i = 0 stagnant_iters = 0 u_prev = get_derivs ( solution ) f_prev = f ( u_prev ) resid_norm = dnrm2 ( npoints , L ( solution ) - f_prev , 1 ) init_resid = resid_norm old_resid = resid_norm * 1 e3_r8 do while ( resid_norm > eta ) call logger % trivia ( 'quasilinear_solve' , 'Nonlinear iteration ' // str ( i ) // & ', with ' // str ( tnli ) // 'linear iterations, and residual ' // str ( resid_norm )) i = i + 1 if ( abs ( old_resid - resid_norm ) / resid_norm < 1 e - 2_r8 ) then stagnant_iters = stagnant_iters + 1 else stagnant_iters = 0 end if if ( stagnant_iters > 3 ) then flag = 1 return end if if ( i > itmax ) then flag = 2 return end if if ( 20 * old_resid < resid_norm ) then flag = 3 return end if rhs = f_prev - jac_prod ( u_prev , u_prev ) gmres_eta = max ( min ( eta * 1 0._r8 ** min ( i + 2 , 6 ), 1 e - 4_r8 ), 1 e - 10_r8 ) gmres_eta = gmres_eta * 1 0._r8 ** ( - 2 * stagnant_iters ) call gmres_solve ( solution , lin_op , rhs , gmres_norm , gmres_flag , & nlhs , nrpre , nli , gmres_eta , preconditioner , & resid_update = 0 , iter_max = gitmax , krylov_dim = kdim ) tnlhs = tnlhs + nlhs tnrpre = tnrpre + nrpre tnli = tnli + nli if ( gmres_flag > 0 ) call logger % warning ( 'quasilinear_solve' , & 'GMRES solver returned with flag ' // str ( gmres_flag )) u_prev = get_derivs ( solution ) f_prev = f ( u_prev ) old_resid = resid_norm resid_norm = dnrm2 ( npoints , L ( solution ) - f_prev , 1 ) if ( gmres_flag /= 0 . and . ( resid_norm > 20 * old_resid . or . any ( isnan ( solution )))) then if ( present ( info )) then info ( 1 ) = i + tnlhs + tnrpre info ( 2 ) = 2 * i + tnlhs info ( 3 ) = tnrpre info ( 4 ) = tnli info ( 5 ) = i end if if ( init_resid < resid_norm ) then flag = 3 else flag = - gmres_flag end if return end if end do if ( present ( info )) then info ( 1 ) = 1 + i + tnlhs + tnrpre info ( 2 ) = 1 + 2 * i + tnlhs info ( 3 ) = tnrpre info ( 4 ) = tnli info ( 5 ) = i end if flag = 0 call logger % trivia ( 'quasilinear_solve' , 'Nonlinear iteration ' // str ( i ) // & ', with ' // str ( tnli ) // ' linear iterations, and residual ' // str ( resid_norm )) contains function get_derivs ( v ) !! Calculates the necessary number of derivatives and assembles !! them in 2-D array. real ( r8 ), dimension (:), intent ( in ) :: v real ( r8 ), dimension ( size ( v ), order ) :: get_derivs integer :: j get_derivs (:, 1 ) = v do j = 2 , order get_derivs (:, j ) = differentiate ( v , i - 1 ) end do end function get_derivs function lin_op ( v , xcur , rhs , rpar , ipar , success ) !! The linear operator for the quasilinearised system. real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be operated upon real ( r8 ), dimension (:), intent ( in ) :: xcur !! Array containing the current estimate of the independent !! variables in the linear system. This may not be needed, but !! is provided just in case. real ( r8 ), dimension (:), intent ( in ) :: rhs !! Array containing the right hand side of the linear !! system. This may not be needed, but is provided just in !! case. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array logical , intent ( out ) :: success !! Indicates whether operation was completed succesfully real ( r8 ), dimension ( size ( xcur )) :: lin_op !! Result of the operation real ( r8 ), dimension ( size ( xcur ), order ) :: v_derivs v_derivs = get_derivs ( v ) lin_op = L ( v ) - jac_prod ( u_prev , v_derivs ) success = . true . end function lin_op function preconditioner ( v , xcur , rhs , rpar , ipar , success ) !! The preconditioner for the quasilinearised system. real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be preconditioned real ( r8 ), dimension (:), intent ( in ) :: xcur !! Array containing the current estimate of the independent !! variables in the linear system. This may not be needed, but !! is provided just in case. real ( r8 ), dimension (:), intent ( in ) :: rhs !! Array containing the right hand side of the linear !! system. This may not be needed, but is provided just in !! case. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array logical , intent ( out ) :: success !! Indicates whether operation was completed succesfully real ( r8 ), dimension ( size ( xcur )) :: preconditioner !! Result of the operation preconditioner = precond ( v , reshape ( xcur , [ size ( xcur ), 1 ]), L , f , f_prev , rhs ) success = . true . end function preconditioner end subroutine quasilinear_solve end module ode_solvers_mod"},{"title":"meta_implementation.F90 – ISOFT","tags":"","loc":"sourcefile/meta_implementation.f90.html","text":"This file depends on sourcefile~~meta_implementation.f90~~EfferentGraph sourcefile~meta_implementation.f90 meta_implementation.F90 sourcefile~meta.f90 meta.F90 sourcefile~meta_implementation.f90->sourcefile~meta.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules meta_implementation_mod Source Code meta_implementation.F90 Source Code ! !  meta_parameters.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! submodule ( meta_mod ) meta_implementation_mod !* Author: Chris MacMackin !  Date: November 2016 !  License: GPLv3 ! ! Implements functions specifying the version of ISOFT, time of ! compilation, etc. This is done in a submodule because it should be ! recompiled with every build (so that compilation time is accurate) ! but without a submodule that would require every module using it ! to be recompiled as well. ! implicit none character ( len = 20 ), parameter :: compile_time_val = __ DATE__ // ' ' // __ TIME__ character ( len = 5 ), parameter :: version_num = '1.0.0' contains module function version () version = version_num end function version module function compile_time () compile_time = compile_time_val end function compile_time module function compile_info () character ( len = 40 ), parameter :: result_format = & '(\"Compiled with \",a,\" using options \",a)' write ( compile_info , result_format ) compiler_version (), compiler_options () compile_info = 'Compiled with \"' // compiler_version () // & '\" using options \"' // compiler_options () // & '\"' end function compile_info end submodule meta_implementation_mod"},{"title":"plume.F90 – ISOFT","tags":"","loc":"sourcefile/plume.f90.html","text":"This file depends on sourcefile~~plume.f90~~EfferentGraph sourcefile~plume.f90 plume.F90 sourcefile~entrainment.f90 entrainment.F90 sourcefile~plume.f90->sourcefile~entrainment.f90 sourcefile~plume_boundary.f90 plume_boundary.F90 sourcefile~plume.f90->sourcefile~plume_boundary.f90 sourcefile~ode_solvers.f90 ode_solvers.f90 sourcefile~plume.f90->sourcefile~ode_solvers.f90 sourcefile~dallaston2015_melt.f90 dallaston2015_melt.F90 sourcefile~plume.f90->sourcefile~dallaston2015_melt.f90 sourcefile~jenkins1991_entrainment.f90 jenkins1991_entrainment.F90 sourcefile~plume.f90->sourcefile~jenkins1991_entrainment.f90 sourcefile~melt_relationship.f90 melt_relationship.F90 sourcefile~plume.f90->sourcefile~melt_relationship.f90 sourcefile~uniform.f90 uniform.F90 sourcefile~plume.f90->sourcefile~uniform.f90 sourcefile~simple_plume.f90 simple_plume.F90 sourcefile~plume.f90->sourcefile~simple_plume.f90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~plume.f90->sourcefile~boundary_types.f90 sourcefile~upstream_plume.f90 upstream_plume.F90 sourcefile~plume.f90->sourcefile~upstream_plume.f90 sourcefile~basal_surface.f90 basal_surface.F90 sourcefile~plume.f90->sourcefile~basal_surface.f90 sourcefile~ambient.f90 ambient.F90 sourcefile~plume.f90->sourcefile~ambient.f90 sourcefile~pseudospectral_block.f90 pseudospectral_block.F90 sourcefile~plume.f90->sourcefile~pseudospectral_block.f90 sourcefile~equation_of_state.f90 equation_of_state.F90 sourcefile~plume.f90->sourcefile~equation_of_state.f90 sourcefile~linear_eos.f90 linear_eos.F90 sourcefile~plume.f90->sourcefile~linear_eos.f90 sourcefile~plume_boundary.f90->sourcefile~boundary_types.f90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~ode_solvers.f90->sourcefile~nitsol.f90 sourcefile~dallaston2015_melt.f90->sourcefile~melt_relationship.f90 sourcefile~jenkins1991_entrainment.f90->sourcefile~entrainment.f90 sourcefile~uniform.f90->sourcefile~ambient.f90 sourcefile~simple_plume.f90->sourcefile~plume_boundary.f90 sourcefile~simple_plume.f90->sourcefile~boundary_types.f90 sourcefile~upstream_plume.f90->sourcefile~plume_boundary.f90 sourcefile~upstream_plume.f90->sourcefile~boundary_types.f90 sourcefile~rksuite_90.f90 rksuite_90.f90 sourcefile~upstream_plume.f90->sourcefile~rksuite_90.f90 sourcefile~uniform_gradient_field.f90 uniform_gradient_field.f90 sourcefile~upstream_plume.f90->sourcefile~uniform_gradient_field.f90 sourcefile~basal_surface.f90->sourcefile~nitsol.f90 sourcefile~linear_eos.f90->sourcefile~equation_of_state.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules plume_mod Source Code plume.F90 Source Code ! !  plume.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module plume_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides a concrete implementation of the [[basal_surface(type)]] data type, ! representing a buoyant plume beneath an ice shelf. ! use iso_fortran_env , only : r8 => real64 use basal_surface_mod , only : basal_surface , hdf_type_attr use factual_mod , only : scalar_field , vector_field , cheb1d_scalar_field , & cheb1d_vector_field , uniform_scalar_field , & uniform_vector_field use ode_solvers_mod , only : quasilinear_solve use entrainment_mod , only : abstract_entrainment use melt_relationship_mod , only : abstract_melt_relationship use plume_boundary_mod , only : plume_boundary use upstream_plume_mod , only : upstream_plume_boundary use boundary_types_mod , only : free_boundary , dirichlet , neumann use ambient_mod , only : ambient_conditions use equation_of_state_mod , only : equation_of_state use jenkins1991_entrainment_mod , only : jenkins1991_entrainment use dallaston2015_melt_mod , only : dallaston2015_melt use uniform_ambient_mod , only : uniform_ambient_conditions use simple_plume_boundary_mod , only : simple_plume_boundary use pseudospectral_block_mod , only : pseudospec_block use linear_eos_mod , only : linear_eos use hdf5 use h5lt use logger_mod , only : logger => master_logger use penf , only : str implicit none private character ( len = 9 ), parameter , public :: hdf_type_name = 'plume' character ( len = 9 ), parameter , public :: hdf_thickness = 'thickness' character ( len = 8 ), parameter , public :: hdf_velocity = 'velocity' character ( len = 11 ), parameter , public :: hdf_temperature = 'temperature' character ( len = 8 ), parameter , public :: hdf_salinity = 'salinity' character ( len = 5 ), parameter , public :: hdf_delta = 'delta' character ( len = 2 ), parameter , public :: hdf_nu = 'nu' character ( len = 2 ), parameter , public :: hdf_mu = 'mu' character ( len = 5 ), parameter , public :: hdf_r = 'r_val' character ( len = 3 ), parameter , public :: hdf_phi = 'phi' type , extends ( basal_surface ), public :: plume !* Author: Christopher MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[basal_surface(type)]] ! abstract data type, representing the buoyant plume beneath an ! ice shelf. ! private type ( cheb1d_scalar_field ) :: thickness !! The thickness of the plume type ( cheb1d_vector_field ) :: velocity !! The velocity of the plume type ( cheb1d_vector_field ) :: velocity_dx !! The derivative of the velocity field type ( cheb1d_scalar_field ) :: temperature !! The temperature of the plume type ( cheb1d_scalar_field ) :: temperature_dx !! The derivative of the temperature of the plume type ( cheb1d_scalar_field ) :: salinity !! The salinity of the plume type ( cheb1d_scalar_field ) :: salinity_dx !! The derivative of the salinity of the plume class ( abstract_entrainment ), allocatable :: entrainment_formulation !! An object which provides the parameterisation for entrainment !! of water into the plume. class ( abstract_melt_relationship ), allocatable :: melt_formulation !! An object which provides the parameterisation for melting, !! salt, and heat fluxes from the plume to the ice. class ( ambient_conditions ), allocatable :: ambient_conds !! An object specifying the temperature and salinity of the !! ambient ocean at its interface with the plume. class ( equation_of_state ), allocatable , public :: eos !! An object specifying the equation of state relating the plume !! water's density to its temperature and salinity. class ( plume_boundary ), allocatable :: boundaries !! An object specifying the boundary conditions for the plume. real ( r8 ) :: delta !! The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real ( r8 ), public :: nu !! The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real ( r8 ) :: mu !! The dimensionless ratio \\mu \\equiv \\frac{C_dx_0}{D_0} real ( r8 ) :: r_val !! The dimensionless ratio of the ocean water density to the !! density of the overlying ice shelf. real ( r8 ), public :: phi !! The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} real ( r8 ) :: time !! The time at which the ice shelf is in this state integer :: thickness_size !! The number of data values in the thickness field integer :: velocity_size !! The number of data values in the velocity field integer :: temperature_size !! The number of data values in the temperature field integer :: salinity_size !! the number of data values in the salinity field logical , dimension ( 7 ) :: lower_bounds = . false . !! Which variables have boundary conditions at the grounding !! line. logical , dimension ( 7 ) :: upper_bounds = . false . !! Which variables have boundary conditions at the calving !! front. type ( pseudospec_block ) :: precond !! A pseudospectral differentiation block which can be used for !! preconditioning. contains procedure :: initialise => plume_initialise procedure :: basal_melt => plume_melt procedure :: basal_drag_parameter => plume_drag_parameter procedure :: water_density => plume_water_density procedure :: update => plume_update procedure :: data_size => plume_data_size procedure :: state_vector => plume_state_vector procedure :: read_data => plume_read_data procedure :: write_data => plume_write_data procedure :: solve => plume_solve end type plume abstract interface #ifdef DEBUG #undef pure #undef elemental #endif pure function scalar_func ( location ) result ( scalar ) !* Author: Chris MacMackin !  Date: April 2016 ! ! Abstract interface for function providing the initial values ! for the scalar properties of a [[plume(type)]] object when it ! is being instantiated. ! import :: r8 real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the property real ( r8 ) :: scalar !! The value of the scalar quantity at `location` end function scalar_func pure function velocity_func ( location ) result ( vector ) !* Author: Chris MacMackin !  Date: April 2016 ! ! Abstract interface for function providing the [[plume(type)]] velocity ! when an object is being instantiated. ! import :: r8 real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the thickness real ( r8 ), dimension (:), allocatable :: vector !! The velocity vector of the water in the plume at `location` end function velocity_func #ifdef DEBUG #define pure #define elemental #endif end interface contains subroutine plume_initialise ( this , domain , resolution , thickness , velocity , & temperature , salinity , entrainment_formulation , & melt_formulation , ambient_conds , eos , boundaries , & delta , nu , mu , r_val , phi ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Instantiates a [[plume(type)]] object with initial coniditions ! provided by the arguments.At present only a 1D model is ! supported. If information is provided for higher dimensions then ! it will be ignored. ! class ( plume ), intent ( out ) :: this !! A plume object with its domain and initial conditions set according !! to the arguments of the constructor function. real ( r8 ), dimension (:,:), intent ( in ) :: domain !! An array containing the upper and lower limits of the domain for !! the plume. The first index represents the dimension for which the !! boundaries apply. If the second index is 1 then it corresponds to !! the lower bound. If the second index is 2 then it corresponds to !! the upper bound. integer , dimension (:), intent ( in ) :: resolution !! The number of data points in each dimension procedure ( scalar_func ) :: thickness !! A function which calculates the initial value of the thickness of !! the plume at a given location. procedure ( velocity_func ) :: velocity !! A function which calculates the initial value of the velocity !! (vector) of the water at a given location in a plume. procedure ( scalar_func ) :: temperature !! A function which calculates the initial value of the temperature of !! the plume at a given location. procedure ( scalar_func ) :: salinity !! A function which calculates the initial value of the salinity of !! the plume at a given location. class ( abstract_entrainment ), allocatable , optional , & intent ( inout ) :: entrainment_formulation !! An object which calculates entrainment into the plume. Will !! be unallocated on exit. Defaults to that used by Jenkins !! (1991) with the coefficient $E_0 = 1$. class ( abstract_melt_relationship ), allocatable , optional , & intent ( inout ) :: melt_formulation !! An object which calculates melting and the resulting thermal !! transfer into/out of the plume. Will be unallocated on !! exit. Defaults to that used by Dallaston et al. (2015), !! scaled to be consistent with the nondimensionalisation used !! here. class ( ambient_conditions ), allocatable , optional , & intent ( inout ) :: ambient_conds !! An object specifying the salinity and temperature of the !! ambient ocean. Will be unallocated on exit. Defaults to !! uniform ambient salinity and temperature, both of which are !! set to 0 (as temperature and salinity are measured relative !! to some reference value). class ( equation_of_state ), allocatable , optional , & intent ( inout ) :: eos !! An object specifying the equation of state for the water in !! the plume. Will be unallocated on exit. Defaults to !! linearised equation of state with no temperature dependence !! and a haline contraction coefficient of 1. The reference !! density is set to be 1 in the dimensionless units when !! salinity and temeprature are 0. class ( plume_boundary ), allocatable , optional , & intent ( inout ) :: boundaries !! An object providing the boundary conditions for the !! plume. Will be unallocated on exit. Defaults to those used by !! Dallaston et al. (2015). real ( r8 ), optional , intent ( in ) :: delta !! The dimensionless ratio \\delta \\equiv !! \\frac{D_0}{h_0}. Defaults to 0.036. real ( r8 ), optional , intent ( in ) :: nu !! The dimensionless ratio \\nu \\equiv !! \\frac{\\kappa_0}{x_0U_o}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: mu !! The dimensionless ratio \\mu \\equiv !! \\frac{\\C_dx_0}{D_0}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: r_val !! The dimensionless ratio of the water density to the ice shelf !! density,  r = \\rho_0/\\rho_i.  Defaults to 1.12. real ( r8 ), optional , intent ( in ) :: phi !! The inverse Rossby number, \\Phi \\equif !! \\frac{fx_0}{U_0}. Defaults to 0. integer :: i , btype_l , btype_u , bdepth_l , bdepth_u i = size ( velocity ([ 0._r8 ])) this % thickness = cheb1d_scalar_field ( resolution ( 1 ), thickness , domain ( 1 , 1 ), domain ( 1 , 2 )) this % velocity = cheb1d_vector_field ( resolution ( 1 ), velocity , domain ( 1 , 1 ), domain ( 1 , 2 ), i - 1 ) this % temperature = cheb1d_scalar_field ( resolution ( 1 ), temperature , domain ( 1 , 1 ), domain ( 1 , 2 )) this % salinity = cheb1d_scalar_field ( resolution ( 1 ), salinity , domain ( 1 , 1 ), domain ( 1 , 2 )) this % thickness_size = this % thickness % raw_size () this % velocity_size = this % velocity % raw_size () this % temperature_size = this % temperature % raw_size () this % salinity_size = this % salinity % raw_size () this % velocity_dx = this % velocity % d_dx ( 1 ) this % salinity_dx = this % salinity % d_dx ( 1 ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( present ( entrainment_formulation )) then call move_alloc ( entrainment_formulation , this % entrainment_formulation ) else allocate ( jenkins1991_entrainment :: this % entrainment_formulation ) end if if ( present ( melt_formulation )) then call move_alloc ( melt_formulation , this % melt_formulation ) else allocate ( dallaston2015_melt :: this % melt_formulation ) end if if ( present ( ambient_conds )) then call move_alloc ( ambient_conds , this % ambient_conds ) else allocate ( uniform_ambient_conditions :: this % ambient_conds ) end if if ( present ( eos )) then call move_alloc ( eos , this % eos ) else allocate ( linear_eos :: this % eos ) end if if ( present ( boundaries )) then call move_alloc ( boundaries , this % boundaries ) else allocate ( simple_plume_boundary :: this % boundaries ) end if if ( present ( delta )) then this % delta = delta else this % delta = 0.036_r8 end if if ( present ( nu )) then this % nu = nu else this % nu = 0.0_r8 end if if ( present ( mu )) then this % mu = mu else this % mu = 0.0_r8 end if if ( present ( r_val )) then this % r_val = r_val else this % r_val = 1.12_r8 end if if ( present ( phi )) then this % phi = phi else this % phi = 0.0_r8 end if this % time = 0.0_r8 ! Initialise preconditioner this % precond = pseudospec_block ( this % thickness ) ! Store information on boundary conditions call this % boundaries % thickness_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % thickness_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower thickness boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper thickness boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if #endif select case ( btype_l ) case ( free_boundary ) case ( dirichlet ) this % lower_bounds ( 1 ) = . true . case default error stop ( 'Only free, and Dirichlet boundary conditions ' // & 'supported for plume thickness.' ) end select select case ( btype_u ) case ( free_boundary ) case ( dirichlet ) this % upper_bounds ( 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for plume.' ) end select call this % boundaries % velocity_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % velocity_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower velocity boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper velocity boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 2 ) call this % boundaries % temperature_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % temperature_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower temperature boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper temperature boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 4 ) call this % boundaries % salinity_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % salinity_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower salinity boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper salinity boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 6 ) #ifdef DEBUG call logger % debug ( 'plume' , 'Initialised new ice shelf object.' ) #endif contains subroutine set_preconditioners ( ltype , utype , comp_id ) integer , intent ( in ) :: ltype , utype , comp_id select case ( ltype ) case ( free_boundary ) case ( dirichlet ) this % lower_bounds ( comp_id ) = . true . case ( neumann ) this % lower_bounds ( comp_id + 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for plume.' ) end select select case ( utype ) case ( free_boundary ) case ( dirichlet ) this % upper_bounds ( comp_id ) = . true . case ( neumann ) this % upper_bounds ( comp_id + 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for plume.' ) end select end subroutine set_preconditioners end subroutine plume_initialise function plume_melt ( this ) result ( melt ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the melt rate at the bottom of the ice ! shelf due to interaction with the plume. ! class ( plume ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate at the base of the ice shelf. melt => this % melt_formulation % melt_rate () end function plume_melt function plume_drag_parameter ( this ) result ( drag ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns a quantity which may be necessary to determine ! the frictional drag the plume exerts on the bottom of the ice ! shelf. The plume would actually tend to exert no drag on the bottom ! of the ice shelf, but this method is present so that there is a ! consistent interface with the [[ground(type)]] data type. ! class ( plume ), intent ( in ) :: this class ( scalar_field ), pointer :: drag !! The melt rate at the base of the ice sheet. type ( uniform_scalar_field ) :: dummy call dummy % allocate_scalar_field ( drag ) drag = uniform_scalar_field ( 0.0_r8 ) call drag % set_temp () #ifdef DEBUG call logger % debug ( 'plume%drag_parameter' , 'Returned plume drag parameter.' ) #endif end function plume_drag_parameter function plume_water_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the density of the plume water beneath the ice ! shelf. The density of this water would vary depending on how much ! saline ambient water has been entrained into the plume versus how ! much fresh water has been released due to melting. However, the ! Boussinesq approximation is used here and only a single reference ! density is returned. ! ! @NOTE Based on my approach to non-dimensionalisation, I'm pretty ! sure the density should always be 1, making this method ! unneccessary. ! class ( plume ), intent ( in ) :: this real ( r8 ) :: density !! The density of the water at the base of the ice sheet. density = 1.0_r8 #ifdef DEBUG call logger % debug ( 'plume%water_density' , 'Plume has average density ' // & trim ( str ( density )) // '.' ) #endif end function plume_water_density subroutine plume_update ( this , state_vector , ice_thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the plume from its state vector. The state ! vector is a real array containing the value of each of the plume's ! properties at each of the locations on the grid used in discretization. ! class ( plume ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! plume. class ( scalar_field ), optional , intent ( in ) :: ice_thickness !! The ice thickness which, if present, will be used to update !! the calculation of the melt rate. integer :: i !TODO: Add some assertion-like checks that the state vector is the right size call this % thickness % set_from_raw ( state_vector ( 1 : this % thickness_size )) i = 1 + this % thickness_size call this % velocity % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % velocity_dx % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % temperature % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % temperature_dx % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % salinity % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) i = i + this % salinity_size call this % salinity_dx % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) if ( present ( ice_thickness )) then call this % melt_formulation % solve_for_melt ( this % velocity , & - ice_thickness / this % r_val , & this % temperature , & this % salinity , & this % thickness , & this % time ) end if #ifdef DEBUG call logger % debug ( 'plume%update' , 'Updated state of plume.' ) #endif end subroutine plume_update function plume_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the plume's state vector. ! This is the size of the vector returned by ! [[plume(type):state_vector]] and taken as an argument by ! [[plume(type):update]]. ! class ( plume ), intent ( in ) :: this integer :: plume_data_size !! The number of elements in the plume's state vector. plume_data_size = this % thickness % raw_size () + this % velocity % raw_size () + & this % velocity_dx % raw_size () + this % temperature % raw_size () + & this % temperature_dx % raw_size () + this % salinity % raw_size () + & this % salinity_dx % raw_size () #ifdef DEBUG call logger % debug ( 'plume%data_size' , 'Plume shelf has ' // & trim ( str ( plume_data_size )) // ' elements ' // & 'in its state vector.' ) #endif end function plume_data_size function plume_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the plume. ! This takes the form of a 1D array. ! class ( plume ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the plume. state_vector = [ this % thickness % raw (), this % velocity % raw (), & this % velocity_dx % raw (), this % temperature % raw (), & this % temperature_dx % raw (), this % salinity % raw (), & this % salinity_dx % raw ()] #ifdef DEBUG call logger % debug ( 'plume%state_vector' , 'Returning state vector ' // & 'for plume.' ) #endif end function plume_state_vector subroutine plume_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the plume object from an HDF file in the ! specified group. This sets the thickness, velocity, temperature, ! salinity dataset, and parameter values. ! class ( plume ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err real ( r8 ), dimension ( 1 ) :: param character ( len = 50 ) :: base_type ret_err = 0 call h5gopen_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % error ( 'plume%read_data' , 'Could not open HDF group \"' // & group_name // '\", so no IO performed.' ) return end if call h5ltget_attribute_string_f ( file_id , group_name , hdf_type_attr , & base_type , error ) if ( trim ( base_type ) /= hdf_type_name ) then call logger % error ( 'plume%read_data' , 'Trying to read data from ' // & 'basal_surface of type other than plume.' ) error = - 1 return end if !call h5ltget_attribute_double_f(file_id, group_name, hdf_delta, & !                                param, error) !this%delta = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_nu, & !                                param, error) !this%nu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_mu, & !                                param, error) !this%mu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_r, & !                                param, error) !this%r_val = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_phi, & !                                param, error) !this%phi = param(1) !if (error /= 0) then !  call logger%warning('plume%read_data','Error code '//     & !                      trim(str(error))//' returned when '//  & !                      'reading attributes from HDF group '// & !                      group_name) !  ret_err = error !end if call this % thickness % read_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume thickness field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % read_hdf ( group_id , hdf_velocity , error ) this % velocity_dx = this % velocity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume velocity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % read_hdf ( group_id , hdf_temperature , error ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume temperature field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % read_hdf ( group_id , hdf_salinity , error ) this % salinity_dx = this % salinity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume salinity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err call logger % trivia ( 'plume%read_data' , 'Read plume data from HDF group ' // & group_name ) end subroutine plume_read_data subroutine plume_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the plume object to an HDF file in the ! specified group. This will consist of a thickness, a velocity, a ! temperature, and a salinity dataset. ! class ( plume ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err ret_err = 0 call h5gcreate_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned ' // & 'when creating HDF group \"' // group_name // '\"' ) call logger % error ( 'plume%write_data' , 'Data IO not performed for plume' ) return end if call h5ltset_attribute_string_f ( file_id , group_name , hdf_type_attr , & hdf_type_name , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_delta , & [ this % delta ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_nu , & [ this % nu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_mu , & [ this % mu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_r , & [ this % r_val ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_phi , & [ this % phi ], 1_size_t , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing attribute to HDF group ' // & group_name ) ret_err = error end if call this % thickness % write_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume thickness field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % write_hdf ( group_id , hdf_velocity , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume velocity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % write_hdf ( group_id , hdf_temperature , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume temperature field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % write_hdf ( group_id , hdf_salinity , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume salinity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err #ifdef DEBUG call logger % debug ( 'plume%write_data' , 'Wrote plume data to HDF group ' // & group_name ) #endif end subroutine plume_write_data subroutine plume_solve ( this , ice_thickness , ice_density , ice_temperature , & time , success ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Solves the state of the plume for the specified ice properties, ! at the specified time. This is done using the a ! quasilinearisation method and a GMRES iterative linear solver. ! class ( plume ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: ice_thickness !! Thickness of the ice above the basal surface real ( r8 ), intent ( in ) :: ice_density !! The density of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: ice_temperature !! The temperature of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: time !! The time to which the basal surface should be solved logical , intent ( out ) :: success !! True if the solver is successful, false otherwise real ( r8 ), dimension (:), allocatable :: solution real ( r8 ) :: residual integer , dimension ( 5 ) :: info integer :: flag class ( scalar_field ), pointer :: b call ice_thickness % guard_temp () b => - ice_thickness / this % r_val call b % guard_temp () select type ( bound => this % boundaries ) class is ( upstream_plume_boundary ) call bound % calculate ( time , non_diff_terms , b ) class default call bound % set_time ( time ) end select solution = this % state_vector () #ifdef DEBUG call logger % debug ( 'plume%solve' , 'Calling QLM ODE solver' ) #endif call quasilinear_solve ( L , f , jac_prod , solution , 1 , residual , flag , info , & 1.e-9_r8 * size ( solution ), precond = preconditioner , & iter_max = 100 , krylov_dim = 85 , gmres_iter_max = 5000 ) call this % update ( solution ) #ifdef DEBUG call logger % debug ( 'plume%solve' , 'QLM solver required ' // & trim ( str ( info ( 5 ))) // ' nonlinear iterations ' // & 'and ' // trim ( str ( info ( 1 ) + info ( 2 ))) // & ' function calls.' ) #endif select case ( flag ) case ( 0 ) call logger % trivia ( 'plume%solver' , 'Solved plume at time ' // trim ( str ( time ))) success = . true . this % time = time case ( 1 ) call logger % warning ( 'plume%solver' , 'Plume solver stagnated with ' // & 'residual of ' // trim ( str ( residual ))) success = . false . case ( 2 ) call logger % error ( 'plume%solver' , 'Reached maximum number of ' // & 'iterations solving plume' ) success = . false . case ( 3 ) call logger % error ( 'plume%solver' , 'Plume solution began to diverge.' ) success = . false . case default call logger % error ( 'plume%solve' , 'QLM solver failed for plume with ' // & 'error code ' // trim ( str ( flag ))) success = . false . end select call ice_thickness % clean_temp (); call b % clean_temp () contains function L ( v ) !! The linear differentiation operator real ( r8 ), dimension (:), intent ( in ) :: v !! The state vector for the system of differential equations real ( r8 ), dimension ( size ( v )) :: L integer :: st , en , btype_l , btype_u , bdepth_l , bdepth_u type ( cheb1d_scalar_field ) :: scalar_tmp type ( cheb1d_vector_field ) :: vector_tmp type ( cheb1d_vector_field ) :: coriolis call this % update ( v ) ! Thickness scalar_tmp = this % thickness % d_dx ( 1 ) call this % boundaries % thickness_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % thickness_bound_info ( 1 , btype_u , bdepth_u ) if ( this % lower_bounds ( 1 )) then call scalar_tmp % set_boundary ( - 1 , 1 , this % thickness % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % thickness % get_boundary ( 1 , 1 )) end if st = 1 en = st + this % thickness_size - 1 L ( st : en ) = scalar_tmp % raw () ! Velocity vector_tmp = this % velocity % d_dx ( 1 ) - this % velocity_dx if ( this % lower_bounds ( 2 )) then call vector_tmp % set_boundary ( - 1 , 1 , this % velocity % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % velocity_size - 1 L ( st : en ) = vector_tmp % raw () if ( this % phi /= 0._r8 ) then coriolis = [ 0._r8 , 0._r8 , this % phi / this % nu ] . cross . this % velocity vector_tmp = this % velocity_dx % d_dx ( 1 ) - coriolis else vector_tmp = this % velocity_dx % d_dx ( 1 ) end if if ( this % lower_bounds ( 3 )) then call vector_tmp % set_boundary ( - 1 , 1 , this % velocity_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % velocity_size - 1 L ( st : en ) = vector_tmp % raw () ! Temperature scalar_tmp = this % temperature % d_dx ( 1 ) - this % temperature_dx if ( this % lower_bounds ( 4 )) then call scalar_tmp % set_boundary ( - 1 , 1 , this % temperature % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % temperature_size - 1 L ( st : en ) = scalar_tmp % raw () scalar_tmp = this % temperature_dx % d_dx ( 1 ) if ( this % lower_bounds ( 5 )) then call scalar_tmp % set_boundary ( - 1 , 1 , this % temperature_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % temperature_size - 1 L ( st : en ) = scalar_tmp % raw () ! Salinity scalar_tmp = this % salinity % d_dx ( 1 ) - this % salinity_dx if ( this % lower_bounds ( 6 )) then call scalar_tmp % set_boundary ( - 1 , 1 , this % salinity % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % salinity_size - 1 L ( st : en ) = scalar_tmp % raw () scalar_tmp = this % salinity_dx % d_dx ( 1 ) if ( this % lower_bounds ( 7 )) then call scalar_tmp % set_boundary ( - 1 , 1 , this % salinity_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % salinity_size - 1 L ( st : en ) = scalar_tmp % raw () end function L subroutine non_diff_terms ( D , Uvec , T , S , b , DU_x , DUU_x , DUT_x , DUS_x ) !! Computes the values of (DU)_x, (DU\\vec{U})_x, !! (DUT)_x, (DUS)_x, when diffusion is not !! included. This should be able to handle uniform field types, !! for use in an ODE solver when integrating near the !! boundary. The momentum term is calculated quite differently !! depending on whether it is being done for the ODE solver !! orthe plume solver. For this reason, as well as the !! usefulness of avoiding taking any derivatives when !! calculating it, I have chosen not to bother calculating it !! here unless it is for the ODE solver. class ( scalar_field ), intent ( in ) :: D !! The plume thickness class ( vector_field ), intent ( in ) :: Uvec !! The plume velocity class ( scalar_field ), intent ( in ) :: T !! The plume temperature class ( scalar_field ), intent ( in ) :: S !! The plume salinity class ( scalar_field ), intent ( in ) :: b !! The debth of the base of the ice shelf class ( scalar_field ), intent ( out ) :: DU_x !! The derivative of the product DU class ( vector_field ), intent ( out ) :: DUU_x !! The derivative of the product DUU class ( scalar_field ), intent ( out ) :: DUT_x !! The derivative of the product DUT class ( scalar_field ), intent ( out ) :: DUS_x !! The derivative of the product DUS integer :: dims class ( scalar_field ), pointer :: m , rho , e , S_a , U , V , & T_a , rho_a , rho_x , Unorm class ( scalar_field ), allocatable , dimension (:) :: tmp type ( cheb1d_vector_field ) :: coriolis call D % guard_temp (); call Uvec % guard_temp (); call T % guard_temp () call S % guard_temp (); call b % guard_temp () S_a => this % ambient_conds % ambient_salinity ( b , time ) T_a => this % ambient_conds % ambient_temperature ( b , time ) call S_a % guard_temp (); call T_a % guard_temp () rho => this % eos % water_density ( T , S ) rho_a => this % eos % water_density ( T_a , S_a ) U => Uvec % component ( 1 ) V => Uvec % component ( 2 ) call rho % guard_temp (); call rho_a % guard_temp (); call U % guard_temp () call V % guard_temp () e => this % entrainment_formulation % entrainment_rate ( Uvec , D , b , rho_a - rho , time ) call e % guard_temp () call this % melt_formulation % solve_for_melt ( Uvec , b , T , S , D , time ) m => this % melt_formulation % melt_rate () call m % guard_temp () DU_x = e + m if ( this % melt_formulation % has_heat_terms ()) then DUT_x = e * T_a - this % melt_formulation % heat_equation_terms () else DUT_x = e * T_a end if if ( this % melt_formulation % has_salt_terms ()) then DUS_x = e * S_a - this % melt_formulation % salt_equation_terms () !        print*, DUS_x%raw() else DUS_x = e * S_a end if select type ( Uvec ) class is ( uniform_vector_field ) Unorm => Uvec % norm () rho_x => this % eos % water_density_derivative ( T , ( DUT_x - DU_x * T ) / ( D * U ), & S , ( DUS_x - DU_x * S ) / ( D * U ), 1 ) call Unorm % guard_temp (); call rho_x % guard_temp () dims = Uvec % raw_size () / Uvec % elements () allocate ( tmp ( dims ), mold = D ) tmp ( 1 ) = 1._r8 - this % delta * D * ( rho_a - rho ) / U ** 2 !print*,tmp(1)%raw() tmp ( 1 ) = ( D * ( rho_a - rho ) * ( b % d_dx ( 1 ) - 2 * this % delta * DU_x / U ) & + 0.5 * this % delta * D ** 2 * rho_x - this % mu * Unorm * U & + this % phi * D * V ) / ( 1._r8 - this % delta * D * ( rho_a - rho ) / U ** 2 ) if ( dims > 1 ) then tmp ( 2 ) = - this % mu * Unorm * V - this % phi * D * U end if DUU_x = tmp call Unorm % clean_temp (); call rho_x % clean_temp () class default !        if (this%phi /= 0._r8) then !          coriolis = [0._r8, 0._r8, this%phi] .cross. Uvec !          DUU_x = -this%mu*Uvec*Uvec%norm() + 0.5_r8*this%delta*D**2*(.grad. rho) & !                  + D*(rho_a - rho)*(.grad.(b - this%delta*D)) - D*coriolis !        else DUU_x = - this % mu * Uvec * Uvec % norm () + 0.5_r8 * this % delta * D ** 2 * (. grad . rho ) & + D * ( rho_a - rho ) * (. grad .( b - this % delta * D )) !        end if end select call e % clean_temp (); call S_a % clean_temp (); call T_a % clean_temp () call rho % clean_temp (); call m % clean_temp (); call rho_a % clean_temp () call U % clean_temp (); call V % clean_temp () call D % clean_temp (); call Uvec % clean_temp (); call T % clean_temp () call S % clean_temp (); call b % clean_temp () end subroutine non_diff_terms function f ( v ) !! The nonlinear operator real ( r8 ), dimension (:,:), intent ( in ) :: v !! The state vector for the system of differential equations, !! and its derivatives. Column i represents the i-1 !! derivative. real ( r8 ), dimension ( size ( v , 1 )) :: f call this % update ( v (:, 1 )) call nonlinear ( f , . false .) end function f function jac_prod ( v , dv ) !! The product of the Jacobian of the nonlienar operator at v, !! multiplying dv. real ( r8 ), dimension (:,:), intent ( in ) :: v !! The state vector for the system of differential equations, !! and its derivatives. Column i represents the i-1 !! derivative. real ( r8 ), dimension (:,:), intent ( in ) :: dv !! The state vector for the system of differential equations, !! and its derivatives, to be multiplied by the !! Jacobian. Column i represents the i-1 derivative. real ( r8 ), dimension ( size ( v , 1 )) :: jac_prod type ( cheb1d_scalar_field ) :: stmp type ( cheb1d_vector_field ) :: vtmp integer :: i call this % update ( v (:, 1 )) call stmp % assign_meta_data ( this % thickness ) call vtmp % assign_meta_data ( this % velocity ) call stmp % set_from_raw ( dv ( 1 : this % thickness_size , 1 )) call this % thickness % set_derivative ( stmp ) i = 1 + this % thickness_size call vtmp % set_from_raw ( dv ( i : i + this % velocity_size - 1 , 1 )) call this % velocity % set_derivative ( vtmp ) i = i + this % velocity_size call vtmp % set_from_raw ( dv ( i : i + this % velocity_size - 1 , 1 )) call this % velocity_dx % set_derivative ( vtmp ) i = i + this % velocity_size call stmp % set_from_raw ( dv ( i : i + this % temperature_size - 1 , 1 )) call this % temperature % set_derivative ( stmp ) i = i + this % temperature_size call stmp % set_from_raw ( dv ( i : i + this % temperature_size - 1 , 1 )) call this % temperature_dx % set_derivative ( stmp ) i = i + this % temperature_size call stmp % set_from_raw ( dv ( i : i + this % salinity_size - 1 , 1 )) call this % salinity % set_derivative ( stmp ) i = i + this % salinity_size call stmp % set_from_raw ( dv ( i : i + this % salinity_size - 1 , 1 )) call this % salinity_dx % set_derivative ( stmp ) call nonlinear ( jac_prod , . true .) call this % thickness % unset_derivative () call this % velocity % unset_derivative () call this % velocity_dx % unset_derivative () call this % temperature % unset_derivative () call this % temperature_dx % unset_derivative () call this % salinity % unset_derivative () call this % salinity_dx % unset_derivative () end function jac_prod subroutine nonlinear ( f , deriv ) real ( r8 ), dimension (:), intent ( out ) :: f logical , intent ( in ) :: deriv !! If true, return Jacobian product, otherwise return result !! of nonlienar operator. integer :: st , en type ( cheb1d_scalar_field ) :: scalar_tmp , D_x , D_nd , S_nd , T_nd type ( cheb1d_vector_field ) :: vector_tmp , U_nd class ( scalar_field ), pointer :: U , U_x ! Use same or similar notation for variables as used in equations associate ( D => this % thickness , Uvec => this % velocity , & Uvec_x => this % velocity_dx , S => this % salinity , & S_x => this % salinity_dx , T => this % temperature , & T_x => this % temperature_dx , mf => this % melt_formulation , & h => ice_thickness , delta => this % delta , nu => this % nu , & mu => this % mu , r => this % r_val , bounds => this % boundaries ) call non_diff_terms ( D , Uvec , T , S , b , D_nd , U_nd , T_nd , S_nd ) ! FIXME: Alter this so that can take advantage of ! parameterisations returning uniform fields. U => this % velocity % component ( 1 ) U_x => this % velocity_dx % component ( 1 ) call U % guard_temp (); call U_x % guard_temp () ! Thickness scalar_tmp = ( D_nd - D * U_x ) / U D_x = scalar_tmp if ( this % lower_bounds ( 1 )) then call scalar_tmp % set_boundary ( - 1 , 1 , bounds % thickness_bound ( - 1 )) end if if ( this % upper_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % thickness_bound ( 1 )) end if st = 1 en = st + this % thickness_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () ! Velocity vector_tmp = 0._r8 * Uvec if ( this % lower_bounds ( 2 )) then call vector_tmp % set_boundary ( - 1 , 1 , bounds % velocity_bound ( - 1 )) end if if ( this % upper_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( 1 )) end if st = en + 1 en = st + this % velocity_size - 1 if ( deriv ) then vector_tmp = vector_tmp % get_derivative () end if f ( st : en ) = vector_tmp % raw () vector_tmp = D * U * Uvec_x !Needed due to compiler bug vector_tmp = ( vector_tmp + D * U_x * Uvec + D_x * U * Uvec - U_nd - & nu * D_x * Uvec_x ) / ( nu * D ) if ( this % lower_bounds ( 3 )) then call vector_tmp % set_boundary ( - 1 , 1 , bounds % velocity_bound ( - 1 )) end if if ( this % upper_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( 1 )) end if st = en + 1 en = st + this % velocity_size - 1 if ( deriv ) then vector_tmp = vector_tmp % get_derivative () end if f ( st : en ) = vector_tmp % raw () ! Temperature scalar_tmp = uniform_scalar_field ( 0._r8 ) if ( this % lower_bounds ( 4 )) then call scalar_tmp % set_boundary ( - 1 , 1 , bounds % temperature_bound ( - 1 )) end if if ( this % upper_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( 1 )) end if st = en + 1 en = st + this % temperature_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () scalar_tmp = ( D * U * T_x + D * U_x * T + D_x * U * T - T_nd - nu * D_x * T_x ) / ( nu * D ) if ( this % lower_bounds ( 5 )) then call scalar_tmp % set_boundary ( - 1 , 1 , bounds % temperature_bound ( - 1 )) end if if ( this % upper_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () ! Salinity scalar_tmp = uniform_scalar_field ( 0._r8 ) if ( this % lower_bounds ( 6 )) then call scalar_tmp % set_boundary ( - 1 , 1 , bounds % salinity_bound ( - 1 )) end if if ( this % upper_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () scalar_tmp = ( D * U * S_x + D * U_x * S + D_x * U * S - S_nd - nu * D_x * S_x ) / ( nu * D ) if ( this % lower_bounds ( 7 )) then call scalar_tmp % set_boundary ( - 1 , 1 , bounds % salinity_bound ( - 1 )) end if if ( this % upper_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () call U % clean_temp (); call U_x % clean_temp () end associate end subroutine nonlinear function preconditioner ( v , state , L_op , f_op , fcur , rhs ) !! The preconditioner, which approximates an inverse of `L`. real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be preconditioned. real ( r8 ), dimension (:,:), intent ( in ) :: state !! The current state vector for the system of differential !! equations, and its derivatives. Column i represents the !! i-1 derivative. procedure ( L ) :: L_op !! The linear, left-hand-side of the ODE being solved. procedure ( f ) :: f_op !! The nonlinear, right-hand-side of the ODE being solved. real ( r8 ), dimension (:), intent ( in ) :: fcur !! The result of `f(u)` real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being !! preconditioned. real ( r8 ), dimension ( size ( v )) :: preconditioner !! The result of applying the preconditioner. integer :: st , en , ust , uen , pst , pen integer :: bloc real ( r8 ) :: nu type ( plume ) :: v_plume type ( cheb1d_scalar_field ) :: scalar_tmp type ( cheb1d_vector_field ) :: vector_tmp class ( scalar_field ), pointer :: U , U_x v_plume % thickness_size = this % thickness_size call v_plume % thickness % assign_meta_data ( this % thickness ) v_plume % velocity_size = this % velocity_size call v_plume % velocity % assign_meta_data ( this % velocity ) call v_plume % velocity_dx % assign_meta_data ( this % velocity_dx ) v_plume % temperature_size = this % temperature_size call v_plume % temperature % assign_meta_data ( this % temperature ) call v_plume % temperature_dx % assign_meta_data ( this % temperature_dx ) v_plume % salinity_size = this % salinity_size call v_plume % salinity % assign_meta_data ( this % salinity ) call v_plume % salinity_dx % assign_meta_data ( this % salinity_dx ) call v_plume % update ( v ) nu = this % nu bloc = get_bound_loc ( 1 ) v_plume % thickness = this % precond % solve_for ( v_plume % thickness , bloc , & v_plume % thickness % get_boundary ( bloc , 1 )) st = 1 en = st + this % thickness_size - 1 preconditioner ( st : en ) = v_plume % thickness % raw () ! Precondition the U_x term after have preconditioned values for S and T st = en + 1 en = st + this % velocity_size - 1 ust = st uen = en bloc = get_bound_loc ( 3 ) v_plume % velocity_dx = this % precond % solve_for ( v_plume % velocity_dx , bloc , & v_plume % velocity_dx % get_boundary ( bloc , 1 )) st = en + 1 en = st + this % velocity_size - 1 preconditioner ( st : en ) = v_plume % velocity_dx % raw () bloc = get_bound_loc ( 2 ) vector_tmp = v_plume % velocity + v_plume % velocity_dx v_plume % velocity = this % precond % solve_for ( vector_tmp , bloc , & v_plume % velocity % get_boundary ( bloc , 1 )) preconditioner ( ust : uen ) = v_plume % velocity % raw () ! Precondition T_x terms before T st = en + 1 en = st + this % temperature_size - 1 pst = st pen = en bloc = get_bound_loc ( 5 ) v_plume % temperature_dx = this % precond % solve_for ( v_plume % temperature_dx , bloc , & v_plume % temperature_dx % get_boundary ( bloc , 1 )) st = en + 1 en = st + this % temperature_size - 1 preconditioner ( st : en ) = v_plume % temperature_dx % raw () bloc = get_bound_loc ( 4 ) v_plume % temperature = this % precond % solve_for ( v_plume % temperature + & v_plume % temperature_dx , bloc , v_plume % temperature % get_boundary ( bloc , 1 )) preconditioner ( pst : pen ) = v_plume % temperature % raw () ! Precondition S_x terms before S st = en + 1 en = st + this % salinity_size - 1 pst = st pen = en bloc = get_bound_loc ( 7 ) v_plume % salinity_dx = this % precond % solve_for ( v_plume % salinity_dx , bloc , & v_plume % salinity_dx % get_boundary ( bloc , 1 )) st = en + 1 en = st + this % temperature_size - 1 preconditioner ( st : en ) = v_plume % salinity_dx % raw () bloc = get_bound_loc ( 6 ) v_plume % salinity = this % precond % solve_for ( v_plume % salinity + v_plume % salinity_dx , bloc , & v_plume % salinity % get_boundary ( bloc , 1 )) preconditioner ( pst : pen ) = v_plume % salinity % raw () end function preconditioner integer function get_bound_loc ( component_id ) integer :: component_id if ( this % lower_bounds ( component_id )) then get_bound_loc = - 1 else if ( this % upper_bounds ( component_id )) then get_bound_loc = 1 else get_bound_loc = 0 end if end function get_bound_loc end subroutine plume_solve end module plume_mod"},{"title":"nitsol.f90 – ISOFT","tags":"","loc":"sourcefile/nitsol.f90.html","text":"Files dependent on this one sourcefile~~nitsol.f90~~AfferentGraph sourcefile~nitsol.f90 nitsol.f90 sourcefile~glacier.f90 glacier.F90 sourcefile~glacier.f90->sourcefile~nitsol.f90 sourcefile~finite_difference_block.f90 finite_difference_block.F90 sourcefile~finite_difference_block.f90->sourcefile~nitsol.f90 sourcefile~ode_solvers.f90 ode_solvers.f90 sourcefile~ode_solvers.f90->sourcefile~nitsol.f90 sourcefile~ice_shelf.f90 ice_shelf.F90 sourcefile~ice_shelf.f90->sourcefile~nitsol.f90 sourcefile~ice_shelf.f90->sourcefile~glacier.f90 sourcefile~cryosphere.f90 cryosphere.F90 sourcefile~cryosphere.f90->sourcefile~nitsol.f90 sourcefile~cryosphere.f90->sourcefile~glacier.f90 sourcefile~basal_surface.f90 basal_surface.F90 sourcefile~cryosphere.f90->sourcefile~basal_surface.f90 sourcefile~basal_surface.f90->sourcefile~nitsol.f90 sourcefile~ground.f90 ground.F90 sourcefile~ground.f90->sourcefile~basal_surface.f90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~ode_solvers.f90 sourcefile~asymmetric_plume.f90->sourcefile~basal_surface.f90 sourcefile~ice_sheet.f90 ice_sheet.F90 sourcefile~ice_sheet.f90->sourcefile~glacier.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~ode_solvers.f90 sourcefile~static_plume.f90->sourcefile~basal_surface.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~ode_solvers.f90 sourcefile~plume.f90->sourcefile~basal_surface.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules nitsol_mod Source Code nitsol.f90 Source Code ! !  nitsol.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module nitsol_mod !* Author: Christopher MacMackin !  Date: July 2016 !  License: GPLv3 ! ! Provides an explicit interface to the ! [NITSOL](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! package. Variables held in common blocks which can be used to ! control NITSOL are also provided here. At some point I may produce ! a proper object oriented interface for it. ! ! Also present is an interface to the GMRES solver provided by ! NITSOL. Both a direct interface and a wrapper are provided. The ! wrapper offers a somewhat more general and F90-ish presentation of ! the routine. ! use iso_fortran_env , only : r8 => real64 implicit none ! Common blocks used by the legacy NITSOL code. This allows other ! code to use them via this module. integer :: iplvl , ipunit common / nitprint / iplvl , ipunit integer :: instep , newstep , krystat real ( r8 ) :: avrate , fcurnrm common / nitinfo / avrate , fcurnrm , instep , newstep , krystat real ( r8 ) :: choice1_exp , choice2_exp , choice2_coef real ( r8 ) :: eta_cutoff , etamax real ( r8 ) :: thmin , thmax , etafixed common / nitparam / choice1_exp , choice2_exp , choice2_coef , & eta_cutoff , etamax , thmin , thmax , etafixed abstract interface subroutine f_intr ( n , xcur , fcur , rpar , ipar , itrmf ) !! Interface for a subroutine which evaluates the function !! the zero of which is sought. import :: r8 integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( out ) :: fcur !! Array of length `n` containing f(xcur) on output real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array integer , intent ( out ) :: itrmf !! Termination flag. 0 means normal termination, 1 means !! failure to produce f(xcur) end subroutine f_intr subroutine jacv_intr ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! Interface for a subroutine which optionally evaluates !! J\\vec{v} or P&#94;{-1}\\vec{v}, where J is the Jacobian !! of f and P is a right preconditioning operator. import :: r8 integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur !! Array of length `n` containing the current f(x) value integer , intent ( in ) :: ijob !! Integer flag indicating which product is desired. 0 !! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v !! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z !! An array of length n containing the desired product on !! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array integer , intent ( out ) :: itrmjv !! Termination flag. 0 indcates normal termination, 1 !! indicatesfailure to prodce J\\vec{v}, and 2 indicates !! failure to produce P&#94;{-1}\\vec{v} end subroutine jacv_intr function dinpr_intr ( n , x , sx , y , sy ) !! Interface for function which calculates vector inner products. !! This has the same interace as the BLAS routine !! [ddot](http://www.netlib.org/lapack/explore-html/de/da4/group__double__blas__level1_ga75066c4825cb6ff1c8ec4403ef8c843a.html). import :: r8 integer , intent ( in ) :: n !! The length of the vectors real ( r8 ), dimension ( * ), intent ( in ) :: x !! The first input vector integer , intent ( in ) :: sx !! The stride in memory between successive elements of `x` real ( r8 ), dimension ( * ), intent ( in ) :: y !! The second input vector integer , intent ( in ) :: sy !! The stride in memory between successive elements of `y` real ( r8 ) :: dinpr_intr !! Inner product of `x` and `y` end function dinpr_intr function dnorm_intr ( n , x , sx ) !! Interface for function which calculates vector norms. This !! has the same interface as the BLAS routine dnrm2. import :: r8 integer , intent ( in ) :: n !! The length of the array real ( r8 ), dimension ( * ), intent ( in ) :: x !! The input vector integer , intent ( in ) :: sx !! The stride in memory between consecutive elements of `x` real ( r8 ) :: dnorm_intr !! The vector norm of `x` end function dnorm_intr function mat_mult ( v , xcur , rhs , rpar , ipar , success ) !! Interface for operations representing the multiplication of a !! vector by a matrix, such as that for a linear operator or a !! preconditioner. import :: r8 real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be multiplied real ( r8 ), dimension (:), intent ( in ) :: xcur !! Array containing the current estimate of the independent !! variables in the linear system. This may not be needed, but !! is provided just in case. real ( r8 ), dimension (:), intent ( in ) :: rhs !! Array containing the right hand side of the linear !! system. This may not be needed, but is provided just in !! case. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array logical , intent ( out ) :: success !! Indicates whether operation was completed succesfully real ( r8 ), dimension ( size ( xcur )) :: mat_mult !! Result of the operation end function mat_mult end interface interface subroutine nitsol ( n , x , f , jacv , ftol , stptol , input , info , rwork , & rpar , ipar , iterm , dinpr , dnorm ) !* Author: Chris MacMackin !  Date: July 2016 ! ! An explicit interface to the ! [nitsol](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! Newton iterative nonlinear solver. ! !####Input parameters ! ! The `input` array argument allows the user to specify various ! options. It should be declared an integer vector of length 11 ! [sic.] in the calling program. To specify an option, set the ! appropriate input component to the desired value according to ! the specifications below. ! ! **Usage Note:** Setting a particular input component to zero gives the ! default option for that component in all cases. ! ! The first five input components are things that every user might wish ! to modify; the remainder will usually be of interest only to more ! experienced users. ! ! Optional every-user input: ! !    input(1) = nnimax = maximum number of nonlinear iterations (default 200). ! !    input(2) = ijacv = flag for determining the method of J*v evaluation: !                 0 => finite-difference evaluation (default) !                 1 => analytic evaluation ! !    input(3) = ikrysl = flag for determining the Krylov solver: !                 0 => GMRES (default) !                 1 => BiCGSTAB !                 2 => TFQMR ! !               For brief descriptions of the solvers plus references, !               see the subroutines nitgm, nitstb, and nittfq. ! !    input(4) = kdmax = maximum Krylov subspace dimension when GMRES is used !               (default 20). ! !    input(5) = irpre = flag for right preconditioning: !                 0 => no right preconditioning !                 1 => right preconditioning ! ! Optional experienced user input: ! !    input(6) = iksmax = maximum allowable number of iterations per call !               to the Krylov solver routine (default 1000). ! !    input(7) = iresup = residual update flag when GMRES is used; on !               restarts, the residual is updated as follows: !                 0 => linear combination (default) !                 1 => direct evaluation !               The first is cheap (one n-vector saxpy) but may lose !               accuracy with extreme residual reduction; the second !               retains accuracy better but costs one J*v product per !               restart. ! !    input(8) = ifdord = order of the finite-difference formula (sometimes) !               used when input(2) = ijacv = 0. When input(2) = ijacv = 0, !               this must be 0, 1, 2, or 4 on input; otherwise, it is !               irrelevant. With input(2) = ijacv = 0, the precise !               meaning is as follows: ! !               If GMRES is used, then ifdord matters only if input(7) = !               iresup = 1, in which case it determines the order of !               the finite-difference formula used in evaluating the !               initial residual at each GMRES restart (default 2); if !               ifdord = 0 on input, then it is set to 2 below. NOTE: This !               only affects initial residuals at restarts; first-order !               differences are always used within each GMRES cycle. Using !               higher-order differences at restarts only should give !               the same accuracy as if higher-order differences were !               used throughout; see K. Turner and H. F. Walker, \"Efficient !               high accuracy solutions with GMRES(m),\" SIAM J. Sci. !               Stat. Comput., 13 (1992), pp. 815--825. ! !               If BiCGSTAB or TFQMR is used, then ifdord determines the !               order of the finite-difference formula used at each !               iteration (default 1); if ifdord = 0 on input, then it !               is set to 1 below. ! !    input(9) = ibtmax = maximum allowable number of backtracks (step !               reductions) per call to nitbt (default 10). ! !               USAGE NOTE: Backtracking can be turned off by setting !\t              ibtmax = -1. Other negative values of ibtmax are not !               valid. ! !    input(10) = ieta = flag determining the forcing term eta as follows: !                 0 => abs( ||fcur|| - ||fprev+Jprev*sprev|| )/||fprev|| !                      (default) !                 1 => (||fcur||/||fprev||)**2 !                 2 => gamma*(||fcur||/||fprev||)**alpha !                      for user-supplied gamma in (0,1] and alpha in (1,2] !                 3 => fixed (constant) eta in (0,1), either 0.1 (default) !\t                     or specified by the user (see USAGE NOTE below) !               Here, fcur = current f, fprev = previous f, etc. The Krylov !               iterations are terminated when an iterate s satisfies !               an inexact Newton condition ||F + J*s|| .le. eta*||F||. ! !               USAGE NOTE: If input(10) = ieta = 2, then alpha and gamma !               must be set in common block nitparam.h as described below. !\t              If input(10) = ieta = 3, then the desired constant eta may !\t              be similarly set in nitparam.h if a value other than the !\t              default of 0.1 is desired. ! !               The first three expressions above are from S. C. Eisenstat !               and H. F. Walker, \"Choosing the forcing terms in an inexact !               Newton method\", SIAM J. Scientific Computing, 17 (1996), !               pp. 16--32. (They may be modified according to certain !               safeguards in subroutine nitdrv.) The first gives convergence !               that is q-superlinear and of r-order (1+sqrt(5))/2. The !               second gives convergence that is r-quadratic and of q-order !               p for every p in [1,2). The third gives convergence that is !               of q-order alpha when gamma < 1 and, when gamma = 1, of !               r-order alpha and q-order p for every p in [1,alpha). The !               fourth gives q-linear convergence with asymptotic rate !               constant eta in a certain norm; see R. S. Dembo, S. C. !\t              Eisenstat, and T. Steihaug, \"Inexact Newton methods\", !               SIAM J. Numer. Anal., 18 (1982), pp. 400-408. ! !               Of these four choices, the 1st is usually satisfactory, !               the 2nd or 3rd is sometimes preferred, and the 4th may be !               useful in some situations, e.g., it may be desirable to !               choose a fairly large fixed eta in (0,1), such as eta = .1, !               when numerical inaccuracy prevents the Krylov solver !               from obtaining much residual reduction. ! ! !####Output parameters ! ! On output, the components of the `info` argument are as follows: ! !     info(1)   = nfe (number of function evaluations) !     info(2)   = njve (number of J*v evaluations) !     info(3)   = nrpre (number of P(inverse)*v evaluations) !     info(4)   = nli (number of linear iterations) !     info(5)   = nni (number of nonlinear iterations) !     info(6)   = nbt (number of backtracks) ! import :: r8 implicit none integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( inout ) :: x !! Vector of length n, initial guess on input and final !! approximate solution on output procedure ( f_intr ) :: f !! User-supplied subroutine for evaluating the function !! the zero of which is sought. procedure ( jacv_intr ) :: jacv !! User-supplied subroutine for optionally evaluating !! J\\vec{v} or P&#94;{-1}\\vec{v}, where J is the Jacobian !! of f and P is a right preconditioning operator. If !! neither analytic J\\vec{v} evaluations nor right !! preconditioning is used, this can be a dummy subroutine; !! if right preconditioning is used but not analytic !! J\\vec{v} evaluations, this need only evaluate !! P&#94;{-1}\\vec{v}. real ( r8 ), intent ( in ) :: ftol !! Stopping tolerance of the f-norm real ( r8 ), intent ( in ) :: stptol !! Stopping tolerance of the step-length integer , dimension ( 10 ), intent ( in ) :: input !! Array containing various user-specified inputs; see above integer , dimension ( 6 ), intent ( out ) :: info !! Array containing various outputs; see above real ( r8 ), dimension ( * ), intent ( inout ) :: rwork !! Work array with length depending on the solver used as follows: !! !!GMRES !!:    n\\times(\\text{kdmax}+5)+\\text{kdmax}\\times(\\text{kdmax}+3), !!     where kdmax is the maximum Krylove subspace dimension, either !!     the default value of 20 or another value specified by the user !! !!BiCGSTAB !!:    11n !! !!TFQMR !!:    14n real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array passed to the `f` and `jacv` routines integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array passed to the `f` and `jacv` routines integer , intent ( out ) :: iterm !! Termination flag. Values have the following meanings: !! !!-k !!:    illegal value in `input(k)` !! !!0 !!:    normal termination: ||F|| < \\text{ftol} or ||\\text{step}|| !!     < \\text{stptol} !! !!1 !!:    `nnimax` nonlinar iterations reached without success !! !!2 !!:    failure to evaluate F !! !!3 !!:    in `nitjv`, J\\vec{v}  failure !! !!4 !!:    in `nitjv`, P&#94;{-1}\\vec{v} failure !! !!5 !!:    in `nitdrv`, insufficient initial model norm reduction for !!     adequate progress. **Note:** This can occur for several !!     reasons; examine `itrmks` on return from the Krylov solver !!     for further information. (This will be printed out if !!     \\text{iplvl}\\ge 3; see the discussion of optional common !!     blocks below.) !! !!6 !!:    in `nitbt`, failure to reach an acceptable step through !!     backtracking procedure ( dinpr_intr ) :: dinpr !! User-supplied function for calculating vector inner products. !! This has the same interace as the BLAS routine !! [ddot](http://www.netlib.org/lapack/explore-html/de/da4/group__double__blas__level1_ga75066c4825cb6ff1c8ec4403ef8c843a.html). !! If the Euclidean inner product is desired then user can link !! to a local BLAS library and provide the name `ddot` to `nitsol`. !! `dinpr` must be declared as an external function that returns !! a double precision in the calling program. procedure ( dnorm_intr ) :: dnorm !! User-supplied function for calculating vector norms. This !! has the same interface as the BLAS routine dnrm2; if the !! Euclidean norm is desired the user can link to a local !! BLAS library and provide the name dnrm2 to nitsol.  dnorm !! must be declared as an external function that returns a !! double precision value in the calling program. end subroutine nitsol subroutine nitgm2 ( n , xcur , fcur , step , eta , f , jacv , rpar , ipar , & ijacv , irpre , iksmax , iresup , ifdord , nfe , njve , & nrpre , nli , kdmax , kdmaxp1 , vv , rr , svbig , svsml , & w , rwork , rsnrm , dinpr , dnorm , itrmks ) !* Author: Chris MacMackin !  Date: March 2017 ! ! An interface to my modified versino of the ! [nitsol](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! implementation of the generalised minimal residual method ! ([GMRES](https://en.wikipedia.org/wiki/Generalized_minimal_residual_method)) ! for iteratively solving linear systems. It has been modified ! so that the user provides a non-zero initial guess of the ! solution. ! import :: r8 implicit none integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur !! Array of length `n` containing current approximate solution real ( r8 ), dimension ( n ), intent ( inout ) :: step !! Vector of of length `n` containing trial step real ( r8 ), intent ( in ) :: eta !! Relative residual reduction factor procedure ( f_intr ) :: f !! User-supplied subroutine for evaluating the function !! the zero of which is sought. procedure ( jacv_intr ) :: jacv !! User-supplied subroutine for optionally evaluating !! J\\vec{v} or P&#94;{-1}\\vec{v}, where J is the Jacobian !! of f and P is a right preconditioning operator. If !! neither analytic J\\vec{v} evaluations nor right !! preconditioning is used, this can be a dummy subroutine; !! if right preconditioning is used but not analytic !! J\\vec{v} evaluations, this need only evaluate !! P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array passed to the `f` and `jacv` routines integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array passed to the `f` and `jacv` routines integer , intent ( in ) :: ijacv !! Flag for determining method of J\\vec{v} evaluation. 0 !! (default) indicates finite-difference evaluation, while 1 !! indicates analytic evaluation. integer , intent ( in ) :: irpre !! Flag for right preconditioning. 0 indicates no !! preconditioning, while 1 inidcates right preconditioning. integer , intent ( in ) :: iksmax !! Maximum allowable number of GMRES iterations integer , intent ( in ) :: iresup !! Residual update flag. On GMRES restarts, the residual can !! be updated using a linear combination (`iresup == 0`) or by !! direct evaluation (`iresup == 1`). The first is cheap (one !! n-vector saxpy) but may lose accuracy with extreme residual !! reduction; the second retains accuracy better but costs one !! J\\vec{v} product. integer , intent ( in ) :: ifdord !! Order of the finite-difference formula (sometimes) used on !! GMRES restarts when J\\vec{v} products are evaluated !! using finite- differences. When ijacv = 0 on input to !! nitsol, ifdord is set to 1, 2, or 4 in nitsol; otherwise, !! it is irrelevant. When ijacv = 0 on input to this !! subroutine, the precise meaning is as follows: !! !! With GMRES, ifdord matters only if iresup = 1, in which case !! it determines the order of the finite-difference formula used !! in evaluating the initial residual at each GMRES restart !! (default 2). If iresup = 1 and ijacv = 0 on input to this !! subroutine, then ijacv is temporarily reset to -1 at each !! restart below to force a finite-difference evaluation of order !! ifdord. NOTE: This only affects initial residuals at restarts; !! first-order differences are always used within each GMRES !! cycle. Using higher-order differences at restarts only should !! give the same accuracy as if higher-order differences were !! used throughout; see K. Turner and H. F. Walker, \"Efficient !! high accuracy solutions with GMRES(m),\" SIAM J. Sci. Stat. !! Comput., 13 (1992), pp. 815--825. integer , intent ( inout ) :: nfe !! Number of function evaluations integer , intent ( inout ) :: njve !! Number of J\\vec{v} evaluations integer , intent ( inout ) :: nrpre !! Number of P&#94;{-1}\\vec{v} evaluations integer , intent ( inout ) :: nli !! Number of linear iterations integer , intent ( in ) :: kdmax !! Maximum Krylov subspace dimension; default 10. integer , intent ( in ) :: kdmaxp1 !! kdmax + 1 real ( r8 ), dimension ( n , kdmaxp1 ), intent ( out ) :: vv !! Matrix for storage of Krylov basis in GMRES; on return, the !! residual vector is contained in the first column. real ( r8 ), dimension ( kdmax , kdmax ), intent ( out ) :: rr !! Matrix for storage of triangular matrix in GMRES. real ( r8 ), dimension ( kdmax ), intent ( out ) :: svbig !! Vector for storage of estimate of singular vector of `rr` !! with largest singular value. real ( r8 ), dimension ( kdmax ), intent ( out ) :: svsml !! Vector for storage of estimate of singular vector of `rr` !! with smallest singular value. real ( r8 ), dimension ( kdmax ), intent ( out ) :: w !! Vector containing right-hand side of triangular system and !! least-squares residual norm in GMRES. real ( r8 ), dimension ( n ), intent ( out ) :: rwork !! Work array real ( r8 ), intent ( out ) :: rsnrm !! GMRES residual norm on return procedure ( dinpr_intr ) :: dinpr !! Inner-product routine, either user-supplied or BLAS `ddot`. procedure ( dnorm_intr ) :: dnorm !! Norm routine, either user supplied or BLAS dnrm2. integer , intent ( out ) :: itrmks !! Termination flag. Values have the following meanings: !! !!0 !!:    normal termination: acceptable step found !! !!1 !!:    J\\vec{v}  failure in `nitjv` !! !!2 !!:    P&#94;{-1}\\vec{v} failure in `nitjv` !! !!3 !!:    Acceptable step not found in `iksmax` GMRES iterations !! !!4 !!:    Insignificant residual norm reduction of a cycle of `kdmax` !!     steps (stagnation) before an acceptable step has been found. !! !!5 !!:    Dangerous ill-conditioning detected before an acceptable !!     step has been found. end subroutine nitgm2 subroutine nittfq2 ( n , xcur , fcur , step , eta , f , jacv , rpar , ipar , & ijacv , irpre , iksmax , ifdord , nfe , njve , & nrpre , nli , r , rcgs , rtil , d , p , q , u , v , y , & rwork1 , rwork2 , rsnrm , dinpr , dnorm , itrmks ) !* Author: Chris MacMackin !  Date: July 2018 ! ! An interface to my modified versino of the ! [nitsol](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! implementation of the transpose-free quasi-minimal residual ! method ! ([TFQMR](https://epubs.siam.org/doi/pdf/10.1137/0914029)) for ! iteratively solving linear systems. It has been modified so ! that the user provides a non-zero initial guess of the ! solution. ! import :: r8 implicit none integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur !! Array of length `n` containing current approximate solution real ( r8 ), dimension ( n ), intent ( inout ) :: step !! Vector of of length `n` containing trial step real ( r8 ), intent ( in ) :: eta !! Relative residual reduction factor procedure ( f_intr ) :: f !! User-supplied subroutine for evaluating the function !! the zero of which is sought. procedure ( jacv_intr ) :: jacv !! User-supplied subroutine for optionally evaluating !! J\\vec{v} or P&#94;{-1}\\vec{v}, where J is the Jacobian !! of f and P is a right preconditioning operator. If !! neither analytic J\\vec{v} evaluations nor right !! preconditioning is used, this can be a dummy subroutine; !! if right preconditioning is used but not analytic !! J\\vec{v} evaluations, this need only evaluate !! P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array passed to the `f` and `jacv` routines integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array passed to the `f` and `jacv` routines integer , intent ( in ) :: ijacv !! Flag for determining method of J\\vec{v} evaluation. 0 !! (default) indicates finite-difference evaluation, while 1 !! indicates analytic evaluation. integer , intent ( in ) :: irpre !! Flag for right preconditioning. 0 indicates no !! preconditioning, while 1 inidcates right preconditioning. integer , intent ( in ) :: iksmax !! Maximum allowable number of TFQMR iterations integer , intent ( in ) :: ifdord !! Order of the finite-difference formula used in TFQMR !! when J*v products are evaluated using finite-differences. !! When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or !! 4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on !! input to this subroutine, ifdord determines the order of the !! finite-difference formula used at each TFQMR iteration !! (default 1). In this case, ijacv is set to -1 below to !! signal to nitjv that the order of the finite-difference !! formula is to be determined by ifdord. The original value !! ijacv = 0 is restored on return. integer , intent ( inout ) :: nfe !! Number of function evaluations integer , intent ( inout ) :: njve !! Number of J\\vec{v} evaluations integer , intent ( inout ) :: nrpre !! Number of P&#94;{-1}\\vec{v} evaluations integer , intent ( inout ) :: nli !! Number of linear iterations real ( r8 ), dimension ( n ), intent ( out ) :: r !! Residual vector (for the QMR process) real ( r8 ), dimension ( n ), intent ( out ) :: rcgs !! Residual vector (of the underlying CGS process) real ( r8 ), dimension ( n ), intent ( out ) :: rtil !! 'Shadow' residual vector used in bi-orthogonalization real ( r8 ), dimension ( n ), intent ( out ) :: d !! Vector used in TFQMR real ( r8 ), dimension ( n ), intent ( out ) :: p !! Vector used in TFQMR real ( r8 ), dimension ( n ), intent ( out ) :: q !! Vector used in TFQMR real ( r8 ), dimension ( n ), intent ( out ) :: u !! Vector used in TFQMR real ( r8 ), dimension ( n ), intent ( out ) :: v !! Vector used in TFQMR real ( r8 ), dimension ( n ), intent ( out ) :: y !! Vector used in TFQMR real ( r8 ), dimension ( n ), intent ( out ) :: rwork1 !! Work vector, passed on to nitjv real ( r8 ), dimension ( n ), intent ( out ) :: rwork2 !! Work vector, passed on to nitjv real ( r8 ), intent ( out ) :: rsnrm !! TFQMR residual norm on return procedure ( dinpr_intr ) :: dinpr !! Inner-product routine, either user-supplied or BLAS `ddot`. procedure ( dnorm_intr ) :: dnorm !! Norm routine, either user supplied or BLAS dnrm2. integer , intent ( out ) :: itrmks !! Termination flag. Values have the following meanings: !! !!0 !!:    normal termination: acceptable step found !! !!1 !!:    J\\vec{v}  failure in `nitjv` !! !!2 !!:    P&#94;{-1}\\vec{v} failure in `nitjv` !! !!3 !!:    Acceptable step not found in `iksmax` TFQMR iterations !! !!4 !!:    TFQMR breakdown !! !!5 !!:    Floating point error (the underlying CGS iteration !!     has probably blown up) end subroutine nittfq2 subroutine nitstb2 ( n , xcur , fcur , step , eta , f , jacv , rpar , ipar , & ijacv , irpre , iksmax , ifdord , nfe , njve , & nrpre , nli , r , rtil , p , phat , v , t , rwork1 , & rwork2 , rsnrm , dinpr , dnorm , itrmks ) !* Author: Chris MacMackin !  Date: July 2018 ! ! An interface to my modified versino of the ! [nitsol](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! implementation of the biconjugate gradient stabilized method ! ([BiCGSTAB](https://en.wikipedia.org/wiki/Biconjugate_gradient_stabilized_method)) ! for iteratively solving linear systems. It has been modified ! so that the user provides a non-zero initial guess of the ! solution. ! import :: r8 implicit none integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur !! Array of length `n` containing current approximate solution real ( r8 ), dimension ( n ), intent ( inout ) :: step !! Vector of of length `n` containing trial step real ( r8 ), intent ( in ) :: eta !! Relative residual reduction factor procedure ( f_intr ) :: f !! User-supplied subroutine for evaluating the function !! the zero of which is sought. procedure ( jacv_intr ) :: jacv !! User-supplied subroutine for optionally evaluating !! J\\vec{v} or P&#94;{-1}\\vec{v}, where J is the Jacobian !! of f and P is a right preconditioning operator. If !! neither analytic J\\vec{v} evaluations nor right !! preconditioning is used, this can be a dummy subroutine; !! if right preconditioning is used but not analytic !! J\\vec{v} evaluations, this need only evaluate !! P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array passed to the `f` and `jacv` routines integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array passed to the `f` and `jacv` routines integer , intent ( in ) :: ijacv !! Flag for determining method of J\\vec{v} evaluation. 0 !! (default) indicates finite-difference evaluation, while 1 !! indicates analytic evaluation. integer , intent ( in ) :: irpre !! Flag for right preconditioning. 0 indicates no !! preconditioning, while 1 inidcates right preconditioning. integer , intent ( in ) :: iksmax !! Maximum allowable number of BiCGSTAB iterations integer , intent ( in ) :: ifdord !! Order of the finite-difference formula used in BiCGSTAB !! when J*v products are evaluated using finite-differences. !! When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or !! 4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on !! input to this subroutine, ifdord determines the order of the !! finite-difference formula used at each BiCGSTAB iteration !! (default 1). In this case, ijacv is set to -1 below to !! signal to nitjv that the order of the finite-difference !! formula is to be determined by ifdord. The original value !! ijacv = 0 is restored on return. integer , intent ( inout ) :: nfe !! Number of function evaluations integer , intent ( inout ) :: njve !! Number of J\\vec{v} evaluations integer , intent ( inout ) :: nrpre !! Number of P&#94;{-1}\\vec{v} evaluations integer , intent ( inout ) :: nli !! Number of linear iterations real ( r8 ), dimension ( n ), intent ( out ) :: r !! Residual vector real ( r8 ), dimension ( n ), intent ( out ) :: rtil !! \\tilde{r} vector used in BiCGSTAB real ( r8 ), dimension ( n ), intent ( out ) :: p !! Vector used in BiCGSTAB real ( r8 ), dimension ( n ), intent ( out ) :: phat !! Vector used in BiCGSTAB real ( r8 ), dimension ( n ), intent ( out ) :: v !! Vector used in BiCGSTAB real ( r8 ), dimension ( n ), intent ( out ) :: t !! Vector used in BiCGSTAB real ( r8 ), dimension ( n ), intent ( out ) :: rwork1 !! Work vector, passed on to nitjv real ( r8 ), dimension ( n ), intent ( out ) :: rwork2 !! Work vector, passed on to nitjv real ( r8 ), intent ( out ) :: rsnrm !! BiCGSTAB residual norm on return procedure ( dinpr_intr ) :: dinpr !! Inner-product routine, either user-supplied or BLAS `ddot`. procedure ( dnorm_intr ) :: dnorm !! Norm routine, either user supplied or BLAS dnrm2. integer , intent ( out ) :: itrmks !! Termination flag. Values have the following meanings: !! !!0 !!:    normal termination: acceptable step found !! !!1 !!:    J\\vec{v}  failure in `nitjv` !! !!2 !!:    P&#94;{-1}\\vec{v} failure in `nitjv` !! !!3 !!:    Acceptable step not found in `iksmax` BiCGSTAB iterations !! !!4 !!:    BiCGSTAB breakdown end subroutine nitstb2 end interface interface function ddot ( n , x , sx , y , sy ) !* Author: Chris MacMackin !  Date: November 2016 ! ! An interface to the BLAS routine for calculating Euclidean ! inner product. This can be passed to [[nitsol]] for the ! argument `dinpr`. ! import :: r8 implicit none integer , intent ( in ) :: n real ( r8 ), dimension ( * ), intent ( in ) :: x integer , intent ( in ) :: sx real ( r8 ), dimension ( * ), intent ( in ) :: y integer , intent ( in ) :: sy real ( r8 ) :: ddot end function ddot function dnrm2 ( n , x , sx ) !* Author: Chris MacMackin !  Date: November 2016 ! ! An interface to the BLAS routine for calculating Euclidean ! norm. This can be passed to [[nitsol]] for the argument ! `dnorm`. ! import :: r8 implicit none integer , intent ( in ) :: n real ( r8 ), dimension ( * ), intent ( in ) :: x integer , intent ( in ) :: sx real ( r8 ) :: dnrm2 end function dnrm2 end interface contains subroutine dummy_jacv ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !* Author: Chris MacMackin !  Date: November 2016 ! ! A dummy subroutine which does not apply a preconditioner or ! calculate an analytic Jacobian. This can be passed to [[nitsol]] ! for the argument `jacv`. ! integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of length `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flag indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce J\\vec{v}, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} end subroutine dummy_jacv subroutine dummy_f ( n , xcur , fcur , rpar , ipar , itrmf ) !* Author: Chris MacMackin !  Date: March 2017 ! ! A dummy subroutine which does not calculate the function. ! integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( out ) :: fcur !! Array of length `n` containing f(xcur) on output real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array integer , intent ( out ) :: itrmf !! Termination flag. 0 means normal termination, 1 means !! failure to produce f(xcur) end subroutine dummy_f subroutine gmres_solve ( solution , lhs , rhs , resid_norm , flag , nlhs , nrpre , & nli , tol , precond , rpar , ipar , resid_update , & iter_max , krylov_dim , inner_prod , norm ) !* Author: Chris MacMackin !  Date: March 2017 ! ! A wraper for the ! [nitsol](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! implementation of the generalised minimal residual method ! ([GMRES](https://en.wikipedia.org/wiki/Generalized_minimal_residual_method)) ! for iteratively solving linear systems. This provides a more ! general interface not specifically intended for use with Newton ! iteration. It also uses Fortran 90 features to provide a more ! convenient call signature. ! real ( r8 ), dimension (:), intent ( inout ) :: solution !! On input, an initial guess of the solution to the linear !! system. On output, the iteratively determined solution. procedure ( mat_mult ) :: lhs !! The linear operator on the left hand side of the linear !! system. real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being solved real ( r8 ), intent ( out ) :: resid_norm !! GMRES residual norm on return integer , intent ( out ) :: flag !! Termination flag. Values have the following meanings: !! !!0 !!:    normal termination: acceptable solution found !! !!1 !!:    J\\vec{v}  failure !! !!2 !!:    P&#94;{-1}\\vec{v} failure !! !!3 !!:    Acceptable solution not found in `iter_max` GMRES iterations !! !!4 !!:    Insignificant residual norm reduction of a cycle of `kdmax` !!     steps (stagnation) before an acceptable solution has been !!     found. !! !!5 !!:    Dangerous ill-conditioning detected before an acceptable !!     solution has been found. real ( r8 ), intent ( in ), optional :: tol !! The tolerance for the solution. Default is `size(solution) * 1e-8`. integer , intent ( out ), optional :: nlhs !! Number of evaluations of the left hand side of the system integer , intent ( out ), optional :: nrpre !! Number of evaluations of the right-preconditioner integer , intent ( out ), optional :: nli !! Number of iterations procedure ( mat_mult ), optional :: precond !! A right-preconditioner which may be used to improve !! convergence of the solution. real ( r8 ), dimension ( * ), intent ( inout ), optional :: rpar !! Parameter/work array passed to the `lhs` and `precond` routines. integer , dimension ( * ), intent ( inout ), optional :: ipar !! Parameter/work array passed to the `lhs` and `precond` routines integer , intent ( in ), optional :: resid_update !! Residual update flag. On GMRES restarts, the residual can !! be updated using a linear combination (`iresup == 0`) or by !! direct evaluation (`iresup == 1`). The first is cheap (one !! n-vector saxpy) but may lose accuracy with extreme residual !! reduction; the second retains accuracy better but costs one !! J\\vec{v} product. Default is 0. integer , intent ( in ), optional :: iter_max !! Maximum allowable number of GMRES iterations. Default is !! 1000. integer , intent ( in ), optional :: krylov_dim !! Maximum Krylov subspace dimension; default 10. procedure ( dinpr_intr ), optional :: inner_prod !! Inner-product routine, either user-supplied or BLAS `ddot`. procedure ( dnorm_intr ), optional :: norm !! Norm routine, either user supplied or BLAS dnrm2. integer :: npoints , preflag , resup , itmax , kdim , nfe , lnlhs , lnrpre , lnli real ( r8 ) :: eta procedure ( dinpr_intr ), pointer :: dinpr procedure ( dnorm_intr ), pointer :: dnorm real ( r8 ), dimension (:), allocatable , save :: xcur , svbig , svsml , w , rwork real ( r8 ), dimension (:,:), allocatable , save :: vv , rr lnlhs = 0 lnrpre = 0 lnli = 0 npoints = size ( solution ) if ( present ( precond )) then preflag = 1 else preflag = 0 end if if ( present ( tol )) then eta = tol else eta = 1.e-8_r8 * npoints end if if ( present ( resid_update )) then resup = resid_update else resup = 0 end if if ( present ( iter_max )) then itmax = iter_max else itmax = 1000 end if if ( present ( krylov_dim )) then kdim = krylov_dim else kdim = 10 end if if ( present ( inner_prod )) then dinpr => inner_prod else dinpr => ddot end if if ( present ( norm )) then dnorm => norm else dnorm => dnrm2 end if xcur = solution if ( allocated ( vv )) then if ( any ( shape ( vv ) /= [ npoints , kdim + 1 ])) then deallocate ( vv ) allocate ( vv ( npoints , kdim + 1 )) end if if ( size ( svbig ) /= kdim ) then deallocate ( rr ) deallocate ( svbig ) deallocate ( svsml ) deallocate ( w ) allocate ( rr ( kdim , kdim )) allocate ( svbig ( kdim )) allocate ( svsml ( kdim )) allocate ( w ( kdim )) end if if ( size ( rwork ) /= npoints ) then deallocate ( rwork ) allocate ( rwork ( npoints )) end if else allocate ( vv ( npoints , kdim + 1 )) allocate ( rr ( kdim , kdim )) allocate ( svbig ( kdim )) allocate ( svsml ( kdim )) allocate ( w ( kdim )) allocate ( rwork ( npoints )) end if call nitgm2 ( npoints , xcur , - rhs , solution , eta , dummy_f , jacv , & rpar , ipar , 1 , preflag , itmax , resup , 1 , nfe , & lnlhs , lnrpre , lnli , kdim , kdim + 1 , vv , rr , svbig , & svsml , w , rwork , resid_norm , dinpr , dnorm , flag ) if ( present ( nlhs )) nlhs = lnlhs if ( present ( nrpre )) nrpre = lnrpre if ( present ( nli )) nli = lnli contains subroutine jacv ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! A wrapper on the user-provided routines for the linear !! operator and preconditioner, to put them in the form NITSOL !! expects. !! integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of length `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flag indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce J\\vec{v}, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} logical :: success itrmjv = 0 if ( ijob == 0 ) then z = lhs ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 1 else if ( ijob == 1 ) then z = precond ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 2 else error stop ( '`ijob` not equal to 0 or 1.' ) end if end subroutine jacv end subroutine gmres_solve subroutine tfqmr_solve ( solution , lhs , rhs , resid_norm , flag , nlhs , nrpre , & nli , tol , precond , rpar , ipar , resid_update , & iter_max , krylov_dim , inner_prod , norm ) !* Author: Chris MacMackin !  Date: March 2017 ! ! A wraper for the ! [nitsol](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! implementation of the transpose-free quasi-minimal residual method ! ([TFQMR](https://epubs.siam.org/doi/pdf/10.1137/0914029)) ! for iteratively solving linear systems. This provides a more ! general interface not specifically intended for use with Newton ! iteration. It also uses Fortran 90 features to provide a more ! convenient call signature. ! real ( r8 ), dimension (:), intent ( inout ) :: solution !! On input, an initial guess of the solution to the linear !! system. On output, the iteratively determined solution. procedure ( mat_mult ) :: lhs !! The linear operator on the left hand side of the linear !! system. real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being solved real ( r8 ), intent ( out ) :: resid_norm !! TFQMR residual norm on return integer , intent ( out ) :: flag !! Termination flag. Values have the following meanings: !! !!0 !!:    normal termination: acceptable step found !! !!1 !!:    J\\vec{v}  failure in `nitjv` !! !!2 !!:    P&#94;{-1}\\vec{v} failure in `nitjv` !! !!3 !!:    Acceptable step not found in `iksmax` TFQMR iterations !! !!4 !!:    TFQMR breakdown !! !!5 !!:    Floating point error (the underlying CGS iteration !!     has probably blown up) real ( r8 ), intent ( in ), optional :: tol !! The tolerance for the solution. Default is `size(solution) * 1e-8`. integer , intent ( out ), optional :: nlhs !! Number of evaluations of the left hand side of the system integer , intent ( out ), optional :: nrpre !! Number of evaluations of the right-preconditioner integer , intent ( out ), optional :: nli !! Number of iterations procedure ( mat_mult ), optional :: precond !! A right-preconditioner which may be used to improve !! convergence of the solution. real ( r8 ), dimension ( * ), intent ( inout ), optional :: rpar !! Parameter/work array passed to the `lhs` and `precond` routines. integer , dimension ( * ), intent ( inout ), optional :: ipar !! Parameter/work array passed to the `lhs` and `precond` routines integer , intent ( in ), optional :: resid_update !! Residual update flag. On GMRES restarts, the residual can !! be updated using a linear combination (`iresup == 0`) or by !! direct evaluation (`iresup == 1`). The first is cheap (one !! n-vector saxpy) but may lose accuracy with extreme residual !! reduction; the second retains accuracy better but costs one !! J\\vec{v} product. Meaningless in this routine, but kept !! for consistent interface. integer , intent ( in ), optional :: iter_max !! Maximum allowable number of TFQMR iterations. Default is !! 1000. integer , intent ( in ), optional :: krylov_dim !! Maximum Krylov subspace dimension; default 10. procedure ( dinpr_intr ), optional :: inner_prod !! Inner-product routine, either user-supplied or BLAS `ddot`. procedure ( dnorm_intr ), optional :: norm !! Norm routine, either user supplied or BLAS dnrm2. integer :: npoints , preflag , resup , itmax , kdim , nfe , lnlhs , lnrpre , lnli real ( r8 ) :: eta procedure ( dinpr_intr ), pointer :: dinpr procedure ( dnorm_intr ), pointer :: dnorm real ( r8 ), dimension (:), allocatable , save :: xcur real ( r8 ), dimension (:,:), allocatable , save :: workers lnlhs = 0 lnrpre = 0 lnli = 0 npoints = size ( solution ) if ( present ( precond )) then preflag = 1 else preflag = 0 end if if ( present ( tol )) then eta = tol else eta = 1.e-8_r8 * npoints end if if ( present ( resid_update )) then resup = resid_update else resup = 0 end if if ( present ( iter_max )) then itmax = iter_max else itmax = 1000 end if if ( present ( krylov_dim )) then kdim = krylov_dim else kdim = 10 end if if ( present ( inner_prod )) then dinpr => inner_prod else dinpr => ddot end if if ( present ( norm )) then dnorm => norm else dnorm => dnrm2 end if xcur = solution if ( allocated ( workers )) then if ( size ( workers , 1 ) /= npoints ) then deallocate ( workers ) allocate ( workers ( npoints , 11 )) end if else allocate ( workers ( npoints , 11 )) end if call nittfq2 ( npoints , xcur , - rhs , solution , eta , dummy_f , jacv , & rpar , ipar , 1 , preflag , itmax , 1 , nfe , lnlhs , lnrpre , & lnli , workers (:, 1 ), workers (:, 2 ), workers (:, 3 ), & workers (:, 4 ), workers (:, 5 ), workers (:, 6 ), & workers (:, 6 ), workers (:, 8 ), workers (:, 9 ), & workers (:, 10 ), workers (:, 11 ), resid_norm , dinpr , & dnorm , flag ) if ( present ( nlhs )) nlhs = lnlhs if ( present ( nrpre )) nrpre = lnrpre if ( present ( nli )) nli = lnli contains subroutine jacv ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! A wrapper on the user-provided routines for the linear !! operator and preconditioner, to put them in the form NITSOL !! expects. !! integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of length `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flag indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce J\\vec{v}, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} logical :: success itrmjv = 0 if ( ijob == 0 ) then z = lhs ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 1 else if ( ijob == 1 ) then z = precond ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 2 else error stop ( '`ijob` not equal to 0 or 1.' ) end if end subroutine jacv end subroutine tfqmr_solve subroutine bicgstab_solve ( solution , lhs , rhs , resid_norm , flag , nlhs , nrpre , & nli , tol , precond , rpar , ipar , resid_update , & iter_max , krylov_dim , inner_prod , norm ) !* Author: Chris MacMackin !  Date: March 2017 ! ! A wraper for the ! [nitsol](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! implementation of the biconjugate gradient stabilized method ! ([BiCGSTAB](https://en.wikipedia.org/wiki/Biconjugate_gradient_stabilized_method)) ! for iteratively solving linear systems. This provides a more ! general interface not specifically intended for use with Newton ! iteration. It also uses Fortran 90 features to provide a more ! convenient call signature. ! real ( r8 ), dimension (:), intent ( inout ) :: solution !! On input, an initial guess of the solution to the linear !! system. On output, the iteratively determined solution. procedure ( mat_mult ) :: lhs !! The linear operator on the left hand side of the linear !! system. real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being solved real ( r8 ), intent ( out ) :: resid_norm !! BiCGSTAB residual norm on return integer , intent ( out ) :: flag !! Termination flag. Values have the following meanings: !! !!0 !!:    normal termination: acceptable step found !! !!1 !!:    J\\vec{v}  failure in `nitjv` !! !!2 !!:    P&#94;{-1}\\vec{v} failure in `nitjv` !! !!3 !!:    Acceptable step not found in `iksmax` BiCGSTAB iterations !! !!4 !!:    BiCGSTAB breakdown real ( r8 ), intent ( in ), optional :: tol !! The tolerance for the solution. Default is `size(solution) * 1e-8`. integer , intent ( out ), optional :: nlhs !! Number of evaluations of the left hand side of the system integer , intent ( out ), optional :: nrpre !! Number of evaluations of the right-preconditioner integer , intent ( out ), optional :: nli !! Number of iterations procedure ( mat_mult ), optional :: precond !! A right-preconditioner which may be used to improve !! convergence of the solution. real ( r8 ), dimension ( * ), intent ( inout ), optional :: rpar !! Parameter/work array passed to the `lhs` and `precond` routines. integer , dimension ( * ), intent ( inout ), optional :: ipar !! Parameter/work array passed to the `lhs` and `precond` routines integer , intent ( in ), optional :: resid_update !! Residual update flag. On GMRES restarts, the residual can be !! updated using a linear combination (`iresup == 0`) or by !! direct evaluation (`iresup == 1`). The first is cheap (one !! n-vector saxpy) but may lose accuracy with extreme residual !! reduction; the second retains accuracy better but costs one !! J\\vec{v} product. Meaningless in this routine, but kept !! for consistent interface. integer , intent ( in ), optional :: iter_max !! Maximum allowable number of TFQMR iterations. Default is !! 1000. integer , intent ( in ), optional :: krylov_dim !! Maximum Krylov subspace dimension; default 10. procedure ( dinpr_intr ), optional :: inner_prod !! Inner-product routine, either user-supplied or BLAS `ddot`. procedure ( dnorm_intr ), optional :: norm !! Norm routine, either user supplied or BLAS dnrm2. integer :: npoints , preflag , resup , itmax , kdim , nfe , lnlhs , lnrpre , lnli real ( r8 ) :: eta procedure ( dinpr_intr ), pointer :: dinpr procedure ( dnorm_intr ), pointer :: dnorm real ( r8 ), dimension (:), allocatable , save :: xcur real ( r8 ), dimension (:,:), allocatable , save :: workers lnlhs = 0 lnrpre = 0 lnli = 0 npoints = size ( solution ) if ( present ( precond )) then preflag = 1 else preflag = 0 end if if ( present ( tol )) then eta = tol else eta = 1.e-8_r8 * npoints end if if ( present ( resid_update )) then resup = resid_update else resup = 0 end if if ( present ( iter_max )) then itmax = iter_max else itmax = 1000 end if if ( present ( krylov_dim )) then kdim = krylov_dim else kdim = 10 end if if ( present ( inner_prod )) then dinpr => inner_prod else dinpr => ddot end if if ( present ( norm )) then dnorm => norm else dnorm => dnrm2 end if xcur = solution if ( allocated ( workers )) then if ( size ( workers , 1 ) /= npoints ) then deallocate ( workers ) allocate ( workers ( npoints , 8 )) end if else allocate ( workers ( npoints , 8 )) end if call nitstb2 ( npoints , xcur , - rhs , solution , eta , dummy_f , jacv , & rpar , ipar , 1 , preflag , itmax , 1 , nfe , lnlhs , lnrpre , & lnli , workers (:, 1 ), workers (:, 2 ), workers (:, 3 ), & workers (:, 4 ), workers (:, 5 ), workers (:, 6 ), & workers (:, 6 ), workers (:, 8 ), resid_norm , dinpr , & dnorm , flag ) if ( present ( nlhs )) nlhs = lnlhs if ( present ( nrpre )) nrpre = lnrpre if ( present ( nli )) nli = lnli contains subroutine jacv ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! A wrapper on the user-provided routines for the linear !! operator and preconditioner, to put them in the form NITSOL !! expects. !! integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of length `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flag indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce J\\vec{v}, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} logical :: success itrmjv = 0 if ( ijob == 0 ) then z = lhs ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 1 else if ( ijob == 1 ) then z = precond ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 2 else error stop ( '`ijob` not equal to 0 or 1.' ) end if end subroutine jacv end subroutine bicgstab_solve !  function scaled_norm(n, x, sx) !    !* Author: Chris MacMackin !    !  Date: December 2016 !    ! !    ! A wraper to the BLAS routine for calculating Euclidean norm !    ! which then scales the norm by the size of the vector. This can !    ! be passed to [[nitsol]] for the argument `dnorm`. !    ! !    implicit none !    integer, intent(in)                :: n !    real(r8), dimension(*), intent(in) :: x !    integer, intent(in)                :: sx !    real(r8)                           :: scaled_norm !    scaled_norm = dnrm2(n,x,sx)/real(n,r8) !  end function scaled_norm ! end module nitsol_mod"},{"title":"prescribed_salinity_eos.F90 – ISOFT","tags":"","loc":"sourcefile/prescribed_salinity_eos.f90.html","text":"This file depends on sourcefile~~prescribed_salinity_eos.f90~~EfferentGraph sourcefile~prescribed_salinity_eos.f90 prescribed_salinity_eos.F90 sourcefile~equation_of_state.f90 equation_of_state.F90 sourcefile~prescribed_salinity_eos.f90->sourcefile~equation_of_state.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules prescribed_eos_mod Source Code prescribed_salinity_eos.F90 Source Code ! !  linear_eos.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module prescribed_eos_mod !* Author: Christopher MacMackin !  Date: March 2017 !  License: GPLv3 ! ! Provides an equation of state where the salinity is prescribed ! such that SD = {\\rm constant}. This is useful for testing and ! debugging the plume model. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , uniform_scalar_field use equation_of_state_mod , only : equation_of_state implicit none private real ( r8 ), parameter :: absolute_zero = - 27 3.15_r8 type , extends ( equation_of_state ), public :: prescribed_eos !* Author: Chris MacMackin !  Date: March 2017 ! ! An equation of state, depending only on salinity, where the ! salinity is prescribed such that SD = {\\rm constant} for ! some specified thickness D. The salinity is related to the ! density by the haline contraction coefficient \\beta_S. The ! only real use for this is testing and debugging the plume model. ! private class ( scalar_field ), allocatable :: density !! The density calculated from the prescribed salinity real ( r8 ) :: beta_s !! The haline contraction coefficient contains procedure :: water_density => prescribed_water_density procedure , pass ( rhs ) :: prescribed_assign generic :: assignment ( = ) => prescribed_assign procedure :: water_density_derivative => prescribed_water_deriv procedure :: haline_contraction => prescribed_haline_contraction procedure :: thermal_contraction => prescribed_thermal_contraction end type prescribed_eos interface prescribed_eos module procedure constructor end interface prescribed_eos contains function constructor ( const , beta_s , thickness ) result ( this ) real ( r8 ), intent ( in ) :: const !! The constant to which SD is equal. real ( r8 ), intent ( in ) :: beta_s !! The haline contraction coefficient, \\beta_S, relating !! salinity and density. class ( scalar_field ), intent ( in ) :: thickness !! The thickness of the plume, from which the salinity is calculated. type ( prescribed_eos ) :: this call thickness % guard_temp () allocate ( this % density , mold = thickness ) this % density = const * beta_s / thickness this % beta_s = beta_s call thickness % clean_temp () end function constructor function prescribed_water_density ( this , temperature , salinity ) result ( density ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns the density corresponding to the prescribed salinity, as ! calculated in the constructor. ! class ( prescribed_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () if ( temperature == uniform_scalar_field ( 0._r8 ) . and . & salinity == uniform_scalar_field ( 0._r8 )) then ! Kludge to ensure correct ambient density is returned call temperature % allocate_scalar_field ( density ) density = uniform_scalar_field ( 0._r8 ) else call this % density % allocate_scalar_field ( density ) density = this % density end if call temperature % clean_temp (); call salinity % clean_temp () call density % set_temp () end function prescribed_water_density function prescribed_water_deriv ( this , temperature , d_temperature , salinity , & d_salinity , dir ) result ( d_density ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Calculates the derivative of the water density. class ( prescribed_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: d_temperature !! A field containing the derivative of the temperature of the !! water, in teh same direction as `dir` class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), intent ( in ) :: d_salinity !! A field containing the derivative of the salinity of the !! water, in the same direction as `dir` integer , intent ( in ) :: dir !! The direction in which to take the derivative class ( scalar_field ), pointer :: d_density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call d_temperature % guard_temp (); call d_salinity % guard_temp () if ( temperature == uniform_scalar_field ( 0._r8 ) . and . & salinity == uniform_scalar_field ( 0._r8 )) then ! Kludge to ensure correct ambient density is returned call temperature % allocate_scalar_field ( d_density ) d_density = uniform_scalar_field ( 0._r8 ) else call this % density % allocate_scalar_field ( d_density ) d_density = this % density % d_dx ( 1 ) end if call temperature % clean_temp (); call salinity % clean_temp () call d_temperature % clean_temp (); call d_salinity % clean_temp () call d_density % set_temp () end function prescribed_water_deriv subroutine prescribed_assign ( lhs , rhs ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Assigns this object to another equation of state object, ! allowing the definided assignment for the precalculated density ! field to work correctly. ! class ( equation_of_state ), intent ( out ) :: lhs class ( prescribed_eos ), intent ( in ) :: rhs select type ( lhs ) class is ( prescribed_eos ) if ( allocated ( lhs % density )) then if (. not . same_type_as ( lhs % density , rhs % density )) then deallocate ( lhs % density ) allocate ( lhs % density , mold = rhs % density ) end if else allocate ( lhs % density , mold = rhs % density ) end if lhs % density = rhs % density class default error stop ( \"Can't assign to `equation_of_state` object of class other \" // & \"than `prescribed_eos`.\" ) end select end subroutine prescribed_assign function prescribed_haline_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: June 2017 ! ! Returns the haline contraction coefficient. ! class ( prescribed_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( this % beta_s ) end function prescribed_haline_contraction function prescribed_thermal_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: June 2017 ! ! Returns the thermal contraction coefficient. ! class ( prescribed_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( 0.0_r8 ) end function prescribed_thermal_contraction end module prescribed_eos_mod"},{"title":"equation_of_state.F90 – ISOFT","tags":"","loc":"sourcefile/equation_of_state.f90.html","text":"Files dependent on this one sourcefile~~equation_of_state.f90~~AfferentGraph sourcefile~equation_of_state.f90 equation_of_state.F90 sourcefile~prescribed_salinity_eos.f90 prescribed_salinity_eos.F90 sourcefile~prescribed_salinity_eos.f90->sourcefile~equation_of_state.f90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~equation_of_state.f90 sourcefile~averaged_linear_eos.f90 averaged_linear_eos.F90 sourcefile~asymmetric_plume.f90->sourcefile~averaged_linear_eos.f90 sourcefile~linear_eos.f90 linear_eos.F90 sourcefile~asymmetric_plume.f90->sourcefile~linear_eos.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~equation_of_state.f90 sourcefile~static_plume.f90->sourcefile~linear_eos.f90 sourcefile~averaged_linear_eos.f90->sourcefile~equation_of_state.f90 sourcefile~linear_eos.f90->sourcefile~equation_of_state.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~equation_of_state.f90 sourcefile~plume.f90->sourcefile~linear_eos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules equation_of_state_mod Source Code equation_of_state.F90 Source Code ! !  equation_of_state.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module equation_of_state_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides an abstract derived type which can be subtyped in order to ! implement an equation of state. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field implicit none private type , abstract , public :: equation_of_state !* Author: Chris MacMackin !  Date: April 2016 ! ! An abstract type with a procedure for calculating water density ! from its temperature and salinity. ! contains procedure ( get_property ), deferred :: water_density !! Returns the water density for the given temperature and salinity. procedure ( get_property_dx ), deferred :: water_density_derivative !! Returns the derivative of the water density for the given !! temperature and salinity. procedure ( get_coef ), deferred :: haline_contraction !! Returns a (possibly approximated) haline contraction coefficient. procedure ( get_coef ), deferred :: thermal_contraction !! Returns a (possibly approximated) therma contraction coefficient. end type equation_of_state abstract interface function get_property ( this , temperature , salinity ) result ( density ) import :: r8 import :: equation_of_state import :: scalar_field class ( equation_of_state ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water end function get_property function get_property_dx ( this , temperature , d_temperature , salinity , & d_salinity , dir ) result ( d_density ) import :: r8 import :: equation_of_state import :: scalar_field class ( equation_of_state ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: d_temperature !! A field containing the derivative of the temperature of the !! water, in teh same direction as `dir` class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), intent ( in ) :: d_salinity !! A field containing the derivative of the salinity of the !! water, in the same direction as `dir` integer , intent ( in ) :: dir !! The direction in which to take the derivative class ( scalar_field ), pointer :: d_density !! A field containing the derivative of the density of the !! water in direction `dir` end function get_property_dx function get_coef ( this , temperature , salinity ) result ( coef ) import :: r8 import :: equation_of_state import :: scalar_field class ( equation_of_state ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef end function get_coef end interface end module equation_of_state_mod"},{"title":"ground.F90 – ISOFT","tags":"","loc":"sourcefile/ground.f90.html","text":"This file depends on sourcefile~~ground.f90~~EfferentGraph sourcefile~ground.f90 ground.F90 sourcefile~basal_surface.f90 basal_surface.F90 sourcefile~ground.f90->sourcefile~basal_surface.f90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~basal_surface.f90->sourcefile~nitsol.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ground_mod Source Code ground.F90 Source Code ! !  ground.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module ground_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides a concrete implementation of the [[basal_surface]] data type, ! representing solid ground. ! use iso_fortran_env , only : r8 => real64 use basal_surface_mod , only : basal_surface use factual_mod , only : scalar_field use hdf5 implicit none private type , extends ( basal_surface ), public :: ground !* Author: Christopher MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[basal_surface]] abstract data type, ! representing the ground beneath an ice sheet. At the moment this ! doesn't actually do anything. ! contains procedure :: basal_melt => ground_melt procedure :: basal_drag_parameter => ground_drag_parameter procedure :: water_density => ground_water_density procedure :: update => ground_update procedure :: data_size => ground_data_size procedure :: state_vector => ground_state_vector procedure :: read_data => ground_read_data procedure :: write_data => ground_write_data procedure :: solve => ground_solve end type ground interface ground module procedure constructor end interface ground contains function constructor () result ( this ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Instantiates a [[ground]] object. ! type ( ground ) :: this end function constructor function ground_melt ( this ) result ( melt ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the melt rate at the bottom of the ice ! sheet due to interaction with the ground. ! class ( ground ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate at the base of the ice sheet. end function ground_melt function ground_drag_parameter ( this ) result ( drag ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns a quantity which may be necessary to determine ! the frictional drag the ground exerts on the bottom of the ice ! sheet. An example would be the coefficient of friction. The ! description of this method is left deliberately vague so that as not ! to constrain how the drag is parameterized. ! class ( ground ), intent ( in ) :: this class ( scalar_field ), pointer :: drag !! The value of a paramter describing the drag of the ground on the !! ice sheet. end function ground_drag_parameter function ground_water_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the density of the water beneath the ice sheet. ! This water would be subglacial discharge and would tend to lubricate ! the motion of the ice sheet. The density probably won't be important ! in the case of an ice sheet, but is included so that the ground data ! type can have the same interface as the [[plume]] data type. ! class ( ground ), intent ( in ) :: this real ( r8 ) :: density !! The density of any water at the base of the ice sheet. end function ground_water_density subroutine ground_update ( this , state_vector , ice_thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the ground from its state vector. The state ! vector is a real array containing the value of each of the ground's ! properties at each of the locations on the grid used in discretization. ! class ( ground ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! ground. class ( scalar_field ), optional , intent ( in ) :: ice_thickness !! The ice thickness which, if present, will be used to update !! the calculation of the melt rate and/or drag parameter. end subroutine ground_update pure function ground_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the ground's state vector. ! This is the size of the vector returned by ! [[ground(type):state_vector]] and taken as an argument by ! [[ground(type):update]]. ! class ( ground ), intent ( in ) :: this integer :: ground_data_size !! The number of elements in the ground's state vector. end function ground_data_size pure function ground_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the ground. ! This takes the form of a 1D array. ! class ( ground ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the ground. end function ground_state_vector subroutine ground_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the ground object from the specified group in ! an HDF file. ! class ( ground ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group from which this data is !! meant to be read. character ( len =* ), intent ( in ) :: group_name !! The name of the group in the HDF5 file storing the !! ground's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id error = 0 end subroutine ground_read_data subroutine ground_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the ground object to an HDF file in the ! specified group. ! class ( ground ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ground's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id call h5gcreate_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then write ( * , * ) 'WARNING: Error code' , error , ' returned when creating HDF ' // & 'group' , group_name write ( * , * ) '         Data IO not performed for ice shelf' return end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then write ( * , * ) 'WARNING: Error code' , error , ' returned when closing HDF ' // & 'group' , group_name write ( * , * ) '         Possible bad IO' end if end subroutine ground_write_data subroutine ground_solve ( this , ice_thickness , ice_density , & ice_temperature , time , success ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Solves the state of the ground for the specified ice properties, ! at the specified time. ! class ( ground ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: ice_thickness !! Thickness of the ice above the basal surface real ( r8 ), intent ( in ) :: ice_density !! The density of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: ice_temperature !! The temperature of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: time !! The time to which the basal surface should be solved logical , intent ( out ) :: success !! True if the solver is successful, false otherwise end subroutine ground_solve end module ground_mod"},{"title":"plume_boundary.F90 – ISOFT","tags":"","loc":"sourcefile/plume_boundary.f90.html","text":"This file depends on sourcefile~~plume_boundary.f90~~EfferentGraph sourcefile~plume_boundary.f90 plume_boundary.F90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~plume_boundary.f90->sourcefile~boundary_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~plume_boundary.f90~~AfferentGraph sourcefile~plume_boundary.f90 plume_boundary.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~plume_boundary.f90 sourcefile~simple_plume.f90 simple_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~simple_plume.f90 sourcefile~upstream_plume.f90 upstream_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~upstream_plume.f90 sourcefile~dallaston2015_seasonal.f90 dallaston2015_seasonal.F90 sourcefile~dallaston2015_seasonal.f90->sourcefile~plume_boundary.f90 sourcefile~simple_plume.f90->sourcefile~plume_boundary.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~plume_boundary.f90 sourcefile~static_plume.f90->sourcefile~simple_plume.f90 sourcefile~static_plume.f90->sourcefile~upstream_plume.f90 sourcefile~upstream_plume.f90->sourcefile~plume_boundary.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~plume_boundary.f90 sourcefile~plume.f90->sourcefile~simple_plume.f90 sourcefile~plume.f90->sourcefile~upstream_plume.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules plume_boundary_mod Source Code plume_boundary.F90 Source Code ! !  plume_boundary.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module plume_boundary_mod !* Author: Christopher MacMackin !  Date: September 2016 !  License: GPLv3 ! ! Provides an abstract derived type which can be subtyped in order to ! specify the boundary conditions for plume types. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field , uniform_scalar_field , & uniform_vector_field use boundary_types_mod , only : free_boundary implicit none private type , public :: plume_boundary !* Author: Chris MacMackin !  Date: September 2016 ! ! A type in which procedures for getting the boundary conditions ! of plumes are to be specified. The descendent types can contain ! whatever data is needed to compute the result. ! ! This class effectively provides free boundary conditions. It's ! type-bound procedures should be overridden to provide case-specific ! conditions. ! contains procedure :: thickness_bound_info => bound_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: velocity_bound_info => bound_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: temperature_bound_info => bound_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: salinity_bound_info => bound_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: thickness_bound => scalar_bound !! Produces a field containing the boundary conditions for plume !! thickness at the specified location. procedure :: velocity_bound => vector_bound !! Produces a field containing the boundary conditions for plume !! velocity at the specified location. procedure :: temperature_bound => scalar_bound !! Produces a field containing the boundary conditions for plume !! temperature at the specified location. procedure :: salinity_bound => scalar_bound !! Produces a field containing the boundary conditions for plume !! salinity at the specified location. procedure :: set_time !! Specifies the time at which to calculate the boundary !! conditions. end type plume_boundary contains subroutine bound_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Provides information about the type of boundary, and the number ! of layers of data-points needed to describe it. ! class ( plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. bound_type = free_boundary bound_depth = 0 end subroutine bound_info function scalar_bound ( this , location ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the boundary values for the specified ! boundary location. ! class ( plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: scalar_bound type ( uniform_scalar_field ) :: dummy call dummy % allocate_scalar_field ( scalar_bound ) scalar_bound = uniform_scalar_field ( 0.0_r8 ) end function scalar_bound function vector_bound ( this , location ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the boundary values for the specified ! boundary location. ! class ( plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( vector_field ), pointer :: vector_bound type ( uniform_scalar_field ) :: dummy call dummy % allocate_vector_field ( vector_bound ) vector_bound = uniform_vector_field ([ 0.0_r8 , 0.0_r8 ]) end function vector_bound subroutine set_time ( this , time ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Sets the time at which boundary conditions are to be calculated. ! class ( plume_boundary ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time end subroutine set_time end module plume_boundary_mod"},{"title":"ice_sheet.F90 – ISOFT","tags":"","loc":"sourcefile/ice_sheet.f90.html","text":"This file depends on sourcefile~~ice_sheet.f90~~EfferentGraph sourcefile~ice_sheet.f90 ice_sheet.F90 sourcefile~viscosity.f90 viscosity.F90 sourcefile~ice_sheet.f90->sourcefile~viscosity.f90 sourcefile~jacobian_block.f90 jacobian_block.F90 sourcefile~ice_sheet.f90->sourcefile~jacobian_block.f90 sourcefile~glacier.f90 glacier.F90 sourcefile~ice_sheet.f90->sourcefile~glacier.f90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~jacobian_block.f90->sourcefile~boundary_types.f90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~glacier.f90->sourcefile~nitsol.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ice_sheet_mod Source Code ice_sheet.F90 Source Code ! !  ice_sheet.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module ice_sheet_mod !* Author: Christopher MacMackin !  Date: April 2016 !  License: GPLv3 ! ! Provides a concrete implementation of the [[glacier]] type, using ! a vertically integrated model of an ice sheet. ! use iso_fortran_env , only : r8 => real64 !use foodie, only: integrand use glacier_mod , only : glacier , thickness_func , velocity_func use factual_mod , only : scalar_field , vector_field , cheb1d_scalar_field , & cheb1d_vector_field , maxval use viscosity_mod , only : abstract_viscosity use jacobian_block_mod , only : jacobian_block use hdf5 use logger_mod , only : logger => master_logger implicit none private type , extends ( glacier ), public :: ice_sheet !* Author: Chris MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[glacier]] type, using a vertically ! integrated model of an ice sheet. This model is 1-dimensional only. ! private type ( cheb1d_scalar_field ) :: thickness !! Thickness of ice sheet, $h$ type ( cheb1d_vector_field ) :: velocity !! Flow velocity of ice sheet, $\\vec{u}$ real ( r8 ) :: lambda !! The dimensionless ratio !! $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real ( r8 ) :: chi !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ class ( abstract_viscosity ), allocatable :: viscosity_law !! An object representing the model used for ice viscosity. real ( r8 ) :: time !! The time at which the ice sheet is in this state contains !$    procedure            :: t => sheet_dt !$    procedure            :: local_error => sheet_local_error !$    procedure            :: integrand_multiply_integrand => sheet_m_sheet !$    procedure            :: integrand_multiply_real => sheet_m_real !$    procedure, pass(rhs) :: real_multiply_integrand => real_m_sheet !$    procedure            :: add => sheet_add !$    procedure            :: sub => sheet_sub !$    procedure            :: assign_integrand => sheet_assign procedure :: ice_thickness => sheet_thickness !$    procedure :: ice_velocity => sheet_velocity procedure :: ice_density => sheet_density procedure :: ice_temperature => sheet_temperature procedure :: residual => sheet_residual procedure :: update => sheet_update procedure :: precondition => sheet_precondition procedure :: set_time => sheet_set_time procedure :: data_size => sheet_data_size procedure :: state_vector => sheet_state_vector procedure :: solve_velocity => sheet_solve_velocity procedure :: read_data => sheet_read_data procedure :: write_data => sheet_write_data procedure :: time_step => sheet_time_step procedure , private :: assign => sheet_assign end type ice_sheet interface ice_sheet module procedure constructor end interface ice_sheet contains function constructor ( domain , resolution , thickness , velocity , & viscosity_law , lambda , chi ) result ( this ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Creates a new [[ice_sheet]] object with initial conditions provided ! by the arguments. At present only a 1D model is supported. If ! information is provided for higher dimensions then it will be ignored. ! real ( r8 ), dimension (:,:), intent ( in ) :: domain !! An array containing the upper and lower limits of the domain for !! the ice sheet. The first index represents the dimension for which !! the boundaries apply. If the second index is 1 then it corresponds !! to the lower bound. If the second index is 2 then it corresponds to !! the upper bound. integer , dimension (:), intent ( in ) :: resolution !! The number of data points in each dimension procedure ( thickness_func ) :: thickness !! A function which calculates the initial value of the thickness of !! the ice sheet at a given location. procedure ( velocity_func ) :: velocity !! A function which calculates the initial value of the velocity !! (vector) of the ice at a given location in an ice sheet. class ( abstract_viscosity ), intent ( in ), optional :: viscosity_law !! An object which calculates the viscosity of the ice. real ( r8 ), intent ( in ), optional :: lambda !! The dimensionless ratio !! $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real ( r8 ), intent ( in ), optional :: chi !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ type ( ice_sheet ) :: this !! An ice sheet object with its domain and initial conditions set !! according to the arguments of the constructor function. end function constructor !$  function sheet_dt(self,t) !$    !* Author: Christopher MacMackin !$    !  Date: April 2016 !$    ! !$    ! Computes the derivative of the ice sheet with respect to time. As !$    ! the only property of the ice which explicitely changes with time is !$    ! the ice thickness, that will be the only portion of the returned type !$    ! which actually corresponds to the derivative. !$    ! !$    class(ice_sheet), intent(in)   :: self !$    real(r8), intent(in), optional :: t !$      !! Time at which to evaluate the derivative !$    class(integrand), allocatable  :: sheet_dt !$      !! The time rate of change of the ice sheet. Has dynamic type !$      !! [[ice_sheet]]. !$  end function sheet_dt !$ !$  function sheet_local_error(lhs, rhs) result(error) !$    !* Author: Christopher MacMackin !$    !  Date: April 2016 !$    ! !$    ! Calculates a real scalar to represent the absolute difference between !$    ! two ice_sheet objects. `rhs` must be a a [[ice_sheet]] object, or a !$    ! runtime error will occur. !$    ! !$    class(ice_sheet), intent(in) :: lhs !$      !! Self !$    class(integrand), intent(in) :: rhs !$      !! The ice sheet object which is being compared against. !$    real(r8) :: error !$      !! The scalar representation of the absolute difference between these !$      !! two ice shelves. !$  end function sheet_local_error !$ !$  function sheet_m_sheet(lhs, rhs) result(product) !$    !* Author: Christopher MacMackin !$    !  Date: April 2016 !$    ! !$    ! Multiplies one ice sheet object by another. That is to say, it !$    ! performs element-wise multiplication of the state vectors !$    ! representing the two arguments. `rhs` must be an [[ice_sheet]] !$    ! object, or a runtime error will occur. !$    ! !$    class(ice_sheet), intent(in)  :: lhs !$      !! Self !$    class(integrand), intent(in)  :: rhs !$      !! The ice sheet object being multiplied by. !$    class(integrand), allocatable :: product !$      !! The product of the two arguments. Has dynamic type [[ice_sheet]]. !$  end function sheet_m_sheet !$ !$  function sheet_m_real(lhs, rhs) result(product) !$    !* Author: Christopher MacMackin !$    !  Date: April 2016 !$    ! !$    ! Multiplies one ice sheet object by a scalar. That is to say, it !$    ! performs element-wise multiplication of the state vector !$    ! representing the ice sheet. !$    ! !$    class(ice_sheet), intent(in)  :: lhs !$      !! Self !$    real(r8), intent(in)          :: rhs !$      !! The scalar being multiplied by. !$    class(integrand), allocatable :: product !$      !! The product of the two arguments. Has dynamic type [[ice_sheet]]. !$  end function sheet_m_real !$ !$  function real_m_sheet(lhs, rhs) result(product) !$    !* Author: Christopher MacMackin !$    !  Date: April 2016 !$    ! !$    ! Multiplies one ice sheet object by a scalar. That is to say, it !$    ! performs element-wise multiplication of the state vector !$    ! representing the ice sheet. !$    ! !$    real(r8), intent(in)          :: lhs !$      !! The scalar being multiplied by. !$    class(ice_sheet), intent(in)  :: rhs !$      !! Self !$    class(integrand), allocatable :: product !$      !! The product of the two arguments. Has dynamic type [[ice_sheet]]. !$  end function real_m_sheet !$ !$  function sheet_add(lhs, rhs) result(sum) !$    !* Author: Christopher MacMackin !$    !  Date: April 2016 !$    ! !$    ! Adds one ice sheet object to another. That is to say, it performs !$    ! element-wise addition of the state vectors representing the two !$    ! arguments. `rhs` must be an [[ice_sheet]] object, or a runtime !$    ! error will occur. !$    ! !$    class(ice_sheet), intent(in)  :: lhs !$      !! Self !$    class(integrand), intent(in)  :: rhs !$      !! The ice sheet object being added. !$    class(integrand), allocatable :: sum !$      !! The sum of the two arguments. Has dynamic type [[ice_sheet]]. !$  end function sheet_add !$ !$  function sheet_sub(lhs, rhs) result(difference) !$    !* Author: Christopher MacMackin !$    !  Date: April 2016 !$    ! !$    ! Subtracts one ice sheet object from another. That is to say, it !$    ! performs element-wise addition of the state vectors representing !$    ! the two arguments. `rhs` must be a a [[ice_sheet]] object, or a !$    ! runtime error will occur. !$    ! !$    class(ice_sheet), intent(in)  :: lhs !$      !! Self !$    class(integrand), intent(in)  :: rhs !$      !! The ice sheet object being subtracted. !$    class(integrand), allocatable :: difference !$      !! The difference of the two arguments. Has dynamic type [[ice_sheet]]. !$  end function sheet_sub !$ !$  subroutine sheet_assign(lhs, rhs) !$    !* Author: Christopher MacMackin !$    !  Date: April 2016 !$    ! !$    ! Assigns the `rhs` ice sheet to this, `lhs`, one. All components !$    ! will be the same following the assignment. !$    ! !$    class(ice_sheet), intent(inout) :: lhs !$      !! Self !$    class(integrand), intent(in)    :: rhs !$      !! The object to be assigned. Must have dynamic type [[ice_sheet]], !$      !! or a runtime error will occur. !$  end subroutine sheet_assign pure function sheet_thickness ( this ) result ( thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the thickness of the ice sheet across its domain. ! class ( ice_sheet ), intent ( in ) :: this class ( scalar_field ), pointer :: thickness !! The ice thickness. end function sheet_thickness function sheet_velocity ( this ) result ( velocity ) !* Author: Christopher MacMackin !  Date: July 2016 ! ! Returns the velocity of the ice sheet across its domain. ! class ( ice_sheet ), intent ( in ) :: this class ( vector_field ), allocatable :: velocity !! The ice velocity. allocate ( velocity , source = this % velocity ) end function sheet_velocity pure function sheet_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the density of the ice in the sheet, which is assumed to be ! uniform across its domain. ! class ( ice_sheet ), intent ( in ) :: this real ( r8 ) :: density !! The ice density. end function sheet_density pure function sheet_temperature ( this ) result ( temperature ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the density of the ice in the sheet, which is assumed to be ! uniform across its domain. ! class ( ice_sheet ), intent ( in ) :: this real ( r8 ) :: temperature !! The ice density. end function sheet_temperature function sheet_residual ( this , previous_states , melt_rate , basal_drag_parameter , & water_density ) result ( residual ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the residual when the current state of the glacier is run ! through the system of equations describing it. The residual takes the ! form of a 1D array, with each element respresenting the residual for ! one of the equations in the system. ! class ( ice_sheet ), intent ( in ) :: this class ( glacier ), dimension (:), intent ( in ) :: previous_states !! The states of the glacier in the previous time steps. The !! first element of the array should be the most recent. The !! default implementation will only make use of the most recent !! state, but the fact that this is an array allows overriding !! methods to use older states for higher-order integration !! methods. class ( scalar_field ), intent ( in ) :: melt_rate !! Thickness of the ice above the glacier. class ( scalar_field ), intent ( in ) :: basal_drag_parameter !! A paramter, e.g. coefficient of friction, needed to calculate the !! drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier. real ( r8 ), dimension (:), allocatable :: residual !! The residual of the system of equations describing the glacier. end function sheet_residual subroutine sheet_update ( this , state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the ice sheet from its state vector. The state ! vector is a real array containing the value of each of the ice sheet's ! properties at each of the locations on the grid used in descretization. ! class ( ice_sheet ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! glacier. end subroutine sheet_update function sheet_precondition ( this , previous_states , melt_rate , & basal_drag_parameter , water_density , & delta_state ) result ( preconditioned ) !* Author: Chris MacMackin !  Date: January 2016 ! ! Provides a preconditioner for the nonlinear solver trying to ! bring the residual to zero. The Jacobian is approximated as a ! block matrix, where each block is a tridiagonal matrix using a ! finite difference method for differentiation. ! class ( ice_sheet ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: previous_states !! The states of the glacier in the previous time steps. The !! first element of the array should be the most recent. The !! default implementation will only make use of the most !! recent state, but the fact that this is an array allows !! overriding methods to use older states for higher-order !! integration methods. class ( scalar_field ), intent ( in ) :: melt_rate !! Thickness of the ice above the glacier class ( scalar_field ), intent ( in ) :: basal_drag_parameter !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier real ( r8 ), dimension (:), intent ( in ) :: delta_state !! The change to the state vector which is being preconditioned. real ( r8 ), dimension (:), allocatable :: preconditioned !! The result of applying the preconditioner to `delta_state`. end function sheet_precondition subroutine sheet_set_time ( this , time ) !* Author: Christopher MacMackin !  Date: November 2016 ! ! Sets the time information held by the ice sheet object. This is ! the time at which the ice sheet is in its current state. ! class ( ice_sheet ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time !! The time at which the glacier is in the present state. this % time = time end subroutine sheet_set_time pure function sheet_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the ice sheet's state vector. ! This is the size of the vector returned by [[ice_sheet(type):residual]] ! and [[ice_sheet(type):state_vector]] and taken as an argument by ! [[ice_sheet(type):update]]. ! class ( ice_sheet ), intent ( in ) :: this integer :: sheet_data_size !! The number of elements in the ice sheet's state vector. end function sheet_data_size pure function sheet_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the ice sheet. ! This takes the form of a 1D array. ! class ( ice_sheet ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the ice sheet. end function sheet_state_vector subroutine sheet_solve_velocity ( this , basal_drag , success ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Computes the ice sheet velocity at the current time with the ! current ice thickness. ! class ( ice_sheet ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: basal_drag !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. logical , intent ( out ) :: success !! True if the integration is successful, false otherwise end subroutine sheet_solve_velocity subroutine sheet_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the ice shelf object from the specified group ! in an HDF5 file. This sets the thickness, the velocity, and ! parameter values. ! class ( ice_sheet ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. end subroutine sheet_read_data subroutine sheet_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the ice sheet object to an HDF file in the ! specified group. This will consist of a thickness and a velocity ! dataset. ! class ( ice_sheet ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice sheet's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. end subroutine sheet_write_data function sheet_time_step ( this ) result ( dt ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Calculates the time step for integrating the ice sheet, using ! the CFL condition. ! class ( ice_sheet ), intent ( in ) :: this real ( r8 ) :: dt !! The time-step to use end function sheet_time_step subroutine sheet_assign ( this , rhs ) !* Author: Chris MacMackin !  Date: February 2017 ! ! Copies the data from one ice sheet into another. This is only ! needed due to a bug in gfortran which means that the intrinsic ! assignment for glacier types is not using the appropriate ! defined assignment for the field components. ! ! It does not assign the Jacobian object as it would take up quite ! a bit of extra space and it is unlikely that it would ever be ! needed without first having to be recalculated. ! class ( ice_sheet ), intent ( out ) :: this class ( glacier ), intent ( in ) :: rhs !! The ice sheet to be assigned to this one. select type ( rhs ) class is ( ice_sheet ) this % thickness = rhs % thickness this % velocity = rhs % velocity this % lambda = rhs % lambda this % chi = rhs % chi allocate ( this % viscosity_law , source = rhs % viscosity_law ) this % time = rhs % time class default call logger % fatal ( 'ice_sheet%assign' , 'Type other than `ice_sheet` ' // & 'requested to be assigned.' ) error stop end select #ifdef DEBUG call logger % debug ( 'ice_sheet%assign' , 'Copied ice sheet data.' ) #endif end subroutine sheet_assign end module ice_sheet_mod"},{"title":"finite_difference_block.F90 – ISOFT","tags":"","loc":"sourcefile/finite_difference_block.f90.html","text":"This file depends on sourcefile~~finite_difference_block.f90~~EfferentGraph sourcefile~finite_difference_block.f90 finite_difference_block.F90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~finite_difference_block.f90->sourcefile~boundary_types.f90 sourcefile~nitsol.f90 nitsol.f90 sourcefile~finite_difference_block.f90->sourcefile~nitsol.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules finite_difference_block_mod Source Code finite_difference_block.F90 Source Code ! !  fin_diff_block.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module finite_difference_block_mod !* Author: Christopher MacMackin !  Date: march 2017 !  License: GPLv3 ! ! Provides a derived type which representes a finite difference ! matrix/operator. This can be useful for preconditioning problems ! which use a spectral discretisation. ! use iso_fortran_env , only : r8 => real64 use factual_mod !, only: abstract_field, scalar_field, vector_field use boundary_types_mod , only : dirichlet , neumann , free_boundary use f95_lapack , only : la_gtsvx use nitsol_mod , only : dnrm2 use penf , only : str use logger_mod , only : logger => master_logger implicit none private integer , parameter :: no_extra_derivative = - 1 type , public :: fin_diff_block !* Author: Chris MacMackin !  Date: December 2016 ! ! A data type representing a matrix finite difference operator. It ! can be useful when preconditioning systems which use a spectral ! discretisation. It is inherently 1-D in its implementation. Note ! that multiplication of a field will simply call that field's ! differentiation operator, which may or may not use a finite ! difference method. ! ! When constructing an instance of this type, a template field ! must be passed which has the same grid as any other fields which ! will be operated upon. Additionally, types and locations of ! boundary conditions must be passed. ! private real ( r8 ), dimension (:), allocatable :: diagonal !! The diagonal of the tridiagonal matrix representation of this !! block. real ( r8 ), dimension (:), allocatable :: super_diagonal !! The super-diagonal of the tridiagonal matrix representation !! of this block. real ( r8 ), dimension (:), allocatable :: sub_diagonal !! The sub-diagonal of the tridiagonal matrix representation of !! this block. real ( r8 ), dimension (:), allocatable :: l_multipliers !! Multipliers defining the L matrix in the LU factorisation of !! the tridiagonal matrix representation of this block. real ( r8 ), dimension (:), allocatable :: u_diagonal !! The diagonal of the U matrix in the LU factorisation of !! the tridiagonal matrix representation of this block. real ( r8 ), dimension (:), allocatable :: u_superdiagonal1 !! The first superdiagonal of the U matrix in the LU !! factorisation of the tridiagonal matrix representation of !! this block. real ( r8 ), dimension (:), allocatable :: u_superdiagonal2 !! The second superdiagonal of the U matrix in the LU !! factorisation of the tridiagonal matrix representation of !! this block. integer , dimension (:), allocatable :: pivots !! Pivot indicies from the LU factorisation of the tridiagonal !! matrix representation of this block. integer , dimension (:), allocatable :: boundary_locs !! Locations in the raw arrays which are used to specify !! boundary conditions. integer , dimension (:), allocatable :: boundary_types !! The types of boundary conditions, specified using the !! parameters found in [[boundary_types_mod]]. logical :: had_offset = . true . !! True if the factorisation was computed from a tridiagonal !! system in which an offset was added to the diagonal. !    real(r8)                            :: magnitude !      !! The norm of the superdiagonal of the matrix. If an iterative !      !! method is used, this is needed to decide how to do so. contains private procedure :: fin_diff_block_solve_scalar procedure :: fin_diff_block_solve_vector generic , public :: solve_for => fin_diff_block_solve_scalar , & fin_diff_block_solve_vector end type fin_diff_block interface fin_diff_block module procedure constructor end interface fin_diff_block contains function constructor ( template , boundary_locs , boundary_types ) result ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Build a tridiagonal matrix block for finite differences. See the ! end of the documentation of the [[fin_diff_block(type)]] type ! for a description of how boundary conditions are treated. ! class ( abstract_field ), intent ( in ) :: template !! A scalar field with the same grid as any fields passed as !! arguments to the [[fin_diff_block(type):solve_for]] method. integer , dimension (:), optional , intent ( in ) :: boundary_locs !! The locations in the raw representation of `rhs` for which !! boundary conditions are specified. Defaults to there being !! none. integer , dimension (:), optional , intent ( in ) :: boundary_types !! Integers specifying the type of boundary condition. The type !! of boundary condition corresponding to a given integer is !! specified in [[boundary_types_mod]]. Only Dirichlet and !! Neumann conditions are supported. Defaults to Dirichlet. The !! order in which they are stored must match that of !! `boundary_locs`. type ( fin_diff_block ) :: this !! A new finite difference operator integer :: i , n , pos logical :: use_cached real ( r8 ), dimension (:), allocatable , save :: cached_dx_c real ( r8 ), save :: cached_upper_bound , & cached_lower_bound class ( vector_field ), pointer :: grid class ( abstract_field ), allocatable , save :: cached_field_type real ( r8 ), dimension (:,:), allocatable :: domain if ( present ( boundary_locs )) then this % boundary_locs = boundary_locs else allocate ( this % boundary_locs ( 0 )) end if if ( present ( boundary_types )) then this % boundary_types = boundary_types else allocate ( this % boundary_types ( size ( this % boundary_locs ))) this % boundary_types = dirichlet end if n = template % raw_size () domain = template % domain () ! Try to use cached copy of inverse grid spacing, if available and suitable if ( allocated ( cached_field_type )) then use_cached = same_type_as ( template , cached_field_type ) . and . & abs ( domain ( 1 , 1 ) - cached_lower_bound ) < 1 e - 10 . and . & abs ( domain ( 1 , 2 ) - cached_upper_bound ) < 1 e - 10 . and . & n == size ( cached_dx_c ) else use_cached = . false . end if ! Construct an array containing the distance between grid ! points, if necessary if (. not . use_cached ) then if ( allocated ( cached_field_type )) then deallocate ( cached_field_type ) deallocate ( cached_dx_c ) end if #ifdef DEBUG call logger % debug ( 'fin_diff_block' , 'Calculating and caching ' // & 'grid spacings.' ) #endif cached_lower_bound = domain ( 1 , 1 ) cached_upper_bound = domain ( 1 , 2 ) allocate ( cached_field_type , mold = template ) allocate ( cached_dx_c ( n )) call template % allocate_vector_field ( grid ) grid = template % grid_spacing () ! Use this array to temporarily hold the grid spacings cached_dx_c = grid % raw () cached_dx_c ( 2 : n - 1 ) = 0.5_r8 / cached_dx_c ( 2 : n - 1 ) cached_dx_c ( 1 ) = 1._r8 / cached_dx_c ( 1 ) cached_dx_c ( n ) = 1._r8 / cached_dx_c ( n ) end if ! Create tridiagonal matrix allocate ( this % diagonal ( n )) this % diagonal = 0._r8 this % diagonal ( 1 ) = - cached_dx_c ( 1 ) this % diagonal ( n ) = cached_dx_c ( n ) this % super_diagonal = cached_dx_c ( 1 : n - 1 ) this % sub_diagonal = - cached_dx_c ( 2 : n ) ! Apply boundary conditions this % diagonal ( 1 ) = this % diagonal ( 1 ) + 1 e - 7 do i = 1 , size ( this % boundary_locs ) pos = this % boundary_locs ( i ) select case ( this % boundary_types ( i )) case ( dirichlet ) this % diagonal ( pos ) = 1._r8 if ( pos < n ) this % super_diagonal ( pos ) = 0._r8 if ( pos > 1 ) this % sub_diagonal ( pos - 1 ) = 1.e-7_r8 case ( neumann ) if ( pos == n ) then this % diagonal ( n ) = cached_dx_c ( n ) this % sub_diagonal ( n - 1 ) = - cached_dx_c ( n ) else if ( pos == 1 ) then this % diagonal ( 1 ) = - cached_dx_c ( 1 ) this % super_diagonal ( 1 ) = cached_dx_c ( 1 ) else this % super_diagonal ( pos ) = cached_dx_c ( pos ) this % sub_diagonal ( pos - 1 ) = cached_dx_c ( pos ) this % diagonal ( pos ) = 0._r8 end if case ( free_boundary ) continue case default call logger % fatal ( 'fin_diff_block' , 'Boundary condition of ' // & 'type other than Dirichlet or Neumann encountered.' ) error stop end select end do do i = 1 , size ( this % boundary_locs ) pos = this % boundary_locs ( i ) select case ( this % boundary_types ( i )) case ( dirichlet ) this % diagonal ( pos ) = 1._r8 if ( pos < n ) this % super_diagonal ( pos ) = 0._r8 if ( pos > 1 ) this % sub_diagonal ( pos - 1 ) = 1.e-7_r8 case ( neumann ) if ( pos == n ) then this % diagonal ( n ) = cached_dx_c ( n ) this % sub_diagonal ( n - 1 ) = - cached_dx_c ( n ) else if ( pos == 1 ) then this % diagonal ( 1 ) = - cached_dx_c ( 1 ) this % super_diagonal ( 1 ) = cached_dx_c ( 1 ) else this % super_diagonal ( pos ) = cached_dx_c ( pos ) this % sub_diagonal ( pos - 1 ) = cached_dx_c ( pos ) this % diagonal ( pos ) = 0._r8 end if case ( free_boundary ) continue case default call logger % fatal ( 'fin_diff_block' , 'Boundary condition of ' // & 'type other than Dirichlet or Neumann encountered.' ) error stop end select end do !this%magnitude = dnrm2(n-1, this%super_diagonal, 1) #ifdef DEBUG call logger % debug ( 'fin_diff_block' , 'Instantiated a finite difference ' // & 'block object.' ) #endif end function constructor !  subroutine fin_diff_block_set_bounds(this, subdiag, diag, supdiag) !    !* Author: Chris MacMackin !    !  Date: June 2017 !    ! !    ! Alters the provided tridiagonal vector to incorporate the !    ! boundary conditions of this block. !    ! !    class(fin_diff_block), intent(in)     :: this !    real(r8), dimension(:), intent(inout) :: subdiag !      !! The subdiagonal !    real(r8), dimension(:), intent(inout) :: diag !      !! The diagonal !    real(r8), dimension(:), intent(inout) :: supdiag !      !! The diagonal !    integer :: i, n, pos !    do i = 1, size(this%boundary_locs) !      pos = this%boundary_locs(i) !      select case(this%boundary_types(i)) !      case(dirichlet) !        diag(pos) = 1._r8 !        if (pos < n) supdiag(pos) = 0._r8 !        if (pos > 1) subdiag(pos-1) = 1.e-7_r8 !      case(neumann) !        if (pos == n) then !          diag(n) = cached_dx_c(n) !          subdiag(n-1) = -cached_dx_c(n) !        else if (pos == 1) then !          diag(1) = -cached_dx_c(1) !          supdiag(1) = cached_dx_c(1) !        else !          supdiag(pos) = cached_dx_c(pos) !          subdiag(pos-1) = cached_dx_c(pos) !          diag(pos) = 0._r8 !        end if !      case(free_boundary) !        continue !      case default !        call logger%fatal('fin_diff_block','Boundary condition of '// & !                          'type other than Dirichlet or Neumann encountered.') !        error stop !      end select !    end do !  end subroutine fin_diff_block_set_bounds function fin_diff_block_solve_scalar ( this , rhs , offset ) result ( solution ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Solves the linear(ised) system represented by this finite ! difference block, for a given right hand side state vector ! (represented by a scalar field). Optionally, the differential ! operator can be augmented by adding an offset, i.e. a scalar ! field which is added to the operator. ! ! @Warning Currently this is only implemented for a 1-D field. ! class ( fin_diff_block ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: rhs !! The right hand side of the linear(ised) system. class ( scalar_field ), optional , intent ( in ) :: offset !! An offset to add to the differential operator class ( scalar_field ), pointer :: solution real ( r8 ), dimension (:), allocatable :: sol_vector , diag_vector integer :: flag , n , i , j real ( r8 ) :: forward_err , & backward_err , & condition_num character ( len = 1 ) :: factor character ( len = :), allocatable :: msg call rhs % guard_temp () if ( present ( offset )) call offset % guard_temp () allocate ( sol_vector ( rhs % raw_size ())) ! Allocate the arrays used to hold the factorisation of the ! tridiagonal matrix n = size ( this % diagonal ) if (. not . allocated ( this % pivots )) then allocate ( this % l_multipliers ( n - 1 )) allocate ( this % u_diagonal ( n )) allocate ( this % u_superdiagonal1 ( n - 1 )) allocate ( this % u_superdiagonal2 ( n - 2 )) allocate ( this % pivots ( n )) factor = 'N' else if (. not . present ( offset ) . and . . not . this % had_offset ) then factor = 'F' else factor = 'N' end if end if if ( present ( offset )) then #ifdef DEBUG if ( offset % elements () /= n ) then call logger % fatal ( 'fin_diff_block%solve_for' , 'Offset field has ' // & 'different resolution than finite difference block.' ) end if #endif allocate ( diag_vector ( n )) where ( this % diagonal == 0._r8 ) diag_vector = this % diagonal + offset % raw () elsewhere diag_vector = this % diagonal end where if (. not . any ( 1 == this % boundary_locs )) then diag_vector ( 1 ) = diag_vector ( 1 ) + offset % get_element ( 1 ) end if if (. not . any ( n == this % boundary_locs )) then diag_vector ( n ) = diag_vector ( n ) + offset % get_element ( n ) end if do i = 1 , size ( this % boundary_locs ) j = this % boundary_locs ( i ) if (( j == 1 . or . j == n ) . and . this % boundary_types ( i ) == free_boundary ) then diag_vector ( j ) = diag_vector ( j ) + offset % get_element ( j ) end if end do call la_gtsvx ( this % sub_diagonal , diag_vector , this % super_diagonal , & rhs % raw (), sol_vector , this % l_multipliers , & this % u_diagonal , this % u_superdiagonal1 , & this % u_superdiagonal2 , this % pivots , factor , 'N' , & forward_err , backward_err , condition_num , flag ) else call la_gtsvx ( this % sub_diagonal , this % diagonal , this % super_diagonal , & rhs % raw (), sol_vector , this % l_multipliers , this % u_diagonal , & this % u_superdiagonal1 , this % u_superdiagonal2 , this % pivots , & factor , 'N' , forward_err , backward_err , condition_num , & flag ) end if if ( flag /= 0 ) then msg = 'Tridiagonal matrix solver returned with flag ' // str ( flag ) call logger % error ( 'fin_diff_block%solve_for' , msg ) else this % had_offset = present ( offset ) #ifdef DEBUG msg = 'Tridiagonal matrix solver retunred with estimated condition ' // & 'number ' // str ( condition_num ) call logger % debug ( 'fin_diff_block%solve_for' , msg ) #endif end if call rhs % allocate_scalar_field ( solution ) call solution % unset_temp () call solution % assign_meta_data ( rhs ) call solution % set_from_raw ( sol_vector ) if ( present ( offset )) call offset % clean_temp () call rhs % clean_temp (); call solution % set_temp () end function fin_diff_block_solve_scalar function fin_diff_block_solve_vector ( this , rhs , offset ) result ( solution ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Solves the linear(ised) system represented by this finite ! difference block, for a given right hand side state vector ! (represented by a vector field). Optionally, the differential ! operator can be augmented by adding an offset, i.e. a vector ! field which is added to the operator. ! ! @Warning Currently this is only implemented for a 1-D field. ! ! @Bug For some reason, calls to the `vector_dimensions()` method ! produce a segfault when `rhs` is ! `class(vector_field)`. Everything works fine if it is ! `class(cheb1d_vector_field)`, so this is used as a workaround. ! class ( fin_diff_block ), intent ( inout ) :: this class ( cheb1d_vector_field ), intent ( in ) :: rhs !! The right hand side of the linear(ised) system. class ( cheb1d_vector_field ), optional , intent ( in ) :: offset !! An offset to add to the differential operator class ( vector_field ), pointer :: solution real ( r8 ), dimension (:), allocatable :: sol_vector , diag_vector integer :: flag , n , i , j , k class ( scalar_field ), pointer :: component , ocomponent integer :: m real ( r8 ) :: forward_err , & backward_err , & condition_num character ( len = 1 ) :: factor character ( len = :), allocatable :: msg call rhs % guard_temp () if ( present ( offset )) call offset % guard_temp () allocate ( sol_vector ( rhs % raw_size ())) n = size ( this % diagonal ) ! Allocate the arrays used to hold the factorisation of the ! tridiagonal matrix if (. not . allocated ( this % pivots )) then allocate ( this % l_multipliers ( n - 1 )) allocate ( this % u_diagonal ( n )) allocate ( this % u_superdiagonal1 ( n - 1 )) allocate ( this % u_superdiagonal2 ( n - 2 )) allocate ( this % pivots ( n )) factor = 'N' else if (. not . present ( offset ) . and . . not . this % had_offset ) then factor = 'F' else factor = 'N' end if end if call rhs % allocate_scalar_field ( component ) call component % guard_temp () if ( present ( offset )) then #ifdef DEBUG if ( offset % elements () /= n ) then call logger % fatal ( 'fin_diff_block%solve_for' , 'Offset field has ' // & 'different resolution than finite difference block.' ) error stop else if ( offset % vector_dimensions () < rhs % vector_dimensions ()) then call logger % fatal ( 'fin_diff_block%solve_for' , 'Offset field has ' // & 'different number of vector components than ' // & 'field being solved for.' ) error stop end if #endif call offset % allocate_scalar_field ( ocomponent ) call ocomponent % guard_temp () end if do i = 1 , rhs % vector_dimensions () if ( i > 1 . and . . not . present ( offset )) factor = 'F' component = rhs % component ( i ) if ( present ( offset )) then ocomponent = offset % component ( i ) if ( i == 1 ) allocate ( diag_vector ( n )) where ( this % diagonal == 0._r8 ) diag_vector = this % diagonal + ocomponent % raw () elsewhere diag_vector = this % diagonal end where if (. not . any ( 1 == this % boundary_locs )) then diag_vector ( 1 ) = diag_vector ( 1 ) + ocomponent % get_element ( 1 ) end if if (. not . any ( n == this % boundary_locs )) then diag_vector ( n ) = diag_vector ( n ) + ocomponent % get_element ( n ) end if do j = 1 , size ( this % boundary_locs ) k = this % boundary_locs ( j ) if (( k == 1 . or . k == n ) . and . this % boundary_types ( j ) == free_boundary ) then diag_vector ( k ) = diag_vector ( k ) + ocomponent % get_element ( k ) end if end do call la_gtsvx ( this % sub_diagonal , diag_vector , this % super_diagonal , & component % raw (), sol_vector (( i - 1 ) * n + 1 : i * n ), & this % l_multipliers , this % u_diagonal , & this % u_superdiagonal1 , this % u_superdiagonal2 , & this % pivots , factor , 'N' , forward_err , backward_err , & condition_num , flag ) else call la_gtsvx ( this % sub_diagonal , this % diagonal , this % super_diagonal , & component % raw (), sol_vector (( i - 1 ) * n + 1 : i * n ), & this % l_multipliers , this % u_diagonal , & this % u_superdiagonal1 , this % u_superdiagonal2 , & this % pivots , factor , 'N' , forward_err , backward_err , & condition_num , flag ) end if end do call component % clean_temp () if ( present ( offset )) call ocomponent % clean_temp () if ( flag /= 0 ) then msg = 'Tridiagonal matrix solver returned with flag ' // str ( flag ) call logger % error ( 'fin_diff_block%solve_for' , msg ) else this % had_offset = present ( offset ) #ifdef DEBUG msg = 'Tridiagonal matrix solver returned with estimated condition ' // & 'number ' // str ( condition_num ) call logger % debug ( 'fin_diff_block%solve_for' , msg ) #endif end if call rhs % allocate_vector_field ( solution ) call solution % unset_temp () call solution % assign_meta_data ( rhs ) call solution % set_from_raw ( sol_vector ) if ( present ( offset )) call offset % clean_temp () call rhs % clean_temp (); call solution % set_temp () end function fin_diff_block_solve_vector end module finite_difference_block_mod"},{"title":"entrainment.F90 – ISOFT","tags":"","loc":"sourcefile/entrainment.f90.html","text":"Files dependent on this one sourcefile~~entrainment.f90~~AfferentGraph sourcefile~entrainment.f90 entrainment.F90 sourcefile~jenkins1991_entrainment.f90 jenkins1991_entrainment.F90 sourcefile~jenkins1991_entrainment.f90->sourcefile~entrainment.f90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~entrainment.f90 sourcefile~asymmetric_plume.f90->sourcefile~jenkins1991_entrainment.f90 sourcefile~kochergin1987_entrainment.f90 kochergin1987_entrainment.F90 sourcefile~kochergin1987_entrainment.f90->sourcefile~entrainment.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~entrainment.f90 sourcefile~static_plume.f90->sourcefile~jenkins1991_entrainment.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~entrainment.f90 sourcefile~plume.f90->sourcefile~jenkins1991_entrainment.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules entrainment_mod Source Code entrainment.F90 Source Code ! !  entrainment.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module entrainment_mod !* Author: Christopher MacMackin !  Date: October 2016 !  License: GPLv3 ! ! Provides an abstract data type to model entrainment into a ! vertically integrated plume. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field implicit none private type , abstract , public :: abstract_entrainment !* Author: Christopher MacMackin !  Date: October 2016 ! ! An abstract data type for calculating entrainment of ambient ! ocean water into a vertically integrated [[plume]]. ! contains procedure ( get_entrainment ), deferred :: entrainment_rate !! Returns the entrainment rate for ambient water into the plume. end type abstract_entrainment abstract interface function get_entrainment ( this , velocity , thickness , depth , density_diff , time ) & result ( property ) import :: abstract_entrainment import :: vector_field import :: scalar_field import :: r8 class ( abstract_entrainment ), intent ( in ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is being !! entrained. class ( scalar_field ), intent ( in ) :: thickness !! The thickness of the plume into which fluid is being !! entrained class ( scalar_field ), intent ( in ) :: depth !! The depth of the upper surface of the plume into which !! fluid is being entrained class ( scalar_field ), intent ( in ) :: density_diff !! The difference between the ambient density and the density of !! the plume into which the ambient fluid is being entrained. real ( r8 ), intent ( in ), optional :: time !! The time at which the entrainment is being calculated. If not !! present then assumed to be same as previous value passed. class ( scalar_field ), pointer :: property !! The value of the entrainment end function get_entrainment end interface end module entrainment_mod"},{"title":"uniform.F90 – ISOFT","tags":"","loc":"sourcefile/uniform.f90.html","text":"This file depends on sourcefile~~uniform.f90~~EfferentGraph sourcefile~uniform.f90 uniform.F90 sourcefile~ambient.f90 ambient.F90 sourcefile~uniform.f90->sourcefile~ambient.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~uniform.f90~~AfferentGraph sourcefile~uniform.f90 uniform.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~uniform.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~uniform.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~uniform.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules uniform_ambient_mod Source Code uniform.F90 Source Code ! !  uniform.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module uniform_ambient_mod !* Author: Christopher MacMackin !  Date: November 2016 !  License: GPLv3 ! ! Provides a derived type specifying uniform ambient temperature and ! salinity conditions beneath an ice shelf. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , uniform_scalar_field use ambient_mod , only : ambient_conditions implicit none private type , extends ( ambient_conditions ), public :: uniform_ambient_conditions !* Author: Chris MacMackin !  Date: April 2016 ! ! An derived type with procedures for getting the ambient ocean ! conditions. This implementation takes these conditions to be ! everywhere uniform. ! private type ( uniform_scalar_field ) :: temperature type ( uniform_scalar_field ) :: salinity contains procedure :: ambient_temperature => uniform_temperature !! Returns the ambient ocean temperature procedure :: ambient_salinity => uniform_salinity !! Returns the ambient ocean temperature end type uniform_ambient_conditions interface uniform_ambient_conditions module procedure constructor end interface uniform_ambient_conditions contains function constructor ( temperature , salinity ) result ( this ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Produces an ambient object which will return the specified ! salinity and temeprature values. ! real ( r8 ), intent ( in ), optional :: temperature !! The temperature of the ambient ocean. Default is 0. real ( r8 ), intent ( in ), optional :: salinity !! The salinity of the ambient ocean. Default is 0. type ( uniform_ambient_conditions ) :: this if ( present ( temperature )) then this % temperature = uniform_scalar_field ( temperature ) else this % temperature = uniform_scalar_field ( 0.0_r8 ) end if if ( present ( salinity )) then this % salinity = uniform_scalar_field ( salinity ) else this % salinity = uniform_scalar_field ( 0.0_r8 ) end if end function constructor function uniform_temperature ( this , depth , t ) result ( property ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Returns the ambient ocean temperature. ! class ( uniform_ambient_conditions ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: depth !! A field containing the depths at which the ambient temperature !! is to be calculated. real ( r8 ), intent ( in ) :: t !! The time at which the ambient conditions are to be calculated. class ( scalar_field ), pointer :: property !! A field containing the ambient temperature at the depth specified !! for each location. call this % temperature % allocate_scalar_field ( property ) property = this % temperature call property % set_temp () ! Shouldn't need to call this, but for ! some rason being set as non-temporary ! when assignment subroutine returns. end function uniform_temperature function uniform_salinity ( this , depth , t ) result ( property ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Returns the ambient ocean salinity. ! class ( uniform_ambient_conditions ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: depth !! A field containing the depths at which the ambient salinity !! is to be calculated. real ( r8 ), intent ( in ) :: t !! The time at which the ambient conditions are to be calculated. class ( scalar_field ), pointer :: property !! A field containing the ambient salinity at the depth specified !! for each location. call this % salinity % allocate_scalar_field ( property ) property = this % salinity call property % set_temp () ! Shouldn't need to call this, but for ! some rason being set as non-temporary ! when assignment subroutine returns. end function uniform_salinity end module uniform_ambient_mod"},{"title":"simple_plume.F90 – ISOFT","tags":"","loc":"sourcefile/simple_plume.f90.html","text":"This file depends on sourcefile~~simple_plume.f90~~EfferentGraph sourcefile~simple_plume.f90 simple_plume.F90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~simple_plume.f90->sourcefile~boundary_types.f90 sourcefile~plume_boundary.f90 plume_boundary.F90 sourcefile~simple_plume.f90->sourcefile~plume_boundary.f90 sourcefile~plume_boundary.f90->sourcefile~boundary_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~simple_plume.f90~~AfferentGraph sourcefile~simple_plume.f90 simple_plume.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~simple_plume.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~simple_plume.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~simple_plume.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules simple_plume_boundary_mod Source Code simple_plume.F90 Source Code ! !  simple_plume.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module simple_plume_boundary_mod !* Author: Christopher MacMackin !  Date: March 2017 !  License: GPLv3 ! ! Provides a derived type which specifies the boundary conditions ! for a 1-D plume model. Dirichlet boundary conditions are used at ! the grounding line, while an outflow condition is used at the end ! of the domain. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field , uniform_scalar_field , & uniform_vector_field use plume_boundary_mod , only : plume_boundary use boundary_types_mod , only : free_boundary , dirichlet , neumann implicit none private type ( uniform_scalar_field ) :: dummy type , extends ( plume_boundary ), public :: simple_plume_boundary !* Author: Chris MacMackin !  Date: March 2017 ! ! A type with procedures for getting the boundary conditions of ! the plume model. Dirichlet boundary conditions are used at the ! grounding line. In order to approximate an outflow condition, ! the derivatives of velocity, temperature, and salinity are set ! to 0 at the end of the domain. Plume thickness is left free ! there, as only a single boundary condition is needed for it. ! private real ( r8 ) :: thickness = 0.0_r8 !! The thickness of the plume at the inflowing boundary real ( r8 ), dimension ( 2 ) :: velocity = 1.0_r8 !! The velocity of the plume at the inflowing boundary real ( r8 ) :: salinity = 0.0_r8 !! The salinity of the plume at the inflowing boundary real ( r8 ) :: temperature = 0.0_r8 !! The tempreature of the plume at the inflowing boundary contains procedure :: thickness_bound_info => simple_thickness_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: velocity_bound_info => simple_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: temperature_bound_info => simple_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: salinity_bound_info => simple_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: thickness_bound => simple_thickness_bound !! Produces a field containing the boundary conditions for plume !! thickness at the specified location. procedure :: velocity_bound => simple_velocity_bound !! Produces a field containing the boundary conditions for plume !! velocity at the specified location. procedure :: temperature_bound => simple_temperature_bound !! Produces a field containing the boundary conditions for plume !! temperature at the specified location. procedure :: salinity_bound => simple_salinity_bound !! Produces a field containing the boundary conditions for plume !! salinity at the specified location. end type simple_plume_boundary interface simple_plume_boundary module procedure constructor end interface simple_plume_boundary contains pure function constructor ( thickness , velocity , temperature , salinity ) & result ( this ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Constructs a boundary condition object for an ice shelf based on ! the conditions used in Dallaston et al. (2015). ! real ( r8 ), intent ( in ) :: thickness !! The water thickness at the inflowing plume boundary real ( r8 ), dimension ( 2 ), intent ( in ) :: velocity !! The longitudinal water velocity at the inflowing plume boundary real ( r8 ), intent ( in ) :: temperature !! The water temperature at the inflowing plume boundary real ( r8 ), intent ( in ) :: salinity !! The water salinity at the inflowing plume boundary type ( simple_plume_boundary ) :: this this % thickness = thickness this % velocity = velocity this % temperature = temperature this % salinity = salinity end function constructor subroutine simple_thickness_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is free. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine simple_thickness_info subroutine simple_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is Neumann. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case ( 1 ) bound_type = neumann bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine simple_info function simple_thickness_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the thickness boundary values for the ! specified boundary location. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % thickness ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function simple_thickness_bound function simple_velocity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the velocity boundary values for ! the specified boundary location. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( vector_field ), pointer :: bound call dummy % allocate_vector_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_vector_field ( this % velocity ) case ( 1 ) bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) case default bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function simple_velocity_bound function simple_temperature_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the temperature boundary values for ! the specified boundary location. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % temperature ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function simple_temperature_bound function simple_salinity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the salinity boundary values for ! the specified boundary location. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % salinity ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function simple_salinity_bound end module simple_plume_boundary_mod"},{"title":"dallaston2015_seasonal.F90 – ISOFT","tags":"","loc":"sourcefile/dallaston2015_seasonal.f90.html","text":"This file depends on sourcefile~~dallaston2015_seasonal.f90~~EfferentGraph sourcefile~dallaston2015_seasonal.f90 dallaston2015_seasonal.F90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~dallaston2015_seasonal.f90->sourcefile~boundary_types.f90 sourcefile~plume_boundary.f90 plume_boundary.F90 sourcefile~dallaston2015_seasonal.f90->sourcefile~plume_boundary.f90 sourcefile~plume_boundary.f90->sourcefile~boundary_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dallaston2015_seasonal_mod Source Code dallaston2015_seasonal.F90 Source Code ! !  dallaston2015_seasonal.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module dallaston2015_seasonal_mod !* Author: Christopher MacMackin !  Date: May 2017 !  License: GPLv3 ! ! Provides a derived type which specifies the boundary conditions ! for a 1-D plume model, when subglacial discharge is oscillating ! over time. This corresponds to Dirichlet conditions at the ! grounding line and Neumann conditions (wth a gradient of 0) at the ! calving front. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field , uniform_scalar_field , & uniform_vector_field use plume_boundary_mod , only : plume_boundary use boundary_types_mod , only : free_boundary , dirichlet , neumann implicit none private type ( uniform_scalar_field ) :: dummy type , extends ( plume_boundary ), public :: dallaston2015_seasonal_boundary !* Author: Chris MacMackin !  Date: May 2017 ! ! A type with procedures for getting the boundary conditions of ! the plume model. It represents the case where subglacial ! discharge is varying in time, altering the boundary conditions ! for velocity and salinity using scalings similar to those in ! Dallaston et al. (2015). Dirichlet boundary conditions are used ! at the grounding line. In order to approximate an outflow ! condition, the derivatives of velocity, temperature, and ! salinity are set to 0 at the end of the domain. Plume thickness ! is left free there, as only a single boundary condition is ! needed for it. ! private real ( r8 ) :: thickness = 0.1_r8 !! The thickness of the plume at the inflowing boundary real ( r8 ) :: frequency = 1.0_r8 !! The angular frequency of the oscillations in discharge real ( r8 ) :: amplitude = 1.0_r8 !! The amplitude of the oscillations in discharge real ( r8 ) :: mean = 1.0_r8 !! The time-average of the discharge, about which it oscillates real ( r8 ) :: discharge = 1.0_r8 !! The current discharge value real ( r8 ) :: temperature = 0.0_r8 !! The tempreature of the plume at the inflowing boundary contains procedure :: thickness_bound_info => seasonal_thickness_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: velocity_bound_info => seasonal_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: temperature_bound_info => seasonal_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: salinity_bound_info => seasonal_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: thickness_bound => seasonal_thickness_bound !! Produces a field containing the boundary conditions for plume !! thickness at the specified location. procedure :: velocity_bound => seasonal_velocity_bound !! Produces a field containing the boundary conditions for plume !! velocity at the specified location. procedure :: temperature_bound => seasonal_temperature_bound !! Produces a field containing the boundary conditions for plume !! temperature at the specified location. procedure :: salinity_bound => seasonal_salinity_bound !! Produces a field containing the boundary conditions for plume !! salinity at the specified location. procedure :: set_time => seasonal_set_time !! Specifies the time at which to calculate the boundary !! conditions. end type dallaston2015_seasonal_boundary interface dallaston2015_seasonal_boundary module procedure constructor end interface dallaston2015_seasonal_boundary contains pure function constructor ( thickness , frequency , amplitude , mean , & temperature ) result ( this ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Constructs a boundary condition object for an ice shelf based on ! the conditions used in Dallaston et al. (2015), but with ! seasonal variations in subglacial discharge. ! real ( r8 ), intent ( in ), optional :: thickness !! The plume thickness at the inflowing plume boundary, defaults !! to 0.1 real ( r8 ), intent ( in ), optional :: frequency !! The angular frequency of the oscillations in discharge, !! defaults to 1.0 real ( r8 ), intent ( in ), optional :: amplitude !! The amplitude of the oscillations in discharge, defaults to !! 1.0 real ( r8 ), intent ( in ), optional :: mean !! The time-average of the discharge, about which it oscillates, !! defaulting to 1.0 real ( r8 ), intent ( in ), optional :: temperature !! The water temperature at the inflowing plume boundary, !! defaults to 0.0 type ( dallaston2015_seasonal_boundary ) :: this if ( present ( thickness )) this % thickness = thickness if ( present ( frequency )) this % frequency = frequency if ( present ( amplitude )) this % amplitude = amplitude if ( present ( mean )) this % mean = mean if ( present ( temperature )) this % temperature = temperature end function constructor subroutine seasonal_thickness_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is free. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine seasonal_thickness_info subroutine seasonal_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is Neumann. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case ( 1 ) bound_type = neumann bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine seasonal_info function seasonal_thickness_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the thickness boundary values for the ! specified boundary location. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % thickness ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function seasonal_thickness_bound function seasonal_velocity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the velocity boundary values for ! the specified boundary location. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( vector_field ), pointer :: bound call dummy % allocate_vector_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_vector_field ([ this % discharge ** ( 1._r8 / 3._r8 ), 0._r8 ]) case ( 1 ) bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) case default bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function seasonal_velocity_bound function seasonal_temperature_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the temperature boundary values for ! the specified boundary location. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % temperature ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function seasonal_temperature_bound function seasonal_salinity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the salinity boundary values for ! the specified boundary location. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % discharge ** ( 2._r8 / 3._r8 ) / this % thickness ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function seasonal_salinity_bound subroutine seasonal_set_time ( this , time ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Sets the time at which boundary conditions are to be calculated. ! class ( dallaston2015_seasonal_boundary ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time this % discharge = this % mean + this % amplitude * sin ( this % frequency * time ) end subroutine seasonal_set_time end module dallaston2015_seasonal_mod"},{"title":"seasonal_glacier.F90 – ISOFT","tags":"","loc":"sourcefile/seasonal_glacier.f90.html","text":"This file depends on sourcefile~~seasonal_glacier.f90~~EfferentGraph sourcefile~seasonal_glacier.f90 seasonal_glacier.F90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~seasonal_glacier.f90->sourcefile~boundary_types.f90 sourcefile~glacier_boundary.f90 glacier_boundary.F90 sourcefile~seasonal_glacier.f90->sourcefile~glacier_boundary.f90 sourcefile~glacier_boundary.f90->sourcefile~boundary_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules seasonal_glacier_boundary_mod Source Code seasonal_glacier.F90 Source Code ! !  seasonal_glacier.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module seasonal_glacier_boundary_mod !* Author: Christopher MacMackin !  Date: October 2017 !  License: GPLv3 ! ! Provides a derived type which specifies the boundary conditions ! for the ice shelf model used by Dallaston et al. (2015), except ! that the ice flux at the grounding line varies sinusoidally in ! time.  There are Dirichlet conditions at the lower bound of the ! first condition as well as, for thickness, the upper bound. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field use boundary_types_mod , only : free_boundary , dirichlet , neumann use glacier_boundary_mod , only : glacier_boundary implicit none private type , extends ( glacier_boundary ), public :: seasonal_glacier_boundary !* Author: Chris MacMackin !  Date: October 2017 ! ! A type with procedures for getting the boundary conditions of ! the ice shelf model used by Dallaston et al. (2015), but with ! the ice flux at the grounding line varying sinusoidally in ! time. There are Dirichlet conditions at the lower bound of the ! first condition as well as, for thickness, the upper bound. ! private real ( r8 ) :: thickness = 1.0_r8 !! The thickness of the glacier at the inflowing boundary real ( r8 ) :: frequency = 1.0_r8 !! The angular frequency of the oscillations in ice flux real ( r8 ) :: amplitude = 0.5_r8 !! The amplitude of the oscillations in ice flux real ( r8 ) :: mean = 1.0_r8 !! The time-average of the ice flux, about which it oscillates real ( r8 ) :: chi = 1.0_r8 !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ logical :: square = . false . !! If true, produce a square wave, otherwise produce a sinusoid contains procedure :: thickness_lower_bound => seasonal_lower_bound !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the thickness !! field. procedure :: velocity_lower_bound => seasonal_lower_bound !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: velocity_upper_bound => seasonal_upper_bound !! Returns a 1D array which should be passed as the !! `exclude_upper_bound`/`provide_upper_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: thickness_lower_type => seasonal_lower_type !! Returns an array indicating what type of boundary conditions !! apply for thickness at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_lower_type => seasonal_lower_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_upper_type => seasonal_upper_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the upper boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: boundary_residuals => seasonal_residuals !! Returns an array consisting of the difference between the !! required boundary values and those which actually exist. This !! can then be appended to a glacier's state vector. The order !! in which these are listed is as follows: lower thickness !! boundary, upper thickness boundary, lower velocity boundary, !! and upper velocity boundary. end type seasonal_glacier_boundary interface seasonal_glacier_boundary module procedure constructor end interface seasonal_glacier_boundary contains pure function constructor ( thickness , frequency , amplitude , mean , chi , & square ) result ( this ) !* Author: Chris MacMackin !  Date: October 2017 ! ! Constructs a boundary condition object for an ice shelf based on ! the conditions used in Dallaston et al. (2015), but with the ice ! flux at the grounding line varying in time. ! real ( r8 ), intent ( in ), optional :: thickness !! The ice thickness at the inflowing ice shelf boundary, !! defaults to 1.0 real ( r8 ), intent ( in ), optional :: frequency !! The angular frequency of the oscillations in ice flux, !! defaults to 0.5 real ( r8 ), intent ( in ), optional :: amplitude !! The amplitude of the oscillations in ice flux, defaults to !! 1.0 real ( r8 ), intent ( in ), optional :: mean !! The time-average of the discharge, about which it oscillates, !! defaulting to 1.0 real ( r8 ), intent ( in ), optional :: chi !! The dimensionless ratio \\chi \\equiv !! \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}, defaults to 1.0 logical , intent ( in ), optional :: square !! If present and true, produce a square wave. Otherwise produce !! a sinusoid. type ( seasonal_glacier_boundary ) :: this if ( present ( thickness )) this % thickness = thickness if ( present ( frequency )) this % frequency = frequency if ( present ( amplitude )) this % amplitude = amplitude if ( present ( mean )) this % mean = mean if ( present ( chi )) this % chi = chi if ( present ( square )) this % square = square end function constructor pure function seasonal_lower_bound ( this ) result ( bound_array ) !* Author: Chris MacMackin !  Date: October 2017 ! ! Indicates that one layer of cells at the lower boundary in the ! first dimension should be omitted. This is appropriate for ! Dirichlet boundary conditions. ! class ( seasonal_glacier_boundary ), intent ( in ) :: this integer , dimension ( 2 ) :: bound_array bound_array = [ 1 , 0 ] end function seasonal_lower_bound pure function seasonal_upper_bound ( this ) result ( bound_array ) !* Author: Chris MacMackin !  Date: October 2017 ! ! Indicates that one layer of cells at the upper boundary in the ! first dimension should be omitted for thickness. This is ! appropriate for Dirichlet boundary conditions. ! class ( seasonal_glacier_boundary ), intent ( in ) :: this integer , dimension ( 2 ) :: bound_array bound_array = [ 1 , 0 ] end function seasonal_upper_bound pure function seasonal_lower_type ( this ) result ( bound_type ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Specifies that the lower boundary in the first dimension has ! Dirichlet boundary conditions. ! class ( seasonal_glacier_boundary ), intent ( in ) :: this integer , dimension (:), allocatable :: bound_type bound_type = [ dirichlet , free_boundary ] end function seasonal_lower_type pure function seasonal_upper_type ( this ) result ( bound_type ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Specifies that the upper boundary in the first dimension has ! Neumann boundary conditions. ! class ( seasonal_glacier_boundary ), intent ( in ) :: this integer , dimension (:), allocatable :: bound_type bound_type = [ neumann , free_boundary ] end function seasonal_upper_type function seasonal_residuals ( this , thickness , velocity , viscosity , t ) & result ( residuals ) !* Author: Chris MacMackin !  Date: October 2017 ! ! Returns the difference between the glacier conditions of the ! plume and the Dirichlet conditions prescribed in the model of ! Dallaston et al. (2015) ! class ( seasonal_glacier_boundary ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: thickness !! A field containing the thickness of the glacier class ( vector_field ), intent ( in ) :: velocity !! A field containing the flow velocity of the glacier class ( scalar_field ), intent ( in ) :: viscosity !! A field containing the viscosity of the ice in the glacier. real ( r8 ), intent ( in ) :: t !! The time at which the boundary conditions are to be !! calculated. real ( r8 ), allocatable , dimension (:) :: residuals !! An array containing the difference between the required !! boundary values and those which are actually present. They !! are stored in the order: lower thickness boundary, upper !! thickness boundary, lower velocity boundary, and upper !! velocity boundary. real ( r8 ) :: vel , tm class ( scalar_field ), pointer :: thickness_bound , & velocity_bound_upper , & velocity_deriv class ( vector_field ), pointer :: velocity_bound_lower call thickness % guard_temp (); call velocity % guard_temp (); call viscosity % guard_temp () call thickness % allocate_scalar_field ( thickness_bound ) thickness_bound = thickness % get_boundary ( - 1 , 1 ) - this % thickness call velocity % allocate_vector_field ( velocity_bound_lower ) if ( this % square ) then vel = this % mean + sign ( this % amplitude , sin ( this % frequency * t )) else vel = this % mean + this % amplitude * sin ( this % frequency * t ) end if velocity_bound_lower = velocity % get_boundary ( - 1 , 1 ) - [ vel ] call velocity % allocate_scalar_field ( velocity_deriv ) velocity_deriv = velocity % component_d_dx ( 1 , 1 ) call velocity % allocate_scalar_field ( velocity_bound_upper ) velocity_bound_upper = velocity_deriv % get_boundary ( 1 , 1 ) & * thickness % get_boundary ( 1 , 1 ) & - ( 0.25_r8 * this % chi ) * thickness % get_boundary ( 1 , 1 ) ** 2 & / viscosity % get_boundary ( 1 , 1 ) residuals = [ thickness_bound % raw (), velocity_bound_lower % raw (), & velocity_bound_upper % raw ()] call thickness % clean_temp (); call velocity % clean_temp (); call viscosity % clean_temp () end function seasonal_residuals end module seasonal_glacier_boundary_mod"},{"title":"upstream_plume.F90 – ISOFT","tags":"","loc":"sourcefile/upstream_plume.f90.html","text":"This file depends on sourcefile~~upstream_plume.f90~~EfferentGraph sourcefile~upstream_plume.f90 upstream_plume.F90 sourcefile~rksuite_90.f90 rksuite_90.f90 sourcefile~upstream_plume.f90->sourcefile~rksuite_90.f90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~upstream_plume.f90->sourcefile~boundary_types.f90 sourcefile~plume_boundary.f90 plume_boundary.F90 sourcefile~upstream_plume.f90->sourcefile~plume_boundary.f90 sourcefile~uniform_gradient_field.f90 uniform_gradient_field.f90 sourcefile~upstream_plume.f90->sourcefile~uniform_gradient_field.f90 sourcefile~plume_boundary.f90->sourcefile~boundary_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~upstream_plume.f90~~AfferentGraph sourcefile~upstream_plume.f90 upstream_plume.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~upstream_plume.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~upstream_plume.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~upstream_plume.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules upstream_plume_mod Source Code upstream_plume.F90 Source Code ! !  upstream_plume.F90 !  This file is part of ISOFT. ! !  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module upstream_plume_mod !* Author: Christopher MacMackin !  Date: July 2017 !  License: GPLv3 ! ! Provides a derived type which specifies the boundary conditions ! for a 1-D plume model. In order to avoid boundary layer effects, ! an ODE solver is used to integrate the plume a little way ! upstream, past the boundary layer. ! use iso_fortran_env , only : r8 => real64 use logger_mod , only : logger => master_logger use penf , only : str use factual_mod , only : scalar_field , vector_field , uniform_scalar_field , & uniform_vector_field use uniform_gradient_field_mod , only : uniform_gradient_field use plume_boundary_mod , only : plume_boundary use boundary_types_mod , only : free_boundary , dirichlet , neumann use rksuite_90 implicit none private type ( uniform_scalar_field ) :: dummy type , extends ( plume_boundary ), public :: upstream_plume_boundary !* Author: Chris MacMackin !  Date: July 2017 ! ! A type with procedures for getting the boundary conditions of ! the plume model. For given boundary conditions, it integrates ! the plume upstream slightly and then returns these when asked ! for boundary values. This allows boundary layers, which can ! cause numerical difficulties, to be avoided. Inflow boundaries ! must be Dirichlet, while outflow boundaries for velocity, ! salinity, and temperature are set to have a gradient of zero. ! ! @Warning The `calculate` method __must__ be called prior to use. ! private procedure ( bound_vals ), nopass , pointer :: get_boundaries => null () !! Calculate the \"actual\" boundary values, used to initiate the !! integration, for the specified time. real ( r8 ) :: distance = 0.05_r8 !! The distance upstream which the plume should be integrated real ( r8 ) :: thickness = 0.1_r8 !! The thickness of the plume at the inflowing boundary real ( r8 ), dimension (:), allocatable :: velocity !! The velocity of the plume at the inflowing boundary real ( r8 ) :: temperature = 0.0_r8 !! The tempreature of the plume at the inflowing boundary real ( r8 ) :: salinity = 1.0_r8 !! The salinity of the plume at the inflowing boundary real ( r8 ) :: boundary_time !! The time at which the boundaries were most recently !! calculated real ( r8 ), dimension (:), allocatable :: thresholds !! Thresholds to use when calculating error in the integration. contains procedure :: thickness_bound_info => upstream_thickness_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: velocity_bound_info => upstream_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: temperature_bound_info => upstream_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: salinity_bound_info => upstream_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: thickness_bound => upstream_thickness_bound !! Produces a field containing the boundary conditions for plume !! thickness at the specified location. procedure :: velocity_bound => upstream_velocity_bound !! Produces a field containing the boundary conditions for plume !! velocity at the specified location. procedure :: temperature_bound => upstream_temperature_bound !! Produces a field containing the boundary conditions for plume !! temperature at the specified location. procedure :: salinity_bound => upstream_salinity_bound !! Produces a field containing the boundary conditions for plume !! salinity at the specified location. procedure :: calculate => upstream_calculate !! Calculates the upstreamed boundary conditions for the given !! time and ice thickness. end type upstream_plume_boundary abstract interface pure subroutine bound_vals ( time , D , U , T , S ) import :: r8 real ( r8 ), intent ( in ) :: time !! The time at which the boundary values are being calculated real ( r8 ), intent ( out ) :: D !! Plume thickness boundary condition real ( r8 ), dimension (:), allocatable , intent ( out ) :: U !! Plume velocity boundary condition real ( r8 ), intent ( out ) :: T !! Plume temperature boundary condition real ( r8 ), intent ( out ) :: S !! Plume salinity boundary condition end subroutine bound_vals subroutine non_diff ( D , U , T , S , b , DU_x , DUU_x , DUT_x , DUS_x ) import :: scalar_field import :: vector_field class ( scalar_field ), intent ( in ) :: D !! The plume thickness class ( vector_field ), intent ( in ) :: U !! The plume velocity class ( scalar_field ), intent ( in ) :: T !! The plume temperature class ( scalar_field ), intent ( in ) :: S !! The plume salinity class ( scalar_field ), intent ( in ) :: b !! The debth of the base of the ice shelf class ( scalar_field ), intent ( out ) :: DU_x !! The derivative of the product DU class ( vector_field ), intent ( out ) :: DUU_x !! The derivative of the product DUU class ( scalar_field ), intent ( out ) :: DUT_x !! The derivative of the product DUT class ( scalar_field ), intent ( out ) :: DUS_x !! The derivative of the product DUS end subroutine non_diff end interface interface upstream_plume_boundary module procedure constructor end interface upstream_plume_boundary contains pure function constructor ( bound_calculator , distance , thresholds ) & result ( this ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Constructs a boundary condition object which integrates an IVP ! from actual boundary values to calculate the staet of the plume ! a little upstream. This can be used to avoid boundary layers. ! procedure ( bound_vals ) :: bound_calculator !! Calculates the \"actual\" inflow boundary conditions, used to !! initiate the integration to find the values to use in the !! simulation. real ( r8 ), intent ( in ) :: distance !! The distance upstream which the plume should be integrated. real ( r8 ), dimension (:), optional , intent ( in ) :: thresholds !! The thresholds to use when evaluating the error of the !! integration. This is done according to the formula !! `abs(e) / max(magnitude_y, THRESHOLDS) <= TOLERANCE`. type ( upstream_plume_boundary ) :: this this % get_boundaries => bound_calculator this % distance = distance if ( present ( thresholds )) this % thresholds = thresholds end function constructor subroutine upstream_thickness_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is free. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine upstream_thickness_info subroutine upstream_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is Neumann. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case ( 1 ) bound_type = neumann bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine upstream_info function upstream_thickness_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Returns a field containing the thickness boundary values for the ! specified boundary location. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % thickness ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function upstream_thickness_bound function upstream_velocity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Returns a field containing the velocity boundary values for ! the specified boundary location. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( vector_field ), pointer :: bound call dummy % allocate_vector_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_vector_field ( this % velocity ) case ( 1 ) bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) case default bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function upstream_velocity_bound function upstream_temperature_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Returns a field containing the temperature boundary values for ! the specified boundary location. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % temperature ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function upstream_temperature_bound function upstream_salinity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Returns a field containing the salinity boundary values for ! the specified boundary location. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % salinity ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function upstream_salinity_bound subroutine upstream_calculate ( this , t , func , b ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Calculates the boundary values to use at the current time with ! the current ice thickness. ! class ( upstream_plume_boundary ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: t !! The time at which to calculate the boundary values. procedure ( non_diff ) :: func !! A function which returns the non-diffusive, non-inertial !! components of the ODEs describing the plume. class ( scalar_field ), intent ( in ) :: b !! The depth of the ice shelf base. integer :: n real ( r8 ) :: D_0 , U_0 , S_0 , T_0 , DU_0 , DUS_0 , DUT_0 real ( r8 ), dimension (:), allocatable :: Uvec_0 , DUvecU_0 class ( scalar_field ), pointer :: b_x real ( r8 ), dimension (:), allocatable :: y0 , ygot , yderiv_got real ( r8 ) :: xgot integer :: flag type ( rk_comm_real_1d ) :: comm call b % guard_temp () call this % get_boundaries ( t , D_0 , Uvec_0 , T_0 , S_0 ) U_0 = Uvec_0 ( 1 ) DU_0 = D_0 * U_0 DUvecU_0 = DU_0 * Uvec_0 DUT_0 = DU_0 * T_0 DUS_0 = DU_0 * S_0 y0 = [ DU_0 , DUvecU_0 , DUT_0 , DUS_0 ] n = size ( y0 ) allocate ( ygot ( n ), yderiv_got ( n )) if (. not . allocated ( this % thresholds )) then allocate ( this % thresholds ( n )) this % thresholds = 1._r8 end if b_x => b % d_dx ( 1 ) call b_x % guard_temp () call setup ( comm , 0._r8 , y0 , this % distance , 1 e - 6_r8 , this % thresholds , & method = 'h' , h_start = 2 e - 3_r8 * this % distance ) call range_integrate ( comm , integrand , this % distance , xgot , ygot , & yderiv_got , flag ) if ( flag /= 1 ) then call logger % error ( 'upstream_plume_boundary%calculate' , & 'Could only integrate plume to x = ' // str ( xgot )) end if !this%thresholds = abs(ygot) + 1e-10 this % thickness = ygot ( 1 ) ** 2 / ygot ( 2 ) this % velocity = ygot ( 2 : n - 2 ) / ygot ( 1 ) this % temperature = ygot ( n - 1 ) / ygot ( 1 ) this % salinity = ygot ( n ) / ygot ( 1 ) call logger % trivia ( 'upstream_plume_boundary%calculate' , & 'Calculated boundary values D=' // str ( this % thickness ) // ', U=' // & str ( this % velocity ) // ', T=' // str ( this % temperature ) // ', S=' // & str ( this % salinity )) if ( this % thickness < 0._r8 ) error stop ( 'Negative plume thickness found' ) call collect_garbage ( comm ) call b % clean_temp (); call b_x % clean_temp () contains function integrand ( x , y ) result ( f ) real ( r8 ), intent ( in ) :: x !! The independent variable real ( r8 ), dimension (:), intent ( in ) :: y !! The dependent variable real ( r8 ), dimension ( size ( y )) :: f !! The derivatives type ( uniform_scalar_field ) :: D , T , S , DU_x , DUT_x , DUS_x type ( uniform_vector_field ) :: Uvec , DUU_x type ( uniform_gradient_field ) :: b_loc D = uniform_scalar_field ( y ( 1 ) ** 2 / y ( 2 )) Uvec = uniform_vector_field ( y ( 2 : n - 2 ) / y ( 1 )) T = uniform_scalar_field ( y ( n - 1 ) / y ( 1 )) S = uniform_scalar_field ( y ( n ) / y ( 1 )) b_loc = uniform_gradient_field ( b % interpolate ([ x ]), [ b_x % interpolate ([ x ])]) call func ( D , Uvec , T , S , b_loc , DU_x , DUU_x , DUT_x , DUS_x ) f ( 1 ) = DU_x % get_value () f ( 2 : n - 2 ) = DUU_x % get_value () f ( n - 1 ) = DUT_x % get_value () f ( n ) = DUS_x % get_value () end function integrand end subroutine upstream_calculate end module upstream_plume_mod"},{"title":"dallaston2015_glacier.F90 – ISOFT","tags":"","loc":"sourcefile/dallaston2015_glacier.f90.html","text":"This file depends on sourcefile~~dallaston2015_glacier.f90~~EfferentGraph sourcefile~dallaston2015_glacier.f90 dallaston2015_glacier.F90 sourcefile~boundary_types.f90 boundary_types.f90 sourcefile~dallaston2015_glacier.f90->sourcefile~boundary_types.f90 sourcefile~glacier_boundary.f90 glacier_boundary.F90 sourcefile~dallaston2015_glacier.f90->sourcefile~glacier_boundary.f90 sourcefile~glacier_boundary.f90->sourcefile~boundary_types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~dallaston2015_glacier.f90~~AfferentGraph sourcefile~dallaston2015_glacier.f90 dallaston2015_glacier.F90 sourcefile~ice_shelf.f90 ice_shelf.F90 sourcefile~ice_shelf.f90->sourcefile~dallaston2015_glacier.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dallaston2015_glacier_boundary_mod Source Code dallaston2015_glacier.F90 Source Code ! !  dallaston2015_glacier.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module dallaston2015_glacier_boundary_mod !* Author: Christopher MacMackin !  Date: November 2016 !  License: GPLv3 ! ! Provides a derived type which specifies the boundary conditions ! for the ice shelf model used by Dallaston et al. (2015).  These ! are Dirichlet conditions at the lower bound of the first condition ! as well as, for thickness, the upper bound. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field use boundary_types_mod , only : free_boundary , dirichlet , neumann use glacier_boundary_mod , only : glacier_boundary implicit none private type , extends ( glacier_boundary ), public :: dallaston2015_glacier_boundary !* Author: Chris MacMackin !  Date: November 2016 ! ! A type with procedures for getting the boundary conditions of ! the ice shelf model used by Dallaston et al. (2015). These are ! Dirichlet conditions at the lower bound of the first condition ! as well as, for thickness, the upper bound. ! ! @TODO Consider testing the consistency conditions at the outgoing boundary? ! private real ( r8 ) :: thickness = 1.0_r8 !! The thickness of the glacier at the inflowing boundary real ( r8 ) :: velocity = 1.0_r8 !! The velocity of the glacier at the inflowing boundary real ( r8 ) :: chi = 1.0_r8 !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ contains procedure :: thickness_lower_bound => dallaston2015_lower_bound !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the thickness !! field. procedure :: velocity_lower_bound => dallaston2015_lower_bound !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: velocity_upper_bound => dallaston2015_upper_bound !! Returns a 1D array which should be passed as the !! `exclude_upper_bound`/`provide_upper_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: thickness_lower_type => dallaston2015_lower_type !! Returns an array indicating what type of boundary conditions !! apply for thickness at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_lower_type => dallaston2015_lower_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_upper_type => dallaston2015_upper_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the upper boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: boundary_residuals => dallaston2015_residuals !! Returns an array consisting of the difference between the !! required boundary values and those which actually exist. This !! can then be appended to a glacier's state vector. The order !! in which these are listed is as follows: lower thickness !! boundary, upper thickness boundary, lower velocity boundary, !! and upper velocity boundary. end type dallaston2015_glacier_boundary interface dallaston2015_glacier_boundary module procedure constructor end interface dallaston2015_glacier_boundary contains pure function constructor ( thickness , velocity , chi ) result ( this ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Constructs a boundary condition object for an ice shelf based on ! the conditions used in Dallaston et al. (2015). ! real ( r8 ), intent ( in ) :: thickness !! The ice thickness at the inflowing ice shelf boundary real ( r8 ), intent ( in ) :: velocity !! The longitudinal ice velocity at the inflowing ice shelf boundary real ( r8 ), intent ( in ) :: chi !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ type ( dallaston2015_glacier_boundary ) :: this this % thickness = thickness this % velocity = velocity this % chi = chi end function constructor pure function dallaston2015_lower_bound ( this ) result ( bound_array ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Indicates that one layer of cells at the lower boundary in the ! first dimension should be omitted. This is appropriate for ! Dirichlet boundary conditions. ! class ( dallaston2015_glacier_boundary ), intent ( in ) :: this integer , dimension ( 2 ) :: bound_array bound_array = [ 1 , 0 ] end function dallaston2015_lower_bound pure function dallaston2015_upper_bound ( this ) result ( bound_array ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Indicates that one layer of cells at the upper boundary in the ! first dimension should be omitted for thickness. This is ! appropriate for Dirichlet boundary conditions. ! class ( dallaston2015_glacier_boundary ), intent ( in ) :: this integer , dimension ( 2 ) :: bound_array bound_array = [ 1 , 0 ] end function dallaston2015_upper_bound pure function dallaston2015_lower_type ( this ) result ( bound_type ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Specifies that the lower boundary in the first dimension has ! Dirichlet boundary conditions. ! class ( dallaston2015_glacier_boundary ), intent ( in ) :: this integer , dimension (:), allocatable :: bound_type bound_type = [ dirichlet , free_boundary ] end function dallaston2015_lower_type pure function dallaston2015_upper_type ( this ) result ( bound_type ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Specifies that the upper boundary in the first dimension has ! Neumann boundary conditions. ! class ( dallaston2015_glacier_boundary ), intent ( in ) :: this integer , dimension (:), allocatable :: bound_type bound_type = [ neumann , free_boundary ] end function dallaston2015_upper_type function dallaston2015_residuals ( this , thickness , velocity , viscosity , t ) & result ( residuals ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Returns the difference between the glacier conditions of the ! plume and the Dirichlet conditions prescribed in the model of ! Dallaston et al. (2015) ! class ( dallaston2015_glacier_boundary ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: thickness !! A field containing the thickness of the glacier class ( vector_field ), intent ( in ) :: velocity !! A field containing the flow velocity of the glacier class ( scalar_field ), intent ( in ) :: viscosity !! A field containing the viscosity of the ice in the glacier. real ( r8 ), intent ( in ) :: t !! The time at which the boundary conditions are to be !! calculated. real ( r8 ), allocatable , dimension (:) :: residuals !! An array containing the difference between the required !! boundary values and those which are actually present. They !! are stored in the order: lower thickness boundary, upper !! thickness boundary, lower velocity boundary, and upper !! velocity boundary. class ( scalar_field ), pointer :: thickness_bound , & velocity_bound_upper , & velocity_deriv class ( vector_field ), pointer :: velocity_bound_lower call thickness % guard_temp (); call velocity % guard_temp (); call viscosity % guard_temp () call thickness % allocate_scalar_field ( thickness_bound ) thickness_bound = thickness % get_boundary ( - 1 , 1 ) - this % thickness call velocity % allocate_vector_field ( velocity_bound_lower ) velocity_bound_lower = velocity % get_boundary ( - 1 , 1 ) - [ this % velocity ] call velocity % allocate_scalar_field ( velocity_deriv ) velocity_deriv = velocity % component_d_dx ( 1 , 1 ) call velocity % allocate_scalar_field ( velocity_bound_upper ) velocity_bound_upper = velocity_deriv % get_boundary ( 1 , 1 ) & * thickness % get_boundary ( 1 , 1 ) & - ( 0.25_r8 * this % chi ) * thickness % get_boundary ( 1 , 1 ) ** 2 & / viscosity % get_boundary ( 1 , 1 ) residuals = [ thickness_bound % raw (), velocity_bound_lower % raw (), & velocity_bound_upper % raw ()] call thickness % clean_temp (); call velocity % clean_temp (); call viscosity % clean_temp () end function dallaston2015_residuals end module dallaston2015_glacier_boundary_mod"},{"title":"averaged_one_equation_melt.f90 – ISOFT","tags":"","loc":"sourcefile/averaged_one_equation_melt.f90.html","text":"This file depends on sourcefile~~averaged_one_equation_melt.f90~~EfferentGraph sourcefile~averaged_one_equation_melt.f90 averaged_one_equation_melt.f90 sourcefile~melt_relationship.f90 melt_relationship.F90 sourcefile~averaged_one_equation_melt.f90->sourcefile~melt_relationship.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ave_one_equation_melt_mod Source Code averaged_one_equation_melt.f90 Source Code ! !  averaged_one_equation_melt.f90 !  This file is part of ISOFT. ! !  Copyright 2018 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module ave_one_equation_melt_mod !* Author: Christopher MacMackin !  Date: August 2018 !  License: GPLv3 ! ! Provides an implementation of melt similar to that used by ! Dallaston, Hewitt, and Wells (2015), prior to their neglecting ! certain terms on scaling arguments. This implementation has been ! modified to account for transverse variation in a ! horizontally-integrated model. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field use melt_relationship_mod , only : abstract_melt_relationship implicit none private type , extends ( abstract_melt_relationship ), public :: ave_one_equation_melt !* Author: Christopher MacMackin !  Date: August 2018 ! ! A parameterisation of melting into a plume which comes from ! heavily simplifying the 3 equation model. It can work with ! horizontally-integrated plume models, taking account of the ! plume's transverse profile. It is taken from Dallaston, Hewitt, ! and Wells (2015), prior to the their dropping some terms based ! on scaling arguments. The melt rate, as well as effect on ! termperature and salinity, are calculated by calling ! [[abstract_melt_relationship:solve_for_melt]] and then accessed ! using [[abstract_melt_relationship:melt_rate]], ! [[abstract_melt_relationship:heat_equation_terms]], ! [[abstract_melt_relationship:salt_equation_terms]]. ! class ( scalar_field ), allocatable :: forcing_values !! Stores the resulting forcing values. real ( r8 ) :: coef1 = 0.018208_r8 !! The unitless multiplier on the thermal forcing term, !! \\Gamma_Tx_0/D_0. real ( r8 ) :: coef2 = 0.023761_r8 !! The unitless multiplier applied to the thermal forcing term to !! get the melt rate, c_oT_0/L. real ( r8 ) :: sal_forcing = 0._r8 !! The unitless multiplier applied to the forcing values to get !! the salinity forcing. It corresponds to the product of !! `coef2` and the ice salinity. Typically this would be zero, !! but it might be positive if there is some marine ice !! present. Alternatively, depending on how the salinity has !! been scaled, it may have a negative value. real ( r8 ) :: melt_temp = 0._r8 !! The melting temperature. While intuitively it makes sense to !! set this to zero, it can be useful to scale temperature in !! such a way that it will have a negative value. real ( r8 ) :: a_UabsT = 1._r8 !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy,  where !! f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the !! variables |\\vec{U}| and T in the transverse !! direction. contains procedure :: solve_for_melt => one_equation_solve procedure :: heat_equation_terms => one_equation_heat !! Returns the terms this melt formulation contributes to the !! heat equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: salt_equation_terms => one_equation_salt !! Returns the terms this melt formulation contributes to the !! salt equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: melt_rate => ave_one_equation_melt_rate !! Returns the melt rate calculated using this formulation, !! after it has been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: has_heat_terms => one_equation_has_heat !! Whether this formulation of melting contributes any terms to !! a plume's heat equation. procedure :: has_salt_terms => one_equation_has_salt !! Whether this formulation of melting contributes any terms to !! a plume's salinity equation. end type ave_one_equation_melt interface ave_one_equation_melt module procedure constructor end interface ave_one_equation_melt contains pure function constructor ( coef1 , coef2 , fresh_sal , melt_temp , a_UabsT ) result ( this ) real ( r8 ), intent ( in ) :: coef1 !! The unitless multiplier on the thermal forcing term, !! \\Gamma_Tx_0/D_0. real ( r8 ), intent ( in ) :: coef2 !! The unitless multiplier applied to the theram forcing term to !! get the melt rate, c_oT_0/L. real ( r8 ), intent ( in ), optional :: fresh_sal !! The salinity of fresh water. Defaults to 0. real ( r8 ), intent ( in ), optional :: melt_temp !! The melting point of the ice. Defaults to 0. real ( r8 ), intent ( in ), optional :: a_UabsT !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy,  where !! f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the !! variables |\\vec{U}| and T in the transverse !! direction. Defaults to 1. type ( ave_one_equation_melt ) :: this !! The newly created object representing the melt relationship. this % coef1 = coef1 if ( present ( fresh_sal )) this % sal_forcing = - fresh_sal * coef2 if ( present ( melt_temp )) this % melt_temp = melt_temp if ( present ( a_UabsT )) this % a_UabsT = a_UabsT end function constructor subroutine one_equation_solve ( this , velocity , pressure , temperature , & salinity , plume_thickness , time ) class ( ave_one_equation_melt ), intent ( inout ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: pressure !! The water pressure at the interface where the melting occurs. class ( scalar_field ), intent ( in ) :: temperature !! The temperature of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: salinity !! The salinity of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: plume_thickness !! The thickness of the plume into which fluid is melting. real ( r8 ), intent ( in ), optional :: time !! The time at which the melting is being solved for. If not !! present then assumed to be same as previous value passed. call velocity % guard_temp (); call pressure % guard_temp () call temperature % guard_temp (); call salinity % guard_temp () call plume_thickness % guard_temp () if (. not . allocated ( this % forcing_values )) then allocate ( this % forcing_values , mold = temperature ) else if (. not . same_type_as ( this % forcing_values , temperature )) then deallocate ( this % forcing_values ) allocate ( this % forcing_values , mold = temperature ) end if this % forcing_values = this % coef1 * ( this % a_UabsT * temperature - & this % melt_temp ) * velocity % norm () call velocity % clean_temp (); call pressure % clean_temp () call temperature % clean_temp (); call salinity % clean_temp () call plume_thickness % clean_temp () end subroutine one_equation_solve function one_equation_heat ( this ) result ( heat ) class ( ave_one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: heat !! The value of the contribution made by melting/thermal !! transfer to the heat equation for a [[plume]] if (. not . allocated ( this % forcing_values )) error stop ( 'Melt values not calculated' ) call this % forcing_values % allocate_scalar_field ( heat ) if ( this % melt_temp /= 0._r8 ) then heat = ( 1 - this % coef2 * this % melt_temp ) * this % forcing_values else heat = this % forcing_values end if call heat % set_temp () ! Shouldn't need to call this, but for some ! rason being set as non-temporary when ! assignment subroutine returns. end function one_equation_heat function one_equation_salt ( this ) result ( salt ) class ( ave_one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: salt !! The value of the contribution made by melting/thermal !! transfer to the salt equation for a [[plume]] if (. not . allocated ( this % forcing_values ) . and . this % sal_forcing /= 0._r8 ) then error stop ( 'Melt values not calculated' ) end if salt => this % sal_forcing * this % forcing_values end function one_equation_salt function ave_one_equation_melt_rate ( this ) result ( melt ) class ( ave_one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate from the ice into the plume water. if (. not . allocated ( this % forcing_values )) error stop ( 'Melt values not calculated' ) melt => this % coef2 * this % forcing_values end function ave_one_equation_melt_rate pure function one_equation_has_heat ( this ) result ( has_heat ) class ( ave_one_equation_melt ), intent ( in ) :: this logical :: has_heat !! Whether this formulation of melting contributes terms to !! the heat equation of the plume. has_heat = . true . end function one_equation_has_heat pure function one_equation_has_salt ( this ) result ( has_salt ) class ( ave_one_equation_melt ), intent ( in ) :: this logical :: has_salt !! Whether this formulation of melting contributes terms to !! the salinity equation of the plume. has_salt = ( this % sal_forcing /= 0._r8 ) end function one_equation_has_salt end module ave_one_equation_melt_mod"},{"title":"newtonian_viscosity.F90 – ISOFT","tags":"","loc":"sourcefile/newtonian_viscosity.f90.html","text":"This file depends on sourcefile~~newtonian_viscosity.f90~~EfferentGraph sourcefile~newtonian_viscosity.f90 newtonian_viscosity.F90 sourcefile~viscosity.f90 viscosity.F90 sourcefile~newtonian_viscosity.f90->sourcefile~viscosity.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~newtonian_viscosity.f90~~AfferentGraph sourcefile~newtonian_viscosity.f90 newtonian_viscosity.F90 sourcefile~ice_shelf.f90 ice_shelf.F90 sourcefile~ice_shelf.f90->sourcefile~newtonian_viscosity.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules newtonian_viscosity_mod Source Code newtonian_viscosity.F90 Source Code ! !  newtonian_viscosity.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module newtonian_viscosity_mod !* Author: Christopher MacMackin !  Date: October 2016 !  License: GPLv3 ! ! Provides a simple concrete implementation for the ! [[abstract_viscosity]] type, for a Newtonian fluid. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field , uniform_scalar_field use viscosity_mod , only : abstract_viscosity implicit none private type , extends ( abstract_viscosity ), public :: newtonian_viscosity !* Author: Christopher MacMackin !  Date: October 2016 ! ! An implementation of Newtonian (constant) viscosity for a glacier. ! private real ( r8 ) :: viscosity_value = 1.0_r8 contains procedure :: ice_viscosity => newtonian_ice_viscosity !! Returns the viscosity for the ice. end type newtonian_viscosity interface newtonian_viscosity module procedure constructor end interface newtonian_viscosity contains pure function constructor ( viscosity_value ) result ( this ) real ( r8 ), intent ( in ) :: viscosity_value !! The numerical value of the viscosity which this type is meant !! to return. type ( newtonian_viscosity ) :: this !! The viscosity object being created. this % viscosity_value = viscosity_value end function constructor function newtonian_ice_viscosity ( this , velocity , temperature , time ) & result ( viscosity ) class ( newtonian_viscosity ), intent ( in ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the ice for which the velocity is !! being calculated real ( r8 ), intent ( in ) :: temperature !! The temperature of the ice for which viscosity is being !! calculated. real ( r8 ), intent ( in ), optional :: time !! The time at which the viscosity is being calculated. If not !! present then assumed to be same as previous value passed. class ( scalar_field ), pointer :: viscosity !! The value of the viscosity type ( uniform_scalar_field ) :: dummy call velocity % guard_temp () call dummy % allocate_scalar_field ( viscosity ) viscosity = uniform_scalar_field ( this % viscosity_value ) call viscosity % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. call velocity % clean_temp () end function newtonian_ice_viscosity end module newtonian_viscosity_mod"},{"title":"glens_law.F90 – ISOFT","tags":"","loc":"sourcefile/glens_law.f90.html","text":"This file depends on sourcefile~~glens_law.f90~~EfferentGraph sourcefile~glens_law.f90 glens_law.F90 sourcefile~viscosity.f90 viscosity.F90 sourcefile~glens_law.f90->sourcefile~viscosity.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules glens_law_mod Source Code glens_law.F90 Source Code ! !  glens_law.f90 !  This file is part of ISOFT. ! !  Copyright 2017 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module glens_law_mod !* Author: Christopher MacMackin !  Date: April 2017 !  License: GPLv3 ! ! Provides a concrete implementation for the [[abstract_viscosity]] ! type using Glen's flow law. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field , abs , sqrt use viscosity_mod , only : abstract_viscosity implicit none private type , extends ( abstract_viscosity ), public :: glens_law_viscosity !* Author: Christopher MacMackin !  Date: April 2017 ! ! An implementation of Glen's flow law to describe glacier ! viscosity. It takes the form \\eta = \\frac{1}{2}BD&#94;{1/n-1}, ! where D = \\sqrt{D_{ij}D_{ij}/2 is the second invarient of ! the strain rate D_{ij} = \\frac{1}{2}\\left(\\frac{\\partial ! u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} ! \\right). Here, B is treated as a constant, although it may ! be parameterised as a function of temperature. ! private real ( r8 ) :: b_val = 1.0_r8 real ( r8 ) :: index = 3._r8 contains procedure :: ice_viscosity => glens_ice_viscosity !! Returns the viscosity for the ice. end type glens_law_viscosity interface glens_law_viscosity module procedure constructor end interface glens_law_viscosity contains pure function constructor ( b_val , index ) result ( this ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Instantiates an instance of a viscosity object implementing ! Glen's flow law. ! real ( r8 ), intent ( in ) :: b_val !! The coefficient, B, in Glen's flow law. real ( r8 ), intent ( in ) :: index !! The index, n, in the exponent of Glen's flow law. type ( glens_law_viscosity ) :: this !! The viscosity object being created. this % b_val = b_val this % index = index end function constructor function glens_ice_viscosity ( this , velocity , temperature , time ) & result ( viscosity ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Calculates the viscosity of ice using Glen's flow law. See the ! documentation of the [[glens_law_viscosity]] object for a ! description of this parameterisation. ! class ( glens_law_viscosity ), intent ( in ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the ice for which the velocity is !! being calculated real ( r8 ), intent ( in ) :: temperature !! The temperature of the ice for which viscosity is being !! calculated. real ( r8 ), intent ( in ), optional :: time !! The time at which the viscosity is being calculated. If not !! present then assumed to be same as previous value passed. class ( scalar_field ), pointer :: viscosity !! The value of the viscosity call velocity % guard_temp () if ( velocity % dimensions () > 1 ) then error stop ( 'Multidimensional case not implemented' ) ! This should all work, but there seems to be yet another ! compiler bug. At present I don't need the multi-dimensional ! case anyway. !      viscosity => velocity%component_d_dx(1, 1)**2 + & !                   velocity%component_d_dx(2, 2)**2 + & !                   0.25_r8*(velocity%component_d_dx(1, 2) + & !                            velocity%component_d_dx(2, 1)**2) !      viscosity => sqrt(viscosity) else viscosity => abs ( velocity % component_d_dx ( 1 , 1 , 1 )) end if viscosity => 0.5_r8 * this % b_val * viscosity ** ( 1._r8 / this % index - 1._r8 ) call velocity % clean_temp () call viscosity % set_temp () end function glens_ice_viscosity end module glens_law_mod"},{"title":"kochergin1987_entrainment.F90 – ISOFT","tags":"","loc":"sourcefile/kochergin1987_entrainment.f90.html","text":"This file depends on sourcefile~~kochergin1987_entrainment.f90~~EfferentGraph sourcefile~kochergin1987_entrainment.f90 kochergin1987_entrainment.F90 sourcefile~entrainment.f90 entrainment.F90 sourcefile~kochergin1987_entrainment.f90->sourcefile~entrainment.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules kochergin1987_entrainment_mod Source Code kochergin1987_entrainment.F90 Source Code ! !  kochergin1987_entrainment.f90 !  This file is part of ISOFT. ! !  Copyright 2018 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module kochergin1987_entrainment_mod !* Author: Christopher MacMackin !  Date: October 2016 !  License: GPLv3 ! ! Provides a concrete implementation of [[abstract_entrainment]] ! in the form of the parameterisation described by Kochergin (1987). ! use iso_fortran_env , only : r8 => real64 use factual_mod !, only: scalar_field, vector_field, abs use entrainment_mod , only : abstract_entrainment implicit none private type , extends ( abstract_entrainment ), public :: kochergin1987_entrainment !* Author: Christopher MacMackin !  Date: Feburary 2018 ! ! A parameterisation of entrainment (e) as described by ! Kochergin (1987): e = ! \\frac{c_L&#94;2}{S_m}\\sqrt{|\\vec{U}|&#94;2+\\frac{g'D}{S_m}}. Here, ! c_L is an entrainment coefficient, \\vec{U} is the ! velocity of the plume, g' is the reduced gravity, and ! S_m is the turbulent Schmidt number. The latter-most can be ! expressed as  S_m = \\frac{Ri}{0.0725(Ri + 0.186 - ! \\sqrt{Ri&#94;2 - 0.316Ri + 0.0346})} , where Ri = ! g'D/|\\vec{U}|&#94;2 is the Richardson number. ! private real ( r8 ) :: coefficient = 1.0_r8 !! The entrainment coefficient c_L&#94;2x_0/D_0 real ( r8 ) :: delta = 0.036_r8 !! The ratio D_0/h_0 contains procedure :: entrainment_rate => kochergin1987_rate !! Returns the entrainment rate for ambient water into the plume. end type kochergin1987_entrainment interface kochergin1987_entrainment module procedure constructor end interface kochergin1987_entrainment contains pure function constructor ( coefficient , delta ) result ( this ) real ( r8 ), intent ( in ) :: coefficient !! The entrainment coefficient c_L&#94;2x_0/D_0 real ( r8 ), intent ( in ) :: delta !! The ratio D_0/h_0 type ( kochergin1987_entrainment ) :: this !! A new entrainment object this % coefficient = coefficient this % delta = delta end function constructor function kochergin1987_rate ( this , velocity , thickness , depth , density_diff , time ) & result ( entrainment ) !* Author: Christopher MacMackin !  Date: Feburary 2018 ! ! e = \\frac{c_L&#94;2}{S_m}\\sqrt{|\\vec{U}|&#94;2+\\frac{g'D}{S_m}}. ! Here, c_L is an entrainment coefficient, \\vec{U} is the ! velocity of the plume, g' is the reduced gravity, and ! S_m is the turbulent Schmidt number. The Schmidt number is a ! function of the Richardson number Ri = g'D/|\\vec{U}|&#94;2: !  S_m = \\frac{Ri}{0.0725(Ri + 0.186 - ! \\sqrt{Ri&#94;2 - 0.316Ri + 0.0346})}.  ! class ( kochergin1987_entrainment ), intent ( in ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is being !! entrained. class ( scalar_field ), intent ( in ) :: thickness !! The thickness of the plume into which fluid is being !! entrained class ( scalar_field ), intent ( in ) :: depth !! The depth of the upper surface of the plume into which !! fluid is being entrained class ( scalar_field ), intent ( in ) :: density_diff !! The difference between the ambient density and the density of !! the plume into which the ambient fluid is being entrained. real ( r8 ), intent ( in ), optional :: time !! The time at which the entrainment is being calculated. If not !! present then assumed to be same as previous value passed. class ( scalar_field ), pointer :: entrainment !! The value of the entrainment class ( scalar_field ), pointer :: Ri , Sm call velocity % guard_temp (); call thickness % guard_temp () call depth % guard_temp (); call density_diff % guard_temp () call depth % allocate_scalar_field ( entrainment ) call entrainment % unset_temp () call depth % allocate_scalar_field ( Ri ) call depth % allocate_scalar_field ( Sm ) call Ri % guard_temp (); call Sm % guard_temp () entrainment = velocity % norm () ! Have to awkwardly split this operation to prevent ICE Ri = this % delta * density_diff * thickness / ( entrainment ** 2 ) Sm = Ri / ( 0.0725_r8 * ( Ri + 0.186_r8 - sqrt ( Ri ** 2 - 0.316_r8 * Ri + 0.0346_r8 ))) entrainment = this % coefficient * entrainment / Sm * sqrt ( 1._r8 + Ri / Sm ) call velocity % clean_temp (); call thickness % clean_temp () call depth % clean_temp (); call density_diff % clean_temp () call Ri % clean_temp (); call Sm % clean_temp () call entrainment % set_temp () end function kochergin1987_rate end module kochergin1987_entrainment_mod"},{"title":"jenkins1991_entrainment.F90 – ISOFT","tags":"","loc":"sourcefile/jenkins1991_entrainment.f90.html","text":"This file depends on sourcefile~~jenkins1991_entrainment.f90~~EfferentGraph sourcefile~jenkins1991_entrainment.f90 jenkins1991_entrainment.F90 sourcefile~entrainment.f90 entrainment.F90 sourcefile~jenkins1991_entrainment.f90->sourcefile~entrainment.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~jenkins1991_entrainment.f90~~AfferentGraph sourcefile~jenkins1991_entrainment.f90 jenkins1991_entrainment.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~jenkins1991_entrainment.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~jenkins1991_entrainment.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~jenkins1991_entrainment.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules jenkins1991_entrainment_mod Source Code jenkins1991_entrainment.F90 Source Code ! !  jenkins1991_entrainment.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module jenkins1991_entrainment_mod !* Author: Christopher MacMackin !  Date: October 2016 !  License: GPLv3 ! ! Provides a concrete implementation of [[abstract_entrainment]] ! in the form of the parameterisation used by Jenkins (1991). ! use iso_fortran_env , only : r8 => real64 use factual_mod !, only: scalar_field, vector_field, abs use entrainment_mod , only : abstract_entrainment implicit none private type , extends ( abstract_entrainment ), public :: jenkins1991_entrainment !* Author: Christopher MacMackin !  Date: October 2016 ! ! A parameterisation of entrainment (e) as described by Jenkins ! (1991): e = E_0 |\\vec{U}\\sin(\\theta) \\simeq ! E_0|\\vec{U}||\\nabla b|. Here, E_0 is a coefficient typically ! taken to be 0.036 (the default value), \\vec{U} is the velocity ! of the plume, \\theta is the angle of slope of the ice shelf ! base, and b is the basal depth of the ice shelf. ! private real ( r8 ) :: coefficient = 1.0_r8 !! The entrainment coefficient $E_0$ contains procedure :: entrainment_rate => jenkins1991_rate !! Returns the entrainment rate for ambient water into the plume. end type jenkins1991_entrainment interface jenkins1991_entrainment module procedure constructor end interface jenkins1991_entrainment contains pure function constructor ( coefficient ) result ( this ) real ( r8 ), intent ( in ) :: coefficient !! The entrainment coefficient, $E_0$ to be used type ( jenkins1991_entrainment ) :: this !! A new entrainment object this % coefficient = coefficient end function constructor function jenkins1991_rate ( this , velocity , thickness , depth , density_diff , time ) & result ( entrainment ) !* Author: Christopher MacMackin !  Date: October 2016 ! ! e = E_0 |\\vec{U}\\sin(\\theta) \\simeq E_0|\\vec{U}||\\nabla b| ! Here, E_0 is a coefficient typically taken to be 0.036 (the ! default value), \\vec{U} is the velocity of the plume, \\theta ! is the angle of slope of the ice shelf base, and b is the ! basal depth of the ice shelf. ! ! @Warning ! The calculation must be performed as ! ```fortran ! this%coefficient * depth%d_dx(1) * velocity%norm() ! ``` ! with the variables in a different order than how the equation is ! usually formulated. If they are in the correct order then ! `gfortran` expects the result to be a `vector_field`. It ! is not clear whether this is due to a bug in `gfortran` or in ! `factual`. ! class ( jenkins1991_entrainment ), intent ( in ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is being !! entrained. class ( scalar_field ), intent ( in ) :: thickness !! The thickness of the plume into which fluid is being !! entrained class ( scalar_field ), intent ( in ) :: depth !! The depth of the upper surface of the plume into which !! fluid is being entrained class ( scalar_field ), intent ( in ) :: density_diff !! The difference between the ambient density and the density of !! the plume into which the ambient fluid is being entrained. real ( r8 ), intent ( in ), optional :: time !! The time at which the entrainment is being calculated. If not !! present then assumed to be same as previous value passed. class ( scalar_field ), pointer :: entrainment !! The value of the entrainment class ( vector_field ), pointer :: tmp call velocity % guard_temp (); call thickness % guard_temp () call depth % guard_temp (); call density_diff % guard_temp () call depth % allocate_scalar_field ( entrainment ) call depth % allocate_vector_field ( tmp ) entrainment = velocity % norm () call entrainment % unset_temp () tmp = . grad . depth entrainment = tmp % norm () ! Needed due to ICE when try to put all on one line. TODO: Create minimal example and submit bug report. entrainment = this % coefficient * entrainment * velocity % norm () call velocity % clean_temp (); call thickness % clean_temp () call depth % clean_temp (); call density_diff % clean_temp () call entrainment % set_temp () end function jenkins1991_rate end module jenkins1991_entrainment_mod"},{"title":"dallaston2015_melt.F90 – ISOFT","tags":"","loc":"sourcefile/dallaston2015_melt.f90.html","text":"This file depends on sourcefile~~dallaston2015_melt.f90~~EfferentGraph sourcefile~dallaston2015_melt.f90 dallaston2015_melt.F90 sourcefile~melt_relationship.f90 melt_relationship.F90 sourcefile~dallaston2015_melt.f90->sourcefile~melt_relationship.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~dallaston2015_melt.f90~~AfferentGraph sourcefile~dallaston2015_melt.f90 dallaston2015_melt.F90 sourcefile~asymmetric_plume.f90 asymmetric_plume.F90 sourcefile~asymmetric_plume.f90->sourcefile~dallaston2015_melt.f90 sourcefile~static_plume.f90 static_plume.F90 sourcefile~static_plume.f90->sourcefile~dallaston2015_melt.f90 sourcefile~plume.f90 plume.F90 sourcefile~plume.f90->sourcefile~dallaston2015_melt.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dallaston2015_melt_mod Source Code dallaston2015_melt.F90 Source Code ! !  dallaston2015_melt.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module dallaston2015_melt_mod !* Author: Christopher MacMackin !  Date: October 2016 !  License: GPLv3 ! ! Provides an implementation of [[abstract_melt_relationship]] which ! mimics the simple model used by Dallaston, Hewitt, and Wells ! (2015) for an ice shelf melting into a vertically integrated ! plume. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field use melt_relationship_mod , only : abstract_melt_relationship implicit none private type , extends ( abstract_melt_relationship ), public :: dallaston2015_melt !* Author: Christopher MacMackin !  Date: October 2016 ! ! A parameterisation of melting into a plume which comes from ! heavily simplifying the 3 equation model. It is taken from ! Dallaston, Hewitt, and Wells (2015). The melt rate, as well as ! effect on termperature and salinity, are calculated by calling ! [[abstract_melt_relationship:solve_for_melt]] and then accessed ! using [[abstract_melt_relationship:melt_rate]], ! [[abstract_melt_relationship:heat_equation_terms]], ! [[abstract_melt_relationship:salt_equation_terms]]. ! class ( scalar_field ), allocatable :: melt_values !! Stores the resulting melt rate real ( r8 ) :: coef = 144 9.29936 !! The coefficient by which the melt rate is multiplied in order !! to determine the contribution to the heat equation. real ( r8 ) :: melt_conversion = 6.9e-4_r8 !! The factor to convert between the scale for melt used by !! Dallaston et al. (2015) and that used in ISOFT,  !! \\frac{m_0x_0}{D_0U_0},  where m_0 is the melt scale !! used by Dalalston et al. real ( r8 ) :: salinity_denom = 1 e100_r8 contains procedure :: solve_for_melt => dallaston2015_solve procedure :: heat_equation_terms => dallaston2015_heat !! Returns the terms this melt formulation contributes to the !! heat equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: salt_equation_terms => dallaston2015_salt !! Returns the terms this melt formulation contributes to the !! salt equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: melt_rate => dallaston2015_melt_rate !! Returns the melt rate calculated using this formulation, !! after it has been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: has_heat_terms => dallaston2015_has_heat !! Whether this formulation of melting contributes any terms to !! a plume's heat equation. procedure :: has_salt_terms => dallaston2015_has_salt !! Whether this formulation of melting contributes any terms to !! a plume's salinity equation. end type dallaston2015_melt interface dallaston2015_melt module procedure constructor end interface dallaston2015_melt contains pure function constructor ( beta , melt_conversion , salinity_denom ) result ( this ) real ( r8 ), intent ( in ) :: beta !! The inverse stefan number,  \\frac{c(T_a - T_m)}{L}  real ( r8 ), intent ( in ) :: melt_conversion !! The factor to convert between the scale for melt used by !! Dallaston et al. (2015) and that used in ISOFT,  !! \\frac{m_0x_0}{D_0U_0},  where m_0 is the melt scale !! used by Dalalston et al. real ( r8 ), intent ( in ), optional :: salinity_denom !! The factor which, when used to divide the `melt_conversion` !! term, produces a conversion factor for the melt-terms in the !! salinity equation of Dallaston et al. (2015). It has the form !!  \\frac{Q_{g0}}{D_0U_0},  where Q_{g0} is the !! subglacial discharge across the grounding line. type ( dallaston2015_melt ) :: this !! The newly created object representing the melt relationship. this % coef = ( beta + 1.0_r8 ) this % melt_conversion = melt_conversion if ( present ( salinity_denom )) this % salinity_denom = salinity_denom end function constructor subroutine dallaston2015_solve ( this , velocity , pressure , temperature , & salinity , plume_thickness , time ) class ( dallaston2015_melt ), intent ( inout ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: pressure !! The water pressure at the interface where the melting occurs. class ( scalar_field ), intent ( in ) :: temperature !! The temperature of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: salinity !! The salinity of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: plume_thickness !! The thickness of the plume into which fluid is melting. real ( r8 ), intent ( in ), optional :: time !! The time at which the melting is being solved for. If not !! present then assumed to be same as previous value passed. call velocity % guard_temp (); call pressure % guard_temp () call temperature % guard_temp (); call salinity % guard_temp () call plume_thickness % guard_temp () if (. not . allocated ( this % melt_values )) then allocate ( this % melt_values , mold = salinity ) end if this % melt_values = velocity % norm () call velocity % clean_temp (); call pressure % clean_temp () call temperature % clean_temp (); call salinity % clean_temp () call plume_thickness % clean_temp () end subroutine dallaston2015_solve function dallaston2015_heat ( this ) result ( heat ) class ( dallaston2015_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: heat !! The value of the contribution made by melting/thermal !! transfer to the heat equation for a [[plume]] if (. not . allocated ( this % melt_values )) error stop ( 'Melt values not allocated' ) call this % melt_values % allocate_scalar_field ( heat ) heat = this % coef * this % melt_values end function dallaston2015_heat function dallaston2015_salt ( this ) result ( salt ) class ( dallaston2015_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: salt !! The value of the contribution made by melting/thermal !! transfer to the salt equation for a [[plume]] if (. not . allocated ( this % melt_values )) error stop ( 'Melt values not allocated' ) call this % melt_values % allocate_scalar_field ( salt ) salt = this % melt_conversion / this % salinity_denom * this % melt_values end function dallaston2015_salt function dallaston2015_melt_rate ( this ) result ( melt ) class ( dallaston2015_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate from the ice into the plume water. if (. not . allocated ( this % melt_values )) error stop ( 'Melt values not allocated' ) call this % melt_values % allocate_scalar_field ( melt ) melt = this % melt_conversion * this % melt_values end function dallaston2015_melt_rate pure function dallaston2015_has_heat ( this ) result ( has_heat ) class ( dallaston2015_melt ), intent ( in ) :: this logical :: has_heat !! Whether this formulation of melting contributes terms to !! the heat equation of the plume. has_heat = . true . end function dallaston2015_has_heat pure function dallaston2015_has_salt ( this ) result ( has_salt ) class ( dallaston2015_melt ), intent ( in ) :: this logical :: has_salt !! Whether this formulation of melting contributes terms to !! the salinity equation of the plume. has_salt = . true . end function dallaston2015_has_salt end module dallaston2015_melt_mod"},{"title":"one_equation_melt.F90 – ISOFT","tags":"","loc":"sourcefile/one_equation_melt.f90.html","text":"This file depends on sourcefile~~one_equation_melt.f90~~EfferentGraph sourcefile~one_equation_melt.f90 one_equation_melt.F90 sourcefile~melt_relationship.f90 melt_relationship.F90 sourcefile~one_equation_melt.f90->sourcefile~melt_relationship.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules one_equation_melt_mod Source Code one_equation_melt.F90 Source Code ! !  one_equation_melt.f90 !  This file is part of ISOFT. ! !  Copyright 2016 Chris MacMackin <cmacmackin@physics.ox.ac.uk> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! #ifdef DEBUG #define pure #define elemental #endif module one_equation_melt_mod !* Author: Christopher MacMackin !  Date: May 2017 !  License: GPLv3 ! ! Provides an implementation of melt similar to that used by ! Dallaston, Hewitt, and Wells (2015), prior to their neglecting ! certain terms on scaling arguments. ! use iso_fortran_env , only : r8 => real64 use factual_mod , only : scalar_field , vector_field use melt_relationship_mod , only : abstract_melt_relationship implicit none private type , extends ( abstract_melt_relationship ), public :: one_equation_melt !* Author: Christopher MacMackin !  Date: May 2017 ! ! A parameterisation of melting into a plume which comes from ! heavily simplifying the 3 equation model. It is taken from ! Dallaston, Hewitt, and Wells (2015), prior to the their dropping ! some terms based on scaling arguments. The melt rate, as well as ! effect on termperature and salinity, are calculated by calling ! [[abstract_melt_relationship:solve_for_melt]] and then accessed ! using [[abstract_melt_relationship:melt_rate]], ! [[abstract_melt_relationship:heat_equation_terms]], ! [[abstract_melt_relationship:salt_equation_terms]]. ! class ( scalar_field ), allocatable :: forcing_values !! Stores the resulting forcing values. real ( r8 ) :: coef1 = 0.018208_r8 !! The unitless multiplier on the thermal forcing term, !! \\Gamma_Tx_0/D_0. real ( r8 ) :: coef2 = 0.023761_r8 !! The unitless multiplier applied to the thermal forcing term to !! get the melt rate, c_oT_0/L. real ( r8 ) :: sal_forcing = 0._r8 !! The unitless multiplier applied to the forcing values to get !! the salinity forcing. It corresponds to the product of !! `coef2` and the ice salinity. Typically this would be zero, !! but it might be positive if there is some marine ice !! present. Alternatively, depending on how the salinity has !! been scaled, it may have a negative value. real ( r8 ) :: melt_temp = 0._r8 !! The melting temperature. While intuitively it makes sense to !! set this to zero, it can be useful to scale temperature in !! such a way that it will have a negative value. contains procedure :: solve_for_melt => one_equation_solve procedure :: heat_equation_terms => one_equation_heat !! Returns the terms this melt formulation contributes to the !! heat equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: salt_equation_terms => one_equation_salt !! Returns the terms this melt formulation contributes to the !! salt equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: melt_rate => one_equation_melt_rate !! Returns the melt rate calculated using this formulation, !! after it has been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: has_heat_terms => one_equation_has_heat !! Whether this formulation of melting contributes any terms to !! a plume's heat equation. procedure :: has_salt_terms => one_equation_has_salt !! Whether this formulation of melting contributes any terms to !! a plume's salinity equation. end type one_equation_melt interface one_equation_melt module procedure constructor end interface one_equation_melt contains pure function constructor ( coef1 , coef2 , fresh_sal , melt_temp ) result ( this ) real ( r8 ), intent ( in ) :: coef1 !! The unitless multiplier on the thermal forcing term, !! \\Gamma_Tx_0/D_0. real ( r8 ), intent ( in ) :: coef2 !! The unitless multiplier applied to the theram forcing term to !! get the melt rate, c_oT_0/L. real ( r8 ), intent ( in ), optional :: fresh_sal !! The salinity of fresh water. Defaults to 0. real ( r8 ), intent ( in ), optional :: melt_temp !! The melting point of the ice. Defaults to 0. type ( one_equation_melt ) :: this !! The newly created object representing the melt relationship. this % coef1 = coef1 this % coef2 = coef2 if ( present ( fresh_sal )) this % sal_forcing = - fresh_sal * coef2 if ( present ( melt_temp )) this % melt_temp = melt_temp end function constructor subroutine one_equation_solve ( this , velocity , pressure , temperature , & salinity , plume_thickness , time ) class ( one_equation_melt ), intent ( inout ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: pressure !! The water pressure at the interface where the melting occurs. class ( scalar_field ), intent ( in ) :: temperature !! The temperature of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: salinity !! The salinity of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: plume_thickness !! The thickness of the plume into which fluid is melting. real ( r8 ), intent ( in ), optional :: time !! The time at which the melting is being solved for. If not !! present then assumed to be same as previous value passed. call velocity % guard_temp (); call pressure % guard_temp () call temperature % guard_temp (); call salinity % guard_temp () call plume_thickness % guard_temp () if (. not . allocated ( this % forcing_values )) then allocate ( this % forcing_values , mold = temperature ) else if (. not . same_type_as ( this % forcing_values , temperature )) then deallocate ( this % forcing_values ) allocate ( this % forcing_values , mold = temperature ) end if this % forcing_values = this % coef1 * ( temperature - this % melt_temp ) * velocity % norm () call velocity % clean_temp (); call pressure % clean_temp () call temperature % clean_temp (); call salinity % clean_temp () call plume_thickness % clean_temp () end subroutine one_equation_solve function one_equation_heat ( this ) result ( heat ) class ( one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: heat !! The value of the contribution made by melting/thermal !! transfer to the heat equation for a [[plume]] if (. not . allocated ( this % forcing_values )) error stop ( 'Melt values not calculated' ) call this % forcing_values % allocate_scalar_field ( heat ) if ( this % melt_temp /= 0._r8 ) then heat = ( 1 - this % coef2 * this % melt_temp ) * this % forcing_values else heat = this % forcing_values end if call heat % set_temp () ! Shouldn't need to call this, but for some ! rason being set as non-temporary when ! assignment subroutine returns. end function one_equation_heat function one_equation_salt ( this ) result ( salt ) class ( one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: salt !! The value of the contribution made by melting/thermal !! transfer to the salt equation for a [[plume]] if (. not . allocated ( this % forcing_values ) . and . this % sal_forcing /= 0._r8 ) then error stop ( 'Melt values not calculated' ) end if salt => this % sal_forcing * this % forcing_values end function one_equation_salt function one_equation_melt_rate ( this ) result ( melt ) class ( one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate from the ice into the plume water. if (. not . allocated ( this % forcing_values )) error stop ( 'Melt values not calculated' ) melt => this % coef2 * this % forcing_values end function one_equation_melt_rate pure function one_equation_has_heat ( this ) result ( has_heat ) class ( one_equation_melt ), intent ( in ) :: this logical :: has_heat !! Whether this formulation of melting contributes terms to !! the heat equation of the plume. has_heat = . true . end function one_equation_has_heat pure function one_equation_has_salt ( this ) result ( has_salt ) class ( one_equation_melt ), intent ( in ) :: this logical :: has_salt !! Whether this formulation of melting contributes terms to !! the salinity equation of the plume. has_salt = ( this % sal_forcing /= 0._r8 ) end function one_equation_has_salt end module one_equation_melt_mod"},{"title":"calculus.py – ISOFT","tags":"","loc":"sourcefile/calculus.py.html","text":"Contents Source Code calculus.py Source Code # #  calculus.py #  This file is part of ISOFT. # #  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> # #  This program is free software; you can redistribute it and/or modify #  it under the terms of the GNU General Public License as published by #  the Free Software Foundation; either version 3 of the License, or #  (at your option) any later version. # #  This program is distributed in the hope that it will be useful, #  but WITHOUT ANY WARRANTY; without even the implied warranty of #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #  GNU General Public License for more details. # #  You should have received a copy of the GNU General Public License #  along with this program; if not, write to the Free Software #  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, #  MA 02110-1301, USA. # import numpy as np cheb_cache = dict () def cheb ( size , lower = 0.0 , upper = 1.0 ): ''' Computes a Chebyshev differentiation matrix of the appropriate size. Returns a 1D Numpy array of Chebyshev collocation points and a 2D differentiation matrix. ''' if ( size , lower , upper ) in cheb_cache : return cheb_cache [( size , lower , upper )] def c ( i ): if i % 2 == 0 : f = 1.0 else : f = - 1.0 if i == 0 or i == size : return f * 2.0 else : return f * 1.0 if size < 1 : raise Exception ( 'Must have more than one Chebyshev node.' ) #~ x = 0.5*np.cos(np.linspace(0.0, 1.0, size+1) * np.pi) + 0.5 x = np . cos ( np . linspace ( 0.0 , 1.0 , size + 1 ) * np . pi ) D = np . empty (( size + 1 , size + 1 )) for i in range ( size + 1 ): if i != 0 and i != size : D [ i , i ] = - x [ i ] / ( 2.0 * ( 1.0 - x [ i ] ** 2 )) for j in range ( i ) + range ( i + 1 , size + 1 ): D [ i , j ] = c ( i ) / c ( j ) / ( x [ i ] - x [ j ]) c = ( 2.0 * float ( size ** 2 ) + 1.0 ) / 6.0 D [ 0 , 0 ] = c D [ size , size ] = - c # Adjust for use on [0,1] interval factor = ( upper - lower ) / 2.0 x = factor * ( 1 + x ) + lower D = 2.0 * D / ( upper - lower ) cheb_cache [( size , lower , upper )] = ( x , D ) return ( x , D ) class Differentiator ( object ): \"\"\"An object which can perform a differentiation operation on a field from an ISOFT run. size The number of Chebyshev modes in the field lower The lower boundary of the field domain upper The upper boundary of the field domain \"\"\" def __init__ ( this , size , lower = 0.0 , upper = 1.0 ): this . x , this . D = cheb ( size - 1 , lower , upper ) def __call__ ( this , rhs ): return this . D . dot ( rhs )"},{"title":"eos.py – ISOFT","tags":"","loc":"sourcefile/eos.py.html","text":"Contents Source Code eos.py Source Code # #  entrainment.py #  This file is part of ISOFT. # #  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> # #  This program is free software; you can redistribute it and/or modify #  it under the terms of the GNU General Public License as published by #  the Free Software Foundation; either version 3 of the License, or #  (at your option) any later version. # #  This program is distributed in the hope that it will be useful, #  but WITHOUT ANY WARRANTY; without even the implied warranty of #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #  GNU General Public License for more details. # #  You should have received a copy of the GNU General Public License #  along with this program; if not, write to the Free Software #  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, #  MA 02110-1301, USA. # '''Contains classes for calculating density of water. ''' import numpy as np import calculus class LinearEos ( object ): '''A class representing a linearised equation of state. It uses the equation: density = ref_density*[1 - beta_T*(T-T_ref) + beta_S*(S-S_ref)] ''' def __init__ ( this , ref_density , beta_T , beta_S , T_ref , S_ref ): this . rd = ref_density this . bT = beta_T this . bS = beta_S this . Tr = T_ref this . Sr = S_ref def __call__ ( this , T , S ): return this . rd * ( 1 - this . bT * ( T - this . Tr ) + this . bS * ( S - this . Sr ))"},{"title":"layers.py – ISOFT","tags":"","loc":"sourcefile/layers.py.html","text":"Contents Source Code layers.py Source Code # #  layers.py #  This file is part of ISOFT. # #  Copyright 2018 Chris MacMackin <cmacmackin@gmail.com> # #  This program is free software; you can redistribute it and/or modify #  it under the terms of the GNU General Public License as published by #  the Free Software Foundation; either version 3 of the License, or #  (at your option) any later version. # #  This program is distributed in the hope that it will be useful, #  but WITHOUT ANY WARRANTY; without even the implied warranty of #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #  GNU General Public License for more details. # #  You should have received a copy of the GNU General Public License #  along with this program; if not, write to the Free Software #  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, #  MA 02110-1301, USA. # import numpy as np import numpy.ma as ma def compute_layers ( shelf , vertical_resolution = 300 ): \"\"\"Computes the internal layers or age field for an ice shelf from the Taylor coefficients. \"\"\" xc = shelf . grid zc = np . linspace ( np . min ( shelf . b ), np . max ( shelf . s ), vertical_resolution ) xx , zz = np . meshgrid ( xc , zc ) shelf_domain = np . logical_or ( np . greater ( zz , shelf . s ), np . less ( zz , shelf . b )) x = ma . array ( xx , mask = shelf_domain , copy = False ) z = ma . array ( zz , mask = shelf_domain , copy = False ) kappa = shelf . kappa # This isn't really the most efficient way to calculate the Taylor # series, but array broadcasting was giving me a headache. k = np . zeros_like ( z ) for i in range ( 1 , 1 + kappa . shape [ 0 ]): k += kappa [ i - 1 ] * ( shelf . s - z ) ** i return x , z , k"},{"title":"readers.py – ISOFT","tags":"","loc":"sourcefile/readers.py.html","text":"Contents Source Code readers.py Source Code # #  readers.py #  This file is part of ISOFT. # #  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> # #  This program is free software; you can redistribute it and/or modify #  it under the terms of the GNU General Public License as published by #  the Free Software Foundation; either version 3 of the License, or #  (at your option) any later version. # #  This program is distributed in the hope that it will be useful, #  but WITHOUT ANY WARRANTY; without even the implied warranty of #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #  GNU General Public License for more details. # #  You should have received a copy of the GNU General Public License #  along with this program; if not, write to the Free Software #  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, #  MA 02110-1301, USA. # ''' Contains classes for reading simulation data from HDF5 files. ''' import h5py import numpy as np class Glacier ( object ): '''A class which reads glacier data from HDF5 output. It presents the data in a convenient manner for plotting. hdf_obj An HDF5 file or group. hdf_group The name of the group in `hdf_obj` which contains the ice shelf data. ''' def __init__ ( self , hdf_obj , hdf_group ): self . groupname = hdf_group self . data = hdf_obj [ hdf_group ] @property def grid ( self ): return self . data [ self . data [ 'thickness' ] . attrs [ 'gridpoints_dim1' ]][ ... ] @property def h ( self ): return self . data [ 'thickness' ][ ... ] @property def uvec ( self ): return self . data [ 'velocity' ][ ... ] . T @property def u ( self ): return self . uvec [ 0 , ... ] @property def v ( self ): return self . uvec [ 1 , ... ] @property def kappa ( self ): n = self . data . attrs [ 'num_kappas' ] kap = np . empty (( n , self . data [ 'thickness' ] . len ())) for i in range ( n ): kap [ i ,:] = self . data [ 'kappa_{0:04d}' . format ( i + 1 )][ ... ] return kap @property def glacier_type ( self ): return self . data . attrs [ 'glacier_type' ] @property def lambd ( self ): return self . data . attrs [ 'lambda' ][ 0 ] @property def chi ( self ): return self . data . attrs [ 'chi' ][ 0 ] class Plume ( object ): '''A class which reads Plume data from HDF5 output. It presents the data in a convenient manner for plotting. hdf_obj An HDF5 file or group. hdf_group The name of the group in `hdf_obj` which contains the ice shelf data. ''' def __init__ ( self , hdf_obj , hdf_group ): self . groupname = hdf_group self . data = hdf_obj [ hdf_group ] @property def grid ( self ): return self . data [ self . data [ 'thickness' ] . attrs [ 'gridpoints_dim1' ]][ ... ] @property def D ( self ): return self . data [ 'thickness' ][ ... ] @property def Uvec ( self ): return self . data [ 'velocity' ][ ... ] . T @property def U ( self ): return self . Uvec [ ... , 0 ] @property def V ( self ): return self . Uvec [ ... , 1 ] @property def S ( self ): return self . data [ 'salinity' ][ ... ] @property def T ( self ): return self . data [ 'temperature' ][ ... ] @property def basal_surface_type ( self ): return self . data . attrs [ 'basal_type' ] @property def delta ( self ): return self . data . attrs [ 'delta' ][ 0 ] @property def mu ( self ): return self . data . attrs [ 'mu' ][ 0 ] @property def nu ( self ): return self . data . attrs [ 'nu' ][ 0 ] @property def r ( self ): return self . data . attrs [ 'r_val' ][ 0 ] @property def phi ( self ): return self . data . attrs [ 'phi' ][ 0 ] class ShelfPlumeCryosphere ( object ): '''An abstract class which represents a Cryosphere object containing at least one glacier and one basal surface. hdf_file The HDF5 file containing the ice shelf/plume data. ''' def __init__ ( self , hdf_file ): self . filename = hdf_file self . data = h5py . File ( hdf_file , 'r' ) self . shelf = Glacier ( self . data , 'glacier' ) self . plume = Plume ( self . data , 'basal_surface' ) @property def isoft_version ( self ): return self . data . attrs [ 'isoft_version' ] @property def compilation_time ( self ): return self . data . attrs [ 'binary_compilation_time' ] @property def output_time ( self ): return self . data . attrs [ 'data_output_time' ] @property def time ( self ): return self . data . attrs [ 'simulation_time' ][ 0 ] @property def grid ( self ): return self . shelf . grid @property def h ( self ): return self . shelf . h @property def uvec ( self ): return self . shelf . uvec @property def u ( self ): return self . shelf . u @property def v ( self ): return self . shelf . v @property def kappa ( self ): return self . shelf . kappa @property def glacier_type ( self ): return self . shelf . glacier_type @property def lambd ( self ): return self . shelf . lambd @property def chi ( self ): return self . shelf . chi @property def s ( self ): return self . h * ( 1.0 - 1.0 / self . r ) @property def b ( self ): return - self . h / self . r @property def D ( self ): return self . plume . D @property def Uvec ( self ): return self . plume . Uvec @property def U ( self ): return self . plume . U @property def V ( self ): return self . plume . V @property def S ( self ): return self . plume . S @property def T ( self ): return self . plume . T @property def basal_surface_type ( self ): return self . plume . basal_surface_type @property def delta ( self ): return self . plume . delta @property def mu ( self ): return self . plume . mu @property def nu ( self ): return self . plume . nu @property def r ( self ): return self . plume . r @property def phi ( self ): return self . plume . phi"},{"title":"viscosity.py – ISOFT","tags":"","loc":"sourcefile/viscosity.py.html","text":"Contents Source Code viscosity.py Source Code # #  viscosity.py #  This file is part of ISOFT. # #  Copyright 2018 Chris MacMackin <cmacmackin@gmail.com> # #  This program is free software; you can redistribute it and/or modify #  it under the terms of the GNU General Public License as published by #  the Free Software Foundation; either version 3 of the License, or #  (at your option) any later version. # #  This program is distributed in the hope that it will be useful, #  but WITHOUT ANY WARRANTY; without even the implied warranty of #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #  GNU General Public License for more details. # #  You should have received a copy of the GNU General Public License #  along with this program; if not, write to the Free Software #  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, #  MA 02110-1301, USA. # '''Contains classes for calculating the viscosity of the ice using different parameterisations. ''' import numpy as np import calculus class NewtonianViscosity ( object ): '''A class representing Newtonian viscosity. value The viscosity value of the ice ''' def __init__ ( this , value = 1.0 ): this . val = value def __call__ ( this , uvec , temperature =- 15.0 , time = 0 ): return this . val * np . ones_like ( uvec [ 0 , ... ]) class GlensLaw ( object ): '''A class using Glen's Law to represent viscosity. It treats viscosity as a power law for strain. size The number of Chebyshev modes in the field lower The lower boundary of the field domain upper The upper boundary of the field domain coef The coefficient by which Glen's Law is scaled index The index of the power law ''' def __init__ ( this , size , lower = 0.0 , upper = 1.0 , coef = 1.0 , index = 3 ): this . diff = calculus . Differentiator ( size , lower , upper ) this . coef = coef this . index = float ( index ) def __call__ ( this , uvec , temperature =- 15.0 , time = 0 ): if ( uvec . ndim > 2 ): raise NotImplementedError ( 'GlensLaw only implemented for 1-D ' 'velocity field.' ) return 0.5 * this . coef * abs ( this . diff ( uvec [:, 0 ])) ** ( 1. / this . index - 1. )"},{"title":"melt.py – ISOFT","tags":"","loc":"sourcefile/melt.py.html","text":"Contents Source Code melt.py Source Code # #  melt.py #  This file is part of ISOFT. # #  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> # #  This program is free software; you can redistribute it and/or modify #  it under the terms of the GNU General Public License as published by #  the Free Software Foundation; either version 3 of the License, or #  (at your option) any later version. # #  This program is distributed in the hope that it will be useful, #  but WITHOUT ANY WARRANTY; without even the implied warranty of #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #  GNU General Public License for more details. # #  You should have received a copy of the GNU General Public License #  along with this program; if not, write to the Free Software #  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, #  MA 02110-1301, USA. # '''Contains classes for calculating the melt rate of the ice shelf using different parameterisations. ''' import numpy as np class Dallaston2015Melt ( object ): '''A class representing the melt formulation used by Dallaston et al. (2015). beta Inverse Stefan number epsilon_g subglacial flux/entrained flux epsilon_m subshelf melt/entrained flux ''' def __init__ ( self , beta , epsilon_g , epsilon_m ): self . beta = beta self . epsilon_g = epsilon_g self . epsilon_m = epsilon_m def __call__ ( self , U , p , T , S , D ): return np . linalg . norm ( U , axis =- 1 ) * ( 1 - self . epsilon_m / self . beta * T ) def thermal_forcing ( self , U , p , T , S , D ): return self ( U , p , T , S , D ) * ( self . beta + 1 ) def saline_forcing ( self , U , p , T , S , D ): return np . zeros ( T . size ) class OneEquationMelt ( object ): '''A class representing a melt formulation similar to that used by Dallaston et al. (2015), but including the terms they removed after scale analysis. coef1 The factor $Gamma_tx_0/D_0$ coef2 The factor $c_0T_0/L$ fresh_sal The numerical salinity value given to fresh water melt_temp The numerical temperature value at which melting occurs ''' def __init__ ( self , coef1 , coef2 , fresh_sal = 0. , melt_temp = 0. ): self . coef1 = coef1 self . coef2 = coef2 self . fresh_sal = fresh_sal self . melt_temp = melt_temp def forcing_value ( self , U , p , T , S , D ): return self . coef1 * np . linalg . norm ( U , axis =- 1 ) * ( T - self . melt_temp ) def __call__ ( self , U , p , T , S , D ): return self . coef2 * self . forcing_value ( U , p , T , S , D ) def thermal_forcing ( self , U , p , T , S , D ): return ( 1. - self . coef2 * self . melt_temp ) * self . forcing_value ( U , p , T , S , D ) def saline_forcing ( self , U , p , T , S , D ): return - self ( U , p , T , S , D ) * self . fresh_sal"},{"title":"entrainment.py – ISOFT","tags":"","loc":"sourcefile/entrainment.py.html","text":"Contents Source Code entrainment.py Source Code # #  entrainment.py #  This file is part of ISOFT. # #  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> # #  This program is free software; you can redistribute it and/or modify #  it under the terms of the GNU General Public License as published by #  the Free Software Foundation; either version 3 of the License, or #  (at your option) any later version. # #  This program is distributed in the hope that it will be useful, #  but WITHOUT ANY WARRANTY; without even the implied warranty of #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #  GNU General Public License for more details. # #  You should have received a copy of the GNU General Public License #  along with this program; if not, write to the Free Software #  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, #  MA 02110-1301, USA. # '''Contains classes for calculating the entrainment rate of the plume using different parameterisations. ''' import numpy as np import calculus class Jenkins1991Entrainment ( object ): '''A class representing the entrainment formulation used by Jenkins et al. (1991). coefficient The coefficient used in the entrainment calculation size The number of Chebyshev modes in the field lower The lower boundary of the field domain upper The upper boundary of the field domain ''' def __init__ ( this , coefficient , size , lower = 0.0 , upper = 1.0 ): this . coef = coefficient this . diff = calculus . Differentiator ( size , lower , upper ) def __call__ ( this , U , D , b , rho_diff = None ): return this . coef * np . linalg . norm ( U , axis =- 1 ) * np . abs ( this . diff ( b )) class Kochergin1987Entrainment ( object ): '''A class representing the entrainment formulation used by Kochergin (1987). coefficient The coefficient $c_l&#94;2x_0/D_0$ used in the entrainment calculation delta The ratio between the scale of the plume thickness and that of the ice thickness, $D_0/h_0$ ''' def __init__ ( this , coefficient , delta ): this . coef = coefficient this . delta = delta def __call__ ( this , U , D , b , rho_diff ): Ri = np . abs ( this . delta * rho_diff * D ) / np . linalg . norm ( U , axis =- 1 ) ** 2 Sm = Ri / ( 0.0725 * ( Ri + 0.186 - np . sqrt ( Ri ** 2 - 0.316 * Ri + 0.0346 ))) return this . coef * np . linalg . norm ( U , axis =- 1 ) / Sm * np . sqrt ( 1 + Ri / Sm )"},{"title":"dimensionless_nums.py – ISOFT","tags":"","loc":"sourcefile/dimensionless_nums.py.html","text":"Contents Source Code dimensionless_nums.py Source Code # #  dimensionless_num.py #  This file is part of ISOFT. # #  Copyright 2017 Chris MacMackin <cmacmackin@gmail.com> # #  This program is free software; you can redistribute it and/or modify #  it under the terms of the GNU General Public License as published by #  the Free Software Foundation; either version 3 of the License, or #  (at your option) any later version. # #  This program is distributed in the hope that it will be useful, #  but WITHOUT ANY WARRANTY; without even the implied warranty of #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the #  GNU General Public License for more details. # #  You should have received a copy of the GNU General Public License #  along with this program; if not, write to the Free Software #  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, #  MA 02110-1301, USA. # '''Contains routines for calculating various useful dimensionless numbers. ''' import numpy as np def froude ( coef , U , drho , D ): return coef * np . linalg . norm ( U , axis =- 1 ) / np . sqrt ( drho * D )"},{"title":"ice_continuity.py – ISOFT","tags":"","loc":"sourcefile/ice_continuity.py.html","text":"/usr/bin/env python Contents Source Code ice_continuity.py Source Code #!/usr/bin/env python from plotting.readers import ShelfPlumeCryosphere from plotting.calculus import Differentiator from plotting.melt import OneEquationMelt import matplotlib.pyplot as plt from matplotlib.backends.backend_pdf import PdfPages import sys if len ( sys . argv ) > 1 : cryo = ShelfPlumeCryosphere ( sys . argv [ 1 ]) else : cryo = ShelfPlumeCryosphere ( 'isoft-0200.h5' ) x = cryo . grid diff = Differentiator ( x . size , x [ - 1 ], x [ 0 ]) D = cryo . D Uvec = cryo . Uvec U = cryo . U T = cryo . T S = cryo . S h = cryo . h u = cryo . u m = OneEquationMelt ( 0.0182 , 4.86e-4 , - 2035.3 , - 54.92 ) lambd = cryo . lambd plt . figure () u_dh = u * diff ( h ) h_du = h * diff ( u ) m = - cryo . lambd * m ( Uvec , cryo . b , T , S , D ) dh_dt = m - u_dh - h_du plt . plot ( x , dh_dt , label = r '$h_t$' ) plt . plot ( x , u_dh , label = r '$uh_x$' ) plt . plot ( x , h_du , label = r '$u_x h$' ) plt . plot ( x , m , label = r '$-\\lambda m$' ) plt . xlabel ( r '$x$' ) plt . legend ( loc = 0 ) plt . tight_layout () if len ( sys . argv ) > 2 : plt . savefig ( sys . argv [ 2 ]) else : plt . show ()"},{"title":"shock.py – ISOFT","tags":"","loc":"sourcefile/shock.py.html","text":"/usr/bin/env python Contents Source Code shock.py Source Code #!/usr/bin/env python import sys from plotting.readers import ShelfPlumeCryosphere from plotting.dimensionless_nums import froude from plotting.eos import LinearEos import matplotlib.pyplot as plt from numpy import sqrt eos = LinearEos ( 3.05e5 , 1.409e-6 , 1.336e-5 , 0. , 0. ) T_a = 0.0 S_a = 0.0 rho_a = eos ( T_a , S_a ) U_0 = 0.196 D_0 = 43.2 rho_0 = 1030. rho_s = 3.38e-3 g = 9.8 coef = U_0 / sqrt ( g * rho_s * D_0 / rho_0 ) if len ( sys . argv ) > 1 : cryo = ShelfPlumeCryosphere ( sys . argv [ 1 ]) else : cryo = ShelfPlumeCryosphere ( 'isoft-0000.h5' ) x = cryo . grid rho = eos ( cryo . T , cryo . S ) plt . figure ( figsize = ( 5 , 5 )) plt . plot ( x , cryo . D , label = '$D$' ) plt . plot ( x , cryo . U , label = '$U$' ) plt . plot ( x , froude ( coef , cryo . Uvec , rho_a - rho , cryo . D ), label = r '$\\rm Fr$' ) plt . legend ( prop = { 'size' : 'medium' }) plt . xlabel ( '$x$' ) plt . tight_layout () if len ( sys . argv ) > 2 : plt . savefig ( sys . argv [ 2 ]) else : plt . show ()"},{"title":"plume_momentum.py – ISOFT","tags":"","loc":"sourcefile/plume_momentum.py.html","text":"/usr/bin/env python Contents Source Code plume_momentum.py Source Code #!/usr/bin/env python from plotting.readers import ShelfPlumeCryosphere from plotting.melt import OneEquationMelt , Dallaston2015Melt from plotting.entrainment import Jenkins1991Entrainment from plotting.eos import LinearEos from plotting.calculus import Differentiator from plotting.dimensionless_nums import froude import numpy as np import matplotlib.pyplot as plt import sys if len ( sys . argv ) > 1 : cryo = ShelfPlumeCryosphere ( sys . argv [ 1 ]) else : cryo = ShelfPlumeCryosphere ( 'isoft-0000.h5' ) x = cryo . grid diff = Differentiator ( x . size , x [ - 1 ], x [ 0 ]) eos = LinearEos ( 3.05e5 , 1.409e-6 , 1.336e-5 , 0. , 0. ) D = cryo . D Uvec = cryo . Uvec U = cryo . U T = cryo . T S = cryo . S b = cryo . b mu = cryo . mu nu = cryo . nu delta = cryo . delta T_a = 0.0 S_a = 0.0 rho = eos ( T , S ) rho_a = eos ( T_a , S_a ) plt . figure ( figsize = ( 5 , 5 )) plt . plot ( x , diff ( D * U ** 2 ), label = r '$(DU&#94;2)_x$' ) plt . plot ( x , D * ( rho_a - rho ) * diff ( b ), label = r '$D(\\rho_a - \\rho)b_x$' ) plt . plot ( x , D * ( rho_a - rho ) * diff ( - delta * D ), label = r '$-D(\\rho_a - \\rho)\\delta D_x$' ) plt . plot ( x , nu * diff ( D * diff ( U )), label = r '$\\nu (DU_{x})_{x}$' ) plt . plot ( x , - mu * np . abs ( U ) * U , label = r '$-\\mu |U|U$' ) plt . plot ( x , delta / 2 * D ** 2 * diff ( rho ), label = r '$\\frac{\\delta D&#94;2}{2}\\rho_x$' ) #plt.plot(x, diff(D*U**2) - D*(rho_a - rho)*diff(b - delta*D) - #         nu*diff(D*diff(U)) + mu*abs(U)*U - delta/2*D**2*diff(rho), #         label='Sum') plt . legend ( prop = { 'size' : 'medium' }) plt . xlabel ( '$x$' ) plt . tight_layout () if len ( sys . argv ) > 2 : plt . savefig ( sys . argv [ 2 ]) else : plt . show ()"},{"title":"decompose.py – ISOFT","tags":"","loc":"sourcefile/decompose.py.html","text":"/usr/bin/env python Contents Source Code decompose.py Source Code #!/usr/bin/env python from plotting.readers import ShelfPlumeCryosphere from plotting.melt import OneEquationMelt , Dallaston2015Melt from plotting.entrainment import Jenkins1991Entrainment from plotting.eos import LinearEos from plotting.calculus import Differentiator from plotting.dimensionless_nums import froude import numpy as np import matplotlib.pyplot as plt import sys if len ( sys . argv ) > 1 : cryo = ShelfPlumeCryosphere ( sys . argv [ 1 ]) else : cryo = ShelfPlumeCryosphere ( 'isoft-0000.h5' ) x = cryo . grid diff = Differentiator ( x . size , x [ - 1 ], x [ 0 ]) m = OneEquationMelt ( 0.0182 , 4.86e-4 , - 2035.3 , - 54.92 ) e = Jenkins1991Entrainment ( 1.0 , x . size , x [ - 1 ], x [ 0 ]) eos = LinearEos ( 3.05e5 , 1.409e-6 , 1.336e-5 , 0. , 0. ) D = cryo . D Uvec = cryo . Uvec U = cryo . U T = cryo . T S = cryo . S b = cryo . b ent = e ( Uvec , D , b ) mu = cryo . mu nu = cryo . nu delta = cryo . delta T_a = 0.0 S_a = 0.0 rho = eos ( T , S ) rho_a = eos ( T_a , S_a ) plt . plot ( x , diff ( D * U ), label = r '$(DU)_x$' ) plt . plot ( x , ent , label = r '$e$' ) plt . plot ( x , m ( Uvec , b , T , S , D ), label = r '$m$' ) plt . plot ( x , diff ( D * U ) - ent - m ( Uvec , b , T , S , D ), label = 'Sum' ) #plt.plot(x, U*diff(D), label=r'$D_xU$') #plt.plot(x, D*diff(U), label=r'$DU_x$') plt . legend () plt . show () plt . plot ( x , diff ( D * U ** 2 ), label = r '$(DU&#94;2)_x$' ) plt . plot ( x , D * ( rho_a - rho ) * diff ( b - delta * D ), label = r '$D(\\rho_a - \\rho)(b_x - \\delta D_x)$' ) plt . plot ( x , nu * diff ( D * diff ( U )), label = r '$\\nu (DU_{x})_{x}$' ) plt . plot ( x , - mu * np . abs ( U ) * U , label = r '$-\\mu |U|U$' ) plt . plot ( x , delta / 2 * D ** 2 * diff ( rho ), label = r '$\\frac{\\delta D&#94;2}{2}\\rho_x$' ) plt . plot ( x , diff ( D * U ** 2 ) - D * ( rho_a - rho ) * diff ( b - delta * D ) - nu * diff ( D * diff ( U )) + mu * abs ( U ) * U - delta / 2 * D ** 2 * diff ( rho ), label = 'Sum' ) #plt.plot(x, U**2*diff(D), label=r'$D_xU&#94;2$') #plt.plot(x, 2*D*U*diff(U), label=r'$2DUU_x$') plt . legend () plt . show () plt . plot ( x , diff ( D * U * T ), label = '$(DUT)_x$' ) plt . plot ( x , ent * T_a , label = '$eT_a$' ) plt . plot ( x , nu * diff ( D * diff ( T )), label = r '$\\nu (DT_{x})_{x}$' ) plt . plot ( x , - m . thermal_forcing ( Uvec , b , T , S , D ), label = '$-\\gamma_T (T-T_m)$' ) plt . plot ( x , diff ( D * U * T ) - ent * T_a - nu * diff ( D * diff ( T )) + m . thermal_forcing ( Uvec , b , T , S , D ), label = 'Sum' ) #plt.plot(x, T*U*diff(D), label=r'$D_xUT$') #plt.plot(x, T*D*diff(U), label=r'$DU_xT$') #plt.plot(x, D*U*diff(T), label=r'$DUT_x$') plt . legend () plt . show () plt . plot ( x , diff ( D * U * S ), label = '$(DUS)_x$' ) plt . plot ( x , ent * S_a , label = '$eS_a$' ) plt . plot ( x , nu * diff ( D * diff ( S )), label = r '$\\nu (DS_{x})_{x}$' ) plt . plot ( x , - m . saline_forcing ( Uvec , b , T , S , D ), label = '$-\\gamma_S (S-S_m)$' ) plt . plot ( x , diff ( D * U * S ) - ent * S_a - nu * diff ( D * diff ( S )) + m . saline_forcing ( Uvec , b , T , S , D ), label = 'Sum' ) #plt.plot(x, S*U*diff(D), label=r'$D_xUS$') #plt.plot(x, S*D*diff(U), label=r'$DU_xS$') #plt.plot(x, D*U*diff(S), label=r'$DUS_x$') plt . legend () plt . show ()"},{"title":"display.py – ISOFT","tags":"","loc":"sourcefile/display.py.html","text":"/usr/bin/env python Contents Source Code display.py Source Code #!/usr/bin/env python from plotting.readers import ShelfPlumeCryosphere import matplotlib.pyplot as plt from matplotlib import gridspec import numpy as np import sys if len ( sys . argv ) > 1 : cryo = ShelfPlumeCryosphere ( sys . argv [ 1 ]) else : cryo = ShelfPlumeCryosphere ( 'isoft-0000.h5' ) x = cryo . grid D = cryo . D Uvec = cryo . Uvec U = cryo . U T = cryo . T S = cryo . S b = cryo . b r = 1.12 gamma = 4 lambd = 1e2 X = 1.0 / ( lambd * 2.02188465743 * 4.3316e-4 ) velocity = np . sqrt ( 1.0 + gamma / 4.0 * X - gamma / 4.0 * X * ( 1.0 - x / X ) ** 2 ) thickness = ( 1.0 - x / X ) / velocity depth = - thickness / r fig = plt . figure ( figsize = ( 5 , 5 )) gs = gridspec . GridSpec ( 2 , 1 , height_ratios = [ 2 , 1 ]) ax1 = fig . add_subplot ( gs [ 0 ]) ax2 = fig . add_subplot ( gs [ 1 ], sharex = ax1 ) ax1 . plot ( x , D , label = '$D$' ) ax1 . plot ( x , U , label = '$U$' ) ax1 . plot ( x , cryo . b , label = '$b$' ) ax1 . plot ( x , depth , '--' , label = r '$\\hat{b}$' ) ax1 . plot ( x , cryo . u , label = r '$u$' ) ax1 . get_xaxis () . set_visible ( False ) ax1 . set_ylim ( - 1 , 3.5 ) ax1 . get_yticklabels ()[ 0 ] . set_visible ( False ) ax1 . legend ( prop = { 'size' : 'medium' }, ncol = 3 , columnspacing = 1.0 , loc = 2 ) ax2 . plot ( x , T , label = '$T$' ) ax2 . plot ( x , S , label = '$S$' ) ax2 . set_xlabel ( '$x$' ) ax2 . legend ( prop = { 'size' : 'medium' }, loc = 3 ) fig . tight_layout () fig . subplots_adjust ( hspace = 0 ) if len ( sys . argv ) > 2 : plt . savefig ( sys . argv [ 2 ]) else : plt . show ()"},{"title":"internal_layers.py – ISOFT","tags":"","loc":"sourcefile/internal_layers.py.html","text":"/usr/bin/env python Contents Source Code internal_layers.py Source Code #!/usr/bin/env python from plotting.readers import ShelfPlumeCryosphere from plotting.layers import compute_layers import numpy as np import numpy.ma as ma import matplotlib import matplotlib.pyplot as plt import sys if len ( sys . argv ) > 1 : cryo = ShelfPlumeCryosphere ( sys . argv [ 1 ]) else : cryo = ShelfPlumeCryosphere ( 'isoft-0000.h5' ) nz = 1200 conts = 16 x , z , k = compute_layers ( cryo , nz ) #plt.plot(cryo.s[-1] - z[:,-1], k[:, -1], label=r'$k$') #plt.plot(cryo.s[-1] - z[:,-1], 1/np.sqrt(1.05 - cryo.s[-1] + z[:,-1]) #         - 1/np.sqrt(1.05), label=r'$k$') #plt.legend(loc=0) #plt.show() plt . figure ( figsize = ( 8 , 6 )) plt . plot ( cryo . grid , cryo . s , 'k' ) plt . plot ( cryo . grid , cryo . b , 'k' ) plt . contour ( x , z , k , conts , linewidths = 0.5 , colors = 'k' ) plt . contourf ( x , z , k , conts , cmap = 'PuBu' ) plt . xlabel ( '$x$' ) plt . ylabel ( '$z$' ) plt . colorbar ( orientation = 'horizontal' , label = r '$k$' ) plt . tight_layout () if len ( sys . argv ) > 2 : plt . savefig ( sys . argv [ 2 ]) else : plt . show ()"},{"title":"rk_comm_real_1d – ISOFT ","tags":"","loc":"type/rk_comm_real_1d.html","text":"type, public :: rk_comm_real_1d Contents Variables t t_old t_start t_end dir h h_old h_start h_average tol f_count full_f_count step_count bad_step_count at_t_start at_t_end thresh weights ymax scratch y yp y_new y_old yp_old v0 v1 err_estimates v2 v3 vtemp stages a b c bhat r e ptr no_of_stages rk_method intrp_degree intrp_able intrp_needs_stages toosml cost safety expon stability_radius tan_angle rs rs1 rs2 rs3 rs4 order last_stage max_stiff_iters no_of_ge_steps fsal ge_max_contrib t_ge_max_contrib ge_f_count ge_assess ge_y ge_yp ge_y_new ge_err_estimates ge_stages erason erasfl mcheps dwarf round_off sqrrmc cubrmc sqtiny outch print_message use_range rec tlast range_t_end xstage ytemp p stiff_bad_step_count hit_t_end_count errold chkeff phase2 save_states stop_on_fatal saved_fatal_err Source Code rk_comm_real_1d Components Type Visibility Attributes Name Initial real(kind=wp), private :: t real(kind=wp), private :: t_old real(kind=wp), private :: t_start real(kind=wp), private :: t_end real(kind=wp), private :: dir real(kind=wp), private :: h real(kind=wp), private :: h_old real(kind=wp), private :: h_start real(kind=wp), private :: h_average real(kind=wp), private :: tol integer, private :: f_count integer, private :: full_f_count integer, private :: step_count integer, private :: bad_step_count logical, private :: at_t_start logical, private :: at_t_end real(kind=wp), private, dimension(:), pointer :: thresh real(kind=wp), private, dimension(:), pointer :: weights real(kind=wp), private, dimension(:), pointer :: ymax real(kind=wp), private, dimension(:), pointer :: scratch real(kind=wp), private, dimension(:), pointer :: y real(kind=wp), private, dimension(:), pointer :: yp real(kind=wp), private, dimension(:), pointer :: y_new real(kind=wp), private, dimension(:), pointer :: y_old real(kind=wp), private, dimension(:), pointer :: yp_old real(kind=wp), private, dimension(:), pointer :: v0 real(kind=wp), private, dimension(:), pointer :: v1 real(kind=wp), private, dimension(:), pointer :: err_estimates real(kind=wp), private, dimension(:), pointer :: v2 real(kind=wp), private, dimension(:), pointer :: v3 real(kind=wp), private, dimension(:), pointer :: vtemp real(kind=wp), private, dimension(:,:), pointer :: stages real(kind=wp), private :: a (13,13) real(kind=wp), private :: b (13) real(kind=wp), private :: c (13) real(kind=wp), private :: bhat (13) real(kind=wp), private :: r (11,6) real(kind=wp), private :: e (7) integer, private :: ptr (13) integer, private :: no_of_stages integer, private :: rk_method integer, private :: intrp_degree logical, private :: intrp_able logical, private :: intrp_needs_stages real(kind=wp), private :: toosml real(kind=wp), private :: cost real(kind=wp), private :: safety real(kind=wp), private :: expon real(kind=wp), private :: stability_radius real(kind=wp), private :: tan_angle real(kind=wp), private :: rs real(kind=wp), private :: rs1 real(kind=wp), private :: rs2 real(kind=wp), private :: rs3 real(kind=wp), private :: rs4 integer, private :: order integer, private :: last_stage integer, private :: max_stiff_iters integer, private :: no_of_ge_steps logical, private :: fsal real(kind=wp), private :: ge_max_contrib real(kind=wp), private :: t_ge_max_contrib integer, private :: ge_f_count real(kind=wp), private, dimension(:), pointer :: ge_assess real(kind=wp), private, dimension(:), pointer :: ge_y real(kind=wp), private, dimension(:), pointer :: ge_yp real(kind=wp), private, dimension(:), pointer :: ge_y_new real(kind=wp), private, dimension(:), pointer :: ge_err_estimates real(kind=wp), private, dimension(:,:), pointer :: ge_stages logical, private :: erason logical, private :: erasfl real(kind=wp), private :: mcheps real(kind=wp), private :: dwarf real(kind=wp), private :: round_off real(kind=wp), private :: sqrrmc real(kind=wp), private :: cubrmc real(kind=wp), private :: sqtiny integer, private :: outch logical, private :: print_message logical, private :: use_range character(len=80), private :: rec (10) real(kind=wp), private :: tlast real(kind=wp), private :: range_t_end real(kind=wp), private, dimension(:), pointer :: xstage real(kind=wp), private, dimension(:), pointer :: ytemp real(kind=wp), private, dimension(:,:), pointer :: p integer, private :: stiff_bad_step_count integer, private :: hit_t_end_count real(kind=wp), private :: errold logical, private :: chkeff logical, private :: phase2 integer, private, dimension(7) :: save_states logical, private :: stop_on_fatal logical, private :: saved_fatal_err Source Code type rk_comm_real_1d private real ( kind = wp ) :: t , t_old , t_start , t_end , dir !indep! real ( kind = wp ) :: h , h_old , h_start , h_average !indep! real ( kind = wp ) :: tol integer :: f_count , full_f_count , step_count , bad_step_count logical :: at_t_start , at_t_end real ( kind = wp ), dimension (:), pointer :: thresh , weights , ymax !shp-dep! real ( kind = wp ), dimension (:), pointer :: scratch , y , yp , y_new !dep! real ( kind = wp ), dimension (:), pointer :: y_old , yp_old , v0 , v1 !dep! real ( kind = wp ), dimension (:), pointer :: err_estimates , v2 , v3 !dep! real ( kind = wp ), dimension (:), pointer :: vtemp !dep! real ( kind = wp ), dimension (:,:), pointer :: stages !dep! real ( kind = wp ) :: a ( 13 , 13 ), b ( 13 ), c ( 13 ), bhat ( 13 ), r ( 11 , 6 ), e ( 7 ) integer :: ptr ( 13 ), no_of_stages , rk_method , intrp_degree logical :: intrp_able , intrp_needs_stages real ( kind = wp ) :: toosml , cost , safety , expon , stability_radius , tan_angle , & rs , rs1 , rs2 , rs3 , rs4 integer :: order , last_stage , max_stiff_iters , no_of_ge_steps logical :: fsal real ( kind = wp ) :: ge_max_contrib real ( kind = wp ) :: t_ge_max_contrib !indep! integer :: ge_f_count real ( kind = wp ), dimension (:), pointer :: ge_assess !shp-dep! real ( kind = wp ), dimension (:), pointer :: ge_y , ge_yp , ge_y_new !dep! real ( kind = wp ), dimension (:), pointer :: ge_err_estimates !dep! real ( kind = wp ), dimension (:,:), pointer :: ge_stages !dep! logical :: erason , erasfl real ( kind = wp ) :: mcheps , dwarf , round_off , sqrrmc , cubrmc , sqtiny integer :: outch logical :: print_message , use_range character ( len = 80 ) :: rec ( 10 ) real ( kind = wp ) :: tlast , range_t_end !indep! real ( kind = wp ), dimension (:), pointer :: xstage , ytemp !dep! real ( kind = wp ), dimension (:,:), pointer :: p !dep! integer :: stiff_bad_step_count , hit_t_end_count real ( kind = wp ) :: errold logical :: chkeff , phase2 integer , dimension ( 7 ) :: save_states logical :: stop_on_fatal , saved_fatal_err end type rk_comm_real_1d"},{"title":"glacier – ISOFT ","tags":"","loc":"type/glacier.html","text":"type, public, abstract :: glacier An abstract data type which represents large masses of ice, such\n as ice shelves and ice sheets. Inherited by type~~glacier~~InheritedByGraph type~glacier glacier type~ice_sheet ice_sheet type~ice_sheet->type~glacier type~cryosphere cryosphere type~cryosphere->type~glacier ice type~ice_shelf ice_shelf type~ice_shelf->type~glacier Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures ice_thickness ice_density ice_temperature residual precondition solve_velocity update set_time data_size state_vector read_data write_data time_step assign assignment(=) integrate integrate_layers Source Code glacier Type-Bound Procedures procedure( get_scalar ), public, deferred :: ice_thickness Returns the thickness of the ice in the glacier across the domain. function get_scalar(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property of the glacier is being returned. procedure( get_r8 ), public, deferred :: ice_density Returns the density of the ice, which is assumed to be uniform. pure function get_r8(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value real(kind=r8) The value of whatever property of the glacier is being returned. procedure( get_r8 ), public, deferred :: ice_temperature Returns the temperature of the ice, which is assumed to be uniform. pure function get_r8(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value real(kind=r8) The value of whatever property of the glacier is being returned. procedure( get_residual ), public, deferred :: residual Computes the residual of the system of equations describing the\n glacier. function get_residual(this, previous_states, melt_rate, basal_drag_parameter, water_density) result(residual) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to\n calculate the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier Return Value real(kind=r8),\n  dimension(:), allocatable The residual of the system of equations describing the\n glacier procedure( precond ), public, deferred :: precondition Applies a preconditioner to the passed state vector. function precond(this, previous_states, melt_rate, basal_drag_parameter, water_density, delta_state) result(preconditioned) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to\n calculate the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier real(kind=r8), intent(in), dimension(:) :: delta_state The change to the state vector which is being\n preconditioned. Return Value real(kind=r8),\n  dimension(:), allocatable The result of applying the preconditioner to delta_state . procedure( solve_vel ), public, deferred :: solve_velocity Solves for the velocity field using the current thickness. subroutine solve_vel(this, basal_drag, success) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. logical, intent(out) :: success True if the integration is successful, false otherwise procedure( setter ), public, deferred :: update Sets the state of the glacier. subroutine setter(this, state_vector) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n glacier. procedure( time_setter ), public, deferred :: set_time Sets the time record for this glacier. subroutine time_setter(this, time) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the glacier is in the present state. procedure( get_i ), public, deferred :: data_size Returns the number of elements in the glacier's state vector pure function get_i(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value integer The value of whatever property of the glacier is being returned. procedure( get_r81d ), public, deferred :: state_vector Returns the glacier's state vector, a 1D array with all necessary \n data to describe its state. function get_r81d(this) result(state_vector) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector of the glacier procedure( read_dat ), public, deferred :: read_data Read the glacier data from an HDF5 file on the disc. subroutine read_dat(this, file_id, group_name, error) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group from which the data\n will be read. character(len=*), intent(in) :: group_name The name of the group in the HDF5 file from which to read\n glacier's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure( write_dat ), public, deferred :: write_data Writes the data describing the glacier to the disc as an HDF5 file. subroutine write_dat(this, file_id, group_name, error) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n glacier's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure( t_step ), public, deferred :: time_step Calculates the appropriate time step for integration. function t_step(this) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value real(kind=r8) A time step which will allow integration of the ice shelf\n without causing numerical instability. procedure( assign_ice ), private, deferred :: assign Copies the data from one glacier into another. This is only\n needed due to a bug in gfortran which means that the\n intrinsic assignment for glacier types is not using the\n appropriate defined assignment for the field components. subroutine assign_ice(this, rhs) Prototype Arguments Type Intent Optional Attributes Name class( glacier ), intent(out) :: this class( glacier ), intent(in) :: rhs generic, public :: assignment(=) => assign private subroutine shelf_assign (this, rhs) Author Chris MacMackin Date February 2017 Copies the data from one ice shelf into another. This is only\n needed due to a bug in gfortran which means that the intrinsic\n assignment for glacier types is not using the appropriate\n defined assignment for the field components. Read more… Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(out) :: this class( glacier ), intent(in) :: rhs The ice shelf to be assigned to this one. procedure, public :: integrate => glacier_integrate Performs a time-step of the integration, taking the state of\n the glacier to the specified time using the provided\n melt-rate data. private subroutine glacier_integrate (this, old_states, basal_melt, basal_drag, water_density, time, success) Author Chris MacMackin Date November 2016 Integrates the glacier's state to time . This is done using the\n NITSOL package of iterative Krylov solvers. If a different\n algorithm for the integration is desired, then this method may\n be overridden in the concrete implementations of the glacier\n type. Read more… Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. class(scalar_field), intent(in) :: basal_melt The melt rate that the bottom of the glacier experiences\n during this time step. class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise procedure, public :: integrate_layers => glacier_integrate_layers Dummy routine which can be over-ridden to integrate internal\n layers of the glacier to the specified time. private subroutine glacier_integrate_layers (this, old_states, time, success) Author Chris MacMackin Date September 2018 Dummy routine which does nothing. Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise Source Code type , abstract , public :: glacier !* Author: Christopehr MacMackin !  Date: April 2016 ! ! An abstract data type which represents large masses of ice, such ! as ice shelves and ice sheets. ! contains procedure ( get_scalar ), deferred :: ice_thickness !! Returns the thickness of the ice in the glacier across the domain. procedure ( get_r8 ), deferred :: ice_density !! Returns the density of the ice, which is assumed to be uniform. procedure ( get_r8 ), deferred :: ice_temperature !! Returns the temperature of the ice, which is assumed to be uniform. procedure ( get_residual ), deferred :: residual !! Computes the residual of the system of equations describing the !! glacier. procedure ( precond ), deferred :: precondition !! Applies a preconditioner to the passed state vector. procedure ( solve_vel ), deferred :: solve_velocity !! Solves for the velocity field using the current thickness. procedure ( setter ), deferred :: update !! Sets the state of the glacier. procedure ( time_setter ), deferred :: set_time !! Sets the time record for this glacier. procedure ( get_i ), deferred :: data_size !! Returns the number of elements in the glacier's state vector procedure ( get_r81d ), deferred :: state_vector !! Returns the glacier's state vector, a 1D array with all necessary !! data to describe its state. procedure ( read_dat ), deferred :: read_data !! Read the glacier data from an HDF5 file on the disc. procedure ( write_dat ), deferred :: write_data !! Writes the data describing the glacier to the disc as an HDF5 file. procedure ( t_step ), deferred :: time_step !! Calculates the appropriate time step for integration. procedure ( assign_ice ), private , deferred :: assign !! Copies the data from one glacier into another. This is only !! needed due to a bug in gfortran which means that the !! intrinsic assignment for glacier types is not using the !! appropriate defined assignment for the field components. generic :: assignment ( = ) => assign procedure :: integrate => glacier_integrate !! Performs a time-step of the integration, taking the state of !! the glacier to the specified time using the provided !! melt-rate data. procedure :: integrate_layers => glacier_integrate_layers !! Dummy routine which can be over-ridden to integrate internal !! layers of the glacier to the specified time. end type glacier"},{"title":"plume_shape – ISOFT ","tags":"","loc":"type/plume_shape.html","text":"type, public :: plume_shape A type containing the data necessary to specify the transverse\n shape of the plume. All variables in the plume are assumed to be\n seperable with the form D(x,y) = f_D2(y)\\hat{D}(x) , U(x,y)\n = f_U2(y)\\hat{U}(x) , etc. The magnitude of the velocity does\n not necessary take the form |\\vec{U}| = \\sqrt{U&#94;2 + V&#94;2} and\n is treated as an independent seperable variable |\\vec{U}| =\n f_{|\\vec{U}|}(y)\\widehat{|\\vec{U}|}(x) . The transverse\n functions f_{D}(y) , f_U2(y) , etc. have all been\n normalised over the integration width y_1 to y_2 . Note that a number of variables are definied using the\n averaging operator \\overline{A} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} A(y) dy. Inherited by type~~plume_shape~~InheritedByGraph type~plume_shape plume_shape type~asym_plume asym_plume type~asym_plume->type~plume_shape shape Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables f_D1 f_D2 f_U1 f_U2 f_V1 f_V2 f_S1 f_S2 f_T1 f_T2 f_Up f_Vp f_Sp f_Tp a_DU a_DV a_DU2 a_DUV a_D2 a_UabsU a_UabsV a_DUS a_DUT a_UabsT a_DS a_DT a_DS_t a_DT_t Source Code plume_shape Components Type Visibility Attributes Name Initial real(kind=r8), public :: f_D1 = 1.0_r8 f_D2(y_1) real(kind=r8), public :: f_D2 = 1.0_r8 f_D2(y_2) real(kind=r8), public :: f_U1 = 1.0_r8 f_U2(y_1) real(kind=r8), public :: f_U2 = 1.0_r8 f_U2(y_2) real(kind=r8), public :: f_V1 = 1.0_r8 f_V2(y_1) real(kind=r8), public :: f_V2 = 1.0_r8 f_V2(y_2) real(kind=r8), public :: f_S1 = 1.0_r8 f_S2(y_1) real(kind=r8), public :: f_S2 = 1.0_r8 f_S2(y_2) real(kind=r8), public :: f_T1 = 1.0_r8 f_T2(y_1) real(kind=r8), public :: f_T2 = 1.0_r8 f_T2(y_2) real(kind=r8), public :: f_Up = 0.0_r8 df_U2(y_2)/dy real(kind=r8), public :: f_Vp = 0.0_r8 df_V2(y_2)/dy real(kind=r8), public :: f_Sp = 0.0_r8 df_S2(y_2)/dy real(kind=r8), public :: f_Tp = 0.0_r8 df_T2(y_2)/dy real(kind=r8), public :: a_DU = 1.0_r8 \\alpha_{DU} = \\overline{f_D2 f_U2} real(kind=r8), public :: a_DV = 1.0_r8 \\alpha_{DV} = \\overline{f_D2 f_V2} real(kind=r8), public :: a_DU2 = 1.0_r8 \\alpha_{DU&#94;2} = \\overline{f_D2 f_U2&#94;2} real(kind=r8), public :: a_DUV = 1.0_r8 \\alpha_{DUV} = \\overline{f_D2 f_U2 f_V2} real(kind=r8), public :: a_D2 = 1.0_r8 \\alpha_{D&#94;2} = \\overline{f_D2&#94;2} real(kind=r8), public :: a_UabsU = 1.0_r8 \\alpha_{|\\vec{U}|U} = \\overline{f_{|\\vec{U}|} f_U2 real(kind=r8), public :: a_UabsV = 1.0_r8 \\alpha_{|\\vec{U}|V} = \\overline{f_{|\\vec{U}|} f_V2 real(kind=r8), public :: a_DUS = 1.0_r8 \\alpha_{DUS} = \\overline{f_D2 f_U2 f_S2} real(kind=r8), public :: a_DUT = 1.0_r8 \\alpha_{DUT} = \\overline{f_D2 f_U2 f_T2} real(kind=r8), public :: a_UabsT = 1.0_r8 \\alpha_{|\\vec{U}|T} = \\overline{f_{|\\vec{U}|} f_T2 real(kind=r8), public :: a_DS = 1.0_r8 \\alpha_{DS} = \\overline{f_D2 f_S2} real(kind=r8), public :: a_DT = 1.0_r8 \\alpha_{DT} = \\overline{f_D2 f_T2} real(kind=r8), public :: a_DS_t = 1.0_r8 \\tilde{\\alpha}_{DS} = \\overline{f_D2 f_S2}/\\alpha_{D&#94;2} real(kind=r8), public :: a_DT_t = 1.0_r8 \\tilde{\\alpha}_{DT} = \\overline{f_D2 f_T2}/\\alpha_{D&#94;2} Source Code type , public :: plume_shape !* Author: Christopher MacMackin !  Date: August 2018 ! ! A type containing the data necessary to specify the transverse ! shape of the plume. All variables in the plume are assumed to be ! seperable with the form D(x,y) = f_D2(y)\\hat{D}(x), U(x,y) ! = f_U2(y)\\hat{U}(x), etc. The magnitude of the velocity does ! not necessary take the form |\\vec{U}| = \\sqrt{U&#94;2 + V&#94;2} and ! is treated as an independent seperable variable |\\vec{U}| = ! f_{|\\vec{U}|}(y)\\widehat{|\\vec{U}|}(x). The transverse ! functions f_{D}(y), f_U2(y), etc. have all been ! normalised over the integration width y_1 to y_2. ! ! @Note that a number of variables are definied using the ! averaging operator  \\overline{A} = \\frac{1}{y_2 - y_1} ! \\int&#94;{y_2}_{y_1} A(y) dy.  ! real ( r8 ) :: f_D1 = 1.0_r8 !! f_D2(y_1) real ( r8 ) :: f_D2 = 1.0_r8 !! f_D2(y_2) real ( r8 ) :: f_U1 = 1.0_r8 !! f_U2(y_1) real ( r8 ) :: f_U2 = 1.0_r8 !! f_U2(y_2) real ( r8 ) :: f_V1 = 1.0_r8 !! f_V2(y_1) real ( r8 ) :: f_V2 = 1.0_r8 !! f_V2(y_2) real ( r8 ) :: f_S1 = 1.0_r8 !! f_S2(y_1) real ( r8 ) :: f_S2 = 1.0_r8 !! f_S2(y_2) real ( r8 ) :: f_T1 = 1.0_r8 !! f_T2(y_1) real ( r8 ) :: f_T2 = 1.0_r8 !! f_T2(y_2) real ( r8 ) :: f_Up = 0.0_r8 !! df_U2(y_2)/dy real ( r8 ) :: f_Vp = 0.0_r8 !! df_V2(y_2)/dy real ( r8 ) :: f_Sp = 0.0_r8 !! df_S2(y_2)/dy real ( r8 ) :: f_Tp = 0.0_r8 !! df_T2(y_2)/dy real ( r8 ) :: a_DU = 1.0_r8 !! \\alpha_{DU} = \\overline{f_D2 f_U2}  real ( r8 ) :: a_DV = 1.0_r8 !! \\alpha_{DV} = \\overline{f_D2 f_V2}  real ( r8 ) :: a_DU2 = 1.0_r8 !! \\alpha_{DU&#94;2} = \\overline{f_D2 f_U2&#94;2}  real ( r8 ) :: a_DUV = 1.0_r8 !! \\alpha_{DUV} = \\overline{f_D2 f_U2 f_V2}  real ( r8 ) :: a_D2 = 1.0_r8 !! \\alpha_{D&#94;2} = \\overline{f_D2&#94;2} real ( r8 ) :: a_UabsU = 1.0_r8 !! \\alpha_{|\\vec{U}|U} = \\overline{f_{|\\vec{U}|} f_U2 real ( r8 ) :: a_UabsV = 1.0_r8 !! \\alpha_{|\\vec{U}|V} = \\overline{f_{|\\vec{U}|} f_V2 real ( r8 ) :: a_DUS = 1.0_r8 !! \\alpha_{DUS} = \\overline{f_D2 f_U2 f_S2}  real ( r8 ) :: a_DUT = 1.0_r8 !! \\alpha_{DUT} = \\overline{f_D2 f_U2 f_T2}  real ( r8 ) :: a_UabsT = 1.0_r8 !! \\alpha_{|\\vec{U}|T} = \\overline{f_{|\\vec{U}|} f_T2 real ( r8 ) :: a_DS = 1.0_r8 !! \\alpha_{DS} = \\overline{f_D2 f_S2}  real ( r8 ) :: a_DT = 1.0_r8 !! \\alpha_{DT} = \\overline{f_D2 f_T2}  real ( r8 ) :: a_DS_t = 1.0_r8 !! \\tilde{\\alpha}_{DS} = \\overline{f_D2 f_S2}/\\alpha_{D&#94;2}  real ( r8 ) :: a_DT_t = 1.0_r8 !! \\tilde{\\alpha}_{DT} = \\overline{f_D2 f_T2}/\\alpha_{D&#94;2}  end type plume_shape"},{"title":"asym_plume – ISOFT ","tags":"","loc":"type/asym_plume.html","text":"type, public, extends( basal_surface ) :: asym_plume A concrete implementation of the basal_surface abstract data type, representing the buoyant plume beneath an\n ice shelf, which has been horizontally integrated over width \\Delta y = y_2 - y_1 in the y-direction. Transverse\n variation is assumed to be seperable, with variables having the\n form D(x,y) = f_D2(y)\\hat{D}(x) , U(x,y) =\n f_U2(y)\\hat{U}(x) . The shape of the transverse functions are\n described using the plume_shape type. Inherits type~~asym_plume~~InheritsGraph type~asym_plume asym_plume type~abstract_melt_relationship abstract_melt_relationship type~asym_plume->type~abstract_melt_relationship melt_formulation type~plume_shape plume_shape type~asym_plume->type~plume_shape shape type~ambient_conditions ambient_conditions type~asym_plume->type~ambient_conditions ambient_conds type~plume_boundary plume_boundary type~asym_plume->type~plume_boundary boundaries type~basal_surface basal_surface type~asym_plume->type~basal_surface type~coriolis_block coriolis_block type~asym_plume->type~coriolis_block vel_precond cheb1d_scalar_field cheb1d_scalar_field type~asym_plume->cheb1d_scalar_field thickness, temperature, temperature_dx, salinity, salinity_dx cheb1d_vector_field cheb1d_vector_field type~asym_plume->cheb1d_vector_field velocity, velocity_dx type~pseudospec_block pseudospec_block type~asym_plume->type~pseudospec_block precond type~abstract_entrainment abstract_entrainment type~asym_plume->type~abstract_entrainment entrainment_formulation type~equation_of_state equation_of_state type~asym_plume->type~equation_of_state eos type~coriolis_block->cheb1d_scalar_field emDxVinv_r, emDxVinv_i, eDx_r, eDx_i type~coriolis_block->type~pseudospec_block integrator var pantypeasym_plumeInheritsGraph = svgPanZoom('#typeasym_plumeInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thickness velocity velocity_dx temperature temperature_dx salinity salinity_dx entrainment_formulation melt_formulation ambient_conds eos boundaries delta nu mu r_val phi shape dy time thickness_size velocity_size temperature_size salinity_size vel_dims lower_bounds upper_bounds precond vel_precond Type-Bound Procedures initialise basal_melt basal_drag_parameter water_density update data_size state_vector read_data write_data solve Source Code asym_plume Components Type Visibility Attributes Name Initial type(cheb1d_scalar_field), private :: thickness The thickness of the plume type(cheb1d_vector_field), private :: velocity The velocity of the plume type(cheb1d_vector_field), private :: velocity_dx The derivative of the velocity field type(cheb1d_scalar_field), private :: temperature The temperature of the plume type(cheb1d_scalar_field), private :: temperature_dx The derivative of the temperature of the plume type(cheb1d_scalar_field), private :: salinity The salinity of the plume type(cheb1d_scalar_field), private :: salinity_dx The derivative of the salinity of the plume class( abstract_entrainment ), private, allocatable :: entrainment_formulation An object which provides the parameterisation for entrainment\n of water into the plume. class( abstract_melt_relationship ), private, allocatable :: melt_formulation An object which provides the parameterisation for melting,\n salt, and heat fluxes from the plume to the ice. class( ambient_conditions ), private, allocatable :: ambient_conds An object specifying the temperature and salinity of the\n ambient ocean at its interface with the plume. class( equation_of_state ), public, allocatable :: eos An object specifying the equation of state relating the plume\n water's density to its temperature and salinity. class( plume_boundary ), private, allocatable :: boundaries An object specifying the boundary conditions for the plume. real(kind=r8), private :: delta The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real(kind=r8), public :: nu The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real(kind=r8), private :: mu The dimensionless ratio \\mu \\equiv \\frac{\\C_dx_0}{D_0} real(kind=r8), private :: r_val The dimensionless ratio of the ocean water density to the\n density of the overlying ice shelf. real(kind=r8), public :: phi The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} type( plume_shape ), public :: shape The coefficients describing the transverse shape of the\n plume. real(kind=r8), private :: dy The width \\Delta y = y_2-y_1 over which the plume has\n been horizontally averaged. real(kind=r8), private :: time The time at which the ice shelf is in this state integer, private :: thickness_size The number of data values in the thickness field integer, private :: velocity_size The number of data values in the velocity field integer, private :: temperature_size The number of data values in the temperature field integer, private :: salinity_size the number of data values in the salinity field integer, private :: vel_dims The number of vector dimensions for the velocity logical, private, dimension(7) :: lower_bounds = .false. Which variables have boundary conditions at the grounding\n line. logical, private, dimension(7) :: upper_bounds = .false. Which variables have boundary conditions at the calving\n front. type( pseudospec_block ), private :: precond A pseudospectral differentiation block which can be used for\n preconditioning. type( coriolis_block ), private :: vel_precond A representation of the operation on the plume velocity terms\n which can be used for preconditioning. Type-Bound Procedures procedure, public :: initialise => asym_plume_initialise private subroutine asym_plume_initialise (this, domain, resolution, thickness, velocity, temperature, salinity, shape, entrainment_formulation, melt_formulation, ambient_conds, eos, boundaries, delta, nu, mu, r_val, phi, dy) Author Christopher MacMackin Date April 2016 Instantiates an asym_plume object with initial\n coniditions provided by the arguments.At present only a 1D model\n is supported. If information is provided for higher dimensions\n then it will be ignored. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(out) :: this A plume object with its domain and initial conditions set according\n to the arguments of the constructor function. real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the plume. The first index represents the dimension for which the\n boundaries apply. If the second index is 1 then it corresponds to\n the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( scalar_func ) :: thickness A function which calculates the initial value of the thickness of \n the plume at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the water at a given location in a plume. procedure( scalar_func ) :: temperature A function which calculates the initial value of the temperature of \n the plume at a given location. procedure( scalar_func ) :: salinity A function which calculates the initial value of the salinity of \n the plume at a given location. type( plume_shape ), intent(in), optional :: shape An object with components describing the transverse profile\n of the plume. Default is a plume that is uniform in the\n transverse direction. class( abstract_entrainment ), intent(inout), optional allocatable :: entrainment_formulation An object which calculates entrainment into the plume. Will\n be unallocated on exit. Defaults to that used by Jenkins\n (1991) with the coefficient $E_0 = 1$. class( abstract_melt_relationship ), intent(inout), optional allocatable :: melt_formulation An object which calculates melting and the resulting thermal\n transfer into/out of the plume. Will be unallocated on\n exit. Defaults to that used by Dallaston et al. (2015),\n scaled to be consistent with the nondimensionalisation used\n here. class( ambient_conditions ), intent(inout), optional allocatable :: ambient_conds An object specifying the salinity and temperature of the\n ambient ocean. Will be unallocated on exit. Defaults to\n uniform ambient salinity and temperature, both of which are\n set to 0 (as temperature and salinity are measured relative\n to some reference value). class( equation_of_state ), intent(inout), optional allocatable :: eos An object specifying the equation of state for the water in\n the plume. Will be unallocated on exit. Defaults to\n linearised equation of state with no temperature dependence\n and a haline contraction coefficient of 1. The reference\n density is set to be 1 in the dimensionless units when\n salinity and temeprature are 0. class( plume_boundary ), intent(inout), optional allocatable :: boundaries An object providing the boundary conditions for the\n plume. Will be unallocated on exit. Defaults to those used by\n Dallaston et al. (2015). real(kind=r8), intent(in), optional :: delta The dimensionless ratio \\delta \\equiv\n \\frac{D_0}{h_0} . Defaults to 0.036. real(kind=r8), intent(in), optional :: nu The dimensionless ratio \\nu \\equiv\n \\frac{\\kappa_0}{x_0U_o} . Defaults to 0. real(kind=r8), intent(in), optional :: mu The dimensionless ratio \\mu \\equiv\n \\frac{C_dx_0}{D_0} . Defaults to 0. real(kind=r8), intent(in), optional :: r_val The dimensionless ratio of the water density to the ice shelf\n density, r = \\rho_0/\\rho_i. Defaults to 1.12. real(kind=r8), intent(in), optional :: phi The inverse Rossby number, \\Phi \\equiv\n \\frac{fx_0}{U_0} . Defaults to 0. real(kind=r8), intent(in), optional :: dy The width over which the plume has been averaged. Defualts to 1. procedure, public :: basal_melt => asym_plume_melt private function asym_plume_melt (this) result(melt) Author Christopher MacMackin Date April 2016 Computes and returns the melt rate at the bottom of the ice\n shelf due to interaction with the plume. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice shelf. procedure, public :: basal_drag_parameter => asym_plume_drag_parameter private function asym_plume_drag_parameter (this) result(drag) Author Christopher MacMackin Date April 2016 Computes and returns a quantity which may be necessary to determine\n the frictional drag the plume exerts on the bottom of the ice\n shelf. The plume would actually tend to exert no drag on the bottom\n of the ice shelf, but this method is present so that there is a\n consistent interface with the ground data type. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. procedure, public :: water_density => asym_plume_water_density private function asym_plume_water_density (this) result(density) Author Christopher MacMackin Date April 2016 Computes and returns the density of the plume water beneath the ice\n shelf. The density of this water would vary depending on how much \n saline ambient water has been entrained into the plume versus how\n much fresh water has been released due to melting. However, the\n Boussinesq approximation is used here and only a single reference \n density is returned. Read more… Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value real(kind=r8) The density of the water at the base of the ice sheet. procedure, public :: update => asym_plume_update private subroutine asym_plume_update (this, state_vector, ice_thickness) Author Christopher MacMackin Date April 2016 Updates the state of the plume from its state vector. The state\n vector is a real array containing the value of each of the plume's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n plume. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate. procedure, public :: data_size => asym_plume_data_size private function asym_plume_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the plume's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value integer The number of elements in the plume's state vector. procedure, public :: state_vector => asym_plume_state_vector private function asym_plume_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the plume. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the plume. procedure, public :: read_data => asym_plume_read_data private subroutine asym_plume_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the plume object from an HDF file in the\n specified group. This sets the thickness, velocity, temperature,\n salinity dataset, and parameter values. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: write_data => asym_plume_write_data private subroutine asym_plume_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the plume object to an HDF file in the\n specified group. This will consist of a thickness, a velocity, a\n temperature, and a salinity dataset. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: solve => asym_plume_solve private subroutine asym_plume_solve (this, ice_thickness, ice_density, ice_temperature, time, success) Author Chris MacMackin Date March 2017 Solves the state of the plume for the specified ice properties,\n at the specified time. This is done using the a\n quasilinearisation method and a GMRES iterative linear solver. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise Source Code type , extends ( basal_surface ), public :: asym_plume !* Author: Christopher MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[basal_surface(type)]] ! abstract data type, representing the buoyant plume beneath an ! ice shelf, which has been horizontally integrated over width ! \\Delta y = y_2 - y_1 in the y-direction. Transverse ! variation is assumed to be seperable, with variables having the ! form D(x,y) = f_D2(y)\\hat{D}(x), U(x,y) = ! f_U2(y)\\hat{U}(x). The shape of the transverse functions are ! described using the [[plume_shape(type)]] type. ! private type ( cheb1d_scalar_field ) :: thickness !! The thickness of the plume type ( cheb1d_vector_field ) :: velocity !! The velocity of the plume type ( cheb1d_vector_field ) :: velocity_dx !! The derivative of the velocity field type ( cheb1d_scalar_field ) :: temperature !! The temperature of the plume type ( cheb1d_scalar_field ) :: temperature_dx !! The derivative of the temperature of the plume type ( cheb1d_scalar_field ) :: salinity !! The salinity of the plume type ( cheb1d_scalar_field ) :: salinity_dx !! The derivative of the salinity of the plume class ( abstract_entrainment ), allocatable :: entrainment_formulation !! An object which provides the parameterisation for entrainment !! of water into the plume. class ( abstract_melt_relationship ), allocatable :: melt_formulation !! An object which provides the parameterisation for melting, !! salt, and heat fluxes from the plume to the ice. class ( ambient_conditions ), allocatable :: ambient_conds !! An object specifying the temperature and salinity of the !! ambient ocean at its interface with the plume. class ( equation_of_state ), allocatable , public :: eos !! An object specifying the equation of state relating the plume !! water's density to its temperature and salinity. class ( plume_boundary ), allocatable :: boundaries !! An object specifying the boundary conditions for the plume. real ( r8 ) :: delta !! The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real ( r8 ), public :: nu !! The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real ( r8 ) :: mu !! The dimensionless ratio \\mu \\equiv \\frac{\\C_dx_0}{D_0} real ( r8 ) :: r_val !! The dimensionless ratio of the ocean water density to the !! density of the overlying ice shelf. real ( r8 ), public :: phi !! The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} type ( plume_shape ), public :: shape !! The coefficients describing the transverse shape of the !! plume. real ( r8 ) :: dy !! The width \\Delta y = y_2-y_1 over which the plume has !! been horizontally averaged. real ( r8 ) :: time !! The time at which the ice shelf is in this state integer :: thickness_size !! The number of data values in the thickness field integer :: velocity_size !! The number of data values in the velocity field integer :: temperature_size !! The number of data values in the temperature field integer :: salinity_size !! the number of data values in the salinity field integer :: vel_dims !! The number of vector dimensions for the velocity logical , dimension ( 7 ) :: lower_bounds = . false . !! Which variables have boundary conditions at the grounding !! line. logical , dimension ( 7 ) :: upper_bounds = . false . !! Which variables have boundary conditions at the calving !! front. type ( pseudospec_block ) :: precond !! A pseudospectral differentiation block which can be used for !! preconditioning. type ( coriolis_block ) :: vel_precond !! A representation of the operation on the plume velocity terms !! which can be used for preconditioning. contains procedure :: initialise => asym_plume_initialise procedure :: basal_melt => asym_plume_melt procedure :: basal_drag_parameter => asym_plume_drag_parameter procedure :: water_density => asym_plume_water_density procedure :: update => asym_plume_update procedure :: data_size => asym_plume_data_size procedure :: state_vector => asym_plume_state_vector procedure :: read_data => asym_plume_read_data procedure :: write_data => asym_plume_write_data procedure :: solve => asym_plume_solve end type asym_plume"},{"title":"ambient_conditions – ISOFT ","tags":"","loc":"type/ambient_conditions.html","text":"type, public, abstract :: ambient_conditions An abstract type to which procedures for getting the ambient ocean\n conditions are to be specified. The descendent types can contain\n whatever data is needed to compute the result. Inherited by type~~ambient_conditions~~InheritedByGraph type~ambient_conditions ambient_conditions type~plume plume type~plume->type~ambient_conditions ambient_conds type~static_plume static_plume type~static_plume->type~ambient_conditions ambient_conds type~uniform_ambient_conditions uniform_ambient_conditions type~uniform_ambient_conditions->type~ambient_conditions type~asym_plume asym_plume type~asym_plume->type~ambient_conditions ambient_conds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures ambient_temperature ambient_salinity Source Code ambient_conditions Type-Bound Procedures procedure( get_property ), public, deferred :: ambient_temperature Returns the ambient ocean temperature function get_property(this, depth, t) result(property) Prototype Arguments Type Intent Optional Attributes Name class( ambient_conditions ), intent(in) :: this class(scalar_field), intent(in) :: depth A field containing the depths at which the ambient conditions\n are to be calculated. real(kind=r8), intent(in) :: t The time at which the ambient conditions are to be calculated. Return Value class(scalar_field),\n  pointer A field containing the ambient conditions at the depth specified\n for each location. procedure( get_property ), public, deferred :: ambient_salinity Returns the ambient ocean temperature function get_property(this, depth, t) result(property) Prototype Arguments Type Intent Optional Attributes Name class( ambient_conditions ), intent(in) :: this class(scalar_field), intent(in) :: depth A field containing the depths at which the ambient conditions\n are to be calculated. real(kind=r8), intent(in) :: t The time at which the ambient conditions are to be calculated. Return Value class(scalar_field),\n  pointer A field containing the ambient conditions at the depth specified\n for each location. Source Code type , abstract , public :: ambient_conditions !* Author: Chris MacMackin !  Date: April 2016 ! ! An abstract type to which procedures for getting the ambient ocean ! conditions are to be specified. The descendent types can contain ! whatever data is needed to compute the result. ! contains procedure ( get_property ), deferred :: ambient_temperature !! Returns the ambient ocean temperature procedure ( get_property ), deferred :: ambient_salinity !! Returns the ambient ocean temperature end type ambient_conditions"},{"title":"linear_eos – ISOFT ","tags":"","loc":"type/linear_eos.html","text":"type, public, extends( equation_of_state ) :: linear_eos A linearised implementation of the equation of state, of the\n form \\rho = \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)]. Inherits type~~linear_eos~~InheritsGraph type~linear_eos linear_eos type~equation_of_state equation_of_state type~linear_eos->type~equation_of_state Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables ref_rho ref_t ref_s beta_t beta_s Constructor linear_eos Type-Bound Procedures water_density water_density_derivative haline_contraction thermal_contraction Source Code linear_eos Components Type Visibility Attributes Name Initial real(kind=r8), private :: ref_rho = 1.0_r8 The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), private :: ref_t = 0.0_r8 The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), private :: ref_s = 0.0_r8 The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), private :: beta_t = 0.0_r8 The thermal contraction coefficient, \\beta_T . real(kind=r8), private :: beta_s = 1.0_r8 The haline contraction coefficient, \\beta_S . Constructor public interface linear_eos private pure function constructor (ref_rho, ref_t, ref_s, beta_t, beta_s) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: ref_rho The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), intent(in) :: ref_t The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), intent(in) :: ref_s The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), intent(in) :: beta_t The thermal contraction coefficient, \\beta_T . real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S . Return Value type( linear_eos ) Type-Bound Procedures procedure, public :: water_density => linear_water_density private function linear_water_density (this, temperature, salinity) result(density) Author Chris MacMackin Date November 2016 Calculates the density of the water from the temperature and\n salinity, using a linear equatino of state, \\rho =\n \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)]. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water procedure, public :: water_density_derivative => linear_water_deriv private function linear_water_deriv (this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Author Chris MacMackin Date November 2016 Calculates the derivative of the water density from the\n temperature and salinity, using a linear equatino of state, \\rho = \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)]. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the density of the water procedure, public :: haline_contraction => linear_haline_contraction private function linear_haline_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date June 2017 Returns the haline contraction coefficient. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable procedure, public :: thermal_contraction => linear_thermal_contraction private function linear_thermal_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date June 2017 Returns the thermal contraction coefficient. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Source Code type , extends ( equation_of_state ), public :: linear_eos !* Author: Chris MacMackin !  Date: April 2016 ! ! A linearised implementation of the equation of state, of the ! form  \\rho = \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)].  ! private real ( r8 ) :: ref_rho = 1.0_r8 !! The density for the temperature and salinity about which the !! equation of state was linearised, \\rho_0. real ( r8 ) :: ref_t = 0.0_r8 !! The temperature about which the equation of state was !! linearised, T_0. real ( r8 ) :: ref_s = 0.0_r8 !! The salinity about which the equation of state was !! linearised, S_0. real ( r8 ) :: beta_t = 0.0_r8 !! The thermal contraction coefficient, \\beta_T. real ( r8 ) :: beta_s = 1.0_r8 !! The haline contraction coefficient, \\beta_S. contains procedure :: water_density => linear_water_density procedure :: water_density_derivative => linear_water_deriv procedure :: haline_contraction => linear_haline_contraction procedure :: thermal_contraction => linear_thermal_contraction end type linear_eos"},{"title":"static_plume – ISOFT ","tags":"","loc":"type/static_plume.html","text":"type, public, extends( basal_surface ) :: static_plume A concrete implementation of the basal_surface abstract data type, representing the buoyant plume beneath an\n ice shelf, but unchanging in time. It keeps the values assigned\n at creation or with the write_data method. It\n is useful if you want to uncouple the ice shelf from the plume. Inherits type~~static_plume~~InheritsGraph type~static_plume static_plume type~abstract_melt_relationship abstract_melt_relationship type~static_plume->type~abstract_melt_relationship melt_formulation type~basal_surface basal_surface type~static_plume->type~basal_surface type~ambient_conditions ambient_conditions type~static_plume->type~ambient_conditions ambient_conds type~plume_boundary plume_boundary type~static_plume->type~plume_boundary boundaries cheb1d_scalar_field cheb1d_scalar_field type~static_plume->cheb1d_scalar_field thickness, temperature, temperature_dx, salinity, salinity_dx cheb1d_vector_field cheb1d_vector_field type~static_plume->cheb1d_vector_field velocity, velocity_dx type~pseudospec_block pseudospec_block type~static_plume->type~pseudospec_block precond type~abstract_entrainment abstract_entrainment type~static_plume->type~abstract_entrainment entrainment_formulation type~equation_of_state equation_of_state type~static_plume->type~equation_of_state eos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thickness velocity velocity_dx temperature temperature_dx salinity salinity_dx entrainment_formulation melt_formulation ambient_conds eos boundaries delta nu mu r_val phi time thickness_size velocity_size temperature_size salinity_size lower_bounds upper_bounds precond Type-Bound Procedures initialise basal_melt basal_drag_parameter water_density update data_size state_vector read_data write_data solve Source Code static_plume Components Type Visibility Attributes Name Initial type(cheb1d_scalar_field), private :: thickness The thickness of the plume type(cheb1d_vector_field), private :: velocity The velocity of the plume type(cheb1d_vector_field), private :: velocity_dx The derivative of the velocity field type(cheb1d_scalar_field), private :: temperature The temperature of the plume type(cheb1d_scalar_field), private :: temperature_dx The derivative of the temperature of the plume type(cheb1d_scalar_field), private :: salinity The salinity of the plume type(cheb1d_scalar_field), private :: salinity_dx The derivative of the salinity of the plume class( abstract_entrainment ), private, allocatable :: entrainment_formulation An object which provides the parameterisation for entrainment\n of water into the plume. class( abstract_melt_relationship ), private, allocatable :: melt_formulation An object which provides the parameterisation for melting,\n salt, and heat fluxes from the plume to the ice. class( ambient_conditions ), private, allocatable :: ambient_conds An object specifying the temperature and salinity of the\n ambient ocean at its interface with the plume. class( equation_of_state ), public, allocatable :: eos An object specifying the equation of state relating the plume\n water's density to its temperature and salinity. class( plume_boundary ), private, allocatable :: boundaries An object specifying the boundary conditions for the plume. real(kind=r8), private :: delta The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real(kind=r8), public :: nu The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real(kind=r8), private :: mu The dimensionless ratio \\mu \\equiv \\frac{C_dx_0}{D_0} real(kind=r8), private :: r_val The dimensionless ratio of the ocean water density to the\n density of the overlying ice shelf. real(kind=r8), public :: phi The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} real(kind=r8), private :: time The time at which the ice shelf is in this state integer, private :: thickness_size The number of data values in the thickness field integer, private :: velocity_size The number of data values in the velocity field integer, private :: temperature_size The number of data values in the temperature field integer, private :: salinity_size the number of data values in the salinity field logical, private, dimension(7) :: lower_bounds = .false. Which variables have boundary conditions at the grounding\n line. logical, private, dimension(7) :: upper_bounds = .false. Which variables have boundary conditions at the calving\n front. type( pseudospec_block ), private :: precond A pseudospectral differentiation block which can be used for\n preconditioning. Type-Bound Procedures procedure, public :: initialise => static_plume_initialise private subroutine static_plume_initialise (this, domain, resolution, thickness, velocity, temperature, salinity, entrainment_formulation, melt_formulation, ambient_conds, eos, boundaries, delta, nu, mu, r_val, phi) Author Christopher MacMackin Date April 2016 Instantiates a plume object with initial coniditions\n provided by the arguments.At present only a 1D model is\n supported. If information is provided for higher dimensions then\n it will be ignored. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(out) :: this A plume object with its domain and initial conditions set according\n to the arguments of the constructor function. real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the plume. The first index represents the dimension for which the\n boundaries apply. If the second index is 1 then it corresponds to\n the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( scalar_func ) :: thickness A function which calculates the initial value of the thickness of \n the plume at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the water at a given location in a plume. procedure( scalar_func ) :: temperature A function which calculates the initial value of the temperature of \n the plume at a given location. procedure( scalar_func ) :: salinity A function which calculates the initial value of the salinity of \n the plume at a given location. class( abstract_entrainment ), intent(inout), optional allocatable :: entrainment_formulation An object which calculates entrainment into the plume. Will\n be unallocated on exit. Defaults to that used by Jenkins\n (1991) with the coefficient $E_0 = 1$. class( abstract_melt_relationship ), intent(inout), optional allocatable :: melt_formulation An object which calculates melting and the resulting thermal\n transfer into/out of the plume. Will be unallocated on\n exit. Defaults to that used by Dallaston et al. (2015),\n scaled to be consistent with the nondimensionalisation used\n here. class( ambient_conditions ), intent(inout), optional allocatable :: ambient_conds An object specifying the salinity and temperature of the\n ambient ocean. Will be unallocated on exit. Defaults to\n uniform ambient salinity and temperature, both of which are\n set to 0 (as temperature and salinity are measured relative\n to some reference value). class( equation_of_state ), intent(inout), optional allocatable :: eos An object specifying the equation of state for the water in\n the plume. Will be unallocated on exit. Defaults to\n linearised equation of state with no temperature dependence\n and a haline contraction coefficient of 1. The reference\n density is set to be 1 in the dimensionless units when\n salinity and temeprature are 0. class( plume_boundary ), intent(inout), optional allocatable :: boundaries An object providing the boundary conditions for the\n plume. Will be unallocated on exit. Defaults to those used by\n Dallaston et al. (2015). real(kind=r8), intent(in), optional :: delta The dimensionless ratio \\delta \\equiv\n \\frac{D_0}{h_0} . Defaults to 0.036. real(kind=r8), intent(in), optional :: nu The dimensionless ratio \\nu \\equiv\n \\frac{\\kappa_0}{x_0U_o} . Defaults to 0. real(kind=r8), intent(in), optional :: mu The dimensionless ratio \\mu \\equiv\n \\frac{\\C_dx_0}{D_0} . Defaults to 0. real(kind=r8), intent(in), optional :: r_val The dimensionless ratio of the water density to the ice shelf\n density, r = \\rho_0/\\rho_i. Defaults to 1.12. real(kind=r8), intent(in), optional :: phi The inverse Rossby number, \\Phi \\equif\n \\frac{fx_0}{U_0} . Defaults to 0. procedure, public :: basal_melt => static_plume_melt private function static_plume_melt (this) result(melt) Author Christopher MacMackin Date April 2016 Computes and returns the melt rate at the bottom of the ice\n shelf due to interaction with the plume. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice shelf. procedure, public :: basal_drag_parameter => static_plume_drag_parameter private function static_plume_drag_parameter (this) result(drag) Author Christopher MacMackin Date April 2016 Computes and returns a quantity which may be necessary to determine\n the frictional drag the plume exerts on the bottom of the ice\n shelf. The plume would actually tend to exert no drag on the bottom\n of the ice shelf, but this method is present so that there is a\n consistent interface with the ground data type. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. procedure, public :: water_density => static_plume_water_density private function static_plume_water_density (this) result(density) Author Christopher MacMackin Date April 2016 Computes and returns the density of the plume water beneath the ice\n shelf. The density of this water would vary depending on how much \n saline ambient water has been entrained into the plume versus how\n much fresh water has been released due to melting. However, the\n Boussinesq approximation is used here and only a single reference \n density is returned. Read more… Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value real(kind=r8) The density of the water at the base of the ice sheet. procedure, public :: update => static_plume_update private subroutine static_plume_update (this, state_vector, ice_thickness) Author Christopher MacMackin Date April 2016 Updates the state of the plume from its state vector. The state\n vector is a real array containing the value of each of the plume's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n plume. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate. procedure, public :: data_size => static_plume_data_size private function static_plume_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the plume's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value integer The number of elements in the plume's state vector. procedure, public :: state_vector => static_plume_state_vector private function static_plume_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the plume. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the plume. procedure, public :: read_data => static_plume_read_data private subroutine static_plume_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the plume object from an HDF file in the\n specified group. This sets the thickness, velocity, temperature,\n salinity dataset, and parameter values. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: write_data => static_plume_write_data private subroutine static_plume_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the plume object to an HDF file in the\n specified group. This will consist of a thickness, a velocity, a\n temperature, and a salinity dataset. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: solve => static_plume_solve private subroutine static_plume_solve (this, ice_thickness, ice_density, ice_temperature, time, success) Author Chris MacMackin Date March 2017 Would normally solve, but for this static implementation of the\n plume it does nothing. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise Source Code type , extends ( basal_surface ), public :: static_plume !* Author: Christopher MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[basal_surface(type)]] ! abstract data type, representing the buoyant plume beneath an ! ice shelf, but unchanging in time. It keeps the values assigned ! at creation or with the [[static_plume:write_data]] method. It ! is useful if you want to uncouple the ice shelf from the plume. ! private type ( cheb1d_scalar_field ) :: thickness !! The thickness of the plume type ( cheb1d_vector_field ) :: velocity !! The velocity of the plume type ( cheb1d_vector_field ) :: velocity_dx !! The derivative of the velocity field type ( cheb1d_scalar_field ) :: temperature !! The temperature of the plume type ( cheb1d_scalar_field ) :: temperature_dx !! The derivative of the temperature of the plume type ( cheb1d_scalar_field ) :: salinity !! The salinity of the plume type ( cheb1d_scalar_field ) :: salinity_dx !! The derivative of the salinity of the plume class ( abstract_entrainment ), allocatable :: entrainment_formulation !! An object which provides the parameterisation for entrainment !! of water into the plume. class ( abstract_melt_relationship ), allocatable :: melt_formulation !! An object which provides the parameterisation for melting, !! salt, and heat fluxes from the plume to the ice. class ( ambient_conditions ), allocatable :: ambient_conds !! An object specifying the temperature and salinity of the !! ambient ocean at its interface with the plume. class ( equation_of_state ), allocatable , public :: eos !! An object specifying the equation of state relating the plume !! water's density to its temperature and salinity. class ( plume_boundary ), allocatable :: boundaries !! An object specifying the boundary conditions for the plume. real ( r8 ) :: delta !! The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real ( r8 ), public :: nu !! The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real ( r8 ) :: mu !! The dimensionless ratio \\mu \\equiv \\frac{C_dx_0}{D_0} real ( r8 ) :: r_val !! The dimensionless ratio of the ocean water density to the !! density of the overlying ice shelf. real ( r8 ), public :: phi !! The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} real ( r8 ) :: time !! The time at which the ice shelf is in this state integer :: thickness_size !! The number of data values in the thickness field integer :: velocity_size !! The number of data values in the velocity field integer :: temperature_size !! The number of data values in the temperature field integer :: salinity_size !! the number of data values in the salinity field logical , dimension ( 7 ) :: lower_bounds = . false . !! Which variables have boundary conditions at the grounding !! line. logical , dimension ( 7 ) :: upper_bounds = . false . !! Which variables have boundary conditions at the calving !! front. type ( pseudospec_block ) :: precond !! A pseudospectral differentiation block which can be used for !! preconditioning. contains procedure :: initialise => static_plume_initialise procedure :: basal_melt => static_plume_melt procedure :: basal_drag_parameter => static_plume_drag_parameter procedure :: water_density => static_plume_water_density procedure :: update => static_plume_update procedure :: data_size => static_plume_data_size procedure :: state_vector => static_plume_state_vector procedure :: read_data => static_plume_read_data procedure :: write_data => static_plume_write_data procedure :: solve => static_plume_solve end type static_plume"},{"title":"cryosphere – ISOFT ","tags":"","loc":"type/cryosphere.html","text":"type, public :: cryosphere A data structure representing glaciers, either as ice shelves or\n (eventually) ice sheets. It will allow coupled systems of\n glaciers as well as different basal couplings with the ocean or\n ground. This type is a subclass of the FOODIE integrand ,\n allowing it to take advantage of that set of integration\n libraries for evolution in time. Inherits type~~cryosphere~~InheritsGraph type~cryosphere cryosphere type~glacier glacier type~cryosphere->type~glacier ice type~basal_surface basal_surface type~cryosphere->type~basal_surface sub_ice Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables ice sub_ice time first_integration dt_factor min_dt_factor performing_time_step Type-Bound Procedures initialise time_step reduce_time_step increase_time_step state_vector integrate read_data read_ice read_sub_ice write_data get_time Source Code cryosphere Components Type Visibility Attributes Name Initial class( glacier ), private, allocatable :: ice A model for the ice shelf or ice sheet class( basal_surface ), private, allocatable :: sub_ice A model for the ground or ocean underneath the ice real(kind=r8), private :: time The time in the simulation logical, private :: first_integration Indicates whether the cryosphere has been integrated before\n or not. real(kind=r8), private :: dt_factor = 1.0_r8 A factor by which to reduce the time step real(kind=r8), private :: min_dt_factor = 1e-3_r8 The smallest time step reduction to allow logical, private :: performing_time_step True if in the process of trying to get a time-step to\n successfully integrate. Type-Bound Procedures procedure, public :: initialise private subroutine initialise (this, ice, sub_ice) Author Christopher MacMackin Date November 2016 Initialise a cryosphere object from the provided\n components. This object will model the evolution of a\n glacier/ice shelf/ice sheet and its surroundings. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(out) :: this class( glacier ), intent(inout), allocatable :: ice An object modelling the ice sheet or shelf component of this\n system. Will be deallocated on return. class( basal_surface ), intent(inout), allocatable :: sub_ice An object modelling the component of this system beneath the\n ice. Will be deallocated on return. procedure, public :: time_step private function time_step (this) Author Chris MacMackin Date December 2016 Calculates an appropriate time step with which to integrate the\n cryosphere so as not to cause numerical instability. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this Return Value real(kind=r8) procedure, public :: reduce_time_step private subroutine reduce_time_step (this) Author Christopher MacMackin Date April 2017 Reuces the time step by a factor of 2, unless doing so would\n take it below the minimum value. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this procedure, public :: increase_time_step private subroutine increase_time_step (this) Author Christopher MacMackin Date April 2017 Increases the time step by a factor of 2, unless doing so would\n take it above the maximum. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this procedure, public :: state_vector private function state_vector (this) Author Chris MacMackin Date April 2017 Returns the state vector for the current state of the\n cryosphere. This takes the form of a 1D array. This routine is\n mainly useful for unit-testing. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable procedure, public :: integrate private subroutine integrate (this, time) Author Christopher MacMackin Date April 2016 Integrates the cryosphere forward until the specified time is\n reached. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this real(kind=r8), intent(in) :: time The time to which to integrate the cryosphere procedure, public :: read_data private subroutine read_data (this, infile, set_time) Author Christopher MacMackin Date April 2017 Reads the data describing the cryosphere from an HDF5 file on\n the disc. h5open_f must have been called once prior to using\n this method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this character(len=*), intent(in) :: infile The file from which to read the data describing the state of the \n cryosphere logical, intent(in), optional :: set_time If present and .true. then set the simulation time of the\n cryosphere to be the same as that in the HDF file. Otherwise,\n leave it unchanged. procedure, public :: read_ice private subroutine read_ice (this, infile, set_time) Author Christopher MacMackin Date December 2017 Reads the data describing the ice component of the cryosphere\n from an HDF5 file on the disc. Data on anything below the ice is\n ignored. h5open_f must have been called once prior to using\n this method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this character(len=*), intent(in) :: infile The file from which to read the data describing the state of the \n cryosphere logical, intent(in), optional :: set_time If present and .true. then set the simulation time of the\n cryosphere to be the same as that in the HDF file. Otherwise,\n leave it unchanged. procedure, public :: read_sub_ice private subroutine read_sub_ice (this, infile, set_time) Author Christopher MacMackin Date April 2017 Reads the data describing the part of the cryosphere beneath the\n ice from an HDF5 file on the disc. Data on the ice itself is\n ignored. h5open_f must have been called once prior to using\n this method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this character(len=*), intent(in) :: infile The file from which to read the data describing the state of the \n cryosphere logical, intent(in), optional :: set_time If present and .true. then set the simulation time of the\n cryosphere to be the same as that in the HDF file. Otherwise,\n leave it unchanged. procedure, public :: write_data private subroutine write_data (this, outfile) Author Christopher MacMackin Date April 2016 Writes the data describing the cryosphere to the disc as an HDF5\n file. h5open_f must have been called once prior to using this\n method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(in) :: this character(len=*), intent(in) :: outfile The file to which to write the data describing the state of the \n cryosphere procedure, public :: get_time private pure function get_time (this) Author Chris MacMackin Date April 2017 Returns the current time of the cryosphere system. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(in) :: this Return Value real(kind=r8) Source Code type , public :: cryosphere !* Author: Christopher MacMackin !  Date: April 2016 ! ! A data structure representing glaciers, either as ice shelves or ! (eventually) ice sheets. It will allow coupled systems of ! glaciers as well as different basal couplings with the ocean or ! ground. This type is a subclass of the ! [FOODIE](https://github.com/Fortran-FOSS-Programmers/FOODIE) ! [integrand](http://fortran-foss-programmers.github.io/FOODIE/type/integrand.html), ! allowing it to take advantage of that set of integration ! libraries for evolution in time. ! private class ( glacier ), allocatable :: ice !! A model for the ice shelf or ice sheet class ( basal_surface ), allocatable :: sub_ice !! A model for the ground or ocean underneath the ice real ( r8 ) :: time !! The time in the simulation logical :: first_integration !! Indicates whether the cryosphere has been integrated before !! or not. real ( r8 ) :: dt_factor = 1.0_r8 !! A factor by which to reduce the time step real ( r8 ) :: min_dt_factor = 1 e - 3_r8 !! The smallest time step reduction to allow logical :: performing_time_step !! True if in the process of trying to get a time-step to !! successfully integrate. contains procedure :: initialise procedure :: time_step procedure :: reduce_time_step procedure :: increase_time_step procedure :: state_vector procedure :: integrate procedure :: read_data procedure :: read_ice procedure :: read_sub_ice procedure :: write_data procedure :: get_time end type cryosphere"},{"title":"abstract_melt_relationship – ISOFT ","tags":"","loc":"type/abstract_melt_relationship.html","text":"type, public, abstract :: abstract_melt_relationship An abstract data type for calculating melting of an ice shelf into\n a vertically integrated plume . The melt rate, as well as\n effect on termperature and salinity, are calculated by calling solve_for_melt and then accessed\n using melt_rate , heat_equation_terms , salt_equation_terms . Inherited by type~~abstract_melt_relationship~~InheritedByGraph type~abstract_melt_relationship abstract_melt_relationship type~asym_plume asym_plume type~asym_plume->type~abstract_melt_relationship melt_formulation type~ave_one_equation_melt ave_one_equation_melt type~ave_one_equation_melt->type~abstract_melt_relationship type~one_equation_melt one_equation_melt type~one_equation_melt->type~abstract_melt_relationship type~dallaston2015_melt dallaston2015_melt type~dallaston2015_melt->type~abstract_melt_relationship type~static_plume static_plume type~static_plume->type~abstract_melt_relationship melt_formulation type~plume plume type~plume->type~abstract_melt_relationship melt_formulation Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures solve_for_melt salt_equation_terms heat_equation_terms melt_rate has_heat_terms has_salt_terms Source Code abstract_melt_relationship Type-Bound Procedures procedure( solve ), public, deferred :: solve_for_melt subroutine solve(this, velocity, pressure, temperature, salinity, plume_thickness, time) Prototype Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed. procedure( get_scalar ), public, deferred :: salt_equation_terms Returns the terms this melt formulation contributes to the\n salt equation, after they have been solved for using solve_for_melt . function get_scalar(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property is being returned. procedure( get_scalar ), public, deferred :: heat_equation_terms Returns the terms this melt formulation contributes to the\n heat equation, after they have been solved for using solve_for_melt . function get_scalar(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property is being returned. procedure( get_scalar ), public, deferred :: melt_rate Returns the melt rate calculated using this formulation,\n after it has been solved for using solve_for_melt . function get_scalar(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property is being returned. procedure( has_terms ), public, deferred :: has_heat_terms Whether this formulation of melting contributes any terms to\n a plume's heat equation. pure function has_terms(this) Prototype Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat or salinity equations. procedure( has_terms ), public, deferred :: has_salt_terms Whether this formulation of melting contributes any terms to\n a plume's salinity equation. pure function has_terms(this) Prototype Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat or salinity equations. Source Code type , abstract , public :: abstract_melt_relationship !* Author: Christopher MacMackin !  Date: October 2016 ! ! An abstract data type for calculating melting of an ice shelf into ! a vertically integrated [[plume(type)]]. The melt rate, as well as ! effect on termperature and salinity, are calculated by calling ! [[abstract_melt_relationship(type):solve_for_melt]] and then accessed ! using [[abstract_melt_relationship(type):melt_rate]], ! [[abstract_melt_relationship(type):heat_equation_terms]], ! [[abstract_melt_relationship(type):salt_equation_terms]]. ! contains procedure ( solve ), deferred :: solve_for_melt procedure ( get_scalar ), deferred :: salt_equation_terms !! Returns the terms this melt formulation contributes to the !! salt equation, after they have been solved for using !! [[abstract_melt_relationship(type):solve_for_melt]]. procedure ( get_scalar ), deferred :: heat_equation_terms !! Returns the terms this melt formulation contributes to the !! heat equation, after they have been solved for using !! [[abstract_melt_relationship(type):solve_for_melt]]. procedure ( get_scalar ), deferred :: melt_rate !! Returns the melt rate calculated using this formulation, !! after it has been solved for using !! [[abstract_melt_relationship(type):solve_for_melt]]. procedure ( has_terms ), deferred :: has_heat_terms !! Whether this formulation of melting contributes any terms to !! a plume's heat equation. procedure ( has_terms ), deferred :: has_salt_terms !! Whether this formulation of melting contributes any terms to !! a plume's salinity equation. end type abstract_melt_relationship"},{"title":"glacier_boundary – ISOFT ","tags":"","loc":"type/glacier_boundary.html","text":"type, public :: glacier_boundary A type in which procedures for getting the boundary conditions\n of glaciers are to be specified. The descendent types can\n contain whatever data is needed to compute the result. It\n provides the routine boundary_residuals to return an\n array with the residuals representing deviation from satisfying\n the conditions. This can then be appended to a glacier 's residual array. When specifying boundary conditions in this way, it becomes\n necessary not to include the residual of the plume data at some\n location(s). Typically this would be adjacent to the boundaries\n being prescribed. In order to accomplish this, routines are\n provided which return arrays indicating at which boundaries data\n should be omitted and how much. These should be passed as\n arguments for the field methods to get and set the field's raw\n data. This class effectively provides free boundary conditions. It's \n type-bound procedures should be overridden to provide case-specific\n conditions. Inherited by type~~glacier_boundary~~InheritedByGraph type~glacier_boundary glacier_boundary type~seasonal_glacier_boundary seasonal_glacier_boundary type~seasonal_glacier_boundary->type~glacier_boundary type~dallaston2015_glacier_boundary dallaston2015_glacier_boundary type~dallaston2015_glacier_boundary->type~glacier_boundary type~ice_shelf ice_shelf type~ice_shelf->type~glacier_boundary boundaries Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures thickness_lower_bound thickness_upper_bound velocity_lower_bound velocity_upper_bound thickness_lower_type thickness_upper_type velocity_lower_type velocity_upper_type boundary_residuals Source Code glacier_boundary Type-Bound Procedures procedure, public :: thickness_lower_bound => bound_array Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the thickness\n field. private pure function bound_array (this) Author Chris MacMackin Date September 2016 Default implementation of the method getting lower and upper\n boundary information, which is then passed to the methods for\n getting and setting raw representations of fields. It returns a\n 1D array of length 2, indicating free boundaries (the raw data\n should represent all cells contained in the field, not excluding\n any near the boundaries). Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: thickness_upper_bound => bound_array Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the thickness\n field. private pure function bound_array (this) Author Chris MacMackin Date September 2016 Default implementation of the method getting lower and upper\n boundary information, which is then passed to the methods for\n getting and setting raw representations of fields. It returns a\n 1D array of length 2, indicating free boundaries (the raw data\n should represent all cells contained in the field, not excluding\n any near the boundaries). Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: velocity_lower_bound => bound_array Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the velocity\n field. private pure function bound_array (this) Author Chris MacMackin Date September 2016 Default implementation of the method getting lower and upper\n boundary information, which is then passed to the methods for\n getting and setting raw representations of fields. It returns a\n 1D array of length 2, indicating free boundaries (the raw data\n should represent all cells contained in the field, not excluding\n any near the boundaries). Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: velocity_upper_bound => bound_array Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the velocity\n field. private pure function bound_array (this) Author Chris MacMackin Date September 2016 Default implementation of the method getting lower and upper\n boundary information, which is then passed to the methods for\n getting and setting raw representations of fields. It returns a\n 1D array of length 2, indicating free boundaries (the raw data\n should represent all cells contained in the field, not excluding\n any near the boundaries). Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: thickness_lower_type => bound_type Returns an array indicating what type of boundary conditions\n apply for thickness at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function bound_type (this) Author Chris MacMackin Date January 2017 Default implementation of the methods getting the boundary types\n for a glacier.  It returns an array which indicates free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: thickness_upper_type => bound_type Returns an array indicating what type of boundary conditions\n apply for thickness at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function bound_type (this) Author Chris MacMackin Date January 2017 Default implementation of the methods getting the boundary types\n for a glacier.  It returns an array which indicates free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: velocity_lower_type => bound_type Returns an array indicating what type of boundary conditions\n apply for velocity at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function bound_type (this) Author Chris MacMackin Date January 2017 Default implementation of the methods getting the boundary types\n for a glacier.  It returns an array which indicates free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: velocity_upper_type => bound_type Returns an array indicating what type of boundary conditions\n apply for velocity at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function bound_type (this) Author Chris MacMackin Date January 2017 Default implementation of the methods getting the boundary types\n for a glacier.  It returns an array which indicates free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: boundary_residuals Returns an array consisting of the difference between the\n required boundary values and those which actually exist. The\n order in which these are listed is as follows: lower\n thickness boundary, upper thickness boundary, lower velocity\n boundary, and upper velocity boundary. private function boundary_residuals (this, thickness, velocity, viscosity, t) result(residuals) Author Chris MacMackin Date September 2016 Default implementation of the boundary_residuals method. It returns a zero-length array, effectively indicating free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this class(scalar_field), intent(in) :: thickness A field containing the thickness of the glacier class(vector_field), intent(in) :: velocity A field containing the flow velocity of the glacier class(scalar_field), intent(in) :: viscosity A field containing the viscosity of the ice in the glacier. real(kind=r8), intent(in) :: t The time at which the boundary conditions are to be\n calculated. Return Value real(kind=r8),\n  allocatable, dimension(:) An array containing the difference between the required\n boundary values and those which are actually present. They\n are stored in the order: lower thickness boundary, upper\n thickness boundary, lower velocity boundary, and upper\n velocity boundary. Source Code type , public :: glacier_boundary !* Author: Chris MacMackin !  Date: September 2016 ! ! A type in which procedures for getting the boundary conditions ! of glaciers are to be specified. The descendent types can ! contain whatever data is needed to compute the result. It ! provides the routine ! [[glacier_boundary(type):boundary_residuals]] to return an ! array with the residuals representing deviation from satisfying ! the conditions. This can then be appended to a ! [[glacier(type)]]'s residual array. ! ! When specifying boundary conditions in this way, it becomes ! necessary not to include the residual of the plume data at some ! location(s). Typically this would be adjacent to the boundaries ! being prescribed. In order to accomplish this, routines are ! provided which return arrays indicating at which boundaries data ! should be omitted and how much. These should be passed as ! arguments for the field methods to get and set the field's raw ! data. ! ! This class effectively provides free boundary conditions. It's ! type-bound procedures should be overridden to provide case-specific ! conditions. ! contains procedure :: thickness_lower_bound => bound_array !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the thickness !! field. procedure :: thickness_upper_bound => bound_array !! Returns a 1D array which should be passed as the !! `exclude_upper_bound`/`provide_upper_bound` argument when !! getting or setting the raw representation of the thickness !! field. procedure :: velocity_lower_bound => bound_array !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: velocity_upper_bound => bound_array !! Returns a 1D array which should be passed as the !! `exclude_upper_bound`/`provide_upper_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: thickness_lower_type => bound_type !! Returns an array indicating what type of boundary conditions !! apply for thickness at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: thickness_upper_type => bound_type !! Returns an array indicating what type of boundary conditions !! apply for thickness at the upper boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_lower_type => bound_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_upper_type => bound_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the upper boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: boundary_residuals !! Returns an array consisting of the difference between the !! required boundary values and those which actually exist. The !! order in which these are listed is as follows: lower !! thickness boundary, upper thickness boundary, lower velocity !! boundary, and upper velocity boundary. end type glacier_boundary"},{"title":"ave_linear_eos – ISOFT ","tags":"","loc":"type/ave_linear_eos.html","text":"type, public, extends( equation_of_state ) :: ave_linear_eos A linearised implementation of the equation of state which has\n been horizontally-integrated. The basic equation of stateis \\rho(x,y) = \\rho_0[1-\\beta_T(T(x,y)-T_0) +\n \\beta_S(S(x,y)-S_0)]. Inherits type~~ave_linear_eos~~InheritsGraph type~ave_linear_eos ave_linear_eos type~equation_of_state equation_of_state type~ave_linear_eos->type~equation_of_state Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables ref_rho ref_t ref_s beta_t beta_s a_DS a_DT a_DS_t a_DT_t Constructor ave_linear_eos Type-Bound Procedures water_density water_density_ave1 water_density_ave2 water_density_derivative haline_contraction thermal_contraction Source Code ave_linear_eos Components Type Visibility Attributes Name Initial real(kind=r8), private :: ref_rho = 1.0_r8 The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), private :: ref_t = 0.0_r8 The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), private :: ref_s = 0.0_r8 The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), private :: beta_t = 0.0_r8 The thermal contraction coefficient, \\beta_T . real(kind=r8), private :: beta_s = 1.0_r8 The haline contraction coefficient, \\beta_S . real(kind=r8), private :: a_DS = 1.0_r8 The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_S dy, where f_{D}(y) and f_S(y) are the shapes of the variables D and S in\n the transverse direction. real(kind=r8), private :: a_DT = 1.0_r8 The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_T dy, where f_{D}(y) and f_T(y) are the shapes of the variables D and T in\n the transverse direction. real(kind=r8), private :: a_DS_t = 1.0_r8 The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DS} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S\n dy, where f_{D}(y) and f_S(y) are the shapes of\n the variables D and S in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. real(kind=r8), private :: a_DT_t = 1.0_r8 The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DT} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T\n dy, where f_{D}(y) and f_T(y) are the shapes of\n the variables D and T in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Constructor public interface ave_linear_eos private pure function constructor (ref_rho, ref_t, ref_s, beta_t, beta_s, a_DS, a_DT, a_DS_t, a_DT_t) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: ref_rho The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), intent(in) :: ref_t The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), intent(in) :: ref_s The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), intent(in) :: beta_t The thermal contraction coefficient, \\beta_T . real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S . real(kind=r8), intent(in), optional :: a_DS The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_S dy, where f_{D}(y) and f_S(y) are the shapes of the variables D and S in\n the transverse direction. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DT The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_T dy, where f_{D}(y) and f_T(y) are the shapes of the variables D and T in\n the transverse direction. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DS_t The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DS} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S\n dy, where f_{D}(y) and f_S(y) are the shapes of\n the variables D and S in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DT_t The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DT} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T\n dy, where f_{D}(y) and f_T(y) are the shapes of\n the variables D and T in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. Return Value type( ave_linear_eos ) Type-Bound Procedures procedure, public :: water_density => linear_water_density private function linear_water_density (this, temperature, salinity) result(density) Author Chris MacMackin Date August 2018 Calculates the density of the water from the temperature and\n salinity, using a linear equation of state, \\rho(x,y) =\n \\rho_0[1-\\beta_T(T(x,y)-T_0) + \\beta_S(S(x,y)-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water procedure, public :: water_density_ave1 => linear_water_density_ave1 private function linear_water_density_ave1 (this, temperature, salinity) result(density) Author Chris MacMackin Date August 2018 Calculates one form of the horizontally-averaged density of the\n water from the temperature and salinity, using a linear equation\n of state, \\bar{rho}(x) =\n \\rho_0[1-\\beta_T(\\alpha_{DT}T(x)-T_0) +\n \\beta_S(\\alpha_{DS}S(x)-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water procedure, public :: water_density_ave2 => linear_water_density_ave2 private function linear_water_density_ave2 (this, temperature, salinity) result(density) Author Chris MacMackin Date August 2018 Calculates another form of the horizontally-averaged density of\n the water from the temperature and salinity, using a linear\n equation of state, \\tilde{\\rho}(x) =\n \\rho_0[1-\\beta_T(\\tilde{\\alpha}_{DT}T(x)-T_0) +\n \\beta_S(\\tilde{\\alpha}_{DS}S(x)-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water procedure, public :: water_density_derivative => linear_water_deriv private function linear_water_deriv (this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Author Chris MacMackin Date August 2018 Calculates the derivative of the average water density from the\n temperature and salinity, using a linear equation of state with\n the second type of averaging, \\tilde{\\rho} =\n \\rho_0[1-\\beta_T(\\tilde{\\alpha}_{DT}T-T_0) +\n \\beta_S(\\tilde{\\alpha}_{DS}S-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the density of the water procedure, public :: haline_contraction => linear_haline_contraction private function linear_haline_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date August 2018 Returns the haline contraction coefficient. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable procedure, public :: thermal_contraction => linear_thermal_contraction private function linear_thermal_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date August 2018 Returns the thermal contraction coefficient. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Source Code type , extends ( equation_of_state ), public :: ave_linear_eos !* Author: Chris MacMackin !  Date: August 2018 ! ! A linearised implementation of the equation of state which has ! been horizontally-integrated. The basic equation of stateis  ! \\rho(x,y) = \\rho_0[1-\\beta_T(T(x,y)-T_0) + ! \\beta_S(S(x,y)-S_0)].  ! private real ( r8 ) :: ref_rho = 1.0_r8 !! The density for the temperature and salinity about which the !! equation of state was linearised, \\rho_0. real ( r8 ) :: ref_t = 0.0_r8 !! The temperature about which the equation of state was !! linearised, T_0. real ( r8 ) :: ref_s = 0.0_r8 !! The salinity about which the equation of state was !! linearised, S_0. real ( r8 ) :: beta_t = 0.0_r8 !! The thermal contraction coefficient, \\beta_T. real ( r8 ) :: beta_s = 1.0_r8 !! The haline contraction coefficient, \\beta_S. real ( r8 ) :: a_DS = 1.0_r8 !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{D}f_S dy,  where f_{D}(y) and !! f_S(y) are the shapes of the variables D and S in !! the transverse direction. real ( r8 ) :: a_DT = 1.0_r8 !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{D}f_T dy,  where f_{D}(y) and !! f_T(y) are the shapes of the variables D and T in !! the transverse direction. real ( r8 ) :: a_DS_t = 1.0_r8 !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\tilde{\\alpha}_{DS} = !! \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S !! dy,  where f_{D}(y) and f_S(y) are the shapes of !! the variables D and S in the transverse direction and !! \\alpha_{D&#94;2} = \\frac{1}{y_2 - !! y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. real ( r8 ) :: a_DT_t = 1.0_r8 !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\tilde{\\alpha}_{DT} = !! \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T !! dy,  where f_{D}(y) and f_T(y) are the shapes of !! the variables D and T in the transverse direction and !! \\alpha_{D&#94;2} = \\frac{1}{y_2 - !! y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. contains procedure :: water_density => linear_water_density procedure :: water_density_ave1 => linear_water_density_ave1 procedure :: water_density_ave2 => linear_water_density_ave2 procedure :: water_density_derivative => linear_water_deriv procedure :: haline_contraction => linear_haline_contraction procedure :: thermal_contraction => linear_thermal_contraction end type ave_linear_eos"},{"title":"ice_shelf – ISOFT ","tags":"","loc":"type/ice_shelf.html","text":"type, public, extends( glacier ) :: ice_shelf A concrete implementation of the glacier type, using a vertically\n integrated model of an ice shelf. This model is 1-dimensional only. Inherits type~~ice_shelf~~InheritsGraph type~ice_shelf ice_shelf type~glacier glacier type~ice_shelf->type~glacier cheb1d_scalar_field cheb1d_scalar_field type~ice_shelf->cheb1d_scalar_field thickness, eta, kappa cheb1d_vector_field cheb1d_vector_field type~ice_shelf->cheb1d_vector_field velocity type~abstract_viscosity abstract_viscosity type~ice_shelf->type~abstract_viscosity viscosity_law type~glacier_boundary glacier_boundary type~ice_shelf->type~glacier_boundary boundaries type~jacobian_block jacobian_block type~ice_shelf->type~jacobian_block thickness_jacobian, velocity_jacobian type~jacobian_block->type~jacobian_block block_increment scalar_field scalar_field type~jacobian_block->scalar_field contents, derivative, field_increment Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thickness velocity eta kappa lambda chi zeta courant viscosity_law boundaries max_dt time thickness_size velocity_size boundary_start thickness_lower_bound_size thickness_upper_bound_size velocity_lower_bound_size velocity_upper_bound_size thickness_jacobian velocity_jacobian stale_eta stale_jacobian Type-Bound Procedures assignment(=) integrate initialise ice_thickness ice_density ice_temperature residual update precondition set_time data_size state_vector kappa_vector read_data write_data time_step solve_velocity assign integrate_layers Source Code ice_shelf Components Type Visibility Attributes Name Initial type(cheb1d_scalar_field), private :: thickness Thickness of ice shelf, h type(cheb1d_vector_field), private :: velocity Flow velocity of ice shelf, \\vec{u} type(cheb1d_scalar_field), private :: eta Viscosity of the ice, \\eta type(cheb1d_scalar_field), private, dimension(:), allocatable :: kappa Taylor coefficients for the vertical structure of a\n Lagrangian tracer representing englacial layers/internal\n reflectors. real(kind=r8), private :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real(kind=r8), private :: chi The dimensionless ratio \\chi \\equiv\n \\frac{\\rho_igh_0x_0}{2\\eta_0u_0} \\left(1 -\n \\frac{\\rho_i}{\\rho_o}\\right) real(kind=r8), private :: zeta The dimensionless ratio \\zeta \\equiv\n \\frac{\\rho_iu_0x_0}{\\eta_0} , corresponding to the Reynolds\n number. Currently unused. real(kind=r8), private :: courant The Courant number to use when calculating the time step. class( abstract_viscosity ), private, allocatable :: viscosity_law An object representing the model used for ice viscosity. class( glacier_boundary ), private, allocatable :: boundaries An object specifying the boundary conditions for the ice\n shelf. real(kind=r8), private :: max_dt The maximu  allowable time step real(kind=r8), private :: time The time at which the ice shelf is in this state. integer, private :: thickness_size The number of data values in the thickness field. integer, private :: velocity_size The number of data values in the velocity field. integer, private :: boundary_start The number of data values needed to represent the boundary\n conditions. integer, private :: thickness_lower_bound_size The number of data values needed to represent the lower\n boundary conditions for thickness. integer, private :: thickness_upper_bound_size The number of data values needed to represent the upper\n boundary conditions for thickness. integer, private :: velocity_lower_bound_size The number of data values needed to represent the lower\n boundary conditions for velocity. integer, private :: velocity_upper_bound_size The number of data values needed to represent the upper\n boundary conditions for thickness. type( jacobian_block ), private :: thickness_jacobian A representation of the Jacobian for the ice shelf thickness. type( jacobian_block ), private :: velocity_jacobian A representation of the Jacobian for the ice shelf velocity. logical, private :: stale_eta Indicates whether the viscosity needs updating. logical, private :: stale_jacobian Indicates if the Jacobians are stale and in need of updating. Type-Bound Procedures generic, public :: assignment(=) => assign private subroutine shelf_assign (this, rhs) Author Chris MacMackin Date February 2017 Copies the data from one ice shelf into another. This is only\n needed due to a bug in gfortran which means that the intrinsic\n assignment for glacier types is not using the appropriate\n defined assignment for the field components. Read more… Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(out) :: this class( glacier ), intent(in) :: rhs The ice shelf to be assigned to this one. procedure, public :: integrate => glacier_integrate Performs a time-step of the integration, taking the state of\n the glacier to the specified time using the provided\n melt-rate data. private subroutine glacier_integrate (this, old_states, basal_melt, basal_drag, water_density, time, success) Author Chris MacMackin Date November 2016 Integrates the glacier's state to time . This is done using the\n NITSOL package of iterative Krylov solvers. If a different\n algorithm for the integration is desired, then this method may\n be overridden in the concrete implementations of the glacier\n type. Read more… Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. class(scalar_field), intent(in) :: basal_melt The melt rate that the bottom of the glacier experiences\n during this time step. class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise procedure, public :: initialise => shelf_initialise private subroutine shelf_initialise (this, domain, resolution, thickness, velocity, temperature, viscosity_law, boundaries, lambda, chi, zeta, courant, max_dt, kappa, n_kappa) Author Christopher MacMackin Date April 2016 Initialises an ice_shelf object with initial conditions provided\n by the arguments. At present only a 1D model is supported. If\n information is provided for higher dimensions then it will be ignored. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(out) :: this real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the ice shelf. The first index represents the dimension for which\n the boundaries apply. If the second index is 1 then it corresponds\n to the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension. procedure( thickness_func ) :: thickness A function which calculates the initial value of the thickness of \n the ice shelf at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the ice at a given location in an ice shelf. real(kind=r8), intent(in), optional :: temperature The temperature of the ice in the ice shelf. class( abstract_viscosity ), intent(inout), optional allocatable :: viscosity_law An object which calculates the viscosity of the ice. If not\n specified, then Glen's law will be used with $n=3$. Will be\n unallocated on return. class( glacier_boundary ), intent(inout), optional allocatable :: boundaries An object specifying the boundary conditions for the ice\n shelf. Will be unallocated on return. real(kind=r8), intent(in), optional :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_ih_0u_0}$. real(kind=r8), intent(in), optional :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}\\left(1 -\n \\frac{\\rho_i}{\\rho_0}\\right)$. real(kind=r8), intent(in), optional :: zeta The dimensionless ratio $\\zeta \\equiv\n \\frac{\\rho_iu_0x_0}{\\eta_0}$, corresponding to the Reynolds\n number. Currently this is unused and always treated as 0. real(kind=r8), intent(in), optional :: courant The Courant number to use when calculating the time\n step. Defaults to 100. Too large a value will pose\n difficulties for the nonlinear solver, while too small a\n value can be numerically unstable. Typically, smaller values\n are needed for lower resolution. real(kind=r8), intent(in), optional :: max_dt The maximum allowable time step. This defaults to 1\\times\n 10&#94;{99} (effectively no maximum). procedure( kappa_init_func ), optional :: kappa A function which specifies the initial values of the Taylor\n coefficients describing the vertical distribution of internal\n reflectors within the ice. The initial conditions at the\n grounding line will provide the boundary conditions there\n throughout the simulation. If this parameter is not provided\n then these layers will not be included in the\n integration. Both this parameter and n_kappa must be\n specified for the calculation to take place. integer, intent(in), optional :: n_kappa The number of Taylor coefficients used to describe internal\n reflectors. If not provided then these reflectors will not be\n included in the integration. Both this parameter and kappa must be specified for the calculation to take place. procedure, public :: ice_thickness => shelf_thickness private function shelf_thickness (this) result(thickness) Author Christopher MacMackin Date April 2016 Returns the thickness of the ice shelf across its domain. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value class(scalar_field),\n  pointer The ice thickness. procedure, public :: ice_density => shelf_density private pure function shelf_density (this) result(density) Author Christopher MacMackin Date April 2016 Returns the density of the ice in the shelf, which is assumed to be\n uniform across its domain. Read more… Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8) The ice density. procedure, public :: ice_temperature => shelf_temperature private pure function shelf_temperature (this) result(temperature) Author Christopher MacMackin Date April 2016 Returns the density of the ice in the shelf, which is assumed to be\n uniform across its domain. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8) The ice density. procedure, public :: residual => shelf_residual private function shelf_residual (this, previous_states, melt_rate, basal_drag_parameter, water_density) result(residual) Author Christopher MacMackin Date April 2016 Returns the residual when the current state of the glacier is run\n through the system of equations describing it. The residual takes the\n form of a 1D array, with each element respresenting the residual for\n one of the equations in the system. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most recent\n state, but the fact that this is an array allows potential\n other implementations to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier. class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate the\n drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. Return Value real(kind=r8),\n  dimension(:), allocatable The residual of the system of equations describing the glacier. procedure, public :: update => shelf_update private subroutine shelf_update (this, state_vector) Author Christopher MacMackin Date April 2016 Updates the state of the ice shelf from its state vector. The state\n vector is a real array containing the value of each of the ice shelf's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n glacier. procedure, public :: precondition => shelf_precondition private function shelf_precondition (this, previous_states, melt_rate, basal_drag_parameter, water_density, delta_state) result(preconditioned) Author Chris MacMackin Date January 2016 Provides a preconditioner for the nonlinear solver trying to\n bring the residual to zero. The Jacobian is approximated as a\n block matrix, where each block is a tridiagonal matrix using a\n finite difference method for differentiation. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier real(kind=r8), intent(in), dimension(:) :: delta_state The change to the state vector which is being preconditioned. Return Value real(kind=r8),\n  dimension(:), allocatable The result of applying the preconditioner to delta_state . procedure, public :: set_time => shelf_set_time private subroutine shelf_set_time (this, time) Author Christopher MacMackin Date November 2016 Sets the time information held by the ice shelf object. This is\n the time at which the ice sheet is in its current state. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the glacier is in the present state. procedure, public :: data_size => shelf_data_size private pure function shelf_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the ice shelf's state vector.\n This is the size of the vector returned by residual and state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value integer The number of elements in the ice shelf's state vector. procedure, public :: state_vector => shelf_state_vector private function shelf_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the ice shelf. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the ice shelf. procedure, public :: kappa_vector => shelf_kappa_vector private function shelf_kappa_vector (this) result(kappa_vector) Author Christopher MacMackin Date April 2016 Returns the a vector representing the current state of the\n internal reflectors in the ice shelf.  This takes the form of a\n 1D array. The routien is only used for debugging purposes. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the ice shelf. procedure, public :: read_data => shelf_read_data private subroutine shelf_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the ice shelf object from the specified group\n in an HDF5 file. This sets the thickness, the velocity, and\n parameter values. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: write_data => shelf_write_data private subroutine shelf_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the ice shelf object to an HDF file in the\n specified group. This will consist of a thickness and a velocity\n dataset. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: time_step => shelf_time_step private function shelf_time_step (this) result(dt) Author Chris MacMackin Date December 2016 Calculates the time step for integrating the ice shelf, using\n the CFL condition. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8) The time-step to use procedure, public :: solve_velocity => shelf_solve_velocity private subroutine shelf_solve_velocity (this, basal_drag, success) Author Chris MacMackin Date May 2017 Computes the ice shelf velocity at the current time with the\n current ice thickness. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. logical, intent(out) :: success True if the integration is successful, false otherwise procedure, private :: assign => shelf_assign private subroutine shelf_assign (this, rhs) Author Chris MacMackin Date February 2017 Copies the data from one ice shelf into another. This is only\n needed due to a bug in gfortran which means that the intrinsic\n assignment for glacier types is not using the appropriate\n defined assignment for the field components. Read more… Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(out) :: this class( glacier ), intent(in) :: rhs The ice shelf to be assigned to this one. procedure, public :: integrate_layers => ice_shelf_integrate_layers private subroutine ice_shelf_integrate_layers (this, old_states, time, success) Author Chris MacMackin Date September 2018 Integrate the Taylor coefficients representing the vertical\n structure of internal reflectors forward to the specified\n time. This is done using an implicit method, with the resulting\n linear system solved using GMRES. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the ice_shelf, with the most recent one\n first. real(kind=r8), intent(in) :: time The time to which the ice_shelf should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise Source Code type , extends ( glacier ), public :: ice_shelf !* Author: Chris MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[glacier]] type, using a vertically ! integrated model of an ice shelf. This model is 1-dimensional only. ! private type ( cheb1d_scalar_field ) :: thickness !! Thickness of ice shelf, h type ( cheb1d_vector_field ) :: velocity !! Flow velocity of ice shelf, \\vec{u} type ( cheb1d_scalar_field ) :: eta !! Viscosity of the ice, \\eta type ( cheb1d_scalar_field ), dimension (:), allocatable :: kappa !! Taylor coefficients for the vertical structure of a !! Lagrangian tracer representing englacial layers/internal !! reflectors. real ( r8 ) :: lambda !! The dimensionless ratio !! $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real ( r8 ) :: chi !! The dimensionless ratio \\chi \\equiv !! \\frac{\\rho_igh_0x_0}{2\\eta_0u_0} \\left(1 - !! \\frac{\\rho_i}{\\rho_o}\\right) real ( r8 ) :: zeta !! The dimensionless ratio \\zeta \\equiv !! \\frac{\\rho_iu_0x_0}{\\eta_0}, corresponding to the Reynolds !! number. Currently unused. real ( r8 ) :: courant !! The Courant number to use when calculating the time step. class ( abstract_viscosity ), allocatable :: viscosity_law !! An object representing the model used for ice viscosity. class ( glacier_boundary ), allocatable :: boundaries !! An object specifying the boundary conditions for the ice !! shelf. real ( r8 ) :: max_dt !! The maximu  allowable time step real ( r8 ) :: time !! The time at which the ice shelf is in this state. integer :: thickness_size !! The number of data values in the thickness field. integer :: velocity_size !! The number of data values in the velocity field. integer :: boundary_start !! The number of data values needed to represent the boundary !! conditions. integer :: thickness_lower_bound_size !! The number of data values needed to represent the lower !! boundary conditions for thickness. integer :: thickness_upper_bound_size !! The number of data values needed to represent the upper !! boundary conditions for thickness. integer :: velocity_lower_bound_size !! The number of data values needed to represent the lower !! boundary conditions for velocity. integer :: velocity_upper_bound_size !! The number of data values needed to represent the upper !! boundary conditions for thickness. type ( jacobian_block ) :: thickness_jacobian !! A representation of the Jacobian for the ice shelf thickness. type ( jacobian_block ) :: velocity_jacobian !! A representation of the Jacobian for the ice shelf velocity. logical :: stale_eta !! Indicates whether the viscosity needs updating. logical :: stale_jacobian !! Indicates if the Jacobians are stale and in need of updating. contains procedure :: initialise => shelf_initialise procedure :: ice_thickness => shelf_thickness !$    procedure :: ice_velocity => shelf_velocity procedure :: ice_density => shelf_density procedure :: ice_temperature => shelf_temperature procedure :: residual => shelf_residual procedure :: update => shelf_update procedure :: precondition => shelf_precondition procedure :: set_time => shelf_set_time procedure :: data_size => shelf_data_size procedure :: state_vector => shelf_state_vector procedure :: kappa_vector => shelf_kappa_vector procedure :: read_data => shelf_read_data procedure :: write_data => shelf_write_data procedure :: time_step => shelf_time_step procedure :: solve_velocity => shelf_solve_velocity !    procedure :: integrate => shelf_integrate procedure , private :: assign => shelf_assign procedure :: integrate_layers => ice_shelf_integrate_layers end type ice_shelf"},{"title":"uniform_gradient_field – ISOFT ","tags":"","loc":"type/uniform_gradient_field.html","text":"type, public, extends(uniform_scalar_field) :: uniform_gradient_field A type of uniform field which also has a uniform gradient. Of\n course, this is impossible in practice, but it can be useful for\n tricking certain routines into working properly. Ideally a whole\n new derived type would be created which just holds the value and\n gradient at a single point, but the emphasis is on getting\n something quickly. Note that the gradient is not propagated\n across operations--the result of all overloaded operators is\n just a normal uniform field with no gradient. Inherits type~~uniform_gradient_field~~InheritsGraph type~uniform_gradient_field uniform_gradient_field uniform_scalar_field uniform_scalar_field type~uniform_gradient_field->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables grad Constructor uniform_gradient_field Type-Bound Procedures d_dx gradient is_equal assign_field Source Code uniform_gradient_field Components Type Visibility Attributes Name Initial real(kind=r8), public, dimension(:), allocatable :: grad The values of the gradient in each direction. Constructor public interface uniform_gradient_field private function constructor (val, grad) result(this) Author Chris MacMackin Date July 2017 Creates a new scalar field with a uniform value across all of\n space but a non-zero gradient. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: val The value of the field real(kind=r8), intent(in), dimension(:) :: grad An array in which the i th element contains the gradient in\n the _i_th direction. Directions corresponding to values of i greater than the size of the array are taken to have a\n gradient of zero. Return Value type( uniform_gradient_field ) A scalar field initated based on teh arguments of this\n function. Type-Bound Procedures procedure, public :: d_dx => uniform_gradient_d_dx \\frac{\\partial&#94;n}{\\partial x_i&#94;n}({\\rm field}) private function uniform_gradient_d_dx (this, dir, order) result(res) Author Chris MacMackin Date July 2017 \\frac{\\partial&#94;{\\rm order}}{\\partial x_{\\rm dir}&#94;{\\rm order}}{\\rm field} Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(in) :: this integer, intent(in) :: dir Direction in which to differentiate integer, intent(in), optional :: order Order of the derivative, default = 1 Return Value class(scalar_field),\n  pointer procedure, private :: gradient => uniform_gradient_gradient \\nabla {\\rm field} private function uniform_gradient_gradient (this) result(res) Author Chris MacMackin Date July 2017 \\nabla{\\rm field} Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(in) :: this Return Value class(vector_field),\n  pointer The result of this operation procedure, private :: is_equal => uniform_gradient_is_equal Checks fields are equal within a tolerance private function uniform_gradient_is_equal (this, rhs) result(iseq) Author Chris MacMackin Date July 2017 Evaluates whether two scalar fields are equal within a tolerance,\n specified by set_tol . Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(in) :: this class(scalar_field), intent(in) :: rhs Return Value logical procedure, private :: assign_field => uniform_gradient_assign {\\rm field} = {\\rm field} private impure elemental subroutine uniform_gradient_assign (this, rhs) Author Chris MacMackin Date July 2017 {\\rm field} = {\\rm field} Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(inout) :: this class(scalar_field), intent(in) :: rhs Source Code type , extends ( uniform_scalar_field ), public :: uniform_gradient_field !* Author: Chris MacMackin !  Date: July 2017 ! ! A type of uniform field which also has a uniform gradient. Of ! course, this is impossible in practice, but it can be useful for ! tricking certain routines into working properly. Ideally a whole ! new derived type would be created which just holds the value and ! gradient at a single point, but the emphasis is on getting ! something quickly. Note that the gradient is not propagated ! across operations--the result of all overloaded operators is ! just a normal uniform field with no gradient. ! real ( r8 ), dimension (:), allocatable :: grad !! The values of the gradient in each direction. contains private procedure , public :: d_dx => uniform_gradient_d_dx !! \\frac{\\partial&#94;n}{\\partial x_i&#94;n}({\\rm field}) procedure :: gradient => uniform_gradient_gradient !! \\nabla {\\rm field} procedure :: is_equal => uniform_gradient_is_equal !! Checks fields are equal within a tolerance procedure :: assign_field => uniform_gradient_assign !! {\\rm field} = {\\rm field} end type uniform_gradient_field"},{"title":"abstract_viscosity – ISOFT ","tags":"","loc":"type/abstract_viscosity.html","text":"type, public, abstract :: abstract_viscosity An abstract data type for calculating viscosity of a vertically\n integrated glacier . Inherited by type~~abstract_viscosity~~InheritedByGraph type~abstract_viscosity abstract_viscosity type~newtonian_viscosity newtonian_viscosity type~newtonian_viscosity->type~abstract_viscosity type~ice_sheet ice_sheet type~ice_sheet->type~abstract_viscosity viscosity_law type~ice_shelf ice_shelf type~ice_shelf->type~abstract_viscosity viscosity_law type~glens_law_viscosity glens_law_viscosity type~glens_law_viscosity->type~abstract_viscosity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures ice_viscosity Source Code abstract_viscosity Type-Bound Procedures procedure( get_viscosity ), public, deferred :: ice_viscosity Returns the viscosity for the ice. function get_viscosity(this, velocity, temperature, time) result(property) Prototype Arguments Type Intent Optional Attributes Name class( abstract_viscosity ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the ice for which the velocity is\n being calculated real(kind=r8), intent(in) :: temperature The temperature of the ice for which viscosity is being\n calculated. real(kind=r8), intent(in), optional :: time The time at which the viscosity is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the viscosity Source Code type , abstract , public :: abstract_viscosity !* Author: Christopher MacMackin !  Date: October 2016 ! ! An abstract data type for calculating viscosity of a vertically ! integrated [[glacier(type)]]. ! contains procedure ( get_viscosity ), deferred :: ice_viscosity !! Returns the viscosity for the ice. end type abstract_viscosity"},{"title":"basal_surface – ISOFT ","tags":"","loc":"type/basal_surface.html","text":"type, public, abstract :: basal_surface An abstract data type which represents whatever lies below a glacier .\n This could be the ground, a plume, or a fully dynamic ocean model.\n Methods are available to provide the coupling information between the glacier and the basal surface. Inherited by type~~basal_surface~~InheritedByGraph type~basal_surface basal_surface type~plume plume type~plume->type~basal_surface type~static_plume static_plume type~static_plume->type~basal_surface type~cryosphere cryosphere type~cryosphere->type~basal_surface sub_ice type~ground ground type~ground->type~basal_surface type~asym_plume asym_plume type~asym_plume->type~basal_surface Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures basal_melt basal_drag_parameter water_density update data_size state_vector read_data write_data solve Source Code basal_surface Type-Bound Procedures procedure( get_scalar ), public, deferred :: basal_melt Returns the basal melt rate. function get_scalar(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property of the basal surface is being\n returned. procedure( get_scalar ), public, deferred :: basal_drag_parameter Returns a value which may be needed to calculate basal drag,\n such as the coefficient of friction. function get_scalar(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property of the basal surface is being\n returned. procedure( get_real ), public, deferred :: water_density Density of the water at the basal surface. function get_real(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value real(kind=r8) The value of whatever property of the basal surface is being \n returned. procedure( setter ), public, deferred :: update Sets the state of the basal surface subroutine setter(this, state_vector, ice_thickness) Prototype Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n basal surface. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate and/or drag parameter. procedure( get_i ), public, deferred :: data_size Returns the number of elements in the basal surface's state\n vector function get_i(this) result(property) Prototype Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value integer The value of whatever property of the basal surface is being\n returned. procedure( get_r81d ), public, deferred :: state_vector Returns the basal surface's state vector, a 1D array with all\n necessary data to describe its state. function get_r81d(this) result(state_vector) Prototype Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector of the basal surface procedure( read_dat ), public, deferred :: read_data Read the basal surface data from an HDF5 file on the disc. subroutine read_dat(this, file_id, group_name, error) Prototype Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group from which the data\n will be read. character(len=*), intent(in) :: group_name The name of the group in the HDF5 file from which to read\n basal surface's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure( write_dat ), public, deferred :: write_data Writes the data describing the basal surface to the disc as\n an HDF5 file. subroutine write_dat(this, file_id, group_name, error) Prototype Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n basal surface's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure( surface_solve ), public, deferred :: solve Solves for the state of the basal surface given a particular\n ice shelf geometry. subroutine surface_solve(this, ice_thickness, ice_density, ice_temperature, time, success) Prototype Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise Source Code type , abstract , public :: basal_surface !* Author: Christopher MacMackin !  Date: April 2016 ! ! An abstract data type which represents whatever lies below a [[glacier]]. ! This could be the ground, a plume, or a fully dynamic ocean model. ! Methods are available to provide the coupling information between the ! [[glacier]] and the basal surface. ! contains procedure ( get_scalar ), deferred :: basal_melt !! Returns the basal melt rate. procedure ( get_scalar ), deferred :: basal_drag_parameter !! Returns a value which may be needed to calculate basal drag, !! such as the coefficient of friction. procedure ( get_real ), deferred :: water_density !! Density of the water at the basal surface. procedure ( setter ), deferred :: update !! Sets the state of the basal surface procedure ( get_i ), deferred :: data_size !! Returns the number of elements in the basal surface's state !! vector procedure ( get_r81d ), deferred :: state_vector !! Returns the basal surface's state vector, a 1D array with all !! necessary data to describe its state. procedure ( read_dat ), deferred :: read_data !! Read the basal surface data from an HDF5 file on the disc. procedure ( write_dat ), deferred :: write_data !! Writes the data describing the basal surface to the disc as !! an HDF5 file. procedure ( surface_solve ), deferred :: solve !! Solves for the state of the basal surface given a particular !! ice shelf geometry. end type basal_surface"},{"title":"preconditioner – ISOFT ","tags":"","loc":"type/preconditioner.html","text":"type, public :: preconditioner Uses Picard iterations to apply the inverse Jacobian of a system\n to a vector, to low accuracy. Rather than directly computing the\n inverse Jacobian, it is more efficient to approximate it. If d is the vector being preconditioned, and z is the\n result of applying the preconditioner, then z = J&#94;{-1}d\n \\Rightarrow Jz = d. Thus, the preconditioner can be applied by\n approximately solving this system for z . Linearising J ,\n this system can be solved efficiently using Picard iteration. Say that the Jacobian is an n\\times n system of blocks of\n the sort implemented in the jacobian_block type (each\n labeled as J_{j,k} ) and that the vector being preconditioned\n constists of n scalar fields ( d_j ). Then m&#94;{th} estimate of the solution for the j&#94;{th} field in the\n preconditioned vector ( z&#94;m_j ) is the solution to J_{j,j}z&#94;m_j = d_j - \\sum_{\\substack{k=1\\ k\\ne j}}&#94;n\n J_{j,k}z&#94;{m-1}_k. Depending on the type of fields being used\n and the direction in which derivatives are being taken, J_{j,j} may be tridiaganol, meaning it can be solved\n efficiently. Contents Variables tolerance max_iterations Constructor preconditioner Type-Bound Procedures apply Source Code preconditioner Components Type Visibility Attributes Name Initial real(kind=r8), private :: tolerance = 1.e-3_r8 integer, private :: max_iterations = 20 Constructor public interface preconditioner private function constructor (tolerance, max_iterations) result(this) Author Chris MacMackin Date December 2016 Create a preconditioner object with the desired tolerance and\n maximum number of iterations. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: tolerance The tolerance within which to apply the inverse Jacobian.\n Defaults to 0.001. integer, intent(in), optional :: max_iterations The maximum number of iterations to use when applying the\n preconditioner. Defaults to 20. Return Value type( preconditioner ) Type-Bound Procedures procedure, public :: apply => preconditioner_apply private subroutine preconditioner_apply (this, jacobian, vector, estimate) Author Chris MacMackin Date December 2016 Use Picard iteration to approximately multiply the state vector\n by the inverse Jacobian. The details for this procedure are in\n the documentation of the preconditioner type. Arguments Type Intent Optional Attributes Name class( preconditioner ), intent(in) :: this class( jacobian_block ), intent(inout), dimension(:,:) :: jacobian An n\\times n matrix approximating the Jacobian for which\n the preconditioner is used. class(scalar_field), intent(in), dimension(:) :: vector A vector of size n which is to be preconditioned. class(scalar_field), intent(inout), dimension(:) :: estimate On entry, an initial guess for the preconditioned vector. On\n exit, the iteratively determined value of the preconditioned\n vector. Source Code type , public :: preconditioner !* Author: Chris MacMackin !  Date: December 2016 ! ! Uses Picard iterations to apply the inverse Jacobian of a system ! to a vector, to low accuracy. Rather than directly computing the ! inverse Jacobian, it is more efficient to approximate it. If ! d is the vector being preconditioned, and z is the ! result of applying the preconditioner, then  z = J&#94;{-1}d ! \\Rightarrow Jz = d. Thus, the preconditioner can be applied by ! approximately solving this system for z. Linearising J, ! this system can be solved efficiently using Picard iteration. ! ! Say that the Jacobian is an n\\times n system of blocks of ! the sort implemented in the [[jacobian_block]] type (each ! labeled as J_{j,k}) and that the vector being preconditioned ! constists of n scalar fields (d_j). Then m&#94;{th} ! estimate of the solution for the j&#94;{th} field in the ! preconditioned vector (z&#94;m_j) is the solution to  ! J_{j,j}z&#94;m_j = d_j - \\sum_{\\substack{k=1\\ k\\ne j}}&#94;n ! J_{j,k}z&#94;{m-1}_k.  Depending on the type of fields being used ! and the direction in which derivatives are being taken, ! J_{j,j} may be tridiaganol, meaning it can be solved ! efficiently. <!--Otherwise, it can be approximated that  ! J_{j,j}z&#94;m_j = \\left(\\frac{\\partial F}{\\partial x_i} + ! F\\Delta_i\\right)z&#94;{m} \\simeq \\frac{\\partial F}{\\partial ! x_i}z&#94;m_j + F\\frac{\\partial z&#94;{m-1}_j}{\\partial x_i}.  The ! first term in this approximation corresponds to a diagonal ! matrix (which can be solved trivially), while the second term is ! known and can be subtracted from the right-hand-side of the ! linear system.--> ! private real ( r8 ) :: tolerance = 1.e-3_r8 integer :: max_iterations = 20 contains procedure :: apply => preconditioner_apply end type preconditioner"},{"title":"pseudospec_block – ISOFT ","tags":"","loc":"type/pseudospec_block.html","text":"type, public :: pseudospec_block A data type representing a matrix pseudospectral differentiation\n operator. It can be useful when preconditioning systems which\n use a spectral discretisation, if higher accuracy than finite\n difference is needed. It is inherently 1-D in its\n implementation. Note that multiplication of a field will simply\n call that field's differentiation operator, which may or may not\n use a pseudospectral method. Inherited by type~~pseudospec_block~~InheritedByGraph type~pseudospec_block pseudospec_block type~plume plume type~plume->type~pseudospec_block precond type~static_plume static_plume type~static_plume->type~pseudospec_block precond type~asym_plume asym_plume type~asym_plume->type~pseudospec_block precond type~coriolis_block coriolis_block type~asym_plume->type~coriolis_block vel_precond type~coriolis_block->type~pseudospec_block integrator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables xvals Constructor pseudospec_block Type-Bound Procedures pseudospec_block_solve_scalar pseudospec_block_solve_vector solve_for Source Code pseudospec_block Components Type Visibility Attributes Name Initial real(kind=r8), private, dimension(:), pointer :: xvals Coordinates of collocation points. Constructor public interface pseudospec_block private function constructor (template) result(this) Author Chris MacMackin Date September 2017 Builds a Chebyshsev pseudospectral differentiation matrix block\n which can be used to solve the inverse problem. The result can\n only be used with fields having the same grid as the template. Arguments Type Intent Optional Attributes Name class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. Return Value type( pseudospec_block ) Type-Bound Procedures procedure, private :: pseudospec_block_solve_scalar private function pseudospec_block_solve_scalar (this, rhs, bound_loc, bound_val, good_bound) result(solution) Author Chris MacMackin Date September 2017 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a scalar field). Read more… Arguments Type Intent Optional Attributes Name class( pseudospec_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. integer, intent(in) :: bound_loc Which boundary is being set. The boundary will be the one\n normal to dimension of number abs(boundary) . If the\n argument is negative, then the lower boundary is returned. If\n positive, then the upper boundary is returned. class(scalar_field), intent(in) :: bound_val The value of the result at the specified boundary. integer, intent(in), optional :: good_bound If provided, indicates which boundary contains trusted\n information from which to calculate the power of the highest\n frequency mode. Defaults to the opposite of bound_loc . Return Value class(scalar_field),\n  pointer procedure, private :: pseudospec_block_solve_vector private function pseudospec_block_solve_vector (this, rhs, bound_loc, bound_val, good_bound) result(solution) Author Chris MacMackin Date September 2017 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a vector field). Read more… Arguments Type Intent Optional Attributes Name class( pseudospec_block ), intent(inout) :: this class(cheb1d_vector_field), intent(in) :: rhs The right hand side of the linear(ised) system. integer, intent(in) :: bound_loc Which boundary is being set. The boundary will be the one\n normal to dimension of number abs(boundary) . If the\n argument is negative, then the lower boundary is returned. If\n positive, then the upper boundary is returned. class(vector_field), intent(in) :: bound_val The value of the result at the specified boundary. integer, intent(in), optional :: good_bound If provided, indicates which boundary contains trusted\n information from which to calculate the power of the highest\n frequency mode. Defaults to the opposite of bound_loc . Return Value class(vector_field),\n  pointer generic, public :: solve_for => pseudospec_block_solve_scalar , pseudospec_block_solve_vector private function pseudospec_block_solve_scalar (this, rhs, bound_loc, bound_val, good_bound) result(solution) Author Chris MacMackin Date September 2017 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a scalar field). Read more… Arguments Type Intent Optional Attributes Name class( pseudospec_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. integer, intent(in) :: bound_loc Which boundary is being set. The boundary will be the one\n normal to dimension of number abs(boundary) . If the\n argument is negative, then the lower boundary is returned. If\n positive, then the upper boundary is returned. class(scalar_field), intent(in) :: bound_val The value of the result at the specified boundary. integer, intent(in), optional :: good_bound If provided, indicates which boundary contains trusted\n information from which to calculate the power of the highest\n frequency mode. Defaults to the opposite of bound_loc . Return Value class(scalar_field),\n  pointer private function pseudospec_block_solve_vector (this, rhs, bound_loc, bound_val, good_bound) result(solution) Author Chris MacMackin Date September 2017 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a vector field). Read more… Arguments Type Intent Optional Attributes Name class( pseudospec_block ), intent(inout) :: this class(cheb1d_vector_field), intent(in) :: rhs The right hand side of the linear(ised) system. integer, intent(in) :: bound_loc Which boundary is being set. The boundary will be the one\n normal to dimension of number abs(boundary) . If the\n argument is negative, then the lower boundary is returned. If\n positive, then the upper boundary is returned. class(vector_field), intent(in) :: bound_val The value of the result at the specified boundary. integer, intent(in), optional :: good_bound If provided, indicates which boundary contains trusted\n information from which to calculate the power of the highest\n frequency mode. Defaults to the opposite of bound_loc . Return Value class(vector_field),\n  pointer Source Code type , public :: pseudospec_block !* Author: Chris MacMackin !  Date: December 2016 ! ! A data type representing a matrix pseudospectral differentiation ! operator. It can be useful when preconditioning systems which ! use a spectral discretisation, if higher accuracy than finite ! difference is needed. It is inherently 1-D in its ! implementation. Note that multiplication of a field will simply ! call that field's differentiation operator, which may or may not ! use a pseudospectral method. ! private real ( r8 ), dimension (:), pointer :: xvals !! Coordinates of collocation points. contains private procedure :: pseudospec_block_solve_scalar procedure :: pseudospec_block_solve_vector generic , public :: solve_for => pseudospec_block_solve_scalar , & pseudospec_block_solve_vector end type pseudospec_block"},{"title":"jacobian_block – ISOFT ","tags":"","loc":"type/jacobian_block.html","text":"type, public :: jacobian_block A data type representing a submatrix of a\n Jacobian. Specifically, it represents the commonly occurring\n operation \\frac{\\partial F}{\\partial x_i} + F\\Delta_i, where \\Delta_i is the differentiation operator in the i -direction. Optionally, there can be an additional\n differentiation operator on the right-hand-side of this. This data type is useful when constructing a preconditioner. A\n preconditioner, A , should approximate the inverse Jacobian of\n a problem being solved. Rather than directly computing the\n inverse Jacobian, it is more efficient to approximate it. If d is the vector being preconditioned, and z is the\n result of applying the preconditioner, then z = J&#94;{-1}d\n \\Rightarrow Jz = d. Thus, the preconditioner can be applied\n by approximately solving this system for z . Linearising J , this system can be solved efficiently using Picard\n iteration. Say that the Jacobian is an n\\times n system of these blocks\n (each labeled as J_{j,k} ) and that the vector being\n preconditioned constists of n scalar fields ( d_j ). Then\n the m&#94;{th} estimate of the solution for the j&#94;{th} field\n in the preconditioned vector ( z&#94;m_j ) is the solution to J_{j,j}z&#94;m_j = d_j - \\sum_{\\substack{k=1\\ k\\ne j}}&#94;n\n J_{j,k}z&#94;{m-1}_k. Depending on the type of fields being used\n and the direction in which derivatives are being taken, J_{j,j} may be tridiaganol, meaning it can be solved\n efficiently. For this purpose, a type-bound multiplication operator is\n provided for the Jacobian block type, which can be used when\n evaluating the right hand side of the linear system. There is\n also a solve_for method, which takes as an argument the field\n representing the right hand side of the system. Boundary conditions are a complicated issue. When constructing\n an instance of this type, locations in the raw field\n representation can be specified for which boundary conditions\n are given. By default these are all Dirichlet conditions, but\n this behaviour may be overridden to be Neumann conditions. Note\n that Neumann conditions result in approximately an order of\n magnitude lower accuracy. When using the Jacobian block for\n multiplation, the type of the boundary does not matter; the\n value at the boundary in the result will be set to 0 or to\n values produced by an optional user-provided function. When\n using the solve_for method, the tridiagonal matrix will be\n altered in the specified locations to reflect the correct\n boundary conditions. This effectively mimics the sorts of\n Jacobian rows typically produced by boundary conditions. Inherits type~~jacobian_block~~InheritsGraph type~jacobian_block jacobian_block type~jacobian_block->type~jacobian_block block_increment scalar_field scalar_field type~jacobian_block->scalar_field contents, derivative, field_increment Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~jacobian_block~~InheritedByGraph type~jacobian_block jacobian_block type~jacobian_block->type~jacobian_block block_increment type~ice_shelf ice_shelf type~ice_shelf->type~jacobian_block thickness_jacobian, velocity_jacobian Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables direction extra_derivative contents coef get_boundaries derivative diagonal super_diagonal sub_diagonal l_multipliers u_diagonal u_superdiagonal1 u_superdiagonal2 pivots boundary_vals boundary_locs boundary_types real_increment field_increment block_increment has_increment Constructor jacobian_block Type-Bound Procedures jacobian_block_multiply jacobian_block_add_real jacobian_block_add_field jacobian_block_add_block jacobian_block_assign get_tridiag operator(*) operator(+) assignment(=) solve_for Source Code jacobian_block Components Type Visibility Attributes Name Initial integer, private :: direction The direction in which any derivatives are taken. integer, private :: extra_derivative = no_extra_derivative The direction in which to apply a differentiation on the\n right-hand-side of the Jacobian block operator. Defaults\n none. class(scalar_field), private, allocatable :: contents The value, A , to which the Jacobian block operation is\n beiing applied. real(kind=r8), private :: coef = 1._r8 Optional coefficient by which the the \\partial F/\\partial x term in the operator will be multiplied. procedure( jacobian_block_bounds ), private, pointer, nopass :: get_boundaries A subroutine which determines the expected boundary conditions\n (and their location in the raw array) for the solution of the\n Jacobian block. class(scalar_field), private, allocatable :: derivative The cached derivative of contents real(kind=r8), private, dimension(:), allocatable :: diagonal The diagonal of the tridiagonal matrix representation of this\n block. real(kind=r8), private, dimension(:), allocatable :: super_diagonal The super-diagonal of the tridiagonal matrix representation\n of this block. real(kind=r8), private, dimension(:), allocatable :: sub_diagonal The sub-diagonal of the tridiagonal matrix representation of\n this block. real(kind=r8), private, dimension(:), allocatable :: l_multipliers Multipliers defining the L matrix in the LU factorisation of\n the tridiagonal matrix representation of this block. real(kind=r8), private, dimension(:), allocatable :: u_diagonal The diagonal of the U matrix in the LU factorisation of\n the tridiagonal matrix representation of this block. real(kind=r8), private, dimension(:), allocatable :: u_superdiagonal1 The first superdiagonal of the U matrix in the LU\n factorisation of the tridiagonal matrix representation of\n this block. real(kind=r8), private, dimension(:), allocatable :: u_superdiagonal2 The second superdiagonal of the U matrix in the LU\n factorisation of the tridiagonal matrix representation of\n this block. integer, private, dimension(:), allocatable :: pivots Pivot indicies from the LU factorisation of the tridiagonal\n matrix representation of this block. real(kind=r8), private, dimension(:), allocatable :: boundary_vals Expected boundary values for the solution to the Jacobian\n block. integer, private, dimension(:), allocatable :: boundary_locs Locations in the raw arrays which are used to specify\n boundary conditions. integer, private, dimension(:), allocatable :: boundary_types The types of boundary conditions, specified using the\n parameters found in boundary_types_mod . real(kind=r8), private :: real_increment A scalar value which is to be added to this Jacobian block\n (i.e. to the diagonal). class(scalar_field), private, allocatable :: field_increment A scalar field which is to be added to this Jacobian block\n (i.e. to the diagonal). type( jacobian_block ), private, pointer :: block_increment => null() Another Jacobian block which is to be added to this one integer, private :: has_increment = 0 Indicates whether or not there has been an increment added to\n this block. If not, then 0. If a scalar real value has been\n added, then 1. If a scalar value has been added, then 2. Constructor public interface jacobian_block private function constructor (source_field, direction, extra_derivative, boundary_locs, boundary_types, boundary_operations, coef) result(this) Author Chris MacMackin Date December 2016 Build a block in a Jacobian matrix, with the form \\frac{\\partial F}{\\partial x_i} + F\\Delta_i, where F is\n a scalar field and \\Delta_i is the differentiation operator\n in the i -direction. Additionally, a further differentiation\n operator may be added to the right hand side of this matrix\n block.  Optional arguments allow for handling of boundary\n conditions. See the end of the documentation of the jacobian_block type for a description of how boundary\n conditions are treated. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: source_field A scalar field ( F ) making up this block of the Jacobian integer, intent(in) :: direction The direction in which field derivatives are taken. integer, intent(in), optional :: extra_derivative If present, specifies the direction of a differentiation\n operator to be added to the right hand side of this matrix\n block. integer, intent(in), optional dimension(:) :: boundary_locs The locations in the raw representation of rhs for which\n boundary conditions are specified. Defaults to there being\n none. integer, intent(in), optional dimension(:) :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. Defaults to Dirichlet. The\n order in which they are stored must match that of boundary_locs . procedure( jacobian_block_bounds ), optional :: boundary_operations A function specifying the values to place at the boundaries\n of the result when using the Jacobian block for\n multiplication. By default, all boundaries are set to 0. The\n order in which the resulting values are stored should match\n that of boundary_locs . real(kind=r8), intent(in), optional :: coef An optional coefficient by which the the \\partial\n F/\\partial x term in the operator will be\n multipled. Default value is 1. Return Value type( jacobian_block ) A new Jacobian block Type-Bound Procedures procedure, private :: jacobian_block_multiply private recursive function jacobian_block_multiply (this, rhs) result(product) Author Chris MacMackin Date December 2016 Provides a matrix multiplication operator between a Jacobian\n block and a scalar field (which corresponds to a state vector). Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class(scalar_field), intent(in) :: rhs A field corresponding to a state vector being multiplied by\n the Jacobian block. Return Value class(scalar_field),\n  pointer procedure, private :: jacobian_block_add_real private function jacobian_block_add_real (this, rhs) result(sum) Author Chris MacMackin Date December 2016 Produces a Jacobian block which has been offset by some constant\n increment. Read more… Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this real(kind=r8), intent(in) :: rhs A scalar which should be added to this block Return Value type( jacobian_block ) procedure, private :: jacobian_block_add_field private function jacobian_block_add_field (this, rhs) result(sum) Author Chris MacMackin Date May 2017 Produces a Jacobian block which has been offset by a scalar\n field. Read more… Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class(scalar_field), intent(in) :: rhs A scalar which should be added to this block Return Value type( jacobian_block ) procedure, private :: jacobian_block_add_block private function jacobian_block_add_block (this, rhs) result(sum) Author Chris MacMackin Date May 2017 Produces a Jacobian block which is the sum of two existing\n blocks. Boundary conditions are set by the first operand\n ( this ). Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class( jacobian_block ), intent(in), target :: rhs A second block which should be added to this block Return Value type( jacobian_block ) procedure, private :: jacobian_block_assign private subroutine jacobian_block_assign (this, rhs) Author Chris MacMackin Date December 2016 Copies the contents of the rhs Jacobian block into this\n one. It will safely deallocate any data necessary. Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(out) :: this type( jacobian_block ), intent(in) :: rhs procedure, private :: get_tridiag => jacobian_block_get_tridiag private recursive subroutine jacobian_block_get_tridiag (this, diagonal, subdiagonal, superdiagonal) Author Chris MacMackin Date May 2017 Computes the tridiagonal matrix used to solve for this Jacobian block. Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this real(kind=r8), intent(out), dimension(:), allocatable :: diagonal real(kind=r8), intent(out), dimension(:), allocatable :: subdiagonal real(kind=r8), intent(out), dimension(:), allocatable :: superdiagonal generic, public :: operator(*) => jacobian_block_multiply private recursive function jacobian_block_multiply (this, rhs) result(product) Author Chris MacMackin Date December 2016 Provides a matrix multiplication operator between a Jacobian\n block and a scalar field (which corresponds to a state vector). Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class(scalar_field), intent(in) :: rhs A field corresponding to a state vector being multiplied by\n the Jacobian block. Return Value class(scalar_field),\n  pointer generic, public :: operator(+) => jacobian_block_add_real , jacobian_block_add_field , jacobian_block_add_block private function jacobian_block_add_real (this, rhs) result(sum) Author Chris MacMackin Date December 2016 Produces a Jacobian block which has been offset by some constant\n increment. Read more… Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this real(kind=r8), intent(in) :: rhs A scalar which should be added to this block Return Value type( jacobian_block ) private function jacobian_block_add_field (this, rhs) result(sum) Author Chris MacMackin Date May 2017 Produces a Jacobian block which has been offset by a scalar\n field. Read more… Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class(scalar_field), intent(in) :: rhs A scalar which should be added to this block Return Value type( jacobian_block ) private function jacobian_block_add_block (this, rhs) result(sum) Author Chris MacMackin Date May 2017 Produces a Jacobian block which is the sum of two existing\n blocks. Boundary conditions are set by the first operand\n ( this ). Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class( jacobian_block ), intent(in), target :: rhs A second block which should be added to this block Return Value type( jacobian_block ) generic, public :: assignment(=) => jacobian_block_assign private subroutine jacobian_block_assign (this, rhs) Author Chris MacMackin Date December 2016 Copies the contents of the rhs Jacobian block into this\n one. It will safely deallocate any data necessary. Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(out) :: this type( jacobian_block ), intent(in) :: rhs procedure, public :: solve_for => jacobian_block_solve private function jacobian_block_solve (this, rhs) result(solution) Author Chris MacMackin Date December 2016 Solves the linear(ised) system represented by this Jacobian\n block, for a given right hand side state vector (represented by\n a scalar field). Read more… Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. Return Value class(scalar_field),\n  pointer Source Code type , public :: jacobian_block !* Author: Chris MacMackin !  Date: December 2016 ! ! A data type representing a submatrix of a ! Jacobian. Specifically, it represents the commonly occurring ! operation  \\frac{\\partial F}{\\partial x_i} + F\\Delta_i,  ! where  \\Delta_i  is the differentiation operator in the ! i-direction. Optionally, there can be an additional ! differentiation operator on the right-hand-side of this. ! ! This data type is useful when constructing a preconditioner. A ! preconditioner, A, should approximate the inverse Jacobian of ! a problem being solved. Rather than directly computing the ! inverse Jacobian, it is more efficient to approximate it. If ! d is the vector being preconditioned, and z is the ! result of applying the preconditioner, then  z = J&#94;{-1}d ! \\Rightarrow Jz = d. Thus, the preconditioner can be applied ! by approximately solving this system for z. Linearising ! J, this system can be solved efficiently using Picard ! iteration. ! ! Say that the Jacobian is an n\\times n system of these blocks ! (each labeled as J_{j,k}) and that the vector being ! preconditioned constists of n scalar fields (d_j). Then ! the m&#94;{th} estimate of the solution for the j&#94;{th} field ! in the preconditioned vector (z&#94;m_j) is the solution to  ! J_{j,j}z&#94;m_j = d_j - \\sum_{\\substack{k=1\\ k\\ne j}}&#94;n ! J_{j,k}z&#94;{m-1}_k.  Depending on the type of fields being used ! and the direction in which derivatives are being taken, ! J_{j,j} may be tridiaganol, meaning it can be solved ! efficiently. <!--Otherwise, it can be approximated that  ! J_{j,j}z&#94;m_j = \\left(\\frac{\\partial F}{\\partial x_i} + ! F\\Delta_i\\right)z&#94;{m} \\simeq \\frac{\\partial F}{\\partial ! x_i}z&#94;m_j + F\\frac{\\partial z&#94;{m-1}_j}{\\partial x_i}.  The ! first term in this approximation corresponds to a diagonal ! matrix (which can be solved trivially), while the second term is ! known and can be subtracted from the right-hand-side of the ! linear system.--> ! ! For this purpose, a type-bound multiplication operator is ! provided for the Jacobian block type, which can be used when ! evaluating the right hand side of the linear system. There is ! also a `solve_for` method, which takes as an argument the field ! representing the right hand side of the system. <!--Before ! applying the latter operator, the `update_estimate` method must ! be called. This allows for the term involving derivative of the ! current estimate of the solution to be subtracted from the ! right-hand-side of the linear system, in cases where the system ! can not be expressed as a tridiagonal matrix.--> ! ! Boundary conditions are a complicated issue. When constructing ! an instance of this type, locations in the raw field ! representation can be specified for which boundary conditions ! are given. By default these are all Dirichlet conditions, but ! this behaviour may be overridden to be Neumann conditions. Note ! that Neumann conditions result in approximately an order of ! magnitude lower accuracy. When using the Jacobian block for ! multiplation, the type of the boundary does not matter; the ! value at the boundary in the result will be set to 0 or to ! values produced by an optional user-provided function. When ! using the `solve_for` method, the tridiagonal matrix will be ! altered in the specified locations to reflect the correct ! boundary conditions. This effectively mimics the sorts of ! Jacobian rows typically produced by boundary conditions. ! private integer :: direction !! The direction in which any derivatives are taken. integer :: extra_derivative = no_extra_derivative !! The direction in which to apply a differentiation on the !! right-hand-side of the Jacobian block operator. Defaults !! none. class ( scalar_field ), allocatable :: contents !! The value, A, to which the Jacobian block operation is !! beiing applied. real ( r8 ) :: coef = 1._r8 !! Optional coefficient by which the the \\partial F/\\partial x !!  term in the operator will be multiplied. procedure ( jacobian_block_bounds ), pointer , nopass :: & get_boundaries !! A subroutine which determines the expected boundary conditions !! (and their location in the raw array) for the solution of the !! Jacobian block. class ( scalar_field ), allocatable :: derivative !! The cached derivative of `contents` real ( r8 ), dimension (:), allocatable :: diagonal !! The diagonal of the tridiagonal matrix representation of this !! block. real ( r8 ), dimension (:), allocatable :: super_diagonal !! The super-diagonal of the tridiagonal matrix representation !! of this block. real ( r8 ), dimension (:), allocatable :: sub_diagonal !! The sub-diagonal of the tridiagonal matrix representation of !! this block. real ( r8 ), dimension (:), allocatable :: l_multipliers !! Multipliers defining the L matrix in the LU factorisation of !! the tridiagonal matrix representation of this block. real ( r8 ), dimension (:), allocatable :: u_diagonal !! The diagonal of the U matrix in the LU factorisation of !! the tridiagonal matrix representation of this block. real ( r8 ), dimension (:), allocatable :: u_superdiagonal1 !! The first superdiagonal of the U matrix in the LU !! factorisation of the tridiagonal matrix representation of !! this block. real ( r8 ), dimension (:), allocatable :: u_superdiagonal2 !! The second superdiagonal of the U matrix in the LU !! factorisation of the tridiagonal matrix representation of !! this block. integer , dimension (:), allocatable :: pivots !! Pivot indicies from the LU factorisation of the tridiagonal !! matrix representation of this block. real ( r8 ), dimension (:), allocatable :: boundary_vals !! Expected boundary values for the solution to the Jacobian !! block. integer , dimension (:), allocatable :: boundary_locs !! Locations in the raw arrays which are used to specify !! boundary conditions. integer , dimension (:), allocatable :: boundary_types !! The types of boundary conditions, specified using the !! parameters found in [[boundary_types_mod]]. real ( r8 ) :: real_increment !! A scalar value which is to be added to this Jacobian block !! (i.e. to the diagonal). class ( scalar_field ), allocatable :: field_increment !! A scalar field which is to be added to this Jacobian block !! (i.e. to the diagonal). type ( jacobian_block ), pointer :: block_increment => null () !! Another Jacobian block which is to be added to this one integer :: has_increment = 0 !! Indicates whether or not there has been an increment added to !! this block. If not, then 0. If a scalar real value has been !! added, then 1. If a scalar value has been added, then 2. contains private procedure :: jacobian_block_multiply procedure :: jacobian_block_add_real procedure :: jacobian_block_add_field procedure :: jacobian_block_add_block procedure :: jacobian_block_assign procedure :: get_tridiag => jacobian_block_get_tridiag generic , public :: operator ( * ) => jacobian_block_multiply generic , public :: operator ( + ) => jacobian_block_add_real , & jacobian_block_add_field , & jacobian_block_add_block generic , public :: assignment ( = ) => jacobian_block_assign procedure , public :: solve_for => jacobian_block_solve end type jacobian_block"},{"title":"coriolis_block – ISOFT ","tags":"","loc":"type/coriolis_block.html","text":"type, public :: coriolis_block A data type representing a matrix operator for the momentum\n components of the linear parts plume equations, with the\n Coriolis force. It can be useful when preconditioning a the\n plume solver. It is inherently 1-D in its implementation, but\n has a transverse velocity component. This type solves the linear, coupled, differential equation \\frac{d}{dx} \\bm{Y} = \\bm{A}\\bm{Y} + \\bm{F} where \\bm{Y} = [U, V, U', V']&#94;{T} ,\n [ \\bm{A} = \\begin{bmatrix}\n 0        & 0         & 1 & 0 \\    ! 0        & 0         & 0 & 1 \\    ! 0        & -\\Phi/\\nu & 0 & 0 \\    ! \\Phi/\\nu & 0         & 0 & 0 Inherits type~~coriolis_block~~InheritsGraph type~coriolis_block coriolis_block type~pseudospec_block pseudospec_block type~coriolis_block->type~pseudospec_block integrator cheb1d_scalar_field cheb1d_scalar_field type~coriolis_block->cheb1d_scalar_field emDxVinv_r, emDxVinv_i, eDx_r, eDx_i Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~coriolis_block~~InheritedByGraph type~coriolis_block coriolis_block type~asym_plume asym_plume type~asym_plume->type~coriolis_block vel_precond Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables D_r D_i emDxVinv_r emDxVinv_i eDx_r eDx_i V_r V_i integrator vel_bound_loc dvel_bound_loc integrate_bound xbounds bound_matrix bound_matrix_scaled factored_matrix pivots r_scales c_scales equed int Constructor coriolis_block Type-Bound Procedures solve_for assign assignment(=) Source Code coriolis_block Components Type Visibility Attributes Name Initial real(kind=r8), private, dimension(4) :: D_r Real component of the diagonal matrix, \\bm{D} , with only\n diagonal values stored real(kind=r8), private, dimension(4) :: D_i Imaginary component of the diagonal matrix, \\bm{D} , with\n only diagonal values stored type(cheb1d_scalar_field), private, dimension(4,4) :: emDxVinv_r Real component of e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1} type(cheb1d_scalar_field), private, dimension(4,4) :: emDxVinv_i Imaginary component of e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1} type(cheb1d_scalar_field), private, dimension(4) :: eDx_r Real component of e&#94;{\\bm{D}x} , with only diagonal values\n stored type(cheb1d_scalar_field), private, dimension(4) :: eDx_i Imaginary component of e&#94;{\\bm{D}x} , with only diagonal\n values stored real(kind=r8), private, dimension(4,4) :: V_r Real component of the change of basis matrix, \\bm{V} real(kind=r8), private, dimension(4,4) :: V_i Imaginary component of the change of basis matrix, \\bm{V} type( pseudospec_block ), private :: integrator A pseudospectral differentiation block which can be used to\n perform integration integer, private :: vel_bound_loc Location code for the velocity's boundary condition integer, private :: dvel_bound_loc Location code for the velocity derivative's boundary\n condition integer, private :: integrate_bound Location from which to perform the integration real(kind=r8), private, dimension(4) :: xbounds Boundary location for each component of the solution vector complex(kind=r8), private, dimension(4,4) :: bound_matrix Matrix for the system to solve in order to satisfy the\n boundary conditions complex(kind=r8), private, dimension(4,4) :: bound_matrix_scaled Matrix for the system to solve in order to satisfy the\n boundary conditions, which has been scaled by LAPACK95 \n to improve conditioning. complex(kind=r8), private, dimension(4,4) :: factored_matrix Factored matrix for the system to solve in order to satisfy\n the boundary conditions integer, private, dimension(4) :: pivots The pivots used in the factorisation of the matrix used to\n satisfy boundary conditions real(kind=r8), private, dimension(4) :: r_scales Row scale factors from equilibrating the bound_matrix real(kind=r8), private, dimension(4) :: c_scales Column scale factors from equilibrating the bound_matrix character(len=1), private :: equed The method used to equilibrate bound_matrix integer, private :: int Constructor public interface coriolis_block private function constructor (phi, nu, velbound, dvelbound, integrate_bound, template) result(this) Author Chris MacMackin Date January 2018 Builds a Coriolis block which can be used to solve the inverse\n problem for the linear components of the plume momentum\n equations. The result can only be used with fields having the\n same grid as the template. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: phi The dimensionless coriolis parameter real(kind=r8), intent(in) :: nu The dimensionless eddy diffusivity integer, intent(in) :: velbound Location code for the velocity's boundary condition. 1\n indicates upper boundary, -1 indicates lower boundary. integer, intent(in) :: dvelbound Location code for the velocity's boundary condition. 1\n indicates upper boundary, -1 indicates lower boundary. integer, intent(in) :: integrate_bound Location code for the boundary to perform integrations\n from. This should be the opposite boundary from where\n boundary data is stored. class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. Return Value type( coriolis_block ) Type-Bound Procedures procedure, public :: solve_for private subroutine solve_for (this, velocity, velocity_dx) Author Chris MacMackin Date January 2018 Inverts the linear portions of the plume momentum equation with\n the provided data. This is done by solving the linear ODE\n described in the documentation for the coriolis_block type. The block object must first have been initialised using\n the constructor. Read more… Arguments Type Intent Optional Attributes Name class( coriolis_block ), intent(inout) :: this class(vector_field), intent(inout) :: velocity On input, the velocity value being preconditioned. On output,\n the preconditioned velocity. class(vector_field), intent(inout) :: velocity_dx On input, the velocity derivative being preconditioned. On\n output, the preconditioned velocity derivative. procedure, private :: assign private subroutine assign (this, rhs) Author Chris MacMackin Date January 2017 Safely assigns the value of one coriolis block to another. Arguments Type Intent Optional Attributes Name class( coriolis_block ), intent(inout) :: this class( coriolis_block ), intent(in) :: rhs The value being assigned generic, public :: assignment(=) => assign private subroutine assign (this, rhs) Author Chris MacMackin Date January 2017 Safely assigns the value of one coriolis block to another. Arguments Type Intent Optional Attributes Name class( coriolis_block ), intent(inout) :: this class( coriolis_block ), intent(in) :: rhs The value being assigned Source Code type , public :: coriolis_block !* Author: Chris MacMackin !  Date: January 2017 ! ! A data type representing a matrix operator for the momentum ! components of the linear parts plume equations, with the ! Coriolis force. It can be useful when preconditioning a the ! plume solver. It is inherently 1-D in its implementation, but ! has a transverse velocity component. ! ! This type solves the linear, coupled, differential equation !  \\frac{d}{dx} \\bm{Y} = \\bm{A}\\bm{Y} + \\bm{F}  ! where  \\bm{Y} = [U, V, U', V']&#94;{T} , !  \\bm{A} = \\begin{bmatrix} ! 0        & 0         & 1 & 0 \\\\ ! 0        & 0         & 0 & 1 \\\\ ! 0        & -\\Phi/\\nu & 0 & 0 \\\\ ! \\Phi/\\nu & 0         & 0 & 0 ! \\end{bmatrix}, !  ! and  \\bm{F}  is the input value to which this block is ! applied in the preconditioner. \\Phi is the dimensionless ! coriolis parameter, while \\nu is the eddy viscosity. ! ! The matrix \\bm{A} can be diagonalised by factoring it such ! that \\bm{A} = \\bm{V}\\bm{D}\\bm{V}&#94;{-1}, where \\bm{V} is a ! change of basis matrix with columns made up of the eigenvectors ! of \\bm{A} and \\bm{D} is a diagonal matrix made up of ! the corresponding eigenvalues. These have the values !  \\bm{V} = \\begin{bmatrix} ! \\tfrac{-1-i}{\\alpha} & \\tfrac{-1+i}{\\alpha} & \\tfrac{1-i}{\\alpha} & \\tfrac{1+i}{\\alpha} \\\\ ! \\tfrac{-1+i}{\\alpha} & \\tfrac{-1-i}{\\alpha} & \\tfrac{1+i}{\\alpha} & \\tfrac{1-i}{\\alpha} \\\\ ! i                    & -i                   & -i                  & i                   \\\\ ! 1                    & 1                    & 1                   & 1 ! \\end{bmatrix}, !  !  \\bm{D} = \\beta\\begin{bmatrix} ! -1-i & 0    & 0   & 0   \\\\ ! 0    & -1+i &     & 0   \\\\ ! 0    & 0    & 1-i & 0   \\\\ ! 0    & 0    & 0   & 1+i ! \\end{bmatrix}, !  !  \\bm{V}&#94;{-1} = \\frac{1}{4}\\begin{bmatrix} ! (-1+i)\\beta & -(1+i)\\beta & -i & 1 \\\\ ! (-1-i)\\beta & -(1-i)\\beta & i  & 1 \\\\ ! (1+i)\\beta  & (1-i)\\beta  & i  & 1 \\\\ ! (1-i)\\beta  & (1+i)\\beta  & -i & 1 ! \\end{bmatrix}, !  !  \\alpha = \\sqrt{\\frac{2\\Phi}{\\nu}}, \\quad \\beta = \\sqrt{\\frac{\\Phi}{2\\nu}}.  ! It can be shown that the solution to the differential equation is !  \\bm{Y} = \\bm{V}\\left(e&#94;{\\bm{D}x}\\bm{B} + !    e&#94;{\\bm{D}x}\\int_0&#94;{x}e&#94;{\\bm{D}x'}\\bm{V}&#94;{-1}\\bm{F}dx' \\right), ! where \\bm{B}\\in\\mathbb{R}&#94;{4} is a vector chosen to satisfy ! the boundary conditions on the system. It can be found by solving a ! 4×4 linear system. ! ! This type inherits ! private real ( r8 ), dimension ( 4 ) :: D_r !! Real component of the diagonal matrix, \\bm{D}, with only !! diagonal values stored real ( r8 ), dimension ( 4 ) :: D_i !! Imaginary component of the diagonal matrix, \\bm{D}, with !! only diagonal values stored type ( cheb1d_scalar_field ), dimension ( 4 , 4 ) :: emDxVinv_r !! Real component of e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1} type ( cheb1d_scalar_field ), dimension ( 4 , 4 ) :: emDxVinv_i !! Imaginary component of e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1} type ( cheb1d_scalar_field ), dimension ( 4 ) :: eDx_r !! Real component of e&#94;{\\bm{D}x}, with only diagonal values !! stored type ( cheb1d_scalar_field ), dimension ( 4 ) :: eDx_i !! Imaginary component of e&#94;{\\bm{D}x}, with only diagonal !! values stored real ( r8 ), dimension ( 4 , 4 ) :: V_r !! Real component of the change of basis matrix, \\bm{V} real ( r8 ), dimension ( 4 , 4 ) :: V_i !! Imaginary component of the change of basis matrix, \\bm{V} type ( pseudospec_block ) :: integrator !! A pseudospectral differentiation block which can be used to !! perform integration integer :: vel_bound_loc !! Location code for the velocity's boundary condition integer :: dvel_bound_loc !! Location code for the velocity derivative's boundary !! condition integer :: integrate_bound !! Location from which to perform the integration real ( r8 ), dimension ( 4 ) :: xbounds !! Boundary location for each component of the solution vector complex ( r8 ), dimension ( 4 , 4 ) :: bound_matrix !! Matrix for the system to solve in order to satisfy the !! boundary conditions complex ( r8 ), dimension ( 4 , 4 ) :: bound_matrix_scaled !! Matrix for the system to solve in order to satisfy the !! boundary conditions, which has been scaled by LAPACK95 !! to improve conditioning. complex ( r8 ), dimension ( 4 , 4 ) :: factored_matrix !! Factored matrix for the system to solve in order to satisfy !! the boundary conditions integer , dimension ( 4 ) :: pivots !! The pivots used in the factorisation of the matrix used to !! satisfy boundary conditions real ( r8 ), dimension ( 4 ) :: r_scales !! Row scale factors from equilibrating the bound_matrix real ( r8 ), dimension ( 4 ) :: c_scales !! Column scale factors from equilibrating the bound_matrix character ( len = 1 ) :: equed !! The method used to equilibrate bound_matrix integer :: int contains private procedure , public :: solve_for procedure :: assign generic , public :: assignment ( = ) => assign end type coriolis_block"},{"title":"plume – ISOFT ","tags":"","loc":"type/plume.html","text":"type, public, extends( basal_surface ) :: plume A concrete implementation of the basal_surface abstract data type, representing the buoyant plume beneath an\n ice shelf. Inherits type~~plume~~InheritsGraph type~plume plume type~abstract_melt_relationship abstract_melt_relationship type~plume->type~abstract_melt_relationship melt_formulation type~basal_surface basal_surface type~plume->type~basal_surface type~ambient_conditions ambient_conditions type~plume->type~ambient_conditions ambient_conds type~plume_boundary plume_boundary type~plume->type~plume_boundary boundaries cheb1d_scalar_field cheb1d_scalar_field type~plume->cheb1d_scalar_field thickness, temperature, temperature_dx, salinity, salinity_dx cheb1d_vector_field cheb1d_vector_field type~plume->cheb1d_vector_field velocity, velocity_dx type~pseudospec_block pseudospec_block type~plume->type~pseudospec_block precond type~abstract_entrainment abstract_entrainment type~plume->type~abstract_entrainment entrainment_formulation type~equation_of_state equation_of_state type~plume->type~equation_of_state eos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thickness velocity velocity_dx temperature temperature_dx salinity salinity_dx entrainment_formulation melt_formulation ambient_conds eos boundaries delta nu mu r_val phi time thickness_size velocity_size temperature_size salinity_size lower_bounds upper_bounds precond Type-Bound Procedures initialise basal_melt basal_drag_parameter water_density update data_size state_vector read_data write_data solve Source Code plume Components Type Visibility Attributes Name Initial type(cheb1d_scalar_field), private :: thickness The thickness of the plume type(cheb1d_vector_field), private :: velocity The velocity of the plume type(cheb1d_vector_field), private :: velocity_dx The derivative of the velocity field type(cheb1d_scalar_field), private :: temperature The temperature of the plume type(cheb1d_scalar_field), private :: temperature_dx The derivative of the temperature of the plume type(cheb1d_scalar_field), private :: salinity The salinity of the plume type(cheb1d_scalar_field), private :: salinity_dx The derivative of the salinity of the plume class( abstract_entrainment ), private, allocatable :: entrainment_formulation An object which provides the parameterisation for entrainment\n of water into the plume. class( abstract_melt_relationship ), private, allocatable :: melt_formulation An object which provides the parameterisation for melting,\n salt, and heat fluxes from the plume to the ice. class( ambient_conditions ), private, allocatable :: ambient_conds An object specifying the temperature and salinity of the\n ambient ocean at its interface with the plume. class( equation_of_state ), public, allocatable :: eos An object specifying the equation of state relating the plume\n water's density to its temperature and salinity. class( plume_boundary ), private, allocatable :: boundaries An object specifying the boundary conditions for the plume. real(kind=r8), private :: delta The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real(kind=r8), public :: nu The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real(kind=r8), private :: mu The dimensionless ratio \\mu \\equiv \\frac{C_dx_0}{D_0} real(kind=r8), private :: r_val The dimensionless ratio of the ocean water density to the\n density of the overlying ice shelf. real(kind=r8), public :: phi The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} real(kind=r8), private :: time The time at which the ice shelf is in this state integer, private :: thickness_size The number of data values in the thickness field integer, private :: velocity_size The number of data values in the velocity field integer, private :: temperature_size The number of data values in the temperature field integer, private :: salinity_size the number of data values in the salinity field logical, private, dimension(7) :: lower_bounds = .false. Which variables have boundary conditions at the grounding\n line. logical, private, dimension(7) :: upper_bounds = .false. Which variables have boundary conditions at the calving\n front. type( pseudospec_block ), private :: precond A pseudospectral differentiation block which can be used for\n preconditioning. Type-Bound Procedures procedure, public :: initialise => plume_initialise private subroutine plume_initialise (this, domain, resolution, thickness, velocity, temperature, salinity, entrainment_formulation, melt_formulation, ambient_conds, eos, boundaries, delta, nu, mu, r_val, phi) Author Christopher MacMackin Date April 2016 Instantiates a plume object with initial coniditions\n provided by the arguments.At present only a 1D model is\n supported. If information is provided for higher dimensions then\n it will be ignored. Arguments Type Intent Optional Attributes Name class( plume ), intent(out) :: this A plume object with its domain and initial conditions set according\n to the arguments of the constructor function. real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the plume. The first index represents the dimension for which the\n boundaries apply. If the second index is 1 then it corresponds to\n the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( scalar_func ) :: thickness A function which calculates the initial value of the thickness of \n the plume at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the water at a given location in a plume. procedure( scalar_func ) :: temperature A function which calculates the initial value of the temperature of \n the plume at a given location. procedure( scalar_func ) :: salinity A function which calculates the initial value of the salinity of \n the plume at a given location. class( abstract_entrainment ), intent(inout), optional allocatable :: entrainment_formulation An object which calculates entrainment into the plume. Will\n be unallocated on exit. Defaults to that used by Jenkins\n (1991) with the coefficient $E_0 = 1$. class( abstract_melt_relationship ), intent(inout), optional allocatable :: melt_formulation An object which calculates melting and the resulting thermal\n transfer into/out of the plume. Will be unallocated on\n exit. Defaults to that used by Dallaston et al. (2015),\n scaled to be consistent with the nondimensionalisation used\n here. class( ambient_conditions ), intent(inout), optional allocatable :: ambient_conds An object specifying the salinity and temperature of the\n ambient ocean. Will be unallocated on exit. Defaults to\n uniform ambient salinity and temperature, both of which are\n set to 0 (as temperature and salinity are measured relative\n to some reference value). class( equation_of_state ), intent(inout), optional allocatable :: eos An object specifying the equation of state for the water in\n the plume. Will be unallocated on exit. Defaults to\n linearised equation of state with no temperature dependence\n and a haline contraction coefficient of 1. The reference\n density is set to be 1 in the dimensionless units when\n salinity and temeprature are 0. class( plume_boundary ), intent(inout), optional allocatable :: boundaries An object providing the boundary conditions for the\n plume. Will be unallocated on exit. Defaults to those used by\n Dallaston et al. (2015). real(kind=r8), intent(in), optional :: delta The dimensionless ratio \\delta \\equiv\n \\frac{D_0}{h_0} . Defaults to 0.036. real(kind=r8), intent(in), optional :: nu The dimensionless ratio \\nu \\equiv\n \\frac{\\kappa_0}{x_0U_o} . Defaults to 0. real(kind=r8), intent(in), optional :: mu The dimensionless ratio \\mu \\equiv\n \\frac{\\C_dx_0}{D_0} . Defaults to 0. real(kind=r8), intent(in), optional :: r_val The dimensionless ratio of the water density to the ice shelf\n density, r = \\rho_0/\\rho_i. Defaults to 1.12. real(kind=r8), intent(in), optional :: phi The inverse Rossby number, \\Phi \\equif\n \\frac{fx_0}{U_0} . Defaults to 0. procedure, public :: basal_melt => plume_melt private function plume_melt (this) result(melt) Author Christopher MacMackin Date April 2016 Computes and returns the melt rate at the bottom of the ice\n shelf due to interaction with the plume. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice shelf. procedure, public :: basal_drag_parameter => plume_drag_parameter private function plume_drag_parameter (this) result(drag) Author Christopher MacMackin Date April 2016 Computes and returns a quantity which may be necessary to determine\n the frictional drag the plume exerts on the bottom of the ice\n shelf. The plume would actually tend to exert no drag on the bottom\n of the ice shelf, but this method is present so that there is a\n consistent interface with the ground data type. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. procedure, public :: water_density => plume_water_density private function plume_water_density (this) result(density) Author Christopher MacMackin Date April 2016 Computes and returns the density of the plume water beneath the ice\n shelf. The density of this water would vary depending on how much \n saline ambient water has been entrained into the plume versus how\n much fresh water has been released due to melting. However, the\n Boussinesq approximation is used here and only a single reference \n density is returned. Read more… Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value real(kind=r8) The density of the water at the base of the ice sheet. procedure, public :: update => plume_update private subroutine plume_update (this, state_vector, ice_thickness) Author Christopher MacMackin Date April 2016 Updates the state of the plume from its state vector. The state\n vector is a real array containing the value of each of the plume's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( plume ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n plume. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate. procedure, public :: data_size => plume_data_size private function plume_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the plume's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value integer The number of elements in the plume's state vector. procedure, public :: state_vector => plume_state_vector private function plume_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the plume. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the plume. procedure, public :: read_data => plume_read_data private subroutine plume_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the plume object from an HDF file in the\n specified group. This sets the thickness, velocity, temperature,\n salinity dataset, and parameter values. Arguments Type Intent Optional Attributes Name class( plume ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: write_data => plume_write_data private subroutine plume_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the plume object to an HDF file in the\n specified group. This will consist of a thickness, a velocity, a\n temperature, and a salinity dataset. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: solve => plume_solve private subroutine plume_solve (this, ice_thickness, ice_density, ice_temperature, time, success) Author Chris MacMackin Date March 2017 Solves the state of the plume for the specified ice properties,\n at the specified time. This is done using the a\n quasilinearisation method and a GMRES iterative linear solver. Arguments Type Intent Optional Attributes Name class( plume ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise Source Code type , extends ( basal_surface ), public :: plume !* Author: Christopher MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[basal_surface(type)]] ! abstract data type, representing the buoyant plume beneath an ! ice shelf. ! private type ( cheb1d_scalar_field ) :: thickness !! The thickness of the plume type ( cheb1d_vector_field ) :: velocity !! The velocity of the plume type ( cheb1d_vector_field ) :: velocity_dx !! The derivative of the velocity field type ( cheb1d_scalar_field ) :: temperature !! The temperature of the plume type ( cheb1d_scalar_field ) :: temperature_dx !! The derivative of the temperature of the plume type ( cheb1d_scalar_field ) :: salinity !! The salinity of the plume type ( cheb1d_scalar_field ) :: salinity_dx !! The derivative of the salinity of the plume class ( abstract_entrainment ), allocatable :: entrainment_formulation !! An object which provides the parameterisation for entrainment !! of water into the plume. class ( abstract_melt_relationship ), allocatable :: melt_formulation !! An object which provides the parameterisation for melting, !! salt, and heat fluxes from the plume to the ice. class ( ambient_conditions ), allocatable :: ambient_conds !! An object specifying the temperature and salinity of the !! ambient ocean at its interface with the plume. class ( equation_of_state ), allocatable , public :: eos !! An object specifying the equation of state relating the plume !! water's density to its temperature and salinity. class ( plume_boundary ), allocatable :: boundaries !! An object specifying the boundary conditions for the plume. real ( r8 ) :: delta !! The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real ( r8 ), public :: nu !! The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real ( r8 ) :: mu !! The dimensionless ratio \\mu \\equiv \\frac{C_dx_0}{D_0} real ( r8 ) :: r_val !! The dimensionless ratio of the ocean water density to the !! density of the overlying ice shelf. real ( r8 ), public :: phi !! The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} real ( r8 ) :: time !! The time at which the ice shelf is in this state integer :: thickness_size !! The number of data values in the thickness field integer :: velocity_size !! The number of data values in the velocity field integer :: temperature_size !! The number of data values in the temperature field integer :: salinity_size !! the number of data values in the salinity field logical , dimension ( 7 ) :: lower_bounds = . false . !! Which variables have boundary conditions at the grounding !! line. logical , dimension ( 7 ) :: upper_bounds = . false . !! Which variables have boundary conditions at the calving !! front. type ( pseudospec_block ) :: precond !! A pseudospectral differentiation block which can be used for !! preconditioning. contains procedure :: initialise => plume_initialise procedure :: basal_melt => plume_melt procedure :: basal_drag_parameter => plume_drag_parameter procedure :: water_density => plume_water_density procedure :: update => plume_update procedure :: data_size => plume_data_size procedure :: state_vector => plume_state_vector procedure :: read_data => plume_read_data procedure :: write_data => plume_write_data procedure :: solve => plume_solve end type plume"},{"title":"prescribed_eos – ISOFT ","tags":"","loc":"type/prescribed_eos.html","text":"type, public, extends( equation_of_state ) :: prescribed_eos An equation of state, depending only on salinity, where the\n salinity is prescribed such that SD = {\\rm constant} for\n some specified thickness D . The salinity is related to the\n density by the haline contraction coefficient \\beta_S . The\n only real use for this is testing and debugging the plume model. Inherits type~~prescribed_eos~~InheritsGraph type~prescribed_eos prescribed_eos type~equation_of_state equation_of_state type~prescribed_eos->type~equation_of_state scalar_field scalar_field type~prescribed_eos->scalar_field density Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables density beta_s Constructor prescribed_eos Type-Bound Procedures water_density prescribed_assign assignment(=) water_density_derivative haline_contraction thermal_contraction Source Code prescribed_eos Components Type Visibility Attributes Name Initial class(scalar_field), private, allocatable :: density The density calculated from the prescribed salinity real(kind=r8), private :: beta_s The haline contraction coefficient Constructor public interface prescribed_eos private function constructor (const, beta_s, thickness) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: const The constant to which SD is equal. real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S , relating\n salinity and density. class(scalar_field), intent(in) :: thickness The thickness of the plume, from which the salinity is calculated. Return Value type( prescribed_eos ) Type-Bound Procedures procedure, public :: water_density => prescribed_water_density private function prescribed_water_density (this, temperature, salinity) result(density) Author Chris MacMackin Date March 2017 Returns the density corresponding to the prescribed salinity, as\n calculated in the constructor. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water procedure, public, pass(rhs) :: prescribed_assign private subroutine prescribed_assign (lhs, rhs) Author Chris MacMackin Date March 2017 Assigns this object to another equation of state object,\n allowing the definided assignment for the precalculated density\n field to work correctly. Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(out) :: lhs class( prescribed_eos ), intent(in) :: rhs generic, public :: assignment(=) => prescribed_assign private subroutine prescribed_assign (lhs, rhs) Author Chris MacMackin Date March 2017 Assigns this object to another equation of state object,\n allowing the definided assignment for the precalculated density\n field to work correctly. Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(out) :: lhs class( prescribed_eos ), intent(in) :: rhs procedure, public :: water_density_derivative => prescribed_water_deriv private function prescribed_water_deriv (this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Author Chris MacMackin Date July 2017 Calculates the derivative of the water density. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the density of the water procedure, public :: haline_contraction => prescribed_haline_contraction private function prescribed_haline_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date June 2017 Returns the haline contraction coefficient. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable procedure, public :: thermal_contraction => prescribed_thermal_contraction private function prescribed_thermal_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date June 2017 Returns the thermal contraction coefficient. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Source Code type , extends ( equation_of_state ), public :: prescribed_eos !* Author: Chris MacMackin !  Date: March 2017 ! ! An equation of state, depending only on salinity, where the ! salinity is prescribed such that SD = {\\rm constant} for ! some specified thickness D. The salinity is related to the ! density by the haline contraction coefficient \\beta_S. The ! only real use for this is testing and debugging the plume model. ! private class ( scalar_field ), allocatable :: density !! The density calculated from the prescribed salinity real ( r8 ) :: beta_s !! The haline contraction coefficient contains procedure :: water_density => prescribed_water_density procedure , pass ( rhs ) :: prescribed_assign generic :: assignment ( = ) => prescribed_assign procedure :: water_density_derivative => prescribed_water_deriv procedure :: haline_contraction => prescribed_haline_contraction procedure :: thermal_contraction => prescribed_thermal_contraction end type prescribed_eos"},{"title":"equation_of_state – ISOFT ","tags":"","loc":"type/equation_of_state.html","text":"type, public, abstract :: equation_of_state An abstract type with a procedure for calculating water density\n from its temperature and salinity. Inherited by type~~equation_of_state~~InheritedByGraph type~equation_of_state equation_of_state type~asym_plume asym_plume type~asym_plume->type~equation_of_state eos type~linear_eos linear_eos type~linear_eos->type~equation_of_state type~static_plume static_plume type~static_plume->type~equation_of_state eos type~prescribed_eos prescribed_eos type~prescribed_eos->type~equation_of_state type~ave_linear_eos ave_linear_eos type~ave_linear_eos->type~equation_of_state type~plume plume type~plume->type~equation_of_state eos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures water_density water_density_derivative haline_contraction thermal_contraction Source Code equation_of_state Type-Bound Procedures procedure( get_property ), public, deferred :: water_density Returns the water density for the given temperature and salinity. function get_property(this, temperature, salinity) result(density) Prototype Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water procedure( get_property_dx ), public, deferred :: water_density_derivative Returns the derivative of the water density for the given\n temperature and salinity. function get_property_dx(this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Prototype Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the derivative of the density of the\n water in direction dir procedure( get_coef ), public, deferred :: haline_contraction Returns a (possibly approximated) haline contraction coefficient. function get_coef(this, temperature, salinity) result(coef) Prototype Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable procedure( get_coef ), public, deferred :: thermal_contraction Returns a (possibly approximated) therma contraction coefficient. function get_coef(this, temperature, salinity) result(coef) Prototype Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Source Code type , abstract , public :: equation_of_state !* Author: Chris MacMackin !  Date: April 2016 ! ! An abstract type with a procedure for calculating water density ! from its temperature and salinity. ! contains procedure ( get_property ), deferred :: water_density !! Returns the water density for the given temperature and salinity. procedure ( get_property_dx ), deferred :: water_density_derivative !! Returns the derivative of the water density for the given !! temperature and salinity. procedure ( get_coef ), deferred :: haline_contraction !! Returns a (possibly approximated) haline contraction coefficient. procedure ( get_coef ), deferred :: thermal_contraction !! Returns a (possibly approximated) therma contraction coefficient. end type equation_of_state"},{"title":"ground – ISOFT ","tags":"","loc":"type/ground.html","text":"type, public, extends( basal_surface ) :: ground A concrete implementation of the basal_surface abstract data type,\n representing the ground beneath an ice sheet. At the moment this\n doesn't actually do anything. Inherits type~~ground~~InheritsGraph type~ground ground type~basal_surface basal_surface type~ground->type~basal_surface Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Constructor ground Type-Bound Procedures basal_melt basal_drag_parameter water_density update data_size state_vector read_data write_data solve Source Code ground Constructor public interface ground private function constructor () result(this) Author Christopher MacMackin Date April 2016 Instantiates a ground object. Arguments None Return Value type( ground ) Type-Bound Procedures procedure, public :: basal_melt => ground_melt private function ground_melt (this) result(melt) Author Christopher MacMackin Date April 2016 Computes and returns the melt rate at the bottom of the ice\n sheet due to interaction with the ground. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. procedure, public :: basal_drag_parameter => ground_drag_parameter private function ground_drag_parameter (this) result(drag) Author Christopher MacMackin Date April 2016 Computes and returns a quantity which may be necessary to determine\n the frictional drag the ground exerts on the bottom of the ice\n sheet. An example would be the coefficient of friction. The \n description of this method is left deliberately vague so that as not\n to constrain how the drag is parameterized. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of a paramter describing the drag of the ground on the\n ice sheet. procedure, public :: water_density => ground_water_density private function ground_water_density (this) result(density) Author Christopher MacMackin Date April 2016 Computes and returns the density of the water beneath the ice sheet.\n This water would be subglacial discharge and would tend to lubricate\n the motion of the ice sheet. The density probably won't be important\n in the case of an ice sheet, but is included so that the ground data\n type can have the same interface as the plume data type. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value real(kind=r8) The density of any water at the base of the ice sheet. procedure, public :: update => ground_update private subroutine ground_update (this, state_vector, ice_thickness) Author Christopher MacMackin Date April 2016 Updates the state of the ground from its state vector. The state\n vector is a real array containing the value of each of the ground's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( ground ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n ground. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate and/or drag parameter. procedure, public :: data_size => ground_data_size private pure function ground_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the ground's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value integer The number of elements in the ground's state vector. procedure, public :: state_vector => ground_state_vector private pure function ground_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the ground. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the ground. procedure, public :: read_data => ground_read_data private subroutine ground_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the ground object from the specified group in\n an HDF file. Arguments Type Intent Optional Attributes Name class( ground ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group from which this data is\n meant to be read. character(len=*), intent(in) :: group_name The name of the group in the HDF5 file storing the\n ground's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: write_data => ground_write_data private subroutine ground_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the ground object to an HDF file in the\n specified group. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ground's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: solve => ground_solve private subroutine ground_solve (this, ice_thickness, ice_density, ice_temperature, time, success) Author Chris MacMackin Date April 2017 Solves the state of the ground for the specified ice properties,\n at the specified time. Arguments Type Intent Optional Attributes Name class( ground ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise Source Code type , extends ( basal_surface ), public :: ground !* Author: Christopher MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[basal_surface]] abstract data type, ! representing the ground beneath an ice sheet. At the moment this ! doesn't actually do anything. ! contains procedure :: basal_melt => ground_melt procedure :: basal_drag_parameter => ground_drag_parameter procedure :: water_density => ground_water_density procedure :: update => ground_update procedure :: data_size => ground_data_size procedure :: state_vector => ground_state_vector procedure :: read_data => ground_read_data procedure :: write_data => ground_write_data procedure :: solve => ground_solve end type ground"},{"title":"plume_boundary – ISOFT ","tags":"","loc":"type/plume_boundary.html","text":"type, public :: plume_boundary A type in which procedures for getting the boundary conditions\n of plumes are to be specified. The descendent types can contain\n whatever data is needed to compute the result. This class effectively provides free boundary conditions. It's \n type-bound procedures should be overridden to provide case-specific\n conditions. Inherited by type~~plume_boundary~~InheritedByGraph type~plume_boundary plume_boundary type~dallaston2015_seasonal_boundary dallaston2015_seasonal_boundary type~dallaston2015_seasonal_boundary->type~plume_boundary type~asym_plume asym_plume type~asym_plume->type~plume_boundary boundaries type~upstream_plume_boundary upstream_plume_boundary type~upstream_plume_boundary->type~plume_boundary type~simple_plume_boundary simple_plume_boundary type~simple_plume_boundary->type~plume_boundary type~static_plume static_plume type~static_plume->type~plume_boundary boundaries type~plume plume type~plume->type~plume_boundary boundaries Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures thickness_bound_info velocity_bound_info temperature_bound_info salinity_bound_info thickness_bound velocity_bound temperature_bound salinity_bound set_time Source Code plume_boundary Type-Bound Procedures procedure, public :: thickness_bound_info => bound_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine bound_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Provides information about the type of boundary, and the number\n of layers of data-points needed to describe it. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: velocity_bound_info => bound_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine bound_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Provides information about the type of boundary, and the number\n of layers of data-points needed to describe it. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: temperature_bound_info => bound_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine bound_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Provides information about the type of boundary, and the number\n of layers of data-points needed to describe it. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: salinity_bound_info => bound_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine bound_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Provides information about the type of boundary, and the number\n of layers of data-points needed to describe it. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: thickness_bound => scalar_bound Produces a field containing the boundary conditions for plume\n thickness at the specified location. private function scalar_bound (this, location) Author Chris MacMackin Date March 2017 Returns a field containing the boundary values for the specified\n boundary location. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: velocity_bound => vector_bound Produces a field containing the boundary conditions for plume\n velocity at the specified location. private function vector_bound (this, location) Author Chris MacMackin Date March 2017 Returns a field containing the boundary values for the specified\n boundary location. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer procedure, public :: temperature_bound => scalar_bound Produces a field containing the boundary conditions for plume\n temperature at the specified location. private function scalar_bound (this, location) Author Chris MacMackin Date March 2017 Returns a field containing the boundary values for the specified\n boundary location. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: salinity_bound => scalar_bound Produces a field containing the boundary conditions for plume\n salinity at the specified location. private function scalar_bound (this, location) Author Chris MacMackin Date March 2017 Returns a field containing the boundary values for the specified\n boundary location. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: set_time Specifies the time at which to calculate the boundary\n conditions. private subroutine set_time (this, time) Author Chris MacMackin Date May 2017 Sets the time at which boundary conditions are to be calculated. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: time Source Code type , public :: plume_boundary !* Author: Chris MacMackin !  Date: September 2016 ! ! A type in which procedures for getting the boundary conditions ! of plumes are to be specified. The descendent types can contain ! whatever data is needed to compute the result. ! ! This class effectively provides free boundary conditions. It's ! type-bound procedures should be overridden to provide case-specific ! conditions. ! contains procedure :: thickness_bound_info => bound_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: velocity_bound_info => bound_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: temperature_bound_info => bound_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: salinity_bound_info => bound_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: thickness_bound => scalar_bound !! Produces a field containing the boundary conditions for plume !! thickness at the specified location. procedure :: velocity_bound => vector_bound !! Produces a field containing the boundary conditions for plume !! velocity at the specified location. procedure :: temperature_bound => scalar_bound !! Produces a field containing the boundary conditions for plume !! temperature at the specified location. procedure :: salinity_bound => scalar_bound !! Produces a field containing the boundary conditions for plume !! salinity at the specified location. procedure :: set_time !! Specifies the time at which to calculate the boundary !! conditions. end type plume_boundary"},{"title":"ice_sheet – ISOFT ","tags":"","loc":"type/ice_sheet.html","text":"type, public, extends( glacier ) :: ice_sheet A concrete implementation of the glacier type, using a vertically\n integrated model of an ice sheet. This model is 1-dimensional only. Inherits type~~ice_sheet~~InheritsGraph type~ice_sheet ice_sheet type~abstract_viscosity abstract_viscosity type~ice_sheet->type~abstract_viscosity viscosity_law type~glacier glacier type~ice_sheet->type~glacier cheb1d_scalar_field cheb1d_scalar_field type~ice_sheet->cheb1d_scalar_field thickness cheb1d_vector_field cheb1d_vector_field type~ice_sheet->cheb1d_vector_field velocity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thickness velocity lambda chi viscosity_law time Constructor ice_sheet Type-Bound Procedures assignment(=) integrate integrate_layers ice_thickness ice_density ice_temperature residual update precondition set_time data_size state_vector solve_velocity read_data write_data time_step assign Source Code ice_sheet Components Type Visibility Attributes Name Initial type(cheb1d_scalar_field), private :: thickness Thickness of ice sheet, $h$ type(cheb1d_vector_field), private :: velocity Flow velocity of ice sheet, $\\vec{u}$ real(kind=r8), private :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real(kind=r8), private :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ class( abstract_viscosity ), private, allocatable :: viscosity_law An object representing the model used for ice viscosity. real(kind=r8), private :: time The time at which the ice sheet is in this state Constructor public interface ice_sheet private function constructor (domain, resolution, thickness, velocity, viscosity_law, lambda, chi) result(this) Author Christopher MacMackin Date April 2016 Creates a new ice_sheet object with initial conditions provided\n by the arguments. At present only a 1D model is supported. If\n information is provided for higher dimensions then it will be ignored. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the ice sheet. The first index represents the dimension for which\n the boundaries apply. If the second index is 1 then it corresponds\n to the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( thickness_func ) :: thickness A function which calculates the initial value of the thickness of \n the ice sheet at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the ice at a given location in an ice sheet. class( abstract_viscosity ), intent(in), optional :: viscosity_law An object which calculates the viscosity of the ice. real(kind=r8), intent(in), optional :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real(kind=r8), intent(in), optional :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Return Value type( ice_sheet ) An ice sheet object with its domain and initial conditions set\n according to the arguments of the constructor function. Type-Bound Procedures generic, public :: assignment(=) => assign private subroutine shelf_assign (this, rhs) Author Chris MacMackin Date February 2017 Copies the data from one ice shelf into another. This is only\n needed due to a bug in gfortran which means that the intrinsic\n assignment for glacier types is not using the appropriate\n defined assignment for the field components. Read more… Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(out) :: this class( glacier ), intent(in) :: rhs The ice shelf to be assigned to this one. procedure, public :: integrate => glacier_integrate Performs a time-step of the integration, taking the state of\n the glacier to the specified time using the provided\n melt-rate data. private subroutine glacier_integrate (this, old_states, basal_melt, basal_drag, water_density, time, success) Author Chris MacMackin Date November 2016 Integrates the glacier's state to time . This is done using the\n NITSOL package of iterative Krylov solvers. If a different\n algorithm for the integration is desired, then this method may\n be overridden in the concrete implementations of the glacier\n type. Read more… Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. class(scalar_field), intent(in) :: basal_melt The melt rate that the bottom of the glacier experiences\n during this time step. class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise procedure, public :: integrate_layers => glacier_integrate_layers Dummy routine which can be over-ridden to integrate internal\n layers of the glacier to the specified time. private subroutine glacier_integrate_layers (this, old_states, time, success) Author Chris MacMackin Date September 2018 Dummy routine which does nothing. Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise procedure, public :: ice_thickness => sheet_thickness private pure function sheet_thickness (this) result(thickness) Author Christopher MacMackin Date April 2016 Returns the thickness of the ice sheet across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value class(scalar_field),\n  pointer The ice thickness. procedure, public :: ice_density => sheet_density private pure function sheet_density (this) result(density) Author Christopher MacMackin Date April 2016 Returns the density of the ice in the sheet, which is assumed to be\n uniform across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8) The ice density. procedure, public :: ice_temperature => sheet_temperature private pure function sheet_temperature (this) result(temperature) Author Christopher MacMackin Date April 2016 Returns the density of the ice in the sheet, which is assumed to be\n uniform across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8) The ice density. procedure, public :: residual => sheet_residual private function sheet_residual (this, previous_states, melt_rate, basal_drag_parameter, water_density) result(residual) Author Christopher MacMackin Date April 2016 Returns the residual when the current state of the glacier is run\n through the system of equations describing it. The residual takes the\n form of a 1D array, with each element respresenting the residual for\n one of the equations in the system. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most recent\n state, but the fact that this is an array allows overriding\n methods to use older states for higher-order integration\n methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier. class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate the\n drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. Return Value real(kind=r8),\n  dimension(:), allocatable The residual of the system of equations describing the glacier. procedure, public :: update => sheet_update private subroutine sheet_update (this, state_vector) Author Christopher MacMackin Date April 2016 Updates the state of the ice sheet from its state vector. The state\n vector is a real array containing the value of each of the ice sheet's\n properties at each of the locations on the grid used in descretization. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n glacier. procedure, public :: precondition => sheet_precondition private function sheet_precondition (this, previous_states, melt_rate, basal_drag_parameter, water_density, delta_state) result(preconditioned) Author Chris MacMackin Date January 2016 Provides a preconditioner for the nonlinear solver trying to\n bring the residual to zero. The Jacobian is approximated as a\n block matrix, where each block is a tridiagonal matrix using a\n finite difference method for differentiation. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier real(kind=r8), intent(in), dimension(:) :: delta_state The change to the state vector which is being preconditioned. Return Value real(kind=r8),\n  dimension(:), allocatable The result of applying the preconditioner to delta_state . procedure, public :: set_time => sheet_set_time private subroutine sheet_set_time (this, time) Author Christopher MacMackin Date November 2016 Sets the time information held by the ice sheet object. This is\n the time at which the ice sheet is in its current state. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the glacier is in the present state. procedure, public :: data_size => sheet_data_size private pure function sheet_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the ice sheet's state vector.\n This is the size of the vector returned by residual and state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value integer The number of elements in the ice sheet's state vector. procedure, public :: state_vector => sheet_state_vector private pure function sheet_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the ice sheet. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the ice sheet. procedure, public :: solve_velocity => sheet_solve_velocity private subroutine sheet_solve_velocity (this, basal_drag, success) Author Chris MacMackin Date May 2017 Computes the ice sheet velocity at the current time with the\n current ice thickness. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. logical, intent(out) :: success True if the integration is successful, false otherwise procedure, public :: read_data => sheet_read_data private subroutine sheet_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the ice shelf object from the specified group\n in an HDF5 file. This sets the thickness, the velocity, and\n parameter values. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: write_data => sheet_write_data private subroutine sheet_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the ice sheet object to an HDF file in the\n specified group. This will consist of a thickness and a velocity\n dataset. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice sheet's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. procedure, public :: time_step => sheet_time_step private function sheet_time_step (this) result(dt) Author Chris MacMackin Date December 2016 Calculates the time step for integrating the ice sheet, using\n the CFL condition. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8) The time-step to use procedure, private :: assign => sheet_assign private subroutine sheet_assign (this, rhs) Author Chris MacMackin Date February 2017 Copies the data from one ice sheet into another. This is only\n needed due to a bug in gfortran which means that the intrinsic\n assignment for glacier types is not using the appropriate\n defined assignment for the field components. Read more… Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(out) :: this class( glacier ), intent(in) :: rhs The ice sheet to be assigned to this one. Source Code type , extends ( glacier ), public :: ice_sheet !* Author: Chris MacMackin !  Date: April 2016 ! ! A concrete implementation of the [[glacier]] type, using a vertically ! integrated model of an ice sheet. This model is 1-dimensional only. ! private type ( cheb1d_scalar_field ) :: thickness !! Thickness of ice sheet, $h$ type ( cheb1d_vector_field ) :: velocity !! Flow velocity of ice sheet, $\\vec{u}$ real ( r8 ) :: lambda !! The dimensionless ratio !! $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real ( r8 ) :: chi !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ class ( abstract_viscosity ), allocatable :: viscosity_law !! An object representing the model used for ice viscosity. real ( r8 ) :: time !! The time at which the ice sheet is in this state contains !$    procedure            :: t => sheet_dt !$    procedure            :: local_error => sheet_local_error !$    procedure            :: integrand_multiply_integrand => sheet_m_sheet !$    procedure            :: integrand_multiply_real => sheet_m_real !$    procedure, pass(rhs) :: real_multiply_integrand => real_m_sheet !$    procedure            :: add => sheet_add !$    procedure            :: sub => sheet_sub !$    procedure            :: assign_integrand => sheet_assign procedure :: ice_thickness => sheet_thickness !$    procedure :: ice_velocity => sheet_velocity procedure :: ice_density => sheet_density procedure :: ice_temperature => sheet_temperature procedure :: residual => sheet_residual procedure :: update => sheet_update procedure :: precondition => sheet_precondition procedure :: set_time => sheet_set_time procedure :: data_size => sheet_data_size procedure :: state_vector => sheet_state_vector procedure :: solve_velocity => sheet_solve_velocity procedure :: read_data => sheet_read_data procedure :: write_data => sheet_write_data procedure :: time_step => sheet_time_step procedure , private :: assign => sheet_assign end type ice_sheet"},{"title":"fin_diff_block – ISOFT ","tags":"","loc":"type/fin_diff_block.html","text":"type, public :: fin_diff_block A data type representing a matrix finite difference operator. It\n can be useful when preconditioning systems which use a spectral\n discretisation. It is inherently 1-D in its implementation. Note\n that multiplication of a field will simply call that field's\n differentiation operator, which may or may not use a finite\n difference method. When constructing an instance of this type, a template field\n must be passed which has the same grid as any other fields which\n will be operated upon. Additionally, types and locations of\n boundary conditions must be passed. Contents Variables diagonal super_diagonal sub_diagonal l_multipliers u_diagonal u_superdiagonal1 u_superdiagonal2 pivots boundary_locs boundary_types had_offset Constructor fin_diff_block Type-Bound Procedures fin_diff_block_solve_scalar fin_diff_block_solve_vector solve_for Source Code fin_diff_block Components Type Visibility Attributes Name Initial real(kind=r8), private, dimension(:), allocatable :: diagonal The diagonal of the tridiagonal matrix representation of this\n block. real(kind=r8), private, dimension(:), allocatable :: super_diagonal The super-diagonal of the tridiagonal matrix representation\n of this block. real(kind=r8), private, dimension(:), allocatable :: sub_diagonal The sub-diagonal of the tridiagonal matrix representation of\n this block. real(kind=r8), private, dimension(:), allocatable :: l_multipliers Multipliers defining the L matrix in the LU factorisation of\n the tridiagonal matrix representation of this block. real(kind=r8), private, dimension(:), allocatable :: u_diagonal The diagonal of the U matrix in the LU factorisation of\n the tridiagonal matrix representation of this block. real(kind=r8), private, dimension(:), allocatable :: u_superdiagonal1 The first superdiagonal of the U matrix in the LU\n factorisation of the tridiagonal matrix representation of\n this block. real(kind=r8), private, dimension(:), allocatable :: u_superdiagonal2 The second superdiagonal of the U matrix in the LU\n factorisation of the tridiagonal matrix representation of\n this block. integer, private, dimension(:), allocatable :: pivots Pivot indicies from the LU factorisation of the tridiagonal\n matrix representation of this block. integer, private, dimension(:), allocatable :: boundary_locs Locations in the raw arrays which are used to specify\n boundary conditions. integer, private, dimension(:), allocatable :: boundary_types The types of boundary conditions, specified using the\n parameters found in boundary_types_mod . logical, private :: had_offset = .true. True if the factorisation was computed from a tridiagonal\n system in which an offset was added to the diagonal. Constructor public interface fin_diff_block private function constructor (template, boundary_locs, boundary_types) result(this) Author Chris MacMackin Date December 2016 Build a tridiagonal matrix block for finite differences. See the\n end of the documentation of the fin_diff_block type\n for a description of how boundary conditions are treated. Arguments Type Intent Optional Attributes Name class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. integer, intent(in), optional dimension(:) :: boundary_locs The locations in the raw representation of rhs for which\n boundary conditions are specified. Defaults to there being\n none. integer, intent(in), optional dimension(:) :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. Defaults to Dirichlet. The\n order in which they are stored must match that of boundary_locs . Return Value type( fin_diff_block ) A new finite difference operator Type-Bound Procedures procedure, private :: fin_diff_block_solve_scalar private function fin_diff_block_solve_scalar (this, rhs, offset) result(solution) Author Chris MacMackin Date December 2016 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a scalar field). Optionally, the differential\n operator can be augmented by adding an offset, i.e. a scalar\n field which is added to the operator. Read more… Arguments Type Intent Optional Attributes Name class( fin_diff_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. class(scalar_field), intent(in), optional :: offset An offset to add to the differential operator Return Value class(scalar_field),\n  pointer procedure, private :: fin_diff_block_solve_vector private function fin_diff_block_solve_vector (this, rhs, offset) result(solution) Author Chris MacMackin Date December 2016 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a vector field). Optionally, the differential\n operator can be augmented by adding an offset, i.e. a vector\n field which is added to the operator. Read more… Arguments Type Intent Optional Attributes Name class( fin_diff_block ), intent(inout) :: this class(cheb1d_vector_field), intent(in) :: rhs The right hand side of the linear(ised) system. class(cheb1d_vector_field), intent(in), optional :: offset An offset to add to the differential operator Return Value class(vector_field),\n  pointer generic, public :: solve_for => fin_diff_block_solve_scalar , fin_diff_block_solve_vector private function fin_diff_block_solve_scalar (this, rhs, offset) result(solution) Author Chris MacMackin Date December 2016 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a scalar field). Optionally, the differential\n operator can be augmented by adding an offset, i.e. a scalar\n field which is added to the operator. Read more… Arguments Type Intent Optional Attributes Name class( fin_diff_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. class(scalar_field), intent(in), optional :: offset An offset to add to the differential operator Return Value class(scalar_field),\n  pointer private function fin_diff_block_solve_vector (this, rhs, offset) result(solution) Author Chris MacMackin Date December 2016 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a vector field). Optionally, the differential\n operator can be augmented by adding an offset, i.e. a vector\n field which is added to the operator. Read more… Arguments Type Intent Optional Attributes Name class( fin_diff_block ), intent(inout) :: this class(cheb1d_vector_field), intent(in) :: rhs The right hand side of the linear(ised) system. class(cheb1d_vector_field), intent(in), optional :: offset An offset to add to the differential operator Return Value class(vector_field),\n  pointer Source Code type , public :: fin_diff_block !* Author: Chris MacMackin !  Date: December 2016 ! ! A data type representing a matrix finite difference operator. It ! can be useful when preconditioning systems which use a spectral ! discretisation. It is inherently 1-D in its implementation. Note ! that multiplication of a field will simply call that field's ! differentiation operator, which may or may not use a finite ! difference method. ! ! When constructing an instance of this type, a template field ! must be passed which has the same grid as any other fields which ! will be operated upon. Additionally, types and locations of ! boundary conditions must be passed. ! private real ( r8 ), dimension (:), allocatable :: diagonal !! The diagonal of the tridiagonal matrix representation of this !! block. real ( r8 ), dimension (:), allocatable :: super_diagonal !! The super-diagonal of the tridiagonal matrix representation !! of this block. real ( r8 ), dimension (:), allocatable :: sub_diagonal !! The sub-diagonal of the tridiagonal matrix representation of !! this block. real ( r8 ), dimension (:), allocatable :: l_multipliers !! Multipliers defining the L matrix in the LU factorisation of !! the tridiagonal matrix representation of this block. real ( r8 ), dimension (:), allocatable :: u_diagonal !! The diagonal of the U matrix in the LU factorisation of !! the tridiagonal matrix representation of this block. real ( r8 ), dimension (:), allocatable :: u_superdiagonal1 !! The first superdiagonal of the U matrix in the LU !! factorisation of the tridiagonal matrix representation of !! this block. real ( r8 ), dimension (:), allocatable :: u_superdiagonal2 !! The second superdiagonal of the U matrix in the LU !! factorisation of the tridiagonal matrix representation of !! this block. integer , dimension (:), allocatable :: pivots !! Pivot indicies from the LU factorisation of the tridiagonal !! matrix representation of this block. integer , dimension (:), allocatable :: boundary_locs !! Locations in the raw arrays which are used to specify !! boundary conditions. integer , dimension (:), allocatable :: boundary_types !! The types of boundary conditions, specified using the !! parameters found in [[boundary_types_mod]]. logical :: had_offset = . true . !! True if the factorisation was computed from a tridiagonal !! system in which an offset was added to the diagonal. !    real(r8)                            :: magnitude !      !! The norm of the superdiagonal of the matrix. If an iterative !      !! method is used, this is needed to decide how to do so. contains private procedure :: fin_diff_block_solve_scalar procedure :: fin_diff_block_solve_vector generic , public :: solve_for => fin_diff_block_solve_scalar , & fin_diff_block_solve_vector end type fin_diff_block"},{"title":"abstract_entrainment – ISOFT ","tags":"","loc":"type/abstract_entrainment.html","text":"type, public, abstract :: abstract_entrainment An abstract data type for calculating entrainment of ambient\n ocean water into a vertically integrated plume . Inherited by type~~abstract_entrainment~~InheritedByGraph type~abstract_entrainment abstract_entrainment type~plume plume type~plume->type~abstract_entrainment entrainment_formulation type~jenkins1991_entrainment jenkins1991_entrainment type~jenkins1991_entrainment->type~abstract_entrainment type~static_plume static_plume type~static_plume->type~abstract_entrainment entrainment_formulation type~asym_plume asym_plume type~asym_plume->type~abstract_entrainment entrainment_formulation type~kochergin1987_entrainment kochergin1987_entrainment type~kochergin1987_entrainment->type~abstract_entrainment Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures entrainment_rate Source Code abstract_entrainment Type-Bound Procedures procedure( get_entrainment ), public, deferred :: entrainment_rate Returns the entrainment rate for ambient water into the plume. function get_entrainment(this, velocity, thickness, depth, density_diff, time) result(property) Prototype Arguments Type Intent Optional Attributes Name class( abstract_entrainment ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is being \n entrained. class(scalar_field), intent(in) :: thickness The thickness of the plume into which fluid is being\n entrained class(scalar_field), intent(in) :: depth The depth of the upper surface of the plume into which\n fluid is being entrained class(scalar_field), intent(in) :: density_diff The difference between the ambient density and the density of\n the plume into which the ambient fluid is being entrained. real(kind=r8), intent(in), optional :: time The time at which the entrainment is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the entrainment Source Code type , abstract , public :: abstract_entrainment !* Author: Christopher MacMackin !  Date: October 2016 ! ! An abstract data type for calculating entrainment of ambient ! ocean water into a vertically integrated [[plume]]. ! contains procedure ( get_entrainment ), deferred :: entrainment_rate !! Returns the entrainment rate for ambient water into the plume. end type abstract_entrainment"},{"title":"uniform_ambient_conditions – ISOFT ","tags":"","loc":"type/uniform_ambient_conditions.html","text":"type, public, extends( ambient_conditions ) :: uniform_ambient_conditions An derived type with procedures for getting the ambient ocean\n conditions. This implementation takes these conditions to be\n everywhere uniform. Inherits type~~uniform_ambient_conditions~~InheritsGraph type~uniform_ambient_conditions uniform_ambient_conditions uniform_scalar_field uniform_scalar_field type~uniform_ambient_conditions->uniform_scalar_field temperature, salinity type~ambient_conditions ambient_conditions type~uniform_ambient_conditions->type~ambient_conditions Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables temperature salinity Constructor uniform_ambient_conditions Type-Bound Procedures ambient_temperature ambient_salinity Source Code uniform_ambient_conditions Components Type Visibility Attributes Name Initial type(uniform_scalar_field), private :: temperature type(uniform_scalar_field), private :: salinity Constructor public interface uniform_ambient_conditions private function constructor (temperature, salinity) result(this) Author Chris MacMackin Date November 2016 Produces an ambient object which will return the specified\n salinity and temeprature values. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: temperature The temperature of the ambient ocean. Default is 0. real(kind=r8), intent(in), optional :: salinity The salinity of the ambient ocean. Default is 0. Return Value type( uniform_ambient_conditions ) Type-Bound Procedures procedure, public :: ambient_temperature => uniform_temperature Returns the ambient ocean temperature private function uniform_temperature (this, depth, t) result(property) Author Chris MacMackin Date November 2016 Returns the ambient ocean temperature. Arguments Type Intent Optional Attributes Name class( uniform_ambient_conditions ), intent(in) :: this class(scalar_field), intent(in) :: depth A field containing the depths at which the ambient temperature\n is to be calculated. real(kind=r8), intent(in) :: t The time at which the ambient conditions are to be calculated. Return Value class(scalar_field),\n  pointer A field containing the ambient temperature at the depth specified\n for each location. procedure, public :: ambient_salinity => uniform_salinity Returns the ambient ocean temperature private function uniform_salinity (this, depth, t) result(property) Author Chris MacMackin Date November 2016 Returns the ambient ocean salinity. Arguments Type Intent Optional Attributes Name class( uniform_ambient_conditions ), intent(in) :: this class(scalar_field), intent(in) :: depth A field containing the depths at which the ambient salinity\n is to be calculated. real(kind=r8), intent(in) :: t The time at which the ambient conditions are to be calculated. Return Value class(scalar_field),\n  pointer A field containing the ambient salinity at the depth specified\n for each location. Source Code type , extends ( ambient_conditions ), public :: uniform_ambient_conditions !* Author: Chris MacMackin !  Date: April 2016 ! ! An derived type with procedures for getting the ambient ocean ! conditions. This implementation takes these conditions to be ! everywhere uniform. ! private type ( uniform_scalar_field ) :: temperature type ( uniform_scalar_field ) :: salinity contains procedure :: ambient_temperature => uniform_temperature !! Returns the ambient ocean temperature procedure :: ambient_salinity => uniform_salinity !! Returns the ambient ocean temperature end type uniform_ambient_conditions"},{"title":"simple_plume_boundary – ISOFT ","tags":"","loc":"type/simple_plume_boundary.html","text":"type, public, extends( plume_boundary ) :: simple_plume_boundary A type with procedures for getting the boundary conditions of\n the plume model. Dirichlet boundary conditions are used at the\n grounding line. In order to approximate an outflow condition,\n the derivatives of velocity, temperature, and salinity are set\n to 0 at the end of the domain. Plume thickness is left free\n there, as only a single boundary condition is needed for it. Inherits type~~simple_plume_boundary~~InheritsGraph type~simple_plume_boundary simple_plume_boundary type~plume_boundary plume_boundary type~simple_plume_boundary->type~plume_boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thickness velocity salinity temperature Constructor simple_plume_boundary Type-Bound Procedures set_time thickness_bound_info velocity_bound_info temperature_bound_info salinity_bound_info thickness_bound velocity_bound temperature_bound salinity_bound Source Code simple_plume_boundary Components Type Visibility Attributes Name Initial real(kind=r8), private :: thickness = 0.0_r8 The thickness of the plume at the inflowing boundary real(kind=r8), private, dimension(2) :: velocity = 1.0_r8 The velocity of the plume at the inflowing boundary real(kind=r8), private :: salinity = 0.0_r8 The salinity of the plume at the inflowing boundary real(kind=r8), private :: temperature = 0.0_r8 The tempreature of the plume at the inflowing boundary Constructor public interface simple_plume_boundary private pure function constructor (thickness, velocity, temperature, salinity) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: thickness The water thickness at the inflowing plume boundary real(kind=r8), intent(in), dimension(2) :: velocity The longitudinal water velocity at the inflowing plume boundary real(kind=r8), intent(in) :: temperature The water temperature at the inflowing plume boundary real(kind=r8), intent(in) :: salinity The water salinity at the inflowing plume boundary Return Value type( simple_plume_boundary ) Type-Bound Procedures procedure, public :: set_time Specifies the time at which to calculate the boundary\n conditions. private subroutine set_time (this, time) Author Chris MacMackin Date May 2017 Sets the time at which boundary conditions are to be calculated. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: time procedure, public :: thickness_bound_info => simple_thickness_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine simple_thickness_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is free. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: velocity_bound_info => simple_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine simple_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: temperature_bound_info => simple_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine simple_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: salinity_bound_info => simple_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine simple_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: thickness_bound => simple_thickness_bound Produces a field containing the boundary conditions for plume\n thickness at the specified location. private function simple_thickness_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the thickness boundary values for the\n specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: velocity_bound => simple_velocity_bound Produces a field containing the boundary conditions for plume\n velocity at the specified location. private function simple_velocity_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the velocity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer procedure, public :: temperature_bound => simple_temperature_bound Produces a field containing the boundary conditions for plume\n temperature at the specified location. private function simple_temperature_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the temperature boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: salinity_bound => simple_salinity_bound Produces a field containing the boundary conditions for plume\n salinity at the specified location. private function simple_salinity_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the salinity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Source Code type , extends ( plume_boundary ), public :: simple_plume_boundary !* Author: Chris MacMackin !  Date: March 2017 ! ! A type with procedures for getting the boundary conditions of ! the plume model. Dirichlet boundary conditions are used at the ! grounding line. In order to approximate an outflow condition, ! the derivatives of velocity, temperature, and salinity are set ! to 0 at the end of the domain. Plume thickness is left free ! there, as only a single boundary condition is needed for it. ! private real ( r8 ) :: thickness = 0.0_r8 !! The thickness of the plume at the inflowing boundary real ( r8 ), dimension ( 2 ) :: velocity = 1.0_r8 !! The velocity of the plume at the inflowing boundary real ( r8 ) :: salinity = 0.0_r8 !! The salinity of the plume at the inflowing boundary real ( r8 ) :: temperature = 0.0_r8 !! The tempreature of the plume at the inflowing boundary contains procedure :: thickness_bound_info => simple_thickness_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: velocity_bound_info => simple_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: temperature_bound_info => simple_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: salinity_bound_info => simple_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: thickness_bound => simple_thickness_bound !! Produces a field containing the boundary conditions for plume !! thickness at the specified location. procedure :: velocity_bound => simple_velocity_bound !! Produces a field containing the boundary conditions for plume !! velocity at the specified location. procedure :: temperature_bound => simple_temperature_bound !! Produces a field containing the boundary conditions for plume !! temperature at the specified location. procedure :: salinity_bound => simple_salinity_bound !! Produces a field containing the boundary conditions for plume !! salinity at the specified location. end type simple_plume_boundary"},{"title":"dallaston2015_seasonal_boundary – ISOFT ","tags":"","loc":"type/dallaston2015_seasonal_boundary.html","text":"type, public, extends( plume_boundary ) :: dallaston2015_seasonal_boundary A type with procedures for getting the boundary conditions of\n the plume model. It represents the case where subglacial\n discharge is varying in time, altering the boundary conditions\n for velocity and salinity using scalings similar to those in\n Dallaston et al. (2015). Dirichlet boundary conditions are used\n at the grounding line. In order to approximate an outflow\n condition, the derivatives of velocity, temperature, and\n salinity are set to 0 at the end of the domain. Plume thickness\n is left free there, as only a single boundary condition is\n needed for it. Inherits type~~dallaston2015_seasonal_boundary~~InheritsGraph type~dallaston2015_seasonal_boundary dallaston2015_seasonal_boundary type~plume_boundary plume_boundary type~dallaston2015_seasonal_boundary->type~plume_boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thickness frequency amplitude mean discharge temperature Constructor dallaston2015_seasonal_boundary Type-Bound Procedures thickness_bound_info velocity_bound_info temperature_bound_info salinity_bound_info thickness_bound velocity_bound temperature_bound salinity_bound set_time Source Code dallaston2015_seasonal_boundary Components Type Visibility Attributes Name Initial real(kind=r8), private :: thickness = 0.1_r8 The thickness of the plume at the inflowing boundary real(kind=r8), private :: frequency = 1.0_r8 The angular frequency of the oscillations in discharge real(kind=r8), private :: amplitude = 1.0_r8 The amplitude of the oscillations in discharge real(kind=r8), private :: mean = 1.0_r8 The time-average of the discharge, about which it oscillates real(kind=r8), private :: discharge = 1.0_r8 The current discharge value real(kind=r8), private :: temperature = 0.0_r8 The tempreature of the plume at the inflowing boundary Constructor public interface dallaston2015_seasonal_boundary private pure function constructor (thickness, frequency, amplitude, mean, temperature) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with\n seasonal variations in subglacial discharge. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: thickness The plume thickness at the inflowing plume boundary, defaults\n to 0.1 real(kind=r8), intent(in), optional :: frequency The angular frequency of the oscillations in discharge,\n defaults to 1.0 real(kind=r8), intent(in), optional :: amplitude The amplitude of the oscillations in discharge, defaults to\n 1.0 real(kind=r8), intent(in), optional :: mean The time-average of the discharge, about which it oscillates,\n defaulting to 1.0 real(kind=r8), intent(in), optional :: temperature The water temperature at the inflowing plume boundary,\n defaults to 0.0 Return Value type( dallaston2015_seasonal_boundary ) Type-Bound Procedures procedure, public :: thickness_bound_info => seasonal_thickness_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine seasonal_thickness_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is free. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: velocity_bound_info => seasonal_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine seasonal_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: temperature_bound_info => seasonal_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine seasonal_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: salinity_bound_info => seasonal_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine seasonal_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: thickness_bound => seasonal_thickness_bound Produces a field containing the boundary conditions for plume\n thickness at the specified location. private function seasonal_thickness_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the thickness boundary values for the\n specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: velocity_bound => seasonal_velocity_bound Produces a field containing the boundary conditions for plume\n velocity at the specified location. private function seasonal_velocity_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the velocity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer procedure, public :: temperature_bound => seasonal_temperature_bound Produces a field containing the boundary conditions for plume\n temperature at the specified location. private function seasonal_temperature_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the temperature boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: salinity_bound => seasonal_salinity_bound Produces a field containing the boundary conditions for plume\n salinity at the specified location. private function seasonal_salinity_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the salinity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: set_time => seasonal_set_time Specifies the time at which to calculate the boundary\n conditions. private subroutine seasonal_set_time (this, time) Author Chris MacMackin Date May 2017 Sets the time at which boundary conditions are to be calculated. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: time Source Code type , extends ( plume_boundary ), public :: dallaston2015_seasonal_boundary !* Author: Chris MacMackin !  Date: May 2017 ! ! A type with procedures for getting the boundary conditions of ! the plume model. It represents the case where subglacial ! discharge is varying in time, altering the boundary conditions ! for velocity and salinity using scalings similar to those in ! Dallaston et al. (2015). Dirichlet boundary conditions are used ! at the grounding line. In order to approximate an outflow ! condition, the derivatives of velocity, temperature, and ! salinity are set to 0 at the end of the domain. Plume thickness ! is left free there, as only a single boundary condition is ! needed for it. ! private real ( r8 ) :: thickness = 0.1_r8 !! The thickness of the plume at the inflowing boundary real ( r8 ) :: frequency = 1.0_r8 !! The angular frequency of the oscillations in discharge real ( r8 ) :: amplitude = 1.0_r8 !! The amplitude of the oscillations in discharge real ( r8 ) :: mean = 1.0_r8 !! The time-average of the discharge, about which it oscillates real ( r8 ) :: discharge = 1.0_r8 !! The current discharge value real ( r8 ) :: temperature = 0.0_r8 !! The tempreature of the plume at the inflowing boundary contains procedure :: thickness_bound_info => seasonal_thickness_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: velocity_bound_info => seasonal_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: temperature_bound_info => seasonal_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: salinity_bound_info => seasonal_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: thickness_bound => seasonal_thickness_bound !! Produces a field containing the boundary conditions for plume !! thickness at the specified location. procedure :: velocity_bound => seasonal_velocity_bound !! Produces a field containing the boundary conditions for plume !! velocity at the specified location. procedure :: temperature_bound => seasonal_temperature_bound !! Produces a field containing the boundary conditions for plume !! temperature at the specified location. procedure :: salinity_bound => seasonal_salinity_bound !! Produces a field containing the boundary conditions for plume !! salinity at the specified location. procedure :: set_time => seasonal_set_time !! Specifies the time at which to calculate the boundary !! conditions. end type dallaston2015_seasonal_boundary"},{"title":"seasonal_glacier_boundary – ISOFT ","tags":"","loc":"type/seasonal_glacier_boundary.html","text":"type, public, extends( glacier_boundary ) :: seasonal_glacier_boundary A type with procedures for getting the boundary conditions of\n the ice shelf model used by Dallaston et al. (2015), but with\n the ice flux at the grounding line varying sinusoidally in\n time. There are Dirichlet conditions at the lower bound of the\n first condition as well as, for thickness, the upper bound. Inherits type~~seasonal_glacier_boundary~~InheritsGraph type~seasonal_glacier_boundary seasonal_glacier_boundary type~glacier_boundary glacier_boundary type~seasonal_glacier_boundary->type~glacier_boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thickness frequency amplitude mean chi square Constructor seasonal_glacier_boundary Type-Bound Procedures thickness_upper_bound thickness_upper_type thickness_lower_bound velocity_lower_bound velocity_upper_bound thickness_lower_type velocity_lower_type velocity_upper_type boundary_residuals Source Code seasonal_glacier_boundary Components Type Visibility Attributes Name Initial real(kind=r8), private :: thickness = 1.0_r8 The thickness of the glacier at the inflowing boundary real(kind=r8), private :: frequency = 1.0_r8 The angular frequency of the oscillations in ice flux real(kind=r8), private :: amplitude = 0.5_r8 The amplitude of the oscillations in ice flux real(kind=r8), private :: mean = 1.0_r8 The time-average of the ice flux, about which it oscillates real(kind=r8), private :: chi = 1.0_r8 The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ logical, private :: square = .false. If true, produce a square wave, otherwise produce a sinusoid Constructor public interface seasonal_glacier_boundary private pure function constructor (thickness, frequency, amplitude, mean, chi, square) result(this) Author Chris MacMackin Date October 2017 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with the ice\n flux at the grounding line varying in time. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: thickness The ice thickness at the inflowing ice shelf boundary,\n defaults to 1.0 real(kind=r8), intent(in), optional :: frequency The angular frequency of the oscillations in ice flux,\n defaults to 0.5 real(kind=r8), intent(in), optional :: amplitude The amplitude of the oscillations in ice flux, defaults to\n 1.0 real(kind=r8), intent(in), optional :: mean The time-average of the discharge, about which it oscillates,\n defaulting to 1.0 real(kind=r8), intent(in), optional :: chi The dimensionless ratio \\chi \\equiv\n \\frac{\\rho_igh_0x_x}{2\\eta_0u_0} , defaults to 1.0 logical, intent(in), optional :: square If present and true, produce a square wave. Otherwise produce\n a sinusoid. Return Value type( seasonal_glacier_boundary ) Type-Bound Procedures procedure, public :: thickness_upper_bound => bound_array Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the thickness\n field. private pure function bound_array (this) Author Chris MacMackin Date September 2016 Default implementation of the method getting lower and upper\n boundary information, which is then passed to the methods for\n getting and setting raw representations of fields. It returns a\n 1D array of length 2, indicating free boundaries (the raw data\n should represent all cells contained in the field, not excluding\n any near the boundaries). Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: thickness_upper_type => bound_type Returns an array indicating what type of boundary conditions\n apply for thickness at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function bound_type (this) Author Chris MacMackin Date January 2017 Default implementation of the methods getting the boundary types\n for a glacier.  It returns an array which indicates free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: thickness_lower_bound => seasonal_lower_bound Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the thickness\n field. private pure function seasonal_lower_bound (this) result(bound_array) Author Chris MacMackin Date October 2017 Indicates that one layer of cells at the lower boundary in the\n first dimension should be omitted. This is appropriate for\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: velocity_lower_bound => seasonal_lower_bound Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the velocity\n field. private pure function seasonal_lower_bound (this) result(bound_array) Author Chris MacMackin Date October 2017 Indicates that one layer of cells at the lower boundary in the\n first dimension should be omitted. This is appropriate for\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: velocity_upper_bound => seasonal_upper_bound Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the velocity\n field. private pure function seasonal_upper_bound (this) result(bound_array) Author Chris MacMackin Date October 2017 Indicates that one layer of cells at the upper boundary in the\n first dimension should be omitted for thickness. This is\n appropriate for Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: thickness_lower_type => seasonal_lower_type Returns an array indicating what type of boundary conditions\n apply for thickness at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function seasonal_lower_type (this) result(bound_type) Author Chris MacMackin Date January 2017 Specifies that the lower boundary in the first dimension has\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: velocity_lower_type => seasonal_lower_type Returns an array indicating what type of boundary conditions\n apply for velocity at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function seasonal_lower_type (this) result(bound_type) Author Chris MacMackin Date January 2017 Specifies that the lower boundary in the first dimension has\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: velocity_upper_type => seasonal_upper_type Returns an array indicating what type of boundary conditions\n apply for velocity at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function seasonal_upper_type (this) result(bound_type) Author Chris MacMackin Date January 2017 Specifies that the upper boundary in the first dimension has\n Neumann boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: boundary_residuals => seasonal_residuals Returns an array consisting of the difference between the\n required boundary values and those which actually exist. This\n can then be appended to a glacier's state vector. The order\n in which these are listed is as follows: lower thickness\n boundary, upper thickness boundary, lower velocity boundary,\n and upper velocity boundary. private function seasonal_residuals (this, thickness, velocity, viscosity, t) result(residuals) Author Chris MacMackin Date October 2017 Returns the difference between the glacier conditions of the\n plume and the Dirichlet conditions prescribed in the model of\n Dallaston et al. (2015) Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this class(scalar_field), intent(in) :: thickness A field containing the thickness of the glacier class(vector_field), intent(in) :: velocity A field containing the flow velocity of the glacier class(scalar_field), intent(in) :: viscosity A field containing the viscosity of the ice in the glacier. real(kind=r8), intent(in) :: t The time at which the boundary conditions are to be\n calculated. Return Value real(kind=r8),\n  allocatable, dimension(:) An array containing the difference between the required\n boundary values and those which are actually present. They\n are stored in the order: lower thickness boundary, upper\n thickness boundary, lower velocity boundary, and upper\n velocity boundary. Source Code type , extends ( glacier_boundary ), public :: seasonal_glacier_boundary !* Author: Chris MacMackin !  Date: October 2017 ! ! A type with procedures for getting the boundary conditions of ! the ice shelf model used by Dallaston et al. (2015), but with ! the ice flux at the grounding line varying sinusoidally in ! time. There are Dirichlet conditions at the lower bound of the ! first condition as well as, for thickness, the upper bound. ! private real ( r8 ) :: thickness = 1.0_r8 !! The thickness of the glacier at the inflowing boundary real ( r8 ) :: frequency = 1.0_r8 !! The angular frequency of the oscillations in ice flux real ( r8 ) :: amplitude = 0.5_r8 !! The amplitude of the oscillations in ice flux real ( r8 ) :: mean = 1.0_r8 !! The time-average of the ice flux, about which it oscillates real ( r8 ) :: chi = 1.0_r8 !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ logical :: square = . false . !! If true, produce a square wave, otherwise produce a sinusoid contains procedure :: thickness_lower_bound => seasonal_lower_bound !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the thickness !! field. procedure :: velocity_lower_bound => seasonal_lower_bound !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: velocity_upper_bound => seasonal_upper_bound !! Returns a 1D array which should be passed as the !! `exclude_upper_bound`/`provide_upper_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: thickness_lower_type => seasonal_lower_type !! Returns an array indicating what type of boundary conditions !! apply for thickness at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_lower_type => seasonal_lower_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_upper_type => seasonal_upper_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the upper boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: boundary_residuals => seasonal_residuals !! Returns an array consisting of the difference between the !! required boundary values and those which actually exist. This !! can then be appended to a glacier's state vector. The order !! in which these are listed is as follows: lower thickness !! boundary, upper thickness boundary, lower velocity boundary, !! and upper velocity boundary. end type seasonal_glacier_boundary"},{"title":"upstream_plume_boundary – ISOFT ","tags":"","loc":"type/upstream_plume_boundary.html","text":"type, public, extends( plume_boundary ) :: upstream_plume_boundary A type with procedures for getting the boundary conditions of\n the plume model. For given boundary conditions, it integrates\n the plume upstream slightly and then returns these when asked\n for boundary values. This allows boundary layers, which can\n cause numerical difficulties, to be avoided. Inflow boundaries\n must be Dirichlet, while outflow boundaries for velocity,\n salinity, and temperature are set to have a gradient of zero. Warning The calculate method must be called prior to use. Inherits type~~upstream_plume_boundary~~InheritsGraph type~upstream_plume_boundary upstream_plume_boundary type~plume_boundary plume_boundary type~upstream_plume_boundary->type~plume_boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables get_boundaries distance thickness velocity temperature salinity boundary_time thresholds Constructor upstream_plume_boundary Type-Bound Procedures set_time thickness_bound_info velocity_bound_info temperature_bound_info salinity_bound_info thickness_bound velocity_bound temperature_bound salinity_bound calculate Source Code upstream_plume_boundary Components Type Visibility Attributes Name Initial procedure( bound_vals ), private, nopass, pointer :: get_boundaries => null() Calculate the \"actual\" boundary values, used to initiate the\n integration, for the specified time. real(kind=r8), private :: distance = 0.05_r8 The distance upstream which the plume should be integrated real(kind=r8), private :: thickness = 0.1_r8 The thickness of the plume at the inflowing boundary real(kind=r8), private, dimension(:), allocatable :: velocity The velocity of the plume at the inflowing boundary real(kind=r8), private :: temperature = 0.0_r8 The tempreature of the plume at the inflowing boundary real(kind=r8), private :: salinity = 1.0_r8 The salinity of the plume at the inflowing boundary real(kind=r8), private :: boundary_time The time at which the boundaries were most recently\n calculated real(kind=r8), private, dimension(:), allocatable :: thresholds Thresholds to use when calculating error in the integration. Constructor public interface upstream_plume_boundary private pure function constructor (bound_calculator, distance, thresholds) result(this) Author Chris MacMackin Date July 2017 Constructs a boundary condition object which integrates an IVP\n from actual boundary values to calculate the staet of the plume\n a little upstream. This can be used to avoid boundary layers. Arguments Type Intent Optional Attributes Name procedure( bound_vals ) :: bound_calculator Calculates the \"actual\" inflow boundary conditions, used to\n initiate the integration to find the values to use in the\n simulation. real(kind=r8), intent(in) :: distance The distance upstream which the plume should be integrated. real(kind=r8), intent(in), optional dimension(:) :: thresholds The thresholds to use when evaluating the error of the\n integration. This is done according to the formula abs(e) / max(magnitude_y, THRESHOLDS) <= TOLERANCE . Return Value type( upstream_plume_boundary ) Type-Bound Procedures procedure, public :: set_time Specifies the time at which to calculate the boundary\n conditions. private subroutine set_time (this, time) Author Chris MacMackin Date May 2017 Sets the time at which boundary conditions are to be calculated. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: time procedure, public :: thickness_bound_info => upstream_thickness_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine upstream_thickness_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date July 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is free. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: velocity_bound_info => upstream_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine upstream_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date July 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: temperature_bound_info => upstream_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine upstream_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date July 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: salinity_bound_info => upstream_info Indicates the type and depth of the thickness boundary at\n different locations. private subroutine upstream_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date July 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. procedure, public :: thickness_bound => upstream_thickness_bound Produces a field containing the boundary conditions for plume\n thickness at the specified location. private function upstream_thickness_bound (this, location) result(bound) Author Chris MacMackin Date July 2017 Returns a field containing the thickness boundary values for the\n specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: velocity_bound => upstream_velocity_bound Produces a field containing the boundary conditions for plume\n velocity at the specified location. private function upstream_velocity_bound (this, location) result(bound) Author Chris MacMackin Date July 2017 Returns a field containing the velocity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer procedure, public :: temperature_bound => upstream_temperature_bound Produces a field containing the boundary conditions for plume\n temperature at the specified location. private function upstream_temperature_bound (this, location) result(bound) Author Chris MacMackin Date July 2017 Returns a field containing the temperature boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: salinity_bound => upstream_salinity_bound Produces a field containing the boundary conditions for plume\n salinity at the specified location. private function upstream_salinity_bound (this, location) result(bound) Author Chris MacMackin Date July 2017 Returns a field containing the salinity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer procedure, public :: calculate => upstream_calculate Calculates the upstreamed boundary conditions for the given\n time and ice thickness. private subroutine upstream_calculate (this, t, func, b) Author Chris MacMackin Date July 2017 Calculates the boundary values to use at the current time with\n the current ice thickness. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: t The time at which to calculate the boundary values. procedure( non_diff ) :: func A function which returns the non-diffusive, non-inertial\n components of the ODEs describing the plume. class(scalar_field), intent(in) :: b The depth of the ice shelf base. Source Code type , extends ( plume_boundary ), public :: upstream_plume_boundary !* Author: Chris MacMackin !  Date: July 2017 ! ! A type with procedures for getting the boundary conditions of ! the plume model. For given boundary conditions, it integrates ! the plume upstream slightly and then returns these when asked ! for boundary values. This allows boundary layers, which can ! cause numerical difficulties, to be avoided. Inflow boundaries ! must be Dirichlet, while outflow boundaries for velocity, ! salinity, and temperature are set to have a gradient of zero. ! ! @Warning The `calculate` method __must__ be called prior to use. ! private procedure ( bound_vals ), nopass , pointer :: get_boundaries => null () !! Calculate the \"actual\" boundary values, used to initiate the !! integration, for the specified time. real ( r8 ) :: distance = 0.05_r8 !! The distance upstream which the plume should be integrated real ( r8 ) :: thickness = 0.1_r8 !! The thickness of the plume at the inflowing boundary real ( r8 ), dimension (:), allocatable :: velocity !! The velocity of the plume at the inflowing boundary real ( r8 ) :: temperature = 0.0_r8 !! The tempreature of the plume at the inflowing boundary real ( r8 ) :: salinity = 1.0_r8 !! The salinity of the plume at the inflowing boundary real ( r8 ) :: boundary_time !! The time at which the boundaries were most recently !! calculated real ( r8 ), dimension (:), allocatable :: thresholds !! Thresholds to use when calculating error in the integration. contains procedure :: thickness_bound_info => upstream_thickness_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: velocity_bound_info => upstream_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: temperature_bound_info => upstream_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: salinity_bound_info => upstream_info !! Indicates the type and depth of the thickness boundary at !! different locations. procedure :: thickness_bound => upstream_thickness_bound !! Produces a field containing the boundary conditions for plume !! thickness at the specified location. procedure :: velocity_bound => upstream_velocity_bound !! Produces a field containing the boundary conditions for plume !! velocity at the specified location. procedure :: temperature_bound => upstream_temperature_bound !! Produces a field containing the boundary conditions for plume !! temperature at the specified location. procedure :: salinity_bound => upstream_salinity_bound !! Produces a field containing the boundary conditions for plume !! salinity at the specified location. procedure :: calculate => upstream_calculate !! Calculates the upstreamed boundary conditions for the given !! time and ice thickness. end type upstream_plume_boundary"},{"title":"dallaston2015_glacier_boundary – ISOFT ","tags":"","loc":"type/dallaston2015_glacier_boundary.html","text":"type, public, extends( glacier_boundary ) :: dallaston2015_glacier_boundary A type with procedures for getting the boundary conditions of\n the ice shelf model used by Dallaston et al. (2015). These are\n Dirichlet conditions at the lower bound of the first condition\n as well as, for thickness, the upper bound. Todo Consider testing the consistency conditions at the outgoing boundary? Inherits type~~dallaston2015_glacier_boundary~~InheritsGraph type~dallaston2015_glacier_boundary dallaston2015_glacier_boundary type~glacier_boundary glacier_boundary type~dallaston2015_glacier_boundary->type~glacier_boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thickness velocity chi Constructor dallaston2015_glacier_boundary Type-Bound Procedures thickness_upper_bound thickness_upper_type thickness_lower_bound velocity_lower_bound velocity_upper_bound thickness_lower_type velocity_lower_type velocity_upper_type boundary_residuals Source Code dallaston2015_glacier_boundary Components Type Visibility Attributes Name Initial real(kind=r8), private :: thickness = 1.0_r8 The thickness of the glacier at the inflowing boundary real(kind=r8), private :: velocity = 1.0_r8 The velocity of the glacier at the inflowing boundary real(kind=r8), private :: chi = 1.0_r8 The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Constructor public interface dallaston2015_glacier_boundary private pure function constructor (thickness, velocity, chi) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: thickness The ice thickness at the inflowing ice shelf boundary real(kind=r8), intent(in) :: velocity The longitudinal ice velocity at the inflowing ice shelf boundary real(kind=r8), intent(in) :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Return Value type( dallaston2015_glacier_boundary ) Type-Bound Procedures procedure, public :: thickness_upper_bound => bound_array Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the thickness\n field. private pure function bound_array (this) Author Chris MacMackin Date September 2016 Default implementation of the method getting lower and upper\n boundary information, which is then passed to the methods for\n getting and setting raw representations of fields. It returns a\n 1D array of length 2, indicating free boundaries (the raw data\n should represent all cells contained in the field, not excluding\n any near the boundaries). Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: thickness_upper_type => bound_type Returns an array indicating what type of boundary conditions\n apply for thickness at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function bound_type (this) Author Chris MacMackin Date January 2017 Default implementation of the methods getting the boundary types\n for a glacier.  It returns an array which indicates free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: thickness_lower_bound => dallaston2015_lower_bound Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the thickness\n field. private pure function dallaston2015_lower_bound (this) result(bound_array) Author Chris MacMackin Date November 2016 Indicates that one layer of cells at the lower boundary in the\n first dimension should be omitted. This is appropriate for\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: velocity_lower_bound => dallaston2015_lower_bound Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the velocity\n field. private pure function dallaston2015_lower_bound (this) result(bound_array) Author Chris MacMackin Date November 2016 Indicates that one layer of cells at the lower boundary in the\n first dimension should be omitted. This is appropriate for\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: velocity_upper_bound => dallaston2015_upper_bound Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the velocity\n field. private pure function dallaston2015_upper_bound (this) result(bound_array) Author Chris MacMackin Date November 2016 Indicates that one layer of cells at the upper boundary in the\n first dimension should be omitted for thickness. This is\n appropriate for Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) procedure, public :: thickness_lower_type => dallaston2015_lower_type Returns an array indicating what type of boundary conditions\n apply for thickness at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function dallaston2015_lower_type (this) result(bound_type) Author Chris MacMackin Date January 2017 Specifies that the lower boundary in the first dimension has\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: velocity_lower_type => dallaston2015_lower_type Returns an array indicating what type of boundary conditions\n apply for velocity at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function dallaston2015_lower_type (this) result(bound_type) Author Chris MacMackin Date January 2017 Specifies that the lower boundary in the first dimension has\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: velocity_upper_type => dallaston2015_upper_type Returns an array indicating what type of boundary conditions\n apply for velocity at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. private pure function dallaston2015_upper_type (this) result(bound_type) Author Chris MacMackin Date January 2017 Specifies that the upper boundary in the first dimension has\n Neumann boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable procedure, public :: boundary_residuals => dallaston2015_residuals Returns an array consisting of the difference between the\n required boundary values and those which actually exist. This\n can then be appended to a glacier's state vector. The order\n in which these are listed is as follows: lower thickness\n boundary, upper thickness boundary, lower velocity boundary,\n and upper velocity boundary. private function dallaston2015_residuals (this, thickness, velocity, viscosity, t) result(residuals) Author Chris MacMackin Date November 2016 Returns the difference between the glacier conditions of the\n plume and the Dirichlet conditions prescribed in the model of\n Dallaston et al. (2015) Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this class(scalar_field), intent(in) :: thickness A field containing the thickness of the glacier class(vector_field), intent(in) :: velocity A field containing the flow velocity of the glacier class(scalar_field), intent(in) :: viscosity A field containing the viscosity of the ice in the glacier. real(kind=r8), intent(in) :: t The time at which the boundary conditions are to be\n calculated. Return Value real(kind=r8),\n  allocatable, dimension(:) An array containing the difference between the required\n boundary values and those which are actually present. They\n are stored in the order: lower thickness boundary, upper\n thickness boundary, lower velocity boundary, and upper\n velocity boundary. Source Code type , extends ( glacier_boundary ), public :: dallaston2015_glacier_boundary !* Author: Chris MacMackin !  Date: November 2016 ! ! A type with procedures for getting the boundary conditions of ! the ice shelf model used by Dallaston et al. (2015). These are ! Dirichlet conditions at the lower bound of the first condition ! as well as, for thickness, the upper bound. ! ! @TODO Consider testing the consistency conditions at the outgoing boundary? ! private real ( r8 ) :: thickness = 1.0_r8 !! The thickness of the glacier at the inflowing boundary real ( r8 ) :: velocity = 1.0_r8 !! The velocity of the glacier at the inflowing boundary real ( r8 ) :: chi = 1.0_r8 !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ contains procedure :: thickness_lower_bound => dallaston2015_lower_bound !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the thickness !! field. procedure :: velocity_lower_bound => dallaston2015_lower_bound !! Returns a 1D array which should be passed as the !! `exclude_lower_bound`/`provide_lower_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: velocity_upper_bound => dallaston2015_upper_bound !! Returns a 1D array which should be passed as the !! `exclude_upper_bound`/`provide_upper_bound` argument when !! getting or setting the raw representation of the velocity !! field. procedure :: thickness_lower_type => dallaston2015_lower_type !! Returns an array indicating what type of boundary conditions !! apply for thickness at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_lower_type => dallaston2015_lower_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the lower boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: velocity_upper_type => dallaston2015_upper_type !! Returns an array indicating what type of boundary conditions !! apply for velocity at the upper boundary of each !! dimension. The types are specified using the parameters in !! [boundary_types_mod]. procedure :: boundary_residuals => dallaston2015_residuals !! Returns an array consisting of the difference between the !! required boundary values and those which actually exist. This !! can then be appended to a glacier's state vector. The order !! in which these are listed is as follows: lower thickness !! boundary, upper thickness boundary, lower velocity boundary, !! and upper velocity boundary. end type dallaston2015_glacier_boundary"},{"title":"ave_one_equation_melt – ISOFT ","tags":"","loc":"type/ave_one_equation_melt.html","text":"type, public, extends( abstract_melt_relationship ) :: ave_one_equation_melt A parameterisation of melting into a plume which comes from\n heavily simplifying the 3 equation model. It can work with\n horizontally-integrated plume models, taking account of the\n plume's transverse profile. It is taken from Dallaston, Hewitt,\n and Wells (2015), prior to the their dropping some terms based\n on scaling arguments. The melt rate, as well as effect on\n termperature and salinity, are calculated by calling solve_for_melt and then accessed\n using melt_rate , heat_equation_terms , salt_equation_terms . Inherits type~~ave_one_equation_melt~~InheritsGraph type~ave_one_equation_melt ave_one_equation_melt type~abstract_melt_relationship abstract_melt_relationship type~ave_one_equation_melt->type~abstract_melt_relationship scalar_field scalar_field type~ave_one_equation_melt->scalar_field forcing_values Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables forcing_values coef1 coef2 sal_forcing melt_temp a_UabsT Constructor ave_one_equation_melt Type-Bound Procedures solve_for_melt heat_equation_terms salt_equation_terms melt_rate has_heat_terms has_salt_terms Source Code ave_one_equation_melt Components Type Visibility Attributes Name Initial class(scalar_field), public, allocatable :: forcing_values Stores the resulting forcing values. real(kind=r8), public :: coef1 = 0.018208_r8 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), public :: coef2 = 0.023761_r8 The unitless multiplier applied to the thermal forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), public :: sal_forcing = 0._r8 The unitless multiplier applied to the forcing values to get\n the salinity forcing. It corresponds to the product of coef2 and the ice salinity. Typically this would be zero,\n but it might be positive if there is some marine ice\n present. Alternatively, depending on how the salinity has\n been scaled, it may have a negative value. real(kind=r8), public :: melt_temp = 0._r8 The melting temperature. While intuitively it makes sense to\n set this to zero, it can be useful to scale temperature in\n such a way that it will have a negative value. real(kind=r8), public :: a_UabsT = 1._r8 The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy, where f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the\n variables |\\vec{U}| and T in the transverse\n direction. Constructor public interface ave_one_equation_melt private pure function constructor (coef1, coef2, fresh_sal, melt_temp, a_UabsT) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coef1 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), intent(in) :: coef2 The unitless multiplier applied to the theram forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), intent(in), optional :: fresh_sal The salinity of fresh water. Defaults to 0. real(kind=r8), intent(in), optional :: melt_temp The melting point of the ice. Defaults to 0. real(kind=r8), intent(in), optional :: a_UabsT The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy, where f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the\n variables |\\vec{U}| and T in the transverse\n direction. Defaults to 1. Return Value type( ave_one_equation_melt ) The newly created object representing the melt relationship. Type-Bound Procedures procedure, public :: solve_for_melt => one_equation_solve private subroutine one_equation_solve (this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed. procedure, public :: heat_equation_terms => one_equation_heat Returns the terms this melt formulation contributes to the\n heat equation, after they have been solved for using solve_for_melt . private function one_equation_heat (this) result(heat) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the heat equation for a plume procedure, public :: salt_equation_terms => one_equation_salt Returns the terms this melt formulation contributes to the\n salt equation, after they have been solved for using solve_for_melt . private function one_equation_salt (this) result(salt) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the salt equation for a plume procedure, public :: melt_rate => ave_one_equation_melt_rate Returns the melt rate calculated using this formulation,\n after it has been solved for using solve_for_melt . private function ave_one_equation_melt_rate (this) result(melt) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate from the ice into the plume water. procedure, public :: has_heat_terms => one_equation_has_heat Whether this formulation of melting contributes any terms to\n a plume's heat equation. private pure function one_equation_has_heat (this) result(has_heat) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat equation of the plume. procedure, public :: has_salt_terms => one_equation_has_salt Whether this formulation of melting contributes any terms to\n a plume's salinity equation. private pure function one_equation_has_salt (this) result(has_salt) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the salinity equation of the plume. Source Code type , extends ( abstract_melt_relationship ), public :: ave_one_equation_melt !* Author: Christopher MacMackin !  Date: August 2018 ! ! A parameterisation of melting into a plume which comes from ! heavily simplifying the 3 equation model. It can work with ! horizontally-integrated plume models, taking account of the ! plume's transverse profile. It is taken from Dallaston, Hewitt, ! and Wells (2015), prior to the their dropping some terms based ! on scaling arguments. The melt rate, as well as effect on ! termperature and salinity, are calculated by calling ! [[abstract_melt_relationship:solve_for_melt]] and then accessed ! using [[abstract_melt_relationship:melt_rate]], ! [[abstract_melt_relationship:heat_equation_terms]], ! [[abstract_melt_relationship:salt_equation_terms]]. ! class ( scalar_field ), allocatable :: forcing_values !! Stores the resulting forcing values. real ( r8 ) :: coef1 = 0.018208_r8 !! The unitless multiplier on the thermal forcing term, !! \\Gamma_Tx_0/D_0. real ( r8 ) :: coef2 = 0.023761_r8 !! The unitless multiplier applied to the thermal forcing term to !! get the melt rate, c_oT_0/L. real ( r8 ) :: sal_forcing = 0._r8 !! The unitless multiplier applied to the forcing values to get !! the salinity forcing. It corresponds to the product of !! `coef2` and the ice salinity. Typically this would be zero, !! but it might be positive if there is some marine ice !! present. Alternatively, depending on how the salinity has !! been scaled, it may have a negative value. real ( r8 ) :: melt_temp = 0._r8 !! The melting temperature. While intuitively it makes sense to !! set this to zero, it can be useful to scale temperature in !! such a way that it will have a negative value. real ( r8 ) :: a_UabsT = 1._r8 !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy,  where !! f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the !! variables |\\vec{U}| and T in the transverse !! direction. contains procedure :: solve_for_melt => one_equation_solve procedure :: heat_equation_terms => one_equation_heat !! Returns the terms this melt formulation contributes to the !! heat equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: salt_equation_terms => one_equation_salt !! Returns the terms this melt formulation contributes to the !! salt equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: melt_rate => ave_one_equation_melt_rate !! Returns the melt rate calculated using this formulation, !! after it has been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: has_heat_terms => one_equation_has_heat !! Whether this formulation of melting contributes any terms to !! a plume's heat equation. procedure :: has_salt_terms => one_equation_has_salt !! Whether this formulation of melting contributes any terms to !! a plume's salinity equation. end type ave_one_equation_melt"},{"title":"newtonian_viscosity – ISOFT ","tags":"","loc":"type/newtonian_viscosity.html","text":"type, public, extends( abstract_viscosity ) :: newtonian_viscosity An implementation of Newtonian (constant) viscosity for a glacier. Inherits type~~newtonian_viscosity~~InheritsGraph type~newtonian_viscosity newtonian_viscosity type~abstract_viscosity abstract_viscosity type~newtonian_viscosity->type~abstract_viscosity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables viscosity_value Constructor newtonian_viscosity Type-Bound Procedures ice_viscosity Source Code newtonian_viscosity Components Type Visibility Attributes Name Initial real(kind=r8), private :: viscosity_value = 1.0_r8 Constructor public interface newtonian_viscosity private pure function constructor (viscosity_value) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: viscosity_value The numerical value of the viscosity which this type is meant \n to return. Return Value type( newtonian_viscosity ) The viscosity object being created. Type-Bound Procedures procedure, public :: ice_viscosity => newtonian_ice_viscosity Returns the viscosity for the ice. private function newtonian_ice_viscosity (this, velocity, temperature, time) result(viscosity) Arguments Type Intent Optional Attributes Name class( newtonian_viscosity ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the ice for which the velocity is\n being calculated real(kind=r8), intent(in) :: temperature The temperature of the ice for which viscosity is being\n calculated. real(kind=r8), intent(in), optional :: time The time at which the viscosity is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the viscosity Source Code type , extends ( abstract_viscosity ), public :: newtonian_viscosity !* Author: Christopher MacMackin !  Date: October 2016 ! ! An implementation of Newtonian (constant) viscosity for a glacier. ! private real ( r8 ) :: viscosity_value = 1.0_r8 contains procedure :: ice_viscosity => newtonian_ice_viscosity !! Returns the viscosity for the ice. end type newtonian_viscosity"},{"title":"glens_law_viscosity – ISOFT ","tags":"","loc":"type/glens_law_viscosity.html","text":"type, public, extends( abstract_viscosity ) :: glens_law_viscosity An implementation of Glen's flow law to describe glacier\n viscosity. It takes the form \\eta = \\frac{1}{2}BD&#94;{1/n-1}, where D = \\sqrt{D_{ij}D_{ij}/2 is the second invarient of\n the strain rate D_{ij} = \\frac{1}{2}\\left(\\frac{\\partial\n u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i}\n \\right). Here, B is treated as a constant, although it may\n be parameterised as a function of temperature. Inherits type~~glens_law_viscosity~~InheritsGraph type~glens_law_viscosity glens_law_viscosity type~abstract_viscosity abstract_viscosity type~glens_law_viscosity->type~abstract_viscosity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables b_val index Constructor glens_law_viscosity Type-Bound Procedures ice_viscosity Source Code glens_law_viscosity Components Type Visibility Attributes Name Initial real(kind=r8), private :: b_val = 1.0_r8 real(kind=r8), private :: index = 3._r8 Constructor public interface glens_law_viscosity private pure function constructor (b_val, index) result(this) Author Christopher MacMackin Date April 2017 Instantiates an instance of a viscosity object implementing\n Glen's flow law. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: b_val The coefficient, B , in Glen's flow law. real(kind=r8), intent(in) :: index The index, n , in the exponent of Glen's flow law. Return Value type( glens_law_viscosity ) The viscosity object being created. Type-Bound Procedures procedure, public :: ice_viscosity => glens_ice_viscosity Returns the viscosity for the ice. private function glens_ice_viscosity (this, velocity, temperature, time) result(viscosity) Author Christopher MacMackin Date April 2017 Calculates the viscosity of ice using Glen's flow law. See the\n documentation of the glens_law_viscosity object for a\n description of this parameterisation. Arguments Type Intent Optional Attributes Name class( glens_law_viscosity ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the ice for which the velocity is\n being calculated real(kind=r8), intent(in) :: temperature The temperature of the ice for which viscosity is being\n calculated. real(kind=r8), intent(in), optional :: time The time at which the viscosity is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the viscosity Source Code type , extends ( abstract_viscosity ), public :: glens_law_viscosity !* Author: Christopher MacMackin !  Date: April 2017 ! ! An implementation of Glen's flow law to describe glacier ! viscosity. It takes the form \\eta = \\frac{1}{2}BD&#94;{1/n-1}, ! where D = \\sqrt{D_{ij}D_{ij}/2 is the second invarient of ! the strain rate D_{ij} = \\frac{1}{2}\\left(\\frac{\\partial ! u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} ! \\right). Here, B is treated as a constant, although it may ! be parameterised as a function of temperature. ! private real ( r8 ) :: b_val = 1.0_r8 real ( r8 ) :: index = 3._r8 contains procedure :: ice_viscosity => glens_ice_viscosity !! Returns the viscosity for the ice. end type glens_law_viscosity"},{"title":"kochergin1987_entrainment – ISOFT ","tags":"","loc":"type/kochergin1987_entrainment.html","text":"type, public, extends( abstract_entrainment ) :: kochergin1987_entrainment A parameterisation of entrainment ( e ) as described by\n Kochergin (1987): e =\n \\frac{c_L&#94;2}{S_m}\\sqrt{|\\vec{U}|&#94;2+\\frac{g'D}{S_m}}. Here, c_L is an entrainment coefficient, \\vec{U} is the\n velocity of the plume, g' is the reduced gravity, and S_m is the turbulent Schmidt number. The latter-most can be\n expressed as S_m = \\frac{Ri}{0.0725(Ri + 0.186 -\n \\sqrt{Ri&#94;2 - 0.316Ri + 0.0346})} , where Ri =\n g'D/|\\vec{U}|&#94;2 is the Richardson number. Inherits type~~kochergin1987_entrainment~~InheritsGraph type~kochergin1987_entrainment kochergin1987_entrainment type~abstract_entrainment abstract_entrainment type~kochergin1987_entrainment->type~abstract_entrainment Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables coefficient delta Constructor kochergin1987_entrainment Type-Bound Procedures entrainment_rate Source Code kochergin1987_entrainment Components Type Visibility Attributes Name Initial real(kind=r8), private :: coefficient = 1.0_r8 The entrainment coefficient c_L&#94;2x_0/D_0 real(kind=r8), private :: delta = 0.036_r8 The ratio D_0/h_0 Constructor public interface kochergin1987_entrainment private pure function constructor (coefficient, delta) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coefficient The entrainment coefficient c_L&#94;2x_0/D_0 real(kind=r8), intent(in) :: delta The ratio D_0/h_0 Return Value type( kochergin1987_entrainment ) A new entrainment object Type-Bound Procedures procedure, public :: entrainment_rate => kochergin1987_rate Returns the entrainment rate for ambient water into the plume. private function kochergin1987_rate (this, velocity, thickness, depth, density_diff, time) result(entrainment) Author Christopher MacMackin Date Feburary 2018 e = \\frac{c_L&#94;2}{S_m}\\sqrt{|\\vec{U}|&#94;2+\\frac{g'D}{S_m}}. Here, c_L is an entrainment coefficient, \\vec{U} is the\n velocity of the plume, g' is the reduced gravity, and S_m is the turbulent Schmidt number. The Schmidt number is a\n function of the Richardson number Ri = g'D/|\\vec{U}|&#94;2 : S_m = \\frac{Ri}{0.0725(Ri + 0.186 -\n \\sqrt{Ri&#94;2 - 0.316Ri + 0.0346})}. Arguments Type Intent Optional Attributes Name class( kochergin1987_entrainment ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is being \n entrained. class(scalar_field), intent(in) :: thickness The thickness of the plume into which fluid is being\n entrained class(scalar_field), intent(in) :: depth The depth of the upper surface of the plume into which\n fluid is being entrained class(scalar_field), intent(in) :: density_diff The difference between the ambient density and the density of\n the plume into which the ambient fluid is being entrained. real(kind=r8), intent(in), optional :: time The time at which the entrainment is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the entrainment Source Code type , extends ( abstract_entrainment ), public :: kochergin1987_entrainment !* Author: Christopher MacMackin !  Date: Feburary 2018 ! ! A parameterisation of entrainment (e) as described by ! Kochergin (1987): e = ! \\frac{c_L&#94;2}{S_m}\\sqrt{|\\vec{U}|&#94;2+\\frac{g'D}{S_m}}. Here, ! c_L is an entrainment coefficient, \\vec{U} is the ! velocity of the plume, g' is the reduced gravity, and ! S_m is the turbulent Schmidt number. The latter-most can be ! expressed as  S_m = \\frac{Ri}{0.0725(Ri + 0.186 - ! \\sqrt{Ri&#94;2 - 0.316Ri + 0.0346})} , where Ri = ! g'D/|\\vec{U}|&#94;2 is the Richardson number. ! private real ( r8 ) :: coefficient = 1.0_r8 !! The entrainment coefficient c_L&#94;2x_0/D_0 real ( r8 ) :: delta = 0.036_r8 !! The ratio D_0/h_0 contains procedure :: entrainment_rate => kochergin1987_rate !! Returns the entrainment rate for ambient water into the plume. end type kochergin1987_entrainment"},{"title":"jenkins1991_entrainment – ISOFT ","tags":"","loc":"type/jenkins1991_entrainment.html","text":"type, public, extends( abstract_entrainment ) :: jenkins1991_entrainment A parameterisation of entrainment ( e ) as described by Jenkins\n (1991): e = E_0 |\\vec{U}\\sin(\\theta) \\simeq\n E_0|\\vec{U}||\\nabla b|. Here, E_0 is a coefficient typically\n taken to be 0.036 (the default value), \\vec{U} is the velocity\n of the plume, \\theta is the angle of slope of the ice shelf\n base, and b is the basal depth of the ice shelf. Inherits type~~jenkins1991_entrainment~~InheritsGraph type~jenkins1991_entrainment jenkins1991_entrainment type~abstract_entrainment abstract_entrainment type~jenkins1991_entrainment->type~abstract_entrainment Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables coefficient Constructor jenkins1991_entrainment Type-Bound Procedures entrainment_rate Source Code jenkins1991_entrainment Components Type Visibility Attributes Name Initial real(kind=r8), private :: coefficient = 1.0_r8 The entrainment coefficient $E_0$ Constructor public interface jenkins1991_entrainment private pure function constructor (coefficient) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coefficient The entrainment coefficient, $E_0$ to be used Return Value type( jenkins1991_entrainment ) A new entrainment object Type-Bound Procedures procedure, public :: entrainment_rate => jenkins1991_rate Returns the entrainment rate for ambient water into the plume. private function jenkins1991_rate (this, velocity, thickness, depth, density_diff, time) result(entrainment) Author Christopher MacMackin Date October 2016 e = E_0 |\\vec{U}\\sin(\\theta) \\simeq E_0|\\vec{U}||\\nabla b| Here, E_0 is a coefficient typically taken to be 0.036 (the\n default value), \\vec{U} is the velocity of the plume, \\theta is the angle of slope of the ice shelf base, and b is the\n basal depth of the ice shelf. Read more… Arguments Type Intent Optional Attributes Name class( jenkins1991_entrainment ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is being \n entrained. class(scalar_field), intent(in) :: thickness The thickness of the plume into which fluid is being\n entrained class(scalar_field), intent(in) :: depth The depth of the upper surface of the plume into which\n fluid is being entrained class(scalar_field), intent(in) :: density_diff The difference between the ambient density and the density of\n the plume into which the ambient fluid is being entrained. real(kind=r8), intent(in), optional :: time The time at which the entrainment is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the entrainment Source Code type , extends ( abstract_entrainment ), public :: jenkins1991_entrainment !* Author: Christopher MacMackin !  Date: October 2016 ! ! A parameterisation of entrainment (e) as described by Jenkins ! (1991): e = E_0 |\\vec{U}\\sin(\\theta) \\simeq ! E_0|\\vec{U}||\\nabla b|. Here, E_0 is a coefficient typically ! taken to be 0.036 (the default value), \\vec{U} is the velocity ! of the plume, \\theta is the angle of slope of the ice shelf ! base, and b is the basal depth of the ice shelf. ! private real ( r8 ) :: coefficient = 1.0_r8 !! The entrainment coefficient $E_0$ contains procedure :: entrainment_rate => jenkins1991_rate !! Returns the entrainment rate for ambient water into the plume. end type jenkins1991_entrainment"},{"title":"dallaston2015_melt – ISOFT ","tags":"","loc":"type/dallaston2015_melt.html","text":"type, public, extends( abstract_melt_relationship ) :: dallaston2015_melt A parameterisation of melting into a plume which comes from\n heavily simplifying the 3 equation model. It is taken from\n Dallaston, Hewitt, and Wells (2015). The melt rate, as well as\n effect on termperature and salinity, are calculated by calling solve_for_melt and then accessed\n using melt_rate , heat_equation_terms , salt_equation_terms . Inherits type~~dallaston2015_melt~~InheritsGraph type~dallaston2015_melt dallaston2015_melt type~abstract_melt_relationship abstract_melt_relationship type~dallaston2015_melt->type~abstract_melt_relationship scalar_field scalar_field type~dallaston2015_melt->scalar_field melt_values Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables melt_values coef melt_conversion salinity_denom Constructor dallaston2015_melt Type-Bound Procedures solve_for_melt heat_equation_terms salt_equation_terms melt_rate has_heat_terms has_salt_terms Source Code dallaston2015_melt Components Type Visibility Attributes Name Initial class(scalar_field), public, allocatable :: melt_values Stores the resulting melt rate real(kind=r8), public :: coef = 1449.29936 The coefficient by which the melt rate is multiplied in order\n to determine the contribution to the heat equation. real(kind=r8), public :: melt_conversion = 6.9e-4_r8 The factor to convert between the scale for melt used by\n Dallaston et al. (2015) and that used in ISOFT, \\frac{m_0x_0}{D_0U_0}, where m_0 is the melt scale\n used by Dalalston et al. real(kind=r8), public :: salinity_denom = 1e100_r8 Constructor public interface dallaston2015_melt private pure function constructor (beta, melt_conversion, salinity_denom) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: beta The inverse stefan number, \\frac{c(T_a - T_m)}{L} real(kind=r8), intent(in) :: melt_conversion The factor to convert between the scale for melt used by\n Dallaston et al. (2015) and that used in ISOFT, \\frac{m_0x_0}{D_0U_0}, where m_0 is the melt scale\n used by Dalalston et al. real(kind=r8), intent(in), optional :: salinity_denom The factor which, when used to divide the melt_conversion term, produces a conversion factor for the melt-terms in the\n salinity equation of Dallaston et al. (2015). It has the form \\frac{Q_{g0}}{D_0U_0}, where Q_{g0} is the\n subglacial discharge across the grounding line. Return Value type( dallaston2015_melt ) The newly created object representing the melt relationship. Type-Bound Procedures procedure, public :: solve_for_melt => dallaston2015_solve private subroutine dallaston2015_solve (this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed. procedure, public :: heat_equation_terms => dallaston2015_heat Returns the terms this melt formulation contributes to the\n heat equation, after they have been solved for using solve_for_melt . private function dallaston2015_heat (this) result(heat) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the heat equation for a plume procedure, public :: salt_equation_terms => dallaston2015_salt Returns the terms this melt formulation contributes to the\n salt equation, after they have been solved for using solve_for_melt . private function dallaston2015_salt (this) result(salt) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the salt equation for a plume procedure, public :: melt_rate => dallaston2015_melt_rate Returns the melt rate calculated using this formulation,\n after it has been solved for using solve_for_melt . private function dallaston2015_melt_rate (this) result(melt) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate from the ice into the plume water. procedure, public :: has_heat_terms => dallaston2015_has_heat Whether this formulation of melting contributes any terms to\n a plume's heat equation. private pure function dallaston2015_has_heat (this) result(has_heat) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat equation of the plume. procedure, public :: has_salt_terms => dallaston2015_has_salt Whether this formulation of melting contributes any terms to\n a plume's salinity equation. private pure function dallaston2015_has_salt (this) result(has_salt) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the salinity equation of the plume. Source Code type , extends ( abstract_melt_relationship ), public :: dallaston2015_melt !* Author: Christopher MacMackin !  Date: October 2016 ! ! A parameterisation of melting into a plume which comes from ! heavily simplifying the 3 equation model. It is taken from ! Dallaston, Hewitt, and Wells (2015). The melt rate, as well as ! effect on termperature and salinity, are calculated by calling ! [[abstract_melt_relationship:solve_for_melt]] and then accessed ! using [[abstract_melt_relationship:melt_rate]], ! [[abstract_melt_relationship:heat_equation_terms]], ! [[abstract_melt_relationship:salt_equation_terms]]. ! class ( scalar_field ), allocatable :: melt_values !! Stores the resulting melt rate real ( r8 ) :: coef = 144 9.29936 !! The coefficient by which the melt rate is multiplied in order !! to determine the contribution to the heat equation. real ( r8 ) :: melt_conversion = 6.9e-4_r8 !! The factor to convert between the scale for melt used by !! Dallaston et al. (2015) and that used in ISOFT,  !! \\frac{m_0x_0}{D_0U_0},  where m_0 is the melt scale !! used by Dalalston et al. real ( r8 ) :: salinity_denom = 1 e100_r8 contains procedure :: solve_for_melt => dallaston2015_solve procedure :: heat_equation_terms => dallaston2015_heat !! Returns the terms this melt formulation contributes to the !! heat equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: salt_equation_terms => dallaston2015_salt !! Returns the terms this melt formulation contributes to the !! salt equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: melt_rate => dallaston2015_melt_rate !! Returns the melt rate calculated using this formulation, !! after it has been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: has_heat_terms => dallaston2015_has_heat !! Whether this formulation of melting contributes any terms to !! a plume's heat equation. procedure :: has_salt_terms => dallaston2015_has_salt !! Whether this formulation of melting contributes any terms to !! a plume's salinity equation. end type dallaston2015_melt"},{"title":"one_equation_melt – ISOFT ","tags":"","loc":"type/one_equation_melt.html","text":"type, public, extends( abstract_melt_relationship ) :: one_equation_melt A parameterisation of melting into a plume which comes from\n heavily simplifying the 3 equation model. It is taken from\n Dallaston, Hewitt, and Wells (2015), prior to the their dropping\n some terms based on scaling arguments. The melt rate, as well as\n effect on termperature and salinity, are calculated by calling solve_for_melt and then accessed\n using melt_rate , heat_equation_terms , salt_equation_terms . Inherits type~~one_equation_melt~~InheritsGraph type~one_equation_melt one_equation_melt type~abstract_melt_relationship abstract_melt_relationship type~one_equation_melt->type~abstract_melt_relationship scalar_field scalar_field type~one_equation_melt->scalar_field forcing_values Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables forcing_values coef1 coef2 sal_forcing melt_temp Constructor one_equation_melt Type-Bound Procedures solve_for_melt heat_equation_terms salt_equation_terms melt_rate has_heat_terms has_salt_terms Source Code one_equation_melt Components Type Visibility Attributes Name Initial class(scalar_field), public, allocatable :: forcing_values Stores the resulting forcing values. real(kind=r8), public :: coef1 = 0.018208_r8 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), public :: coef2 = 0.023761_r8 The unitless multiplier applied to the thermal forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), public :: sal_forcing = 0._r8 The unitless multiplier applied to the forcing values to get\n the salinity forcing. It corresponds to the product of coef2 and the ice salinity. Typically this would be zero,\n but it might be positive if there is some marine ice\n present. Alternatively, depending on how the salinity has\n been scaled, it may have a negative value. real(kind=r8), public :: melt_temp = 0._r8 The melting temperature. While intuitively it makes sense to\n set this to zero, it can be useful to scale temperature in\n such a way that it will have a negative value. Constructor public interface one_equation_melt private pure function constructor (coef1, coef2, fresh_sal, melt_temp) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coef1 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), intent(in) :: coef2 The unitless multiplier applied to the theram forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), intent(in), optional :: fresh_sal The salinity of fresh water. Defaults to 0. real(kind=r8), intent(in), optional :: melt_temp The melting point of the ice. Defaults to 0. Return Value type( one_equation_melt ) The newly created object representing the melt relationship. Type-Bound Procedures procedure, public :: solve_for_melt => one_equation_solve private subroutine one_equation_solve (this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed. procedure, public :: heat_equation_terms => one_equation_heat Returns the terms this melt formulation contributes to the\n heat equation, after they have been solved for using solve_for_melt . private function one_equation_heat (this) result(heat) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the heat equation for a plume procedure, public :: salt_equation_terms => one_equation_salt Returns the terms this melt formulation contributes to the\n salt equation, after they have been solved for using solve_for_melt . private function one_equation_salt (this) result(salt) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the salt equation for a plume procedure, public :: melt_rate => one_equation_melt_rate Returns the melt rate calculated using this formulation,\n after it has been solved for using solve_for_melt . private function one_equation_melt_rate (this) result(melt) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate from the ice into the plume water. procedure, public :: has_heat_terms => one_equation_has_heat Whether this formulation of melting contributes any terms to\n a plume's heat equation. private pure function one_equation_has_heat (this) result(has_heat) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat equation of the plume. procedure, public :: has_salt_terms => one_equation_has_salt Whether this formulation of melting contributes any terms to\n a plume's salinity equation. private pure function one_equation_has_salt (this) result(has_salt) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the salinity equation of the plume. Source Code type , extends ( abstract_melt_relationship ), public :: one_equation_melt !* Author: Christopher MacMackin !  Date: May 2017 ! ! A parameterisation of melting into a plume which comes from ! heavily simplifying the 3 equation model. It is taken from ! Dallaston, Hewitt, and Wells (2015), prior to the their dropping ! some terms based on scaling arguments. The melt rate, as well as ! effect on termperature and salinity, are calculated by calling ! [[abstract_melt_relationship:solve_for_melt]] and then accessed ! using [[abstract_melt_relationship:melt_rate]], ! [[abstract_melt_relationship:heat_equation_terms]], ! [[abstract_melt_relationship:salt_equation_terms]]. ! class ( scalar_field ), allocatable :: forcing_values !! Stores the resulting forcing values. real ( r8 ) :: coef1 = 0.018208_r8 !! The unitless multiplier on the thermal forcing term, !! \\Gamma_Tx_0/D_0. real ( r8 ) :: coef2 = 0.023761_r8 !! The unitless multiplier applied to the thermal forcing term to !! get the melt rate, c_oT_0/L. real ( r8 ) :: sal_forcing = 0._r8 !! The unitless multiplier applied to the forcing values to get !! the salinity forcing. It corresponds to the product of !! `coef2` and the ice salinity. Typically this would be zero, !! but it might be positive if there is some marine ice !! present. Alternatively, depending on how the salinity has !! been scaled, it may have a negative value. real ( r8 ) :: melt_temp = 0._r8 !! The melting temperature. While intuitively it makes sense to !! set this to zero, it can be useful to scale temperature in !! such a way that it will have a negative value. contains procedure :: solve_for_melt => one_equation_solve procedure :: heat_equation_terms => one_equation_heat !! Returns the terms this melt formulation contributes to the !! heat equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: salt_equation_terms => one_equation_salt !! Returns the terms this melt formulation contributes to the !! salt equation, after they have been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: melt_rate => one_equation_melt_rate !! Returns the melt rate calculated using this formulation, !! after it has been solved for using !! [[abstract_melt_relationship:solve_for_melt]]. procedure :: has_heat_terms => one_equation_has_heat !! Whether this formulation of melting contributes any terms to !! a plume's heat equation. procedure :: has_salt_terms => one_equation_has_salt !! Whether this formulation of melting contributes any terms to !! a plume's salinity equation. end type one_equation_melt"},{"title":"get_scalar – ISOFT","tags":"","loc":"interface/get_scalar.html","text":"abstract interface private function get_scalar(this) result(property) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property of the glacier is being returned."},{"title":"get_r8 – ISOFT","tags":"","loc":"interface/get_r8.html","text":"abstract interface private pure function get_r8(this) result(property) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value real(kind=r8) The value of whatever property of the glacier is being returned."},{"title":"get_residual – ISOFT","tags":"","loc":"interface/get_residual.html","text":"abstract interface private function get_residual(this, previous_states, melt_rate, basal_drag_parameter, water_density) result(residual) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to\n calculate the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier Return Value real(kind=r8),\n  dimension(:),allocatable The residual of the system of equations describing the\n glacier"},{"title":"precond – ISOFT","tags":"","loc":"interface/precond.html","text":"abstract interface private function precond(this, previous_states, melt_rate, basal_drag_parameter, water_density, delta_state) result(preconditioned) Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to\n calculate the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier real(kind=r8), intent(in), dimension(:) :: delta_state The change to the state vector which is being\n preconditioned. Return Value real(kind=r8),\n  dimension(:),allocatable The result of applying the preconditioner to delta_state ."},{"title":"get_r81d – ISOFT","tags":"","loc":"interface/get_r81d.html","text":"abstract interface private function get_r81d(this) result(state_vector) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:),allocatable The state vector of the glacier"},{"title":"get_i – ISOFT","tags":"","loc":"interface/get_i.html","text":"abstract interface private pure function get_i(this) result(property) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value integer The value of whatever property of the glacier is being returned."},{"title":"t_step – ISOFT","tags":"","loc":"interface/t_step.html","text":"abstract interface private function t_step(this) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value real(kind=r8) A time step which will allow integration of the ice shelf\n without causing numerical instability."},{"title":"solve_vel – ISOFT","tags":"","loc":"interface/solve_vel.html","text":"abstract interface private subroutine solve_vel(this, basal_drag, success) Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. logical, intent(out) :: success True if the integration is successful, false otherwise"},{"title":"setter – ISOFT","tags":"","loc":"interface/setter.html","text":"abstract interface private subroutine setter(this, state_vector) Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n glacier."},{"title":"time_setter – ISOFT","tags":"","loc":"interface/time_setter.html","text":"abstract interface private subroutine time_setter(this, time) Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the glacier is in the present state."},{"title":"read_dat – ISOFT","tags":"","loc":"interface/read_dat.html","text":"abstract interface private subroutine read_dat(this, file_id, group_name, error) Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group from which the data\n will be read. character(len=*), intent(in) :: group_name The name of the group in the HDF5 file from which to read\n glacier's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0."},{"title":"write_dat – ISOFT","tags":"","loc":"interface/write_dat.html","text":"abstract interface private subroutine write_dat(this, file_id, group_name, error) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n glacier's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0."},{"title":"assign_ice – ISOFT","tags":"","loc":"interface/assign_ice.html","text":"abstract interface private subroutine assign_ice(this, rhs) Arguments Type Intent Optional Attributes Name class( glacier ), intent(out) :: this class( glacier ), intent(in) :: rhs"},{"title":"thickness_func – ISOFT","tags":"","loc":"interface/thickness_func.html","text":"abstract interface public pure function thickness_func(location) result(thickness) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the thickness Return Value real(kind=r8) The thickness of the glacier at location Description Abstract interface for function providing the glacier thickness\n when a concrete object is being instantiated."},{"title":"velocity_func – ISOFT","tags":"","loc":"interface/velocity_func~3.html","text":"abstract interface public pure function velocity_func(location) result(velocity) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the thickness Return Value real(kind=r8),\n  dimension(:),allocatable The velocity vector of the ice in the glacier at location Description Abstract interface for function providing the glacier velocity\n when a concrete object is being instantiated."},{"title":"scalar_func – ISOFT","tags":"","loc":"interface/scalar_func.html","text":"abstract interface private pure function scalar_func(location) result(scalar) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the property Return Value real(kind=r8) The value of the scalar quantity at location Description Abstract interface for function providing the initial values\n for the scalar properties of an asym_plume object\n when it is being instantiated."},{"title":"velocity_func – ISOFT","tags":"","loc":"interface/velocity_func.html","text":"abstract interface private pure function velocity_func(location) result(vector) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the thickness Return Value real(kind=r8),\n  dimension(:),allocatable The velocity vector of the water in the plume at location Description Abstract interface for function providing the asym_plume velocity when an object is being\n instantiated."},{"title":"get_property – ISOFT","tags":"","loc":"interface/get_property.html","text":"abstract interface private function get_property(this, depth, t) result(property) Arguments Type Intent Optional Attributes Name class( ambient_conditions ), intent(in) :: this class(scalar_field), intent(in) :: depth A field containing the depths at which the ambient conditions\n are to be calculated. real(kind=r8), intent(in) :: t The time at which the ambient conditions are to be calculated. Return Value class(scalar_field),\n  pointer A field containing the ambient conditions at the depth specified\n for each location."},{"title":"scalar_func – ISOFT","tags":"","loc":"interface/scalar_func~2.html","text":"abstract interface private pure function scalar_func(location) result(scalar) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the property Return Value real(kind=r8) The value of the scalar quantity at location Description Abstract interface for function providing the initial values\n for the scalar properties of a static_plume object when it\n is being instantiated."},{"title":"velocity_func – ISOFT","tags":"","loc":"interface/velocity_func~2.html","text":"abstract interface private pure function velocity_func(location) result(vector) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the thickness Return Value real(kind=r8),\n  dimension(:),allocatable The velocity vector of the water in the plume at location Description Abstract interface for function providing the plume velocity\n when an object is being instantiated."},{"title":"get_scalar – ISOFT","tags":"","loc":"interface/get_scalar~2.html","text":"abstract interface private function get_scalar(this) result(property) Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property is being returned."},{"title":"has_terms – ISOFT","tags":"","loc":"interface/has_terms.html","text":"abstract interface private pure function has_terms(this) Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat or salinity equations."},{"title":"solve – ISOFT","tags":"","loc":"interface/solve.html","text":"abstract interface private subroutine solve(this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed."},{"title":"kappa_init_func – ISOFT","tags":"","loc":"interface/kappa_init_func.html","text":"abstract interface private pure function kappa_init_func(n, location) result(kappa) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The index of the Taylor coefficient being calculated real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the coefficient Return Value real(kind=r8) The value of coefficient n at location Description Abstract interface for function providing the Taylor\n coefficients describing the distribution of internal\n reflectors within an ice shelf."},{"title":"get_viscosity – ISOFT","tags":"","loc":"interface/get_viscosity.html","text":"abstract interface private function get_viscosity(this, velocity, temperature, time) result(property) Arguments Type Intent Optional Attributes Name class( abstract_viscosity ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the ice for which the velocity is\n being calculated real(kind=r8), intent(in) :: temperature The temperature of the ice for which viscosity is being\n calculated. real(kind=r8), intent(in), optional :: time The time at which the viscosity is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the viscosity"},{"title":"get_scalar – ISOFT","tags":"","loc":"interface/get_scalar~3.html","text":"abstract interface private function get_scalar(this) result(property) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property of the basal surface is being\n returned."},{"title":"get_real – ISOFT","tags":"","loc":"interface/get_real.html","text":"abstract interface private function get_real(this) result(property) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value real(kind=r8) The value of whatever property of the basal surface is being \n returned."},{"title":"get_r81d – ISOFT","tags":"","loc":"interface/get_r81d~2.html","text":"abstract interface private function get_r81d(this) result(state_vector) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:),allocatable The state vector of the basal surface"},{"title":"get_i – ISOFT","tags":"","loc":"interface/get_i~2.html","text":"abstract interface private function get_i(this) result(property) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value integer The value of whatever property of the basal surface is being\n returned."},{"title":"setter – ISOFT","tags":"","loc":"interface/setter~2.html","text":"abstract interface private subroutine setter(this, state_vector, ice_thickness) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n basal surface. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate and/or drag parameter."},{"title":"time_setter – ISOFT","tags":"","loc":"interface/time_setter~2.html","text":"abstract interface private subroutine time_setter(this, time) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the basal surface is in the present state."},{"title":"read_dat – ISOFT","tags":"","loc":"interface/read_dat~2.html","text":"abstract interface private subroutine read_dat(this, file_id, group_name, error) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group from which the data\n will be read. character(len=*), intent(in) :: group_name The name of the group in the HDF5 file from which to read\n basal surface's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0."},{"title":"write_dat – ISOFT","tags":"","loc":"interface/write_dat~2.html","text":"abstract interface private subroutine write_dat(this, file_id, group_name, error) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n basal surface's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0."},{"title":"surface_solve – ISOFT","tags":"","loc":"interface/surface_solve.html","text":"abstract interface private subroutine surface_solve(this, ice_thickness, ice_density, ice_temperature, time, success) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise"},{"title":"L_intr – ISOFT","tags":"","loc":"interface/l_intr.html","text":"abstract interface public function L_intr(u) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: u The state vector for the system of differential equations Return Value real(kind=r8),\n  dimension(size(u)) Description An interface for the (linear) left-hand-side of an ODE\n being solved by quasilinearisation."},{"title":"f_intr – ISOFT","tags":"","loc":"interface/f_intr.html","text":"abstract interface public function f_intr(u) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:,:) :: u The state vector for the system of differential equations,\n and its derivatives. Column i represents the i-1 derivative. Return Value real(kind=r8),\n  dimension(size(u,1)) Description An interface for the (nonlinear) right-hand-side of an ODE\n being solved by quasilinearisation."},{"title":"jac_intr – ISOFT","tags":"","loc":"interface/jac_intr.html","text":"abstract interface public function jac_intr(u, du) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:,:) :: u The state vector for the system of differential equations,\n and its derivatives, for which the Jacobian should be\n evaluated. Column i represents the i-1 derivative. real(kind=r8), intent(in), dimension(:,:) :: du The state vector for the system of differential equations,\n and its derivatives, which the Jacobian operates on. Column i represents the i-1 derivative. Return Value real(kind=r8),\n  dimension(size(u,1)) Description An interface for the product of the Jacobian of the\n (nonlinear) right-hand-side of an ODE and another vector."},{"title":"diff_intr – ISOFT","tags":"","loc":"interface/diff_intr.html","text":"abstract interface public function diff_intr(u, n) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: u The state vector for the system of differential equations integer, intent(in) :: n The order of the derivative to take Return Value real(kind=r8),\n  dimension(size(u)) Description An interface for a function evaluating the derivative of the\n state vector."},{"title":"pre_intr – ISOFT","tags":"","loc":"interface/pre_intr.html","text":"abstract interface public function pre_intr(v, u, L, f, fcur, rhs) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: v The vector to be preconditioned. real(kind=r8), intent(in), dimension(:,:) :: u The current state vector for the system of differential\n equations, and its derivatives. Column i represents the i-1 derivative. procedure( L_intr ) :: L The linear, left-hand-side of the ODE being solved. procedure( f_intr ) :: f The nonlinear, right-hand-side of the ODE being solved. real(kind=r8), intent(in), dimension(:) :: fcur The result of f(u) real(kind=r8), intent(in), dimension(:) :: rhs The right hand side of the linear system being\n preconditioned. Return Value real(kind=r8),\n  dimension(size(v)) The result of applying the preconditioner. Description An interface for a preconditioner to be used with the\n quasilinearisation ODE solver."},{"title":"scalar_func – ISOFT","tags":"","loc":"interface/scalar_func~3.html","text":"abstract interface private pure function scalar_func(location) result(scalar) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the property Return Value real(kind=r8) The value of the scalar quantity at location Description Abstract interface for function providing the initial values\n for the scalar properties of a plume object when it\n is being instantiated."},{"title":"velocity_func – ISOFT","tags":"","loc":"interface/velocity_func~4.html","text":"abstract interface private pure function velocity_func(location) result(vector) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the thickness Return Value real(kind=r8),\n  dimension(:),allocatable The velocity vector of the water in the plume at location Description Abstract interface for function providing the plume velocity\n when an object is being instantiated."},{"title":"dinpr_intr – ISOFT","tags":"","loc":"interface/dinpr_intr.html","text":"abstract interface public function dinpr_intr(n, x, sx, y, sy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The length of the vectors real(kind=r8), intent(in), dimension(*) :: x The first input vector integer, intent(in) :: sx The stride in memory between successive elements of x real(kind=r8), intent(in), dimension(*) :: y The second input vector integer, intent(in) :: sy The stride in memory between successive elements of y Return Value real(kind=r8) Inner product of x and y Description Interface for function which calculates vector inner products.\n This has the same interace as the BLAS routine ddot ."},{"title":"dnorm_intr – ISOFT","tags":"","loc":"interface/dnorm_intr.html","text":"abstract interface public function dnorm_intr(n, x, sx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The length of the array real(kind=r8), intent(in), dimension(*) :: x The input vector integer, intent(in) :: sx The stride in memory between consecutive elements of x Return Value real(kind=r8) The vector norm of x Description Interface for function which calculates vector norms. This\n has the same interface as the BLAS routine dnrm2."},{"title":"mat_mult – ISOFT","tags":"","loc":"interface/mat_mult.html","text":"abstract interface public function mat_mult(v, xcur, rhs, rpar, ipar, success) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: v The vector to be multiplied real(kind=r8), intent(in), dimension(:) :: xcur Array containing the current estimate of the independent\n variables in the linear system. This may not be needed, but\n is provided just in case. real(kind=r8), intent(in), dimension(:) :: rhs Array containing the right hand side of the linear\n system. This may not be needed, but is provided just in\n case. real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array integer, intent(inout), dimension(*) :: ipar Parameter/work array logical, intent(out) :: success Indicates whether operation was completed succesfully Return Value real(kind=r8),\n  dimension(size(xcur)) Result of the operation Description Interface for operations representing the multiplication of a\n vector by a matrix, such as that for a linear operator or a\n preconditioner."},{"title":"f_intr – ISOFT","tags":"","loc":"interface/f_intr~2.html","text":"abstract interface public subroutine f_intr(n, xcur, fcur, rpar, ipar, itrmf) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(out), dimension(n) :: fcur Array of length n containing f(xcur) on output real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array integer, intent(inout), dimension(*) :: ipar Parameter/work array integer, intent(out) :: itrmf Termination flag. 0 means normal termination, 1 means\n failure to produce f(xcur) Description Interface for a subroutine which evaluates the function\n the zero of which is sought."},{"title":"jacv_intr – ISOFT","tags":"","loc":"interface/jacv_intr.html","text":"abstract interface public subroutine jacv_intr(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(in), dimension(n) :: fcur Array of length n containing the current f(x) value integer, intent(in) :: ijob Integer flag indicating which product is desired. 0\n indicates z = J\\vec{v} . 1 indicates z = P&#94;{-1}\\vec{v} . real(kind=r8), intent(in), dimension(n) :: v An array of length n to be multiplied real(kind=r8), intent(out), dimension(n) :: z An array of length n containing the desired product on\n output. real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array integer, intent(inout), dimension(*) :: ipar Parameter/work array integer, intent(out) :: itrmjv Termination flag. 0 indcates normal termination, 1\n indicatesfailure to prodce J\\vec{v} , and 2 indicates\n failure to produce P&#94;{-1}\\vec{v} Description Interface for a subroutine which optionally evaluates J\\vec{v} or P&#94;{-1}\\vec{v} , where J is the Jacobian\n of f and P is a right preconditioning operator."},{"title":"get_property – ISOFT","tags":"","loc":"interface/get_property~2.html","text":"abstract interface private function get_property(this, temperature, salinity) result(density) Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water"},{"title":"get_property_dx – ISOFT","tags":"","loc":"interface/get_property_dx.html","text":"abstract interface private function get_property_dx(this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the derivative of the density of the\n water in direction dir"},{"title":"get_coef – ISOFT","tags":"","loc":"interface/get_coef.html","text":"abstract interface private function get_coef(this, temperature, salinity) result(coef) Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable"},{"title":"get_entrainment – ISOFT","tags":"","loc":"interface/get_entrainment.html","text":"abstract interface private function get_entrainment(this, velocity, thickness, depth, density_diff, time) result(property) Arguments Type Intent Optional Attributes Name class( abstract_entrainment ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is being \n entrained. class(scalar_field), intent(in) :: thickness The thickness of the plume into which fluid is being\n entrained class(scalar_field), intent(in) :: depth The depth of the upper surface of the plume into which\n fluid is being entrained class(scalar_field), intent(in) :: density_diff The difference between the ambient density and the density of\n the plume into which the ambient fluid is being entrained. real(kind=r8), intent(in), optional :: time The time at which the entrainment is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the entrainment"},{"title":"bound_vals – ISOFT","tags":"","loc":"interface/bound_vals.html","text":"abstract interface private pure subroutine bound_vals(time, D, U, T, S) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: time The time at which the boundary values are being calculated real(kind=r8), intent(out) :: D Plume thickness boundary condition real(kind=r8), intent(out), dimension(:), allocatable :: U Plume velocity boundary condition real(kind=r8), intent(out) :: T Plume temperature boundary condition real(kind=r8), intent(out) :: S Plume salinity boundary condition"},{"title":"non_diff – ISOFT","tags":"","loc":"interface/non_diff.html","text":"abstract interface private subroutine non_diff(D, U, T, S, b, DU_x, DUU_x, DUT_x, DUS_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: D The plume thickness class(vector_field), intent(in) :: U The plume velocity class(scalar_field), intent(in) :: T The plume temperature class(scalar_field), intent(in) :: S The plume salinity class(scalar_field), intent(in) :: b The debth of the base of the ice shelf class(scalar_field), intent(out) :: DU_x The derivative of the product DU class(vector_field), intent(out) :: DUU_x The derivative of the product DUU class(scalar_field), intent(out) :: DUT_x The derivative of the product DUT class(scalar_field), intent(out) :: DUS_x The derivative of the product DUS"},{"title":"nitstb2 – ISOFT","tags":"","loc":"proc/nitstb2.html","text":"subroutine nitstb2(n, xcur, fcur, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, ifdord, nfe, njve, nrpre, nli, r, rtil, p, phat, v, t, rwork1, rwork2, rsnrm, dinpr, dnorm, itrmks) FCNRM is no longer an argument, as it needs to be calculated from the\n residual, which isn't known until a little way into this routine. It\n could be calculated by the calling routine, but that would mean doing\n the calculation twice. step    = vector of length n, (trial) step. eta     = relative residual reduction factor. f      = name of user-supplied subroutine for evaluating the function \n           the zero of which is sought; this routine has the form subroutine f(n, xcur, fcur, rpar, ipar, itrmf)\n\n       where xcur is the array containing the current x value, fcur \n       is f(xcur) on output, rpar and ipar are, respectively, real \n       and integer parameter/work arrays for use by the subroutine,\n       and itrmf is an integer termination flag.  The meaning of\n       itrmf is as follows:\n         0 =&gt; normal termination; desired function value calculated.\n         1 =&gt; failure to produce f(xcur). jacv   = name of user-supplied subroutine for evaluating J v or \n           P(inverse) v, where J is the Jacobian of f and P is a \n           right preconditioning operator. If neither analytic J v \n           evaluations nor right preconditioning is used, this can \n           be a dummy subroutine; if right preconditioning is used but \n           not analytic J v evaluations, this need only evaluate \n           P(inverse)*v. The form is subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv)\n\n       where xcur and fcur are vectors of length n containing the \n       current x and f values, ijob is an integer flag indicating \n       which product is desired, v is a vector of length n to be \n       multiplied, z is a vector of length n containing the desired \n       product on output, rpar and ipar are, respectively, real \n       and integer parameter/work arrays for use by the subroutine, \n       and itrmjv is an integer termination \n       flag. The meaning of ijob is as follows: \n         0 =&gt; z = J*v\n         1 =&gt; z = P(inverse)*v \n       The meaning of itrmjv is as follows:\n         0 =&gt; normal termination; desired product evaluated. \n         1 =&gt; failure to produce J*v.\n         2 =&gt; failure to produce P(inverse)*v. \n       This subroutine is called only from nitjv, and is always \n       called with v .ne. z. rpar    = real parameter/work array passed to the f and jacv routines. ipar    = integer parameter/work array passed to the f and jacv routines. ijacv   = flag for determining method of J*v evaluation.\n              0 => finite-difference evaluation (default). \n              1 => analytic evaluation. irpre   = flag for right preconditioning. \n              0 => no right preconditioning\n              1 => right preconditioning iksmax  = maximum allowable number of BiCGSTAB iterations. ifdord  = order of the finite-difference formula used in BiCGSTAB \n            when J*v products are evaluated using finite-differences. \n            When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or \n            4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on \n            input to this subroutine, ifdord determines the order of the \n            finite-difference formula used at each BiCGSTAB iteration \n            (default 1). In this case, ijacv is set to -1 below to \n            signal to nitjv that the order of the finite-difference \n            formula is to be determined by ifdord. The original value \n            ijacv = 0 is restored on return. nfe     = number of function evaluations. njve    = number of J*v evaluations. nrpre   = number of P(inverse)*v evaluations. nli     = number of linear iterations. r       = residual vector rtil    = \"r-tilde\" vector used in BiCGSTAB p       = vector used in BiCGSTAB phat    = vector used in BiCGSTAB v       = vector used in BiCGSTAB t       = vector used in BiCGSTAB rwork1  = work vector, passed on to nitjv rwork2  = work vector, passed on to nitjv rsnrm   = BiCGSTAB residual norm on return. dinpr   = inner-product routine, either user-supplied or blas ddot. dnorm   = norm routine, either user-supplied or blas dnrm2. itrmks  = termination flag; values have the following meanings: \n              0 => normal termination: acceptable step found. \n              1 => J v failure in nitjv. \n              2 => P(inverse) v failure in nitjv. \n              3 => acceptable step not found in iksmax BiCGSTAB iterations. \n              4 => BiCGSTAB breakdown. Note: On return, nitsol terminates if itrmks is 1 or 2. \n         If itrmks is 3 or 4, nitsol may terminate or continue. \n         In this event, the step returned is a meaningful inexact \n         Newton step only if the residual norm has been reduced. \n         A decision on termination/continuation is made in nitdrv \n         according to whether there is sufficient residual norm \n         reduction, even though the desired inexact Newton condition \n         may not hold. Subroutines required by this and all called routines: user supplied: f, jacv\n\nnitsol routines: nitjv, nitfd\n\nblas routines: daxpy, dcopy, dscal\n\nlapack routine:  dlamch\n\nuser supplied or blas: dinpr, dnorm\n\nexplanation: In nitsol, dinpr and dnorm are set to either the blas \nddot and dnrm2 routines or the user-supplied usrnpr and usrnrm \nroutines. This subroutine called by: nitdrv Subroutines called by this subroutine: daxpy, dcopy, dscal, dinpr, dlamch,\n    dnorm, nitjv Common block: <<<<<<<<<<<<<<<<<<<<< TAKEN FROM nitprint.h >>>>>>>>>>>>>>>>>>>>>>>>> Include these declaratinos and common blocks directly so that the \n include files are not needed in isoft. Do not set the step to 0, as it contains an initial guess at the \n solution. C      do 10 i = 1, n\nC         step(i) = 0.d0\nC 10   continue Because the initial step is not zero, the residual must include an\n evaluation of the left-hand-side.. Arguments Type Intent Optional Attributes Name integer :: n double precision :: xcur (n) double precision :: fcur (n) double precision :: step (n) double precision :: eta real :: f integer :: jacv double precision :: rpar (*) integer :: ipar (*) integer :: ijacv integer :: irpre integer :: iksmax integer :: ifdord integer :: nfe integer :: njve integer :: nrpre integer :: nli double precision :: r (n) double precision :: rtil (n) double precision :: p (n) double precision :: phat (n) double precision :: v (n) double precision :: t (n) double precision :: rwork1 (n) double precision :: rwork2 (n) double precision :: rsnrm double precision :: dinpr double precision :: dnorm integer :: itrmks Calls proc~~nitstb2~~CallsGraph proc~nitstb2 nitstb2 dcopy dcopy proc~nitstb2->dcopy nitjv nitjv proc~nitstb2->nitjv daxpy daxpy proc~nitstb2->daxpy dscal dscal proc~nitstb2->dscal dlamch dlamch proc~nitstb2->dlamch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks nitprint Common Blocks common /nitprint/ If diagnostic information is desired, include this common block in the \n main program and set iplvl and ipunit according to the following: iplvl = 0 =&gt; no printout\n       = 1 =&gt; iteration numbers and F-norms\n       = 2 =&gt; ... + some stats, step norms, and linear model norms\n       = 3 =&gt; ... + some Krylov solver and backtrack information\n       = 4 =&gt; ... + more Krylov solver and backtrack information\n\n ipunit = printout unit number. Type Attributes Name Initial integer :: iplvl integer :: ipunit $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })"},{"title":"nitgm2 – ISOFT","tags":"","loc":"proc/nitgm2.html","text":"subroutine nitgm2(n, xcur, fcur, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, iresup, ifdord, nfe, njve, nrpre, nli, kdmax, kdmaxp1, vv, rr, svbig, svsml, w, rwork, rsnrm, dinpr, dnorm, itrmks) FCNRM is no longer an argument, as it needs to be calculated from the\n residual, which isn't known until a little way into this routine. It\n could be calculated by the calling routine, but that would mean doing\n the calculation twice. step    = vector of length n, (trial) step. eta     = relative residual reduction factor. f       = name of user-supplied subroutine for evaluating the function \n            the zero of which is sought; this routine has the form subroutine f(n, xcur, fcur, rpar, ipar, itrmf)\n\n       where xcur is the array containing the current x value, fcur \n       is f(xcur) on output, rpar and ipar are, respectively, real \n       and integer parameter/work arrays for use by the subroutine,\n       and itrmf is an integer termination flag.  The meaning of\n       itrmf is as follows:\n         0 =&gt; normal termination; desired function value calculated.\n         1 =&gt; failure to produce f(xcur). jacv    = name of user-supplied subroutine for evaluating J v or \n            P(inverse) v, where J is the Jacobian of f and P is a \n            right preconditioning operator. If neither analytic J v \n            evaluations nor right preconditioning is used, this can \n            be a dummy subroutine; if right preconditioning is used but \n            not analytic J v evaluations, this need only evaluate \n            P(inverse)*v. The form is subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv)\n\n        where xcur and fcur are vectors of length n containing the \n        current x and f values, ijob is an integer flag indicating \n        which product is desired, v is a vector of length n to be \n        multiplied, z is a vector of length n containing the desired \n        product on output, rpar and ipar are, respectively, real \n        and integer parameter/work arrays for use by the subroutine, \n        and itrmjv is an integer termination \n        flag. The meaning of ijob is as follows: \n          0 =&gt; z = J*v\n          1 =&gt; z = P(inverse)*v \n        The meaning of itrmjv is as follows:\n          0 =&gt; normal termination; desired product evaluated. \n          1 =&gt; failure to produce J*v.\n          2 =&gt; failure to produce P(inverse)*v. \n        This subroutine is called only from nitjv, and is always \n        called with v .ne. z. rpar    = real parameter/work array passed to the f and jacv routines. ipar    = integer parameter/work array passed to the f and jacv routines. ijacv   = flag for determining method of J*v evaluation.\n              0 => finite-difference evaluation (default). \n              1 => analytic evaluation. irpre   = flag for right preconditioning. \n              0 => no right preconditioning\n              1 => right preconditioning iksmax  = maximum allowable number of GMRES iterations. iresup  = residual update flag; on GMRES restarts, the residual is \n            updated as follows: \n               0 => linear combination (default) \n               1 => direct evaluation\n            The first is cheap (one n-vector saxpy) but may lose \n            accuracy with extreme residual reduction; the second \n            retains accuracy better but costs one J*v product ifdord  = order of the finite-difference formula (sometimes) used on \n            GMRES restarts when J*v products are evaluated using finite-\n            differences. When ijacv = 0 on input to nitsol, ifdord is set \n            to 1, 2, or 4 in nitsol; otherwise, it is irrelevant. When \n            ijacv = 0 on input to this subroutine, the precise meaning is \n            as follows: With GMRES , ifdord matters only if iresup = 1 , in which case it determines the order of the finite-difference formula used in evaluating the initial residual at each GMRES restart ( default 2 ). If iresup = 1 and ijacv = 0 on input to this subroutine , then ijacv is temporarily reset to -1 at each restart below to force a finite-difference evaluation of order ifdord . NOTE : This only affects initial residuals at restarts ; first-order differences are always used within each GMRES cycle . Using higher-order differences at restarts only should give the same accuracy as if higher-order differences were used throughout ; see K . Turner and H . F . Walker , \"Efficient high accuracy solutions with GMRES(m),\" SIAM J . Sci . Stat . Comput ., 13 ( 1992 ), pp . 815--825 . nfe     = number of function evaluations. njve    = number of J*v evaluations. nrpre   = number of P(inverse)*v evaluations. nli     = number of linear iterations. kdmax   = maximum Krylov subspace dimension; default 10. kdmaxp1 = kdmax + 1. vv      = n x (kdmax+1) matrix for storage of Krylov basis in GMRES;\n            on return, the residual vector is contained in the first \n            column. rr      = kdmax x kdmax matrix for storage of triangular matrix in GMRES. svbig   = vector of length kdmax for storage of estimate of singular \n            vector of rr with largest singular value. svsml   = vector of length kdmax for storage of estimate of singular \n            vector of rr with smallest singular value. w       = vector of length kdmax, contains right-hand side of \n            triangular system and least-squares residual norm in GMRES. rwork   = vector of length n, work array. rsnrm   = GMRES residual norm on return. dinpr   = inner-product routine, either user-supplied or blas ddot. dnorm   = norm routine, either user-supplied or blas dnrm2. itrmks  = termination flag; values have the following meanings: \n              0 => normal termination: acceptable step found. \n              1 => J v failure in nitjv. \n              2 => P(inverse) v failure in nitjv. \n              3 => acceptable step not found in iksmax GMRES iterations. \n              4 => insufficient residual norm reduction over a cycle \n                   of kdmax steps (stagnation) before an acceptable step \n                   has been found. \n              5 => dangerous ill-conditioning detected before an acceptable \n                   step has been found. Note: On return, nitsol terminates if itrmks is 1 or 2. If  \n         itrmks is 3, 4, or 5, nitsol may terminate or continue. In \n         this event, a meaningful inexact Newton step is returned, \n         even though the desired inexact Newton condition may not \n         hold, and a decision on termination/continuation is made \n         in nitdrv according to whether there is sufficient residual \n         norm reduction. Subroutines required by this and all called routines: user supplied: f, jacv\n\nnitsol routines: nitjv, nitfd\n\nlapack routine: dlaic1, dlamch\n\nblas routines: daxpy, dcopy, dscal\n\nuser supplied or blas: dinpr, dnorm\n\nexplanation: In nitsol, dinpr and dnorm are set to either the blas \nddot and dnrm2 routines or the user-supplied usrnpr and usrnrm \nroutines. This subroutine called by: nitdrv Subroutines called by this subroutine: daxpy, dcopy, dscal, dlaic1, \n    dlamch, dinpr, dnorm, nitjv Common block: <<<<<<<<<<<<<<<<<<<<< TAKEN FROM nitprint.h >>>>>>>>>>>>>>>>>>>>>>>>> Include these declaratinos and common blocks directly so that the \n include files are not needed in isoft. Do not set the step to 0, as it contains an initial guess at the \n solution. C      do 20 i = 1, n\nC         step(i) = 0.d0\nC 20   continue Because the initial step is not zero, the residual must include an\n evaluation of the left-hand-side.. C      call dcopy(n, fcur, 1, vv(1,1), 1) Arguments Type Intent Optional Attributes Name integer :: n double precision :: xcur (n) double precision :: fcur (n) double precision :: step (n) double precision :: eta real :: f integer :: jacv double precision :: rpar (*) integer :: ipar (*) integer :: ijacv integer :: irpre integer :: iksmax integer :: iresup integer :: ifdord integer :: nfe integer :: njve integer :: nrpre integer :: nli integer :: kdmax integer :: kdmaxp1 double precision :: vv (n,kdmaxp1) double precision :: rr (kdmax,kdmax) double precision :: svbig (kdmax) double precision :: svsml (kdmax) double precision :: w (kdmax) double precision :: rwork (n) double precision :: rsnrm double precision :: dinpr double precision :: dnorm integer :: itrmks Calls proc~~nitgm2~~CallsGraph proc~nitgm2 nitgm2 2 2 proc~nitgm2->2 dscal dscal proc~nitgm2->dscal daxpy daxpy proc~nitgm2->daxpy dsin dsin proc~nitgm2->dsin dacos dacos proc~nitgm2->dacos dfloat dfloat proc~nitgm2->dfloat dcopy dcopy proc~nitgm2->dcopy dlamch dlamch proc~nitgm2->dlamch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks nitprint Common Blocks common /nitprint/ If diagnostic information is desired, include this common block in the \n main program and set iplvl and ipunit according to the following: iplvl = 0 =&gt; no printout\n       = 1 =&gt; iteration numbers and F-norms\n       = 2 =&gt; ... + some stats, step norms, and linear model norms\n       = 3 =&gt; ... + some Krylov solver and backtrack information\n       = 4 =&gt; ... + more Krylov solver and backtrack information\n\n ipunit = printout unit number. Type Attributes Name Initial integer :: iplvl integer :: ipunit $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })"},{"title":"nittfq2 – ISOFT","tags":"","loc":"proc/nittfq2.html","text":"subroutine nittfq2(n, xcur, fcur, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, ifdord, nfe, njve, nrpre, nli, r, rcgs, rtil, d, p, q, u, v, y, rwork1, rwork2, rsnrm, dinpr, dnorm, itrmks) FCNRM is no longer an argument, as it needs to be calculated from the\n residual, which isn't known until a little way into this routine. It\n could be calculated by the calling routine, but that would mean doing\n the calculation twice. step    = vector of length n, (trial) step. eta     = relative residual reduction factor. f      = name of user-supplied subroutine for evaluating the function \n           the zero of which is sought; this routine has the form subroutine f(n, xcur, fcur, rpar, ipar, itrmf)\n\n       where xcur is the array containing the current x value, fcur \n       is f(xcur) on output, rpar and ipar are, respectively, real \n       and integer parameter/work arrays for use by the subroutine,\n       and itrmf is an integer termination flag.  The meaning of\n       itrmf is as follows:\n         0 =&gt; normal termination; desired function value calculated.\n         1 =&gt; failure to produce f(xcur). jacv   = name of user-supplied subroutine for evaluating J v or \n           P(inverse) v, where J is the Jacobian of f and P is a \n           right preconditioning operator. If neither analytic J v \n           evaluations nor right preconditioning is used, this can \n           be a dummy subroutine; if right preconditioning is used but \n           not analytic J v evaluations, this need only evaluate \n           P(inverse)*v. The form is subroutine jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv)\n\n       where xcur and fcur are vectors of length n containing the \n       current x and f values, ijob is an integer flag indicating \n       which product is desired, v is a vector of length n to be \n       multiplied, z is a vector of length n containing the desired \n       product on output, rpar and ipar are, respectively, real \n       and integer parameter/work arrays for use by the subroutine, \n       and itrmjv is an integer termination \n       flag. The meaning of ijob is as follows: \n         0 =&gt; z = J*v\n         1 =&gt; z = P(inverse)*v \n       The meaning of itrmjv is as follows:\n         0 =&gt; normal termination; desired product evaluated. \n         1 =&gt; failure to produce J*v.\n         2 =&gt; failure to produce P(inverse)*v. \n       This subroutine is called only from nitjv, and is always \n       called with v .ne. z. rpar    = real parameter/work array passed to the f and jacv routines. ipar    = integer parameter/work array passed to the f and jacv routines. ijacv   = flag for determining method of J*v evaluation.\n              0 => finite-difference evaluation (default). \n              1 => analytic evaluation. irpre   = flag for right preconditioning. \n              0 => no right preconditioning\n              1 => right preconditioning iksmax  = maximum allowable number of TFQMR iterations. ifdord  = order of the finite-difference formula used in BiCGSTAB \n            when J*v products are evaluated using finite-differences. \n            When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or \n            4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on \n            input to this subroutine, ifdord determines the order of the \n            finite-difference formula used at each BiCGSTAB iteration \n            (default 1). In this case, ijacv is set to -1 below to \n            signal to nitjv that the order of the finite-difference \n            formula is to be determined by ifdord. The original value \n            ijacv = 0 is restored on return. nfe     = number of function evaluations. njve    = number of J*v evaluations. nrpre   = number of P(inverse)*v evaluations. nli     = number of linear iterations. r       = residual vector (for the QMR process) rcgs    = residual vector (of the underlying CGS process) rtil    = 'shadow' residual vector used in bi-orthogonalization d       = vector used in TFQMR p       = vector used in TFQMR q       = vector used in TFQMR u       = vector used in TFQMR v       = vector used in TFQMR y       = vector used in TFQMR rwork1  = work vector, passed on to nitjv rwork2  = work vector, passed on to nitjv rsnrm   = TFQMR residual norm on return. dinpr   = inner-product routine, either user-supplied or blas ddot. dnorm   = norm routine, either user-supplied or blas dnrm2. itrmks  = termination flag; values have the following meanings: \n              0 => normal termination: acceptable step found. \n              1 => J v failure in nitjv. \n              2 => P(inverse) v failure in nitjv. \n              3 => acceptable step not found in iksmax TFQMR iterations. \n              4 => TFQMR breakdown.\n              5 => floating point error (the underlying CGS iteration\n                   has probably blown up) Note: On return, nitsol terminates if itrmks is 1 or 2. \n         If itrmks is 3 or 4, nitsol may terminate or continue. \n         In this event, the step returned is a meaningful inexact \n         Newton step only if the residual norm has been reduced. \n         A decision on termination/continuation is made in nitdrv \n         according to whether there is sufficient residual norm \n         reduction, even though the desired inexact Newton condition \n         may not hold. <<<<<<<<<<<<<<<<<<<<< TAKEN FROM nitprint.h >>>>>>>>>>>>>>>>>>>>>>>>> Include these declaratinos and common blocks directly so that the \n include files are not needed in isoft. Do not set the step to 0, as it contains an initial guess at the \n solution. C      do 10 i = 1, n\nC         step(i) = zero\nC 10   continue Because the initial step is not zero, the residual must include an\n evaluation of the left-hand-side.. Arguments Type Intent Optional Attributes Name integer :: n double precision :: xcur (n) double precision :: fcur (n) double precision :: step (n) double precision :: eta real :: f integer :: jacv double precision :: rpar (*) integer :: ipar (*) integer :: ijacv integer :: irpre integer :: iksmax integer :: ifdord integer :: nfe integer :: njve integer :: nrpre integer :: nli double precision :: r (n) double precision :: rcgs (n) double precision :: rtil (n) double precision :: d (n) double precision :: p (n) double precision :: q (n) double precision :: u (n) double precision :: v (n) double precision :: y (n) double precision :: rwork1 (n) double precision :: rwork2 (n) double precision :: rsnrm double precision :: dinpr double precision :: dnorm integer :: itrmks Calls proc~~nittfq2~~CallsGraph proc~nittfq2 nittfq2 nitjv nitjv proc~nittfq2->nitjv daxpy daxpy proc~nittfq2->daxpy dscal dscal proc~nittfq2->dscal dcopy dcopy proc~nittfq2->dcopy dswap dswap proc~nittfq2->dswap dlamch dlamch proc~nittfq2->dlamch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks nitprint Common Blocks common /nitprint/ If diagnostic information is desired, include this common block in the \n main program and set iplvl and ipunit according to the following: iplvl = 0 =&gt; no printout\n       = 1 =&gt; iteration numbers and F-norms\n       = 2 =&gt; ... + some stats, step norms, and linear model norms\n       = 3 =&gt; ... + some Krylov solver and backtrack information\n       = 4 =&gt; ... + more Krylov solver and backtrack information\n\n ipunit = printout unit number. Type Attributes Name Initial integer :: iplvl integer :: ipunit $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })"},{"title":"splev – ISOFT","tags":"","loc":"proc/splev.html","text":"subroutine splev(t, n, c, k, x, y, m, e, ier) Arguments Type Intent Optional Attributes Name real(kind=8) :: t (n) integer :: n real(kind=8) :: c (n) integer :: k real(kind=8) :: x (m) real(kind=8) :: y (m) integer :: m integer :: e integer :: ier Contents None"},{"title":"fpbspl – ISOFT","tags":"","loc":"proc/fpbspl.html","text":"subroutine fpbspl(t, n, k, x, l, h) Arguments Type Intent Optional Attributes Name real(kind=8) :: t (n) integer :: n integer :: k real(kind=8) :: x integer :: l real(kind=8) :: h (20) Contents None"},{"title":"current_time – ISOFT","tags":"","loc":"proc/current_time.html","text":"public function current_time() Returns the current date and time in the same format as the compile_time function. Arguments None Return Value character(len=20) Called by proc~~current_time~~CalledByGraph proc~current_time current_time proc~write_data write_data proc~write_data->proc~current_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code current_time Source Code function current_time () !* Author: Chris MacMackin !  Date: November 2016 ! ! Returns the current date and time in the same format as the ! [[compile_time]] function. ! character ( len = 20 ) :: current_time integer ( i8 ), dimension ( 8 ) :: time_vals call date_and_time ( values = time_vals ) write ( current_time , time_format ) months ( time_vals ( 2 )), time_vals ( 3 ), & time_vals ( 1 ), time_vals ( 5 ), time_vals ( 6 ), & time_vals ( 7 ) end function current_time"},{"title":"version – ISOFT","tags":"","loc":"interface/version.html","text":"interface Calls interface~~version~~CallsGraph interface~version version proc~version version interface~version->proc~version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~version~~CalledByGraph interface~version version proc~read_ice read_ice proc~read_ice->interface~version proc~write_data write_data proc~write_data->interface~version proc~read_sub_ice read_sub_ice proc~read_sub_ice->interface~version proc~read_data read_data proc~read_data->interface~version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function version() Implementation → Arguments None Return Value character(len=5) Description Returns the version number for ISOFT."},{"title":"compile_time – ISOFT","tags":"","loc":"interface/compile_time.html","text":"interface Calls interface~~compile_time~~CallsGraph interface~compile_time compile_time proc~compile_time compile_time interface~compile_time->proc~compile_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~compile_time~~CalledByGraph interface~compile_time compile_time proc~write_data write_data proc~write_data->interface~compile_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function compile_time() Implementation → Arguments None Return Value character(len=20) Description Returns the date and time at which ISOFT was compiled."},{"title":"compile_info – ISOFT","tags":"","loc":"interface/compile_info.html","text":"interface Calls interface~~compile_info~~CallsGraph interface~compile_info compile_info proc~compile_info compile_info interface~compile_info->proc~compile_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function compile_info() Implementation → Arguments None Return Value character(len=1000) Description Returns compiler version and and flags."},{"title":"get_saved_state_r1 – ISOFT","tags":"","loc":"proc/get_saved_state_r1.html","text":"private function get_saved_state_r1(srname, save_states) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: srname integer, intent(inout), dimension(7) :: save_states Return Value integer Called by proc~~get_saved_state_r1~~CalledByGraph proc~get_saved_state_r1 get_saved_state_r1 proc~step_integrate_r1 step_integrate_r1 proc~step_integrate_r1->proc~get_saved_state_r1 proc~interpolate_r1 interpolate_r1 proc~interpolate_r1->proc~get_saved_state_r1 proc~global_error_r1 global_error_r1 proc~global_error_r1->proc~get_saved_state_r1 proc~reset_t_end_r1 reset_t_end_r1 proc~reset_t_end_r1->proc~get_saved_state_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->proc~get_saved_state_r1 interface~reset_t_end reset_t_end proc~range_integrate_r1->interface~reset_t_end interface~interpolate interpolate proc~range_integrate_r1->interface~interpolate interface~step_integrate step_integrate proc~range_integrate_r1->interface~step_integrate proc~statistics_r1 statistics_r1 proc~statistics_r1->proc~get_saved_state_r1 interface~reset_t_end->proc~reset_t_end_r1 interface~interpolate->proc~interpolate_r1 interface~step_integrate->proc~step_integrate_r1 interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 interface~global_error global_error interface~global_error->proc~global_error_r1 interface~statistics statistics interface~statistics->proc~statistics_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate var panprocget_saved_state_r1CalledByGraph = svgPanZoom('#procget_saved_state_r1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_saved_state_r1 Source Code function get_saved_state_r1 ( srname , save_states ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! integer , dimension ( 7 ), intent ( inout ) :: save_states character ( len =* ), intent ( in ) :: srname integer :: get_saved_state_r1 ! integer :: name ! integer , parameter :: fatal = 911 ! select case ( srname ) case ( \"SETUP\" ); name = 1 case ( \"RANGE_INTEGRATE\" ); name = 2 case ( \"STATISTICS\" ); name = 3 case ( \"GLOBAL_ERROR\" ); name = 4 case ( \"STEP_INTEGRATE\" ); name = 5 case ( \"INTERPOLATE\" ); name = 6 case ( \"RESET_T_END\" ); name = 7 case default ; name = 0 end select ! !  Check for status of given routine but check for any fatal errors first ! if ( any ( save_states ( 1 : 7 ) == fatal )) then get_saved_state_r1 = fatal else get_saved_state_r1 = save_states ( name ) end if ! end function get_saved_state_r1"},{"title":"get_saved_fatal_r1 – ISOFT","tags":"","loc":"proc/get_saved_fatal_r1.html","text":"private function get_saved_fatal_r1(comm) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(in) :: comm Return Value logical Called by proc~~get_saved_fatal_r1~~CalledByGraph proc~get_saved_fatal_r1 get_saved_fatal_r1 interface~get_saved_fatal get_saved_fatal interface~get_saved_fatal->proc~get_saved_fatal_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->proc~get_saved_fatal_r1 interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_saved_fatal_r1 Source Code function get_saved_fatal_r1 ( comm ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( in ) :: comm logical :: get_saved_fatal_r1 ! get_saved_fatal_r1 = comm % saved_fatal_err ! end function get_saved_fatal_r1"},{"title":"get_stop_on_fatal_r1 – ISOFT","tags":"","loc":"proc/get_stop_on_fatal_r1.html","text":"private function get_stop_on_fatal_r1(comm) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(in) :: comm Return Value logical Called by proc~~get_stop_on_fatal_r1~~CalledByGraph proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1 rkmsg_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~step_integrate_r1 step_integrate_r1 proc~step_integrate_r1->proc~rkmsg_r1 proc~interpolate_r1 interpolate_r1 proc~interpolate_r1->proc~rkmsg_r1 proc~global_error_r1 global_error_r1 proc~global_error_r1->proc~rkmsg_r1 proc~setup_r1 setup_r1 proc~setup_r1->proc~rkmsg_r1 proc~reset_t_end_r1 reset_t_end_r1 proc~reset_t_end_r1->proc~rkmsg_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->proc~rkmsg_r1 interface~reset_t_end reset_t_end proc~range_integrate_r1->interface~reset_t_end interface~interpolate interpolate proc~range_integrate_r1->interface~interpolate interface~step_integrate step_integrate proc~range_integrate_r1->interface~step_integrate proc~statistics_r1 statistics_r1 proc~statistics_r1->proc~rkmsg_r1 interface~reset_t_end->proc~reset_t_end_r1 interface~interpolate->proc~interpolate_r1 interface~step_integrate->proc~step_integrate_r1 interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 interface~global_error global_error interface~global_error->proc~global_error_r1 interface~statistics statistics interface~statistics->proc~statistics_r1 interface~setup setup interface~setup->proc~setup_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate proc~upstream_calculate->interface~setup var panprocget_stop_on_fatal_r1CalledByGraph = svgPanZoom('#procget_stop_on_fatal_r1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_stop_on_fatal_r1 Source Code function get_stop_on_fatal_r1 ( comm ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( in ) :: comm logical get_stop_on_fatal_r1 ! get_stop_on_fatal_r1 = comm % stop_on_fatal ! end function get_stop_on_fatal_r1"},{"title":"machine_const – ISOFT","tags":"","loc":"proc/machine_const.html","text":"private subroutine machine_const(round_off, sqrrmc, cubrmc, sqtiny, outch) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out) :: round_off real(kind=wp), intent(out) :: sqrrmc real(kind=wp), intent(out) :: cubrmc real(kind=wp), intent(out) :: sqtiny integer, intent(out) :: outch Called by proc~~machine_const~~CalledByGraph proc~machine_const machine_const proc~setup_r1 setup_r1 proc~setup_r1->proc~machine_const interface~setup setup interface~setup->proc~setup_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code machine_const Source Code subroutine machine_const ( round_off , sqrrmc , cubrmc , sqtiny , outch ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( out ) :: round_off , sqrrmc , cubrmc , sqtiny integer , intent ( out ) :: outch ! real ( kind = wp ) :: dummy real ( kind = wp ), parameter :: third = 1.0_wp / 3.0_wp , ten = 1 0.0_wp ! outch = 6 ! round_off = ten * epsilon ( dummy ) sqrrmc = sqrt ( epsilon ( dummy )) cubrmc = epsilon ( dummy ) ** third sqtiny = sqrt ( tiny ( dummy )) ! end subroutine machine_const"},{"title":"method_const – ISOFT","tags":"","loc":"proc/method_const.html","text":"private subroutine method_const(rk_method, a, b, c, bhat, r, e, ptr, no_of_stages, intrp_degree, intrp_able, intrp_needs_stages, cost, safety, expon, stability_radius, tan_angle, rs, rs1, rs2, rs3, rs4, order, last_stage, max_stiff_iters, no_of_ge_steps, fsal, cdiff) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rk_method real(kind=wp), intent(out) :: a (13,13) real(kind=wp), intent(out) :: b (13) real(kind=wp), intent(out) :: c (13) real(kind=wp), intent(out) :: bhat (13) real(kind=wp), intent(out) :: r (11,6) real(kind=wp), intent(out) :: e (7) integer, intent(out) :: ptr (13) integer, intent(out) :: no_of_stages integer, intent(out) :: intrp_degree logical, intent(out) :: intrp_able logical, intent(out) :: intrp_needs_stages real(kind=wp), intent(out) :: cost real(kind=wp), intent(out) :: safety real(kind=wp), intent(out) :: expon real(kind=wp), intent(out) :: stability_radius real(kind=wp), intent(out) :: tan_angle real(kind=wp), intent(out) :: rs real(kind=wp), intent(out) :: rs1 real(kind=wp), intent(out) :: rs2 real(kind=wp), intent(out) :: rs3 real(kind=wp), intent(out) :: rs4 integer, intent(out) :: order integer, intent(out) :: last_stage integer, intent(out) :: max_stiff_iters integer, intent(out) :: no_of_ge_steps logical, intent(out) :: fsal real(kind=wp), intent(out) :: cdiff Called by proc~~method_const~~CalledByGraph proc~method_const method_const proc~setup_r1 setup_r1 proc~setup_r1->proc~method_const interface~setup setup interface~setup->proc~setup_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code method_const Source Code subroutine method_const ( rk_method , a , b , c , bhat , r , e , ptr , no_of_stages , & intrp_degree , intrp_able , intrp_needs_stages , & cost , safety , expon , stability_radius , & tan_angle , rs , rs1 , rs2 , rs3 , rs4 , order , last_stage , & max_stiff_iters , no_of_ge_steps , fsal , cdiff ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! integer , intent ( in ) :: rk_method real ( kind = wp ), intent ( out ) :: a ( 13 , 13 ), b ( 13 ), c ( 13 ), bhat ( 13 ), r ( 11 , 6 ), e ( 7 ) integer , intent ( out ) :: ptr ( 13 ), no_of_stages , intrp_degree logical , intent ( out ) :: intrp_able , intrp_needs_stages real ( kind = wp ), intent ( out ) :: cost , safety , expon , stability_radius , & tan_angle , rs , rs1 , rs2 , rs3 , rs4 , cdiff integer , intent ( out ) :: order , last_stage , max_stiff_iters , no_of_ge_steps logical , intent ( out ) :: fsal ! integer :: i real ( kind = wp ), parameter :: fivepc = 0.05_wp , one = 1.0_wp , two = 2.0_wp , & fifty = 5 0.0_wp ! select case ( rk_method ) case ( 1 ) ! !  METHD = 1. !    This pair is from \"A 3(2) Pair of Runge-Kutta Formulas\" by P. Bogacki !    and L.F. Shampine, Appl. Math. Lett., 2, pp. 321-325, 1989.  The authors !    are grateful to P. Bogacki for his assistance in implementing the pair. ! no_of_stages = 4 ; fsal = . true .; order = 2 tan_angle = 8.9_wp ; stability_radius = 2.3_wp safety = 0.8_wp ; intrp_able = . true .; intrp_degree = 3 intrp_needs_stages = . false .; no_of_ge_steps = 3 ! ptr ( 1 : 4 ) = ( / 0 , 1 , 2 , 3 / ) ! a ( 2 , 1 ) = 1.0_wp / 2.0_wp a ( 3 , 1 ) = 0.0_wp a ( 3 , 2 ) = 3.0_wp / 4.0_wp a ( 4 , 1 ) = 2.0_wp / 9.0_wp a ( 4 , 2 ) = 1.0_wp / 3.0_wp a ( 4 , 3 ) = 4.0_wp / 9.0_wp ! !  The coefficients BHAT refer to the formula used to advance the !  integration, here the one of order 3.  The coefficients B refer !  to the other formula, here the one of order 2. For this pair, BHAT !  is not needed since FSAL = .TRUE. ! b ( 1 ) = 7.0_wp / 2 4.0_wp b ( 2 ) = 1.0_wp / 4.0_wp b ( 3 ) = 1.0_wp / 3.0_wp b ( 4 ) = 1.0_wp / 8.0_wp ! c ( 1 ) = 0.0_wp c ( 2 ) = 1.0_wp / 2.0_wp c ( 3 ) = 3.0_wp / 4.0_wp c ( 4 ) = 1.0_wp ! case ( 2 ) ! !  METHD = 2 !    This pair is from \"An Efficient Runge-Kutta (4,5) Pair\" by P. Bogacki !    and L.F. Shampine, Rept. 89-20, Math. Dept., Southern Methodist !    University, Dallas, Texas, USA, 1989.  The authors are grateful to !    P. Bogacki for his assistance in implementing the pair.  Shampine and !    Bogacki subsequently modified the formula to enhance the reliability of !    the pair.  The original fourth order formula is used in an estimate of !    the local error.  If the step fails, the computation is broken off.  If !    the step is acceptable, the first evaluation of the next step is done, !    i.e., the pair is implemented as FSAL and the local error of the step !    is again estimated with a fourth order formula using the additional data. !    The step must succeed with both estimators to be accepted.  When the !    second estimate is formed, it is used for the subsequent adjustment of !    the step size because it is of higher quality.  The two fourth order !    formulas are well matched to leading order, and only exceptionally do !    the estimators disagree -- problems with discontinuous coefficients are !    handled more reliably by using two estimators as is global error !    estimation. ! no_of_stages = 8 ; fsal = . true .; order = 4 tan_angle = 5.2_wp ; stability_radius = 3.9_wp safety = 0.8_wp ; intrp_able = . true . intrp_needs_stages = . true .; intrp_degree = 6 no_of_ge_steps = 2 ! ptr ( 1 : 8 ) = ( / 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 / ) ! a ( 2 , 1 ) = 1.0_wp / 6.0_wp a ( 3 , 1 ) = 2.0_wp / 2 7.0_wp a ( 3 , 2 ) = 4.0_wp / 2 7.0_wp a ( 4 , 1 ) = 18 3.0_wp / 137 2.0_wp a ( 4 , 2 ) = - 16 2.0_wp / 34 3.0_wp a ( 4 , 3 ) = 105 3.0_wp / 137 2.0_wp a ( 5 , 1 ) = 6 8.0_wp / 29 7.0_wp a ( 5 , 2 ) = - 4.0_wp / 1 1.0_wp a ( 5 , 3 ) = 4 2.0_wp / 14 3.0_wp a ( 5 , 4 ) = 196 0.0_wp / 386 1.0_wp a ( 6 , 1 ) = 59 7.0_wp / 2252 8.0_wp a ( 6 , 2 ) = 8 1.0_wp / 35 2.0_wp a ( 6 , 3 ) = 6309 9.0_wp / 58572 8.0_wp a ( 6 , 4 ) = 5865 3.0_wp / 36608 0.0_wp a ( 6 , 5 ) = 461 7.0_wp / 2048 0.0_wp a ( 7 , 1 ) = 17419 7.0_wp / 95924 4.0_wp a ( 7 , 2 ) = - 3094 2.0_wp / 7993 7.0_wp a ( 7 , 3 ) = 815213 7.0_wp / 1974443 9.0_wp a ( 7 , 4 ) = 66610 6.0_wp / 103918 1.0_wp a ( 7 , 5 ) = - 2942 1.0_wp / 2906 8.0_wp a ( 7 , 6 ) = 48204 8.0_wp / 41421 9.0_wp a ( 8 , 1 ) = 58 7.0_wp / 806 4.0_wp a ( 8 , 2 ) = 0.0_wp a ( 8 , 3 ) = 444033 9.0_wp / 1549184 0.0_wp a ( 8 , 4 ) = 2435 3.0_wp / 12480 0.0_wp a ( 8 , 5 ) = 38 7.0_wp / 4480 0.0_wp a ( 8 , 6 ) = 215 2.0_wp / 598 5.0_wp a ( 8 , 7 ) = 726 7.0_wp / 9408 0.0_wp ! !  The coefficients B refer to the formula of order 4. ! b ( 1 ) = 247 9.0_wp / 3499 2.0_wp b ( 2 ) = 0.0_wp b ( 3 ) = 12 3.0_wp / 41 6.0_wp b ( 4 ) = 61294 1.0_wp / 341172 0.0_wp b ( 5 ) = 4 3.0_wp / 144 0.0_wp b ( 6 ) = 227 2.0_wp / 656 1.0_wp b ( 7 ) = 7993 7.0_wp / 111391 2.0_wp b ( 8 ) = 329 3.0_wp / 55695 6.0_wp ! !  The coefficients E refer to an estimate of the local error based on !  the first formula of order 4.  It is the difference of the fifth order !  result, here located in A(8,:), and the fourth order result.  By !  construction both E(2) and E(7) are zero. ! e ( 1 ) = - 3.0_wp / 128 0.0_wp e ( 2 ) = 0.0_wp e ( 3 ) = 656 1.0_wp / 63232 0.0_wp e ( 4 ) = - 34 3.0_wp / 2080 0.0_wp e ( 5 ) = 24 3.0_wp / 1280 0.0_wp e ( 6 ) = - 1.0_wp / 9 5.0_wp e ( 7 ) = 0.0_wp ! c ( 1 ) = 0.0_wp c ( 2 ) = 1.0_wp / 6.0_wp c ( 3 ) = 2.0_wp / 9.0_wp c ( 4 ) = 3.0_wp / 7.0_wp c ( 5 ) = 2.0_wp / 3.0_wp c ( 6 ) = 3.0_wp / 4.0_wp c ( 7 ) = 1.0_wp c ( 8 ) = 1.0_wp ! !  To do interpolation with this pair, some extra stages have to be computed. !  The following additional A and C coefficients are for this purpose. !  In addition there is an array R that plays a role for interpolation !  analogous to that of BHAT for the basic step. ! c ( 9 ) = 1.0_wp / 2.0_wp c ( 10 ) = 5.0_wp / 6.0_wp c ( 11 ) = 1.0_wp / 9.0_wp ! a ( 9 , 1 ) = 45 5.0_wp / 614 4.0_wp a ( 10 , 1 ) = - 83788834371 5.0_wp / 1317698863718 4.0_wp a ( 11 , 1 ) = 9871907326 3.0_wp / 155196518400 0.0_wp a ( 9 , 2 ) = 0.0_wp a ( 10 , 2 ) = 3040941 5.0_wp / 5295536 2.0_wp a ( 11 , 2 ) = 130 7.0_wp / 12355 2.0_wp a ( 9 , 3 ) = 1025630 1.0_wp / 3540992 0.0_wp a ( 10 , 3 ) = - 4832152596 3.0_wp / 75916806963 2.0_wp a ( 11 , 3 ) = 463206655938 7.0_wp / 7018175324160 0.0_wp a ( 9 , 4 ) = 230736 1.0_wp / 1797120 0.0_wp a ( 10 , 4 ) = 853073845332 1.0_wp / 19765482955776 0.0_wp a ( 11 , 4 ) = 782859430238 9.0_wp / 38218251202560 0.0_wp a ( 9 , 5 ) = - 38 7.0_wp / 10240 0.0_wp a ( 10 , 5 ) = 136164052300 1.0_wp / 162678872064 0.0_wp a ( 11 , 5 ) = 4076368 7.0_wp / 1107025920 0.0_wp a ( 9 , 6 ) = 7 3.0_wp / 513 0.0_wp a ( 10 , 6 ) = - 1314306068 9.0_wp / 3860445889 8.0_wp a ( 11 , 6 ) = 3487273240 7.0_wp / 22461058620 0.0_wp a ( 9 , 7 ) = - 726 7.0_wp / 21504 0.0_wp a ( 10 , 7 ) = 1870022196 9.0_wp / 37958403481 6.0_wp a ( 11 , 7 ) = - 256189 7.0_wp / 3010560 0.0_wp a ( 9 , 8 ) = 1.0_wp / 3 2.0_wp a ( 10 , 8 ) = - 583159 5.0_wp / 84728579 2.0_wp a ( 11 , 8 ) = 1.0_wp / 1 0.0_wp a ( 10 , 9 ) = - 518364 0.0_wp / 2647768 1.0_wp a ( 11 , 9 ) = - 1.0_wp / 1 0.0_wp a ( 11 , 10 ) = - 140331709 3.0_wp / 1137161025 0.0_wp ! r ( 1 : 11 , 1 ) = 0.0_wp ; r ( 2 , 1 : 6 ) = 0.0_wp r ( 1 , 6 ) = - 1213433839 3.0_wp / 105080976 0.0_wp r ( 1 , 5 ) = - 162074122 9.0_wp / 5003856 0.0_wp r ( 1 , 4 ) = - 204805889 3.0_wp / 5987520 0.0_wp r ( 1 , 3 ) = - 8709848000 9.0_wp / 525404880 0.0_wp r ( 1 , 2 ) = - 1151327027 3.0_wp / 350269920 0.0_wp ! r ( 3 , 6 ) = - 3319734036 7.0_wp / 121843321 6.0_wp r ( 3 , 5 ) = - 53986802498 7.0_wp / 609216608 0.0_wp r ( 3 , 4 ) = - 3999118868 1.0_wp / 37490252 8.0_wp r ( 3 , 3 ) = - 6950973822 7.0_wp / 121843321 6.0_wp r ( 3 , 2 ) = - 2932774461 3.0_wp / 243686643 2.0_wp ! r ( 4 , 6 ) = - 28480099720 1.0_wp / 1990533916 8.0_wp r ( 4 , 5 ) = - 789687545047 1.0_wp / 16587782640 0.0_wp r ( 4 , 4 ) = - 33394581287 9.0_wp / 567103680 0.0_wp r ( 4 , 3 ) = - 1620992345623 7.0_wp / 49763347920 0.0_wp r ( 4 , 2 ) = - 238259074169 9.0_wp / 33175565280 0.0_wp ! r ( 5 , 6 ) = - 54091 9.0_wp / 74131 2.0_wp r ( 5 , 5 ) = - 10362606 7.0_wp / 4324320 0.0_wp r ( 5 , 4 ) = - 63377 9.0_wp / 21120 0.0_wp r ( 5 , 3 ) = - 3240678 7.0_wp / 1853280 0.0_wp r ( 5 , 2 ) = - 3659119 3.0_wp / 8648640 0.0_wp ! r ( 6 , 6 ) = 715799830 4.0_wp / 37435097 7.0_wp r ( 6 , 5 ) = 3040584246 4.0_wp / 62391829 5.0_wp r ( 6 , 4 ) = 18302226 4.0_wp / 533263 5.0_wp r ( 6 , 3 ) = - 335702403 2.0_wp / 187175488 5.0_wp r ( 6 , 2 ) = - 61158673 6.0_wp / 8913118 5.0_wp ! r ( 7 , 6 ) = - 13807 3.0_wp / 940 8.0_wp r ( 7 , 5 ) = - 71943 3.0_wp / 1568 0.0_wp r ( 7 , 4 ) = - 162054 1.0_wp / 3136 0.0_wp r ( 7 , 3 ) = - 38515 1.0_wp / 1568 0.0_wp r ( 7 , 2 ) = - 6540 3.0_wp / 1568 0.0_wp ! r ( 8 , 6 ) = 124 5.0_wp / 6 4.0_wp r ( 8 , 5 ) = 399 1.0_wp / 6 4.0_wp r ( 8 , 4 ) = 471 5.0_wp / 6 4.0_wp r ( 8 , 3 ) = 250 1.0_wp / 6 4.0_wp r ( 8 , 2 ) = 14 9.0_wp / 1 6.0_wp r ( 8 , 1 ) = 1.0_wp ! r ( 9 , 6 ) = 5 5.0_wp / 3.0_wp r ( 9 , 5 ) = 7 1.0_wp r ( 9 , 4 ) = 10 3.0_wp r ( 9 , 3 ) = 19 9.0_wp / 3.0_wp r ( 9 , 2 ) = 1 6.0d0 ! r ( 10 , 6 ) = - 177400462 7.0_wp / 7581073 5.0_wp r ( 10 , 5 ) = - 177400462 7.0_wp / 2527024 5.0_wp r ( 10 , 4 ) = - 2647768 1.0_wp / 35997 5.0_wp r ( 10 , 3 ) = - 1141188051 1.0_wp / 37905367 5.0_wp r ( 10 , 2 ) = - 42364289 6.0_wp / 12635122 5.0_wp ! r ( 11 , 6 ) = 3 5.0_wp r ( 11 , 5 ) = 10 5.0_wp r ( 11 , 4 ) = 11 7.0_wp r ( 11 , 3 ) = 5 9.0_wp r ( 11 , 2 ) = 1 2.0_wp ! case ( 3 ) ! !  METHD = 3 !    This pair is from \"High Order Embedded Runge-Kutta Formulae\" by P.J. !    Prince and J.R. Dormand, J. Comp. Appl. Math.,7, pp. 67-75, 1981.  The !    authors are grateful to P. Prince and J. Dormand for their assistance in !    implementing the pair. ! no_of_stages = 13 ; fsal = . false .; order = 7 tan_angle = 1 1.0_wp ; stability_radius = 5.2_wp safety = 0.8_wp ; intrp_able = . false . intrp_needs_stages = . false .; intrp_degree = 0 no_of_ge_steps = 2 ! ptr ( 1 : 13 ) = ( / 0 , 1 , 2 , 1 , 3 , 2 , 4 , 5 , 6 , 7 , 8 , 9 , 1 / ) ! a ( 2 , 1 ) = 5.55555555555555555555555555556e-2_wp a ( 3 , 1 ) = 2.08333333333333333333333333333e-2_wp a ( 3 , 2 ) = 6.25e-2_wp a ( 4 , 1 ) = 3.125e-2_wp a ( 4 , 2 ) = 0.0_wp a ( 4 , 3 ) = 9.375e-2_wp a ( 5 , 1 ) = 3.125e-1_wp a ( 5 , 2 ) = 0.0_wp a ( 5 , 3 ) = - 1.171875_wp a ( 5 , 4 ) = 1.171875_wp a ( 6 , 1 ) = 3.75e-2_wp a ( 6 , 2 ) = 0.0_wp a ( 6 , 3 ) = 0.0_wp a ( 6 , 4 ) = 1.875e-1_wp a ( 6 , 5 ) = 1.5e-1_wp a ( 7 , 1 ) = 4.79101371111111111111111111111e-2_wp a ( 7 , 2 ) = 0.0_wp a ( 7 , 3 ) = 0.0_wp a ( 7 , 4 ) = 1.12248712777777777777777777778e-1_wp a ( 7 , 5 ) = - 2.55056737777777777777777777778e-2_wp a ( 7 , 6 ) = 1.28468238888888888888888888889e-2_wp a ( 8 , 1 ) = 1.6917989787292281181431107136e-2_wp a ( 8 , 2 ) = 0.0_wp a ( 8 , 3 ) = 0.0_wp a ( 8 , 4 ) = 3.87848278486043169526545744159e-1_wp a ( 8 , 5 ) = 3.59773698515003278967008896348e-2_wp a ( 8 , 6 ) = 1.96970214215666060156715256072e-1_wp a ( 8 , 7 ) = - 1.72713852340501838761392997002e-1_wp a ( 9 , 1 ) = 6.90957533591923006485645489846e-2_wp a ( 9 , 2 ) = 0.0_wp a ( 9 , 3 ) = 0.0_wp a ( 9 , 4 ) = - 6.34247976728854151882807874972e-1_wp a ( 9 , 5 ) = - 1.61197575224604080366876923982e-1_wp a ( 9 , 6 ) = 1.38650309458825255419866950133e-1_wp a ( 9 , 7 ) = 9.4092861403575626972423968413e-1_wp a ( 9 , 8 ) = 2.11636326481943981855372117132e-1_wp a ( 10 , 1 ) = 1.83556996839045385489806023537e-1_wp a ( 10 , 2 ) = 0.0_wp a ( 10 , 3 ) = 0.0_wp a ( 10 , 4 ) = - 2.46876808431559245274431575997_wp a ( 10 , 5 ) = - 2.91286887816300456388002572804e-1_wp a ( 10 , 6 ) = - 2.6473020233117375688439799466e-2_wp a ( 10 , 7 ) = 2.84783876419280044916451825422_wp a ( 10 , 8 ) = 2.81387331469849792539403641827e-1_wp a ( 10 , 9 ) = 1.23744899863314657627030212664e-1_wp a ( 11 , 1 ) = - 1.21542481739588805916051052503_wp a ( 11 , 2 ) = 0.0_wp a ( 11 , 3 ) = 0.0_wp a ( 11 , 4 ) = 1.66726086659457724322804132886e1_wp a ( 11 , 5 ) = 9.15741828416817960595718650451e-1_wp a ( 11 , 6 ) = - 6.05660580435747094755450554309_wp a ( 11 , 7 ) = - 1.60035735941561781118417064101e1_wp a ( 11 , 8 ) = 1.4849303086297662557545391898e1_wp a ( 11 , 9 ) = - 1.33715757352898493182930413962e1_wp a ( 11 , 10 ) = 5.13418264817963793317325361166_wp a ( 12 , 1 ) = 2.58860916438264283815730932232e-1_wp a ( 12 , 2 ) = 0.0_wp a ( 12 , 3 ) = 0.0_wp a ( 12 , 4 ) = - 4.77448578548920511231011750971_wp a ( 12 , 5 ) = - 4.3509301377703250944070041181e-1_wp a ( 12 , 6 ) = - 3.04948333207224150956051286631_wp a ( 12 , 7 ) = 5.57792003993609911742367663447_wp a ( 12 , 8 ) = 6.15583158986104009733868912669_wp a ( 12 , 9 ) = - 5.06210458673693837007740643391_wp a ( 12 , 10 ) = 2.19392617318067906127491429047_wp a ( 12 , 11 ) = 1.34627998659334941535726237887e-1_wp a ( 13 , 1 ) = 8.22427599626507477963168204773e-1_wp a ( 13 , 2 ) = 0.0_wp a ( 13 , 3 ) = 0.0_wp a ( 13 , 4 ) = - 1.16586732572776642839765530355e1_wp a ( 13 , 5 ) = - 7.57622116690936195881116154088e-1_wp a ( 13 , 6 ) = 7.13973588159581527978269282765e-1_wp a ( 13 , 7 ) = 1.20757749868900567395661704486e1_wp a ( 13 , 8 ) = - 2.12765911392040265639082085897_wp a ( 13 , 9 ) = 1.99016620704895541832807169835_wp a ( 13 , 10 ) = - 2.34286471544040292660294691857e-1_wp a ( 13 , 11 ) = 1.7589857770794226507310510589e-1_wp a ( 13 , 12 ) = 0.0_wp ! !  The coefficients BHAT refer to the formula used to advance the !  integration, here the one of order 8.  The coefficients B refer !  to the other formula, here the one of order 7. ! bhat ( 1 ) = 4.17474911415302462220859284685e-2_wp bhat ( 2 ) = 0.0_wp bhat ( 3 ) = 0.0_wp bhat ( 4 ) = 0.0_wp bhat ( 5 ) = 0.0_wp bhat ( 6 ) = - 5.54523286112393089615218946547e-2_wp bhat ( 7 ) = 2.39312807201180097046747354249e-1_wp bhat ( 8 ) = 7.0351066940344302305804641089e-1_wp bhat ( 9 ) = - 7.59759613814460929884487677085e-1_wp bhat ( 10 ) = 6.60563030922286341461378594838e-1_wp bhat ( 11 ) = 1.58187482510123335529614838601e-1_wp bhat ( 12 ) = - 2.38109538752862804471863555306e-1_wp bhat ( 13 ) = 2.5e-1_wp ! b ( 1 ) = 2.9553213676353496981964883112e-2_wp b ( 2 ) = 0.0_wp b ( 3 ) = 0.0_wp b ( 4 ) = 0.0_wp b ( 5 ) = 0.0_wp b ( 6 ) = - 8.28606276487797039766805612689e-1_wp b ( 7 ) = 3.11240900051118327929913751627e-1_wp b ( 8 ) = 2.46734519059988698196468570407_wp b ( 9 ) = - 2.54694165184190873912738007542_wp b ( 10 ) = 1.44354858367677524030187495069_wp b ( 11 ) = 7.94155958811272872713019541622e-2_wp b ( 12 ) = 4.44444444444444444444444444445e-2_wp b ( 13 ) = 0.0_wp ! c ( 1 ) = 0.0_wp c ( 2 ) = 5.55555555555555555555555555556e-2_wp c ( 3 ) = 8.33333333333333333333333333334e-2_wp c ( 4 ) = 1.25e-1_wp c ( 5 ) = 3.125e-1_wp c ( 6 ) = 3.75e-1_wp c ( 7 ) = 1.475e-1_wp c ( 8 ) = 4.65e-1_wp c ( 9 ) = 5.64865451382259575398358501426e-1_wp c ( 10 ) = 6.5e-1_wp c ( 11 ) = 9.24656277640504446745013574318e-1_wp c ( 12 ) = 1.0_wp c ( 13 ) = c ( 12 ) ! end select ! !  The definitions of all pairs come here for the calculation of !  LAST_STAGE - the position of the last evaluated stage in a method !  RS1, RS2, RS3, RS4 - minimum and maximum rations used is step selection !  COST - the cost of a step !  MAX_STIFF_ITERS - the number of iterations permitted in stiffness detection !     There are at most Q = 3 function calls per iteration. MAX_STIFF_ITERS !     is determined so that  Q*MAX_STIFF_ITERS <= 5% of the cost of !     50 steps and 1 <= MAX_STIFF_ITERS <= 8. This limits the number of !     function calls in each diagnosis of stiffness to 24. !  EXPON - an exponent for use in step slection !  CDIFF - a coefficent used in determining the minimum permissible step ! last_stage = ptr ( no_of_stages ) if ( fsal ) then cost = real ( no_of_stages - 1 , kind = wp ) else cost = real ( no_of_stages , kind = wp ) end if ! max_stiff_iters = min ( 8 , max ( 1 , int ( fivepc * cost * fifty ))) ! expon = one / ( order + one ) ! !     In calculating CDIFF it is assumed that there will be a non-zero !     difference |C(I) - C(J)| less than one. If C(I) = C(J) for any I not !     equal to J, they should be made precisely equal by assignment. ! cdiff = one do i = 1 , no_of_stages - 1 cdiff = min ( cdiff , minval ( & abs (( c ( i ) - c ( i + 1 : no_of_stages ))), & mask = ( c ( i ) - c ( i + 1 : no_of_stages ) /= 0 )) ) end do ! rs = two ; rs1 = one / rs ; rs2 = rs ** 2 rs3 = rs * rs2 ; rs4 = one / rs3 ! end subroutine method_const"},{"title":"setup_r1 – ISOFT","tags":"","loc":"proc/setup_r1.html","text":"private subroutine setup_r1(comm, t_start, y_start, t_end, tolerance, thresholds, method, task, error_assess, h_start, message) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ) :: comm real(kind=wp), intent(in) :: t_start real(kind=wp), intent(in), dimension(:) :: y_start real(kind=wp), intent(in) :: t_end real(kind=wp), intent(in) :: tolerance real(kind=wp), intent(in), dimension(:) :: thresholds character(len=*), intent(in), optional :: method character(len=*), intent(in), optional :: task logical, intent(in), optional :: error_assess real(kind=wp), intent(in), optional :: h_start logical, intent(in), optional :: message Calls proc~~setup_r1~~CallsGraph proc~setup_r1 setup_r1 proc~rkmsg_r1 rkmsg_r1 proc~setup_r1->proc~rkmsg_r1 proc~machine_const machine_const proc~setup_r1->proc~machine_const proc~method_const method_const proc~setup_r1->proc~method_const proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setup_r1~~CalledByGraph proc~setup_r1 setup_r1 interface~setup setup interface~setup->proc~setup_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code setup_r1 Source Code subroutine setup_r1 ( comm , t_start , y_start , t_end , tolerance , thresholds , & method , task , error_assess , h_start , message ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( in ) :: t_end , t_start !indep! real ( kind = wp ), intent ( in ) :: tolerance real ( kind = wp ), dimension (:), intent ( in ) :: y_start !dep! real ( kind = wp ), dimension (:), intent ( in ) :: thresholds !shp-dep! type ( rk_comm_real_1d ) :: comm real ( kind = wp ), intent ( in ), optional :: h_start !indep! logical , intent ( in ), optional :: error_assess , message character ( len =* ), intent ( in ), optional :: task , method ! character ( len =* ), parameter :: srname = \"SETUP\" ! real ( kind = wp ) :: hmin !indep! real ( kind = wp ) :: cdiff integer :: ier , nrec , tr_dim_of_stages logical :: legalt character ( len = 1 ) :: task1 , method1 ! integer , parameter :: not_ready =- 1 , fatal = 911 , just_fine = 1 real ( kind = wp ), parameter :: zero = 0.0_wp , pt01 = 0.01_wp , fivepc = 0.05_wp , & third = 1.0_wp / 3.0_wp , one = 1.0_wp , two = 2.0_wp , ten = 1 0.0_wp , fifty = 5 0.0_wp ! ier = just_fine ; nrec = 0 ! !  Clear previous state of the suite. ! call setup_global_stuff nullify ( comm % thresh , comm % err_estimates , comm % weights , comm % y_old , & comm % scratch , & comm % y , comm % yp , comm % y_new , comm % yp_old , comm % stages , comm % ge_y , & comm % ge_yp , comm % ge_err_estimates , comm % ge_assess , comm % ge_y_new , & comm % ge_stages , comm % v0 , comm % v1 , comm % v2 , comm % v3 , comm % vtemp , & comm % xstage , comm % ytemp , comm % p ) ! !  Fetch output channel and machine constants; ! call machine_const ( comm % round_off , comm % sqrrmc , comm % cubrmc , comm % sqtiny , & comm % outch ) ! body : do ! !  Check for valid shape if ( size ( shape ( y_start )) > 0 ) then if ( any ( shape ( y_start ) == 0 )) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a)\" ) & \" ** An extent of Y_START has zero length. This is not permitted.\" exit body end if end if ! !  Check and process non-trivial optional arguments if ( present ( task )) then task1 = task ( 1 : 1 ); comm % use_range = task1 == \"R\" . or . task1 == \"r\" legalt = comm % use_range . or . task1 == \"S\" . or . task1 == \"s\" if (. not . legalt ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,a,a/a)\" ) & \" ** You have set the first character of TASK to be '\" , TASK1 , \"'.\" , & \" ** It must be one of 'R','r','S' or 's'.\" exit body end if end if if ( present ( method )) then method1 = method ( 1 : 1 ) select case ( method1 ) case ( \"L\" , \"l\" ); comm % rk_method = 1 case ( \"M\" , \"m\" ); comm % rk_method = 2 case ( \"H\" , \"h\" ); comm % rk_method = 3 case default ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,a,a/a)\" ) & \" ** You have set the first character of METHOD to be '\" , METHOD1 , \"'.\" , & \" ** It must be one of 'L','l','M','m','H' or 'h'.\" exit body end select end if if ( present ( message )) comm % print_message = message ! ! Check consistency of array arguments ! if ( any ( shape ( y_start ) /= shape ( thresholds ))) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** The shapes of Y_START and THRESHOLDS are not consistent.\" exit body end if ! ! Check and process compulsory arguments if ( t_start == t_end ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a,e13.5,a)\" ) & \" ** You have set T_START = T_END = \" , T_START , \".\" exit body else comm % t_end = t_end ; comm % t_start = t_start comm % t_old = t_start ; comm % t = t_start comm % dir = sign ( one , t_end - t_start ) end if if (( tolerance > pt01 ) . or . ( tolerance < comm % round_off )) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,e13.5,a/a,e13.5,a)\" ) & \" ** You have set TOLERANCE = \" , tolerance , \" which is not permitted. The\" , & \" ** range of permitted values is (\" , comm % round_off , \",0.01).\" exit body else comm % tol = tolerance end if if ( minval ( thresholds ) < comm % sqtiny ) then !spec-ar! ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a,e13.5,a)\" ) & \" ** You have set a component of THRESHOLDS to be less than the permitted\" , & \" ** minimum,\" , comm % sqtiny , \".\" exit body end if ! !  Set formula definitions and characteristics call method_const ( comm % rk_method , comm % a , comm % b , comm % c , comm % bhat , & comm % r , comm % e , comm % ptr , comm % no_of_stages , comm % intrp_degree , & comm % intrp_able , comm % intrp_needs_stages , comm % cost , & comm % safety , comm % expon , comm % stability_radius , comm % tan_angle , & comm % rs , comm % rs1 , comm % rs2 , comm % rs3 , comm % rs4 , comm % order , & comm % last_stage , comm % max_stiff_iters , comm % no_of_ge_steps , comm % fsal ,& cdiff ) ! tr_dim_of_stages = maxval ( comm % ptr ( 2 : comm % no_of_stages )) comm % toosml = comm % round_off / cdiff ! !  In STEP_INTEGRATE the first step taken will have magnitude H.  If !  H_START = ABS(H_START) is not equal to zero, H = H_START.  If H_START is !  equal to zero, the code is to find an on-scale initial step size H.  To !  start this process, H is set here to an upper bound on the first step !  size that reflects the scale of the independent variable. !  RANGE_INTEGRATE has some additional information, namely the first output !  point, that is used to refine this bound in STEP_INTEGRATE when called !  from RANGE_INTEGRATE.  If H_START is not zero, but it is either too big !  or too small, the input H_START is ignored and H_START is set to zero to !  activate the automatic determination of an on-scale initial step size. ! hmin = max ( comm % sqtiny , comm % toosml * max ( abs ( t_start ), abs ( t_end ))) if ( abs ( t_end - t_start ) < hmin ) then ier = fatal ; nrec = 4 ; write ( comm % rec , \"(a/a/a,e13.5,a/a,e13.5,a)\" ) & \" ** You have set values for T_END and T_START that are not clearly\" , & \" ** distinguishable for the method and the precision of the computer\" , & \" ** being used. ABS(T_END-T_START) is \" , ABS ( T_END - T_START ), \" but should be\" , & \" **  at least \" , hmin , \".\" exit body end if if ( present ( h_start )) comm % h_start = abs ( h_start ) if ( comm % h_start > abs ( t_end - t_start ) . or . comm % h_start < hmin ) & comm % h_start = zero if ( comm % h_start == zero ) then comm % h = max ( abs ( t_end - t_start ) / comm % rs3 , hmin ) else comm % h = comm % h_start end if ! !  Allocate a number of arrays using pointers. ! allocate ( comm % thresh ( size ( y_start , 1 )), & !alloc! comm % err_estimates ( size ( y_start , 1 )), & !alloc! comm % weights ( size ( y_start , 1 )), & !alloc! comm % y_old ( size ( y_start , 1 )), & !alloc! comm % scratch ( size ( y_start , 1 )), & !alloc! comm % y ( size ( y_start , 1 )), & !alloc! comm % yp ( size ( y_start , 1 )), & !alloc! comm % stages ( size ( y_start , 1 ), tr_dim_of_stages ), & !alloc! comm % ymax ( size ( y_start , 1 )), stat = ier ) !alloc! if ( ier /= 0 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** Not enough storage available to create workspace required internally.\" exit body else comm % y = y_start ; comm % ymax = abs ( y_start ) comm % thresh = thresholds ; comm % y_new => comm % scratch ; comm % yp_old => comm % scratch comm % v0 => comm % err_estimates ; comm % vtemp => comm % scratch comm % v1 => comm % stages (:, 1 ); comm % v2 => comm % stages (:, 2 ) comm % v3 => comm % stages (:, 3 ) end if ! !  Pre-allocate storage for interpolation if the TASK = `R' was specified. ! if ( comm % use_range ) then if ( comm % intrp_able ) then if ( comm % rk_method == 1 ) then comm % p => comm % stages (:, 1 : 2 ) else if ( comm % rk_method == 2 ) then allocate ( comm % p ( size ( y_start , 1 ), 5 ), & !alloc! comm % ytemp ( size ( y_start , 1 )), & !alloc! comm % xstage ( size ( y_start , 1 )), stat = ier ) !alloc! if ( ier /= 0 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** Not enough storage available to create workspace required internally.\" exit body end if end if end if end if ! !  Initialise state and allocate storage for global error assessment ! comm % t_ge_max_contrib = t_start if ( present ( error_assess )) comm % erason = error_assess if ( comm % erason ) then ! !  Storage is required for the stages of a secondary integration. The !  stages of the primary intergration can only be overwritten in the !  cases where there is no interpolant or the interpolant does not !  require information about the stages (e.g. METHOD 'H' and METHOD 'L', !  respectively). if (. not . comm % intrp_needs_stages ) then comm % ge_stages => comm % stages else allocate ( comm % ge_stages ( size ( y_start , 1 ), tr_dim_of_stages ), stat = ier ) !alloc! if ( ier /= 0 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** Not enough storage available to create workspace required internally.\" exit body end if end if allocate ( comm % ge_y ( size ( y_start , 1 )), & !alloc! comm % ge_yp ( size ( y_start , 1 )), & !alloc! comm % ge_err_estimates ( size ( y_start , 1 )), & !alloc! comm % ge_assess ( size ( y_start , 1 )), & !alloc! comm % ge_y_new ( size ( y_start , 1 )), stat = ier ) !alloc! if ( ier /= 0 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** Not enough storage available to create workspace required internally.\" exit body else comm % ge_assess = 0.0_wp ; comm % ge_y = y_start end if end if exit body end do body ! call rkmsg_r1 ( ier , srname , nrec , comm ) ! contains subroutine setup_global_stuff ! comm % h_start = 0.0_wp ; comm % h_old = 0.0_wp comm % f_count = 0 ; comm % full_f_count = 0 ; comm % step_count = 0 ; comm % bad_step_count = 0 comm % at_t_start = . true .; comm % at_t_end = . false . comm % rk_method = 2 ; comm % ge_max_contrib = 0.0_wp ; comm % ge_f_count = 0 comm % erason = . false .; comm % erasfl = . false . comm % print_message = . true .; comm % use_range = . true . comm % stiff_bad_step_count = 0 ; comm % hit_t_end_count = 0 comm % errold = 0.0_wp ; comm % h_average = 0.0_wp comm % chkeff = . false .; comm % phase2 = . true . comm % save_states ( 1 : 7 ) = not_ready comm % stop_on_fatal = . true .; comm % saved_fatal_err = . false . ! end subroutine setup_global_stuff end subroutine setup_r1"},{"title":"collect_garbage_r1 – ISOFT","tags":"","loc":"proc/collect_garbage_r1.html","text":"private subroutine collect_garbage_r1(comm) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ) :: comm Called by proc~~collect_garbage_r1~~CalledByGraph proc~collect_garbage_r1 collect_garbage_r1 interface~collect_garbage collect_garbage interface~collect_garbage->proc~collect_garbage_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~collect_garbage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code collect_garbage_r1 Source Code subroutine collect_garbage_r1 ( comm ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! Modified by I.Gladwell (Aug 2002) ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ) :: comm ! if ( associated ( comm % thresh )) then deallocate ( comm % thresh ); nullify ( comm % thresh ) end if if ( associated ( comm % y )) then deallocate ( comm % y ); nullify ( comm % y ) end if if ( associated ( comm % yp )) then deallocate ( comm % yp ); nullify ( comm % yp ) end if if ( associated ( comm % ymax )) then deallocate ( comm % ymax ); nullify ( comm % ymax ) end if if ( associated ( comm % scratch )) then deallocate ( comm % scratch ); nullify ( comm % scratch ) nullify ( comm % y_new ); nullify ( comm % yp_old ); nullify ( comm % vtemp ) end if if ( associated ( comm % weights )) then deallocate ( comm % weights ); nullify ( comm % weights ) end if if ( associated ( comm % ytemp )) then deallocate ( comm % ytemp ); nullify ( comm % ytemp ) end if if ( associated ( comm % y_old )) then deallocate ( comm % y_old ); nullify ( comm % y_old ) end if if ( associated ( comm % err_estimates )) then deallocate ( comm % err_estimates ); nullify ( comm % err_estimates ) nullify ( comm % v0 ) end if if ( associated ( comm % p , comm % stages (:, 1 : 2 ))) then nullify ( comm % p ) end if if ( associated ( comm % ge_stages , comm % stages )) then deallocate ( comm % stages ); nullify ( comm % stages ); nullify ( comm % ge_stages ); nullify ( comm % v1 , comm % v2 , comm % v3 ) else if ( associated ( comm % ge_stages )) then deallocate ( comm % ge_stages ); nullify ( comm % ge_stages ) end if if ( associated ( comm % ge_y_new )) then deallocate ( comm % ge_y_new ); nullify ( comm % ge_y_new ) end if if ( associated ( comm % ge_assess )) then deallocate ( comm % ge_assess ); nullify ( comm % ge_assess ) end if if ( associated ( comm % ge_err_estimates )) then deallocate ( comm % ge_err_estimates ); nullify ( comm % ge_err_estimates ) end if if ( associated ( comm % ge_yp )) then deallocate ( comm % ge_yp ); nullify ( comm % ge_yp ) end if if ( associated ( comm % ge_y )) then deallocate ( comm % ge_y ); nullify ( comm % ge_y ) end if if ( associated ( comm % xstage )) then deallocate ( comm % xstage ); nullify ( comm % xstage ) end if if ( associated ( comm % p )) then deallocate ( comm % p ); nullify ( comm % p ) end if if ( associated ( comm % stages )) then deallocate ( comm % stages ); nullify ( comm % stages ) end if ! end subroutine collect_garbage_r1"},{"title":"range_integrate_r1 – ISOFT","tags":"","loc":"proc/range_integrate_r1.html","text":"private recursive subroutine range_integrate_r1(comm, f, t_want, t_got, y_got, yderiv_got, flag) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(in) :: t_want real(kind=wp), intent(out) :: t_got real(kind=wp), intent(out), dimension(:) :: y_got real(kind=wp), intent(out), dimension(:) :: yderiv_got integer, intent(out), optional :: flag Calls proc~~range_integrate_r1~~CallsGraph proc~range_integrate_r1 range_integrate_r1 interface~reset_t_end reset_t_end proc~range_integrate_r1->interface~reset_t_end interface~interpolate interpolate proc~range_integrate_r1->interface~interpolate interface~step_integrate step_integrate proc~range_integrate_r1->interface~step_integrate proc~set_saved_state_r1 set_saved_state_r1 proc~range_integrate_r1->proc~set_saved_state_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~range_integrate_r1->proc~get_saved_state_r1 proc~rkmsg_r1 rkmsg_r1 proc~range_integrate_r1->proc~rkmsg_r1 proc~get_saved_fatal_r1 get_saved_fatal_r1 proc~range_integrate_r1->proc~get_saved_fatal_r1 proc~reset_t_end_r1 reset_t_end_r1 interface~reset_t_end->proc~reset_t_end_r1 proc~interpolate_r1 interpolate_r1 interface~interpolate->proc~interpolate_r1 proc~step_integrate_r1 step_integrate_r1 interface~step_integrate->proc~step_integrate_r1 proc~rkmsg_r1->proc~set_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~step_integrate_r1->proc~set_saved_state_r1 proc~step_integrate_r1->proc~get_saved_state_r1 proc~step_integrate_r1->proc~rkmsg_r1 proc~stiff_r1 stiff_r1 proc~step_integrate_r1->proc~stiff_r1 proc~step_r1 step_r1 proc~step_integrate_r1->proc~step_r1 proc~truerr_r1 truerr_r1 proc~step_integrate_r1->proc~truerr_r1 proc~interpolate_r1->proc~get_saved_state_r1 proc~interpolate_r1->proc~rkmsg_r1 proc~reset_t_end_r1->proc~get_saved_state_r1 proc~reset_t_end_r1->proc~rkmsg_r1 proc~truerr_r1->proc~step_r1 var panprocrange_integrate_r1CallsGraph = svgPanZoom('#procrange_integrate_r1CallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~range_integrate_r1~~CalledByGraph proc~range_integrate_r1 range_integrate_r1 interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code range_integrate_r1 Source Code recursive subroutine range_integrate_r1 ( comm , f , t_want , t_got , y_got , yderiv_got , & flag ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( in ) :: t_want !indep! real ( kind = wp ), intent ( out ) :: t_got !indep! real ( kind = wp ), dimension (:), intent ( out ) :: y_got , yderiv_got !dep! integer , intent ( out ), optional :: flag type ( rk_comm_real_1d ), intent ( inout ) :: comm ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! character ( len =* ), parameter :: srname = \"RANGE_INTEGRATE\" ! real ( kind = wp ) :: hmin , t_now !indep! integer :: step_flag , ier , nrec , state logical :: goback , baderr ! integer , parameter :: not_ready =- 1 , usable =- 2 , fatal = 911 , catastrophe = 912 , & just_fine = 1 logical , parameter :: tell = . false ., ask = . true . real ( kind = wp ), parameter :: zero = 0.0_wp ! ier = just_fine ; nrec = 0 goback = . false .; baderr = . false . body : do ! !  Is it permissible to call RANGE_INTEGRATE? ! state = get_saved_state_r1 ( \"SETUP\" , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( state == not_ready ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** You have not called SETUP, so you cannot use RANGE_INTEGRATE.\" exit body end if if (. not . comm % use_range ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have called RANGE_INTEGRATE after you specified in SETUP that you\" ,& \" ** were going to use STEP_INTEGRATE. This is not permitted.\" exit body end if state = get_saved_state_r1 ( srname , comm % save_states ) if ( state == 5 . or . state == 6 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a/a)\" ) & \" ** This routine has already returned with a hard failure. You must call\" ,& \" ** SETUP to start another problem.\" exit body end if state = usable call set_saved_state_r1 ( srname , state , comm ) ! if ( comm % at_t_start ) then ! !  First call. ! !  A value of T_END is specified in SETUP. When INTRP_ABLE = .FALSE., as with !  METHOD = 'H', output is obtained at the specified T_WANT by resetting T_END !  to T_WANT.  At this point, before the integration gets started, this can !  be done with a simple assignment.  Later it is done with a call to !  RESET_T_END. The original T_END is saved in RANGE_T_END. ! comm % range_t_end = comm % t_end if (. not . comm % intrp_able ) comm % t_end = t_want ! !  The last T_GOT returned is in the variable TLAST. T records how far the !  integration has advanced towards the specified T_END.  When output is !  obtained by interpolation, the integration goes past the T_GOT returned !  (T is closer to the specified T_END than T_GOT). comm % tlast = comm % t_start ; t_got = comm % t_start ! !  If the code is to find an on-scale initial step size H, a bound was placed !  on H in SETUP.  Here the first output point is used to refine this bound. if ( comm % h_start == zero ) then comm % h = min ( abs ( comm % h ), abs ( t_want - comm % t_start )) hmin = max ( comm % sqtiny , comm % toosml * & max ( abs ( comm % t_start ), abs ( comm % t_end ))) comm % h = max ( comm % h , hmin ) end if ! else ! !  Subsequent call. ! if ( comm % tlast == comm % range_t_end ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a)\" ) & \" ** You have called RANGE_INTEGRATE after reaching T_END. (Your last call\" ,& \" ** to RANGE_INTEGRATE  resulted in T_GOT = T_END.)  To start a new\" ,& \" ** problem, you will need to call SETUP.\" exit body end if ! end if ! !  Check for valid T_WANT. ! if ( comm % dir * ( t_want - comm % tlast ) <= zero ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a)\" ) & \" ** You have made a call to RANGE_INTEGRATE with a T_WANT that does not lie\" ,& \" ** between the previous value of T_GOT (T_START on the first call) and\" ,& \" ** T_END. This is not permitted. Check your program carefully.\" exit body end if if ( comm % dir * ( t_want - comm % range_t_end ) > zero ) then hmin = max ( comm % sqtiny , comm % toosml * & max ( abs ( t_want ), abs ( comm % range_t_end ))) if ( abs ( t_want - comm % range_t_end ) < hmin ) then ier = fatal ; nrec = 4 ; write ( comm % rec , \"(a/a/a/a)\" ) & \" ** You have made a call to RANGE_INTEGRATE with a T_WANT that does not lie\" ,& \" ** between the previous value of T_GOT (T_START on the first call) and\" ,& \" ** T_END. This is not permitted. T_WANT is very close to T_END, so you may\" ,& \" ** have meant to set it to be T_END exactly.  Check your program carefully.\" else ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a/a)\" ) & \" ** You have made a call to RANGE_INTEGRATE with a T_WANT that does not lie\" ,& \" ** between the previous value of T_GOT (T_START on the first call) and\" ,& \" ** T_END. This is not permitted. Check your program carefully.\" end if exit body end if if (. not . comm % intrp_able ) then hmin = max ( comm % sqtiny , comm % toosml * max ( abs ( comm % tlast ), abs ( t_want ))) if ( abs ( t_want - comm % tlast ) < hmin ) then ier = fatal ; nrec = 4 ; write ( comm % rec , \"(a/a/a/a,e13.5,a)\" ) & \" ** You have made a call to RANGE_INTEGRATE with a T_WANT that is not\" ,& \" ** sufficiently different from the last value of T_GOT (T_START on the\" ,& \" ** first call). When using METHOD = 'H', it must differ by at least \" ,& \" ** \" , HMIN , \".\" exit body end if ! !  We have a valid T_WANT. There is no interpolation with this METHOD and !  therefore we step to T_WANT exactly by resetting T_END with a call to !  RESET_T_END. On the first step this matter is handled differently as !  explained above. ! if (. not . comm % at_t_start ) then call reset_t_end ( comm , t_want ) baderr = get_saved_fatal_r1 ( comm ) if ( baderr ) exit body end if end if ! !  Process output, decide whether to take another step. ! proceed : do ! if ( comm % intrp_able ) then ! !  Interpolation is possible with this METHOD.  The integration has !  already reached T. If this is past T_WANT, GOBACK is set .TRUE. and !  the answers are obtained by interpolation. ! goback = comm % dir * ( comm % t - t_want ) >= zero if ( goback ) then call interpolate ( comm , f , t_want , y_got , yderiv_got ) baderr = get_saved_fatal_r1 ( comm ) if ( baderr ) exit body t_got = t_want end if else ! !  Interpolation is not possible with this METHOD, so output is obtained !  by integrating to T_WANT = T_END.  Both Y_GOT and YDERIV_GOT are then !  already loaded with the solution at T_WANT by STEP_INTEGRATE. ! goback = comm % t == t_want if ( goback ) t_got = t_want end if ! !  If done, go to the exit point. if ( goback ) exit body ! !  Take a step with STEP_INTEGRATE in the direction of T_END.  On exit, the !  solution is advanced to T_NOW.  The approximate solution at T_NOW is !  available in Y_GOT.  If output is obtained by stepping to the end (T_NOW !  = T_WANT = T_END), Y_GOT can be returned directly.  If output is !  obtained by interpolation, the subroutine INTERPOLATE that does this uses !  the values in COMM for its computations and places the approximate solution !  at T_WANT in the arrays Y_GOT,YDERIV_GOT for return to the calling !  program. T_NOW is output from STEP_INTEGRATE and is actually a copy of T !  from inside COMM. call step_integrate ( comm , f , t_now , y_got , yderiv_got , step_flag ) ier = step_flag ! !  A successful step by STEP_INTEGRATE is indicated by step_flag= 1. ! select case ( step_flag ) case ( 1 ); cycle proceed case ( 2 ); nrec = 4 ; write ( comm % rec , \"(a/a/a/a)\" ) & \" ** The last message was produced on a call to STEP_INTEGRATE from\" ,& \" ** RANGE_INTEGRATE. In RANGE_INTAGRATE the appropriate action is to\" ,& \" ** change to METHOD = 'M', or, if insufficient memory is available,\" ,& \" ** to METHOD = 'L'. \" case ( 3 : 6 ); nrec = 2 ; write ( comm % rec , \"(a)\" ) & \" ** The last message was produced on a call to STEP_INTEGRATE from\" ,& \" ** RANGE_INTEGRATE.\" case default ; baderr = . true . end select t_got = comm % t ; exit body end do proceed ! end do body ! if ( baderr ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a)\" ) & \" ** An internal call by RANGE_INTEGRATE to a subroutine resulted in an\" ,& \" ** error that should not happen. Check your program carefully for array\" ,& \" ** sizes, correct number of arguments, type mismatches ... .\" end if ! comm % tlast = t_got ! !  All exits are done here after a call to RKMSG_R1 to report !  what happened ! call rkmsg_r1 ( ier , srname , nrec , comm , flag ) ! end subroutine range_integrate_r1"},{"title":"step_integrate_r1 – ISOFT","tags":"","loc":"proc/step_integrate_r1.html","text":"private recursive subroutine step_integrate_r1(comm, f, t_now, y_now, yderiv_now, flag) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(out) :: t_now real(kind=wp), intent(out), dimension(:) :: y_now real(kind=wp), intent(out), dimension(:) :: yderiv_now integer, intent(out), optional :: flag Calls proc~~step_integrate_r1~~CallsGraph proc~step_integrate_r1 step_integrate_r1 proc~truerr_r1 truerr_r1 proc~step_integrate_r1->proc~truerr_r1 proc~stiff_r1 stiff_r1 proc~step_integrate_r1->proc~stiff_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~step_integrate_r1->proc~set_saved_state_r1 proc~step_r1 step_r1 proc~step_integrate_r1->proc~step_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~step_integrate_r1->proc~get_saved_state_r1 proc~rkmsg_r1 rkmsg_r1 proc~step_integrate_r1->proc~rkmsg_r1 proc~truerr_r1->proc~step_r1 proc~rkmsg_r1->proc~set_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~step_integrate_r1~~CalledByGraph proc~step_integrate_r1 step_integrate_r1 interface~step_integrate step_integrate interface~step_integrate->proc~step_integrate_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->interface~step_integrate interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code step_integrate_r1 Source Code recursive subroutine step_integrate_r1 ( comm , f , t_now , y_now , yderiv_now , flag ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( out ) :: t_now !indep! integer , intent ( out ), optional :: flag type ( rk_comm_real_1d ), intent ( inout ) :: comm real ( kind = wp ), dimension (:), intent ( out ) :: y_now , yderiv_now !dep! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! character ( len =* ), parameter :: srname = \"STEP_INTEGRATE\" ! real ( kind = wp ) :: hmin , htry !indep! real ( kind = wp ) :: alpha , beta , err , tau , t1 , t2 , ypnorm , extra_wk integer :: ier , nrec , state logical :: failed , phase1 , phase3 , toomch , sure_stiff ! integer , parameter :: not_ready =- 1 , usable =- 2 , fatal = 911 , catastrophe = 912 , & max_f_count = 5000 , just_fine = 1 logical , parameter :: tell = . false ., ask = . true . real ( kind = wp ), parameter :: zero = 0.0_wp , pt1 = 0.1_wp , pt9 = 0.9_wp , one = 1.0_wp , & two = 2.0_wp , hundrd = 10 0.0_wp ! ier = just_fine ; nrec = 0 ! !  Is it permissible to call STEP_INTEGRATE? ! body : do state = get_saved_state_r1 ( \"SETUP\" , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( state == not_ready ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** You have not called SETUP, so you cannot use STEP_INTEGRATE.\" exit body end if if ( comm % use_range ) then if ( get_saved_state_r1 ( \"RANGE_INTEGRATE\" , comm % save_states ) /= usable ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have called STEP_INTEGRATE after you specified in SETUP that you\" , & \" ** were going to use RANGE_INTEGRATE. This is not permitted.\" comm % use_range = . false . exit body end if end if state = get_saved_state_r1 ( srname , comm % save_states ) if ( state == 5 . or . state == 6 ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a)\" ) & \" ** STEP_INTEGRATE has already returned with a flag value of 5 or 6. You\" ,& \" ** cannot continue integrating this problem. You must call SETUP to start \" ,& \" ** another problem.\" exit body end if ! if ( comm % at_t_start ) then ! comm % yp = f ( comm % t , comm % y ); comm % f_count = comm % f_count + 1 if ( comm % erason ) comm % ge_yp = comm % yp ! !  The weights for the control of the error depend on the size of the !  solution at the beginning and at the end of the step. On the first !  step we do not have all this information. Whilst determining the !  initial step size we initialize each component of WEIGHTS to the !  larger of the corresponding component of both abs(Y) and the threshold. ! comm % weights = max ( abs ( comm % y ), comm % thresh ) ! !  If H_START is equal to zero, the code is to find an on-scale initial !  step size H.  STEP_INTEGRATE has an elaborate scheme of three phases for !  finding such an H, and some preparations are made earlier.  In SETUP an !  upper bound is placed on H that reflects the scale of the independent !  variable.  RANGE_INTEGRATE, when used, refines this bound using the !  first output point.  Here in STEP_INTEGRATE PHASE1 applies a rule of !  thumb based on the error control, the order of the the formula, and the !  size of the initial slope to get a crude approximation to an on-scale H. !  PHASE2 may reduce H in the course of taking the first step.  PHASE3 !  repeatedly adjusts H and retakes the first step until H is on scale. ! !  A guess for the magnitude of the first step size H can be provided to SETUP !  as H_START.  If it is too big or too small, it is ignored and the automatic !  determination of an on-scale initial step size is activated.  If it is !  acceptable, H is set to H_START in SETUP.  Even when H is supplied to !  STEP_INTEGRATE, PHASE3 of the scheme for finding an on-scale initial step !  size is made active so that the code can deal with a bad guess. ! phase1 = comm % h_start == zero ; comm % phase2 = phase1 ; phase3 = . true . if ( phase1 ) then comm % h = abs ( comm % h ) ypnorm = max ( zero , & maxval ( abs ( comm % yp ) / comm % weights , mask = comm % y /= zero )) !spec-ar1! tau = comm % tol ** comm % expon if ( comm % h * ypnorm > tau ) comm % h = tau / ypnorm hmin = max ( comm % sqtiny , comm % toosml * & max ( abs ( comm % t_start ), abs ( comm % t_end ))) comm % h = comm % dir * max ( comm % h , hmin ) phase1 = . false . end if ! else ! ! Continuation call ! if ( comm % at_t_end ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a,e13.5,a/a/a)\" ) & \" ** You have already reached T_END ( = \" , comm % t_end , \"). To integrate\" ,& \" ** furhter with the same problem you must call the routine RESET_T_END\" ,& \" ** with a new value of T_END.\" exit body end if end if ! !  Begin computation of a step here. ! failed = . false . ! take_step : do ! comm % h = sign ( abs ( comm % h ), comm % dir ) ! !  Reduce the step size if necessary so that the code will not step !  past T_END.  \"Look ahead\" to prevent unnecessarily small step sizes. ! comm % at_t_end = comm % dir * (( comm % t + comm % h ) - comm % t_end ) >= zero if ( comm % at_t_end ) then comm % h = comm % t_end - comm % t else if ( comm % dir * (( comm % t + two * comm % h ) - comm % t_end ) >= zero ) then comm % h = ( comm % t_end - comm % t ) / two end if ! !  When the integrator is at T and attempts a step of H, the function !  defining the differential equations will be evaluated at a number of !  arguments between T and T+H.  If H is too small, these arguments cannot !  be clearly distinguished in the precision available. ! hmin = max ( comm % sqtiny , comm % toosml * max ( abs ( comm % t ), abs ( comm % t + comm % h ))) if ( abs ( comm % h ) < hmin ) then ier = 5 ; nrec = 3 ; write ( comm % rec , \"(a/a,e13.5,a,e13.5,a/a)\" ) & \" ** In order to satisfy your error requirements STEP_INTEGRATE would have\" ,& \" ** to use a step size of \" , comm % H , \" at T_NOW = \" , comm % T , \" This is too\" ,& \" ** small for the machine precision.\" exit body end if ! !  Monitor the impact of output on the efficiency of the integration. ! if ( comm % chkeff ) then comm % hit_t_end_count = comm % hit_t_end_count + 1 if ( comm % hit_t_end_count >= 100 . and . & comm % hit_t_end_count >= comm % step_count / 3 ) then ier = 2 ; nrec = 5 ; write ( comm % rec , \"(a/a/a/a/a)\" ) & \" ** More than 100 output points have been obtained by integrating to T_END.\" ,& \" ** They have been sufficiently close to one another that the efficiency\" ,& \" ** of the integration has been degraded. It would probably be (much) more\" ,& \" ** efficient to obtain output by interpolating with INTERPOLATE (after\" ,& \" ** changing to METHOD='M' if you are using METHOD = 'H').\" comm % hit_t_end_count = 0 ; exit body end if end if ! !  Check for stiffness and for too much work.  Stiffness can be !  checked only after a successful step. ! if (. not . failed ) then ! !  Check for too much work. toomch = comm % f_count > max_f_count if ( toomch ) then ier = 3 ; nrec = 3 ; write ( comm % rec , \"(a,i6,a/a/a)\" ) & \" ** Approximately \" , max_f_count , \" function evaluations have been used to\" ,& \" ** compute the solution since the integration started or since this\" , & \" ** message was last printed.\" ! !  After this warning message, F_COUNT is reset to permit the integration !  to continue.  The total number of function evaluations in the primary !  integration is FULL_F_COUNT + F_COUNT ! comm % full_f_count = comm % full_f_count + comm % f_count comm % f_count = 0 end if ! !  Check for stiffness.  If stiffness is detected, the message about too !  much work is augmented inside STIFF to explain that it is due to !  stiffness. ! call stiff_r1 ( comm , f , toomch , sure_stiff ) if ( sure_stiff ) then ! !  Predict how much extra work will be needed to reach TND. extra_wk = ( comm % cost * abs (( comm % t_end - comm % t ) / comm % h_average )) / & real ( comm % full_f_count + comm % f_count , kind = wp ) ier = 4 ; nrec = nrec + 4 write ( comm % rec ( nrec - 3 : nrec ), \"(a/a,e13.5,a/a/a)\" ) & \" ** Your problem has been diagnosed as stiff.  If the  situation persists,\" ,& \" ** it will cost roughly \" , extra_wk , \" times as much to reach T_END as it\" , & \" ** has cost to reach T_NOW. You should probably change to a code intended\" ,& \" ** for stiff problems.\" end if if ( ier /= just_fine ) exit body end if ! !  Take a step.  Whilst finding an on-scale H (PHASE2 = .TRUE.), the input !  value of H might be reduced (repeatedly), but it will not be reduced !  below HMIN.  The local error is estimated, a weight vector is formed, !  and a weighted maximum norm, ERR, of the local error is returned. !  The presence of the optional argument PHASE2 in the call to STEP !  indicates that this is the primary integration. ! !  H is used by both STEP_INTEGRATE and STEP. Since it may be changed inside !  STEP, a local copy is made. ! htry = comm % h call step_r1 ( comm , f , comm % t , comm % y , comm % yp , comm % stages , comm % tol , htry , & comm % y_new , comm % err_estimates , err , hmin , comm % phase2 ) comm % h = htry ! !  Compare the norm of the local error to the tolerance. ! if ( err > comm % tol ) then ! !  Failed step.  Reduce the step size and try again. ! !  First step:  Terminate PHASE3 of the search for an on-scale step size. !               The step size is not on scale, so ERR may not be accurate; !               reduce H by a fixed factor.  Failed attempts to take the !               first step are not counted. !  Later step:  Use ERR to compute an \"optimal\" reduction of H.  More than !               one failure indicates a difficulty with the problem and an !               ERR that may not be accurate, so reduce H by a fixed factor. ! if ( comm % at_t_start ) then phase3 = . false .; alpha = comm % rs1 else comm % bad_step_count = comm % bad_step_count + 1 comm % stiff_bad_step_count = comm % stiff_bad_step_count + 1 if ( failed ) then alpha = comm % rs1 else alpha = comm % safety * ( comm % tol / err ) ** comm % expon alpha = max ( alpha , comm % rs1 ) end if end if comm % h = alpha * comm % h ; failed = . true .; cycle take_step end if ! !  Successful step. ! !  Predict a step size appropriate for the next step.  After the first !  step the prediction can be refined using an idea of H.A. Watts that !  takes account of how well the prediction worked on the previous step. ! beta = ( err / comm % tol ) ** comm % expon if (. not . comm % at_t_start ) then t1 = ( err ** comm % expon ) / comm % h t2 = ( comm % errold ** comm % expon ) / comm % h_old if ( t1 < t2 * hundrd . and . t2 < t1 * hundrd ) beta = beta * ( t1 / t2 ) end if alpha = comm % rs3 if ( comm % safety < beta * alpha ) alpha = comm % safety / beta ! !  On the first step a search is made for an on-scale step size.  PHASE2 !  of the scheme comes to an end here because a step size has been found !  that is both successful and has a credible local error estimate. Except !  in the special case that the first step is also the last, the step is !  repeated in PHASE3 as long as an increase greater than RS2 appears !  possible.  An increase as big as RS3 is permitted.  A step failure !  terminates PHASE3. ! if ( comm % at_t_start ) then comm % phase2 = . false . phase3 = phase3 . and . . not . comm % at_t_end . and . ( alpha > comm % rs2 ) if ( phase3 ) then comm % h = alpha * comm % h ; cycle take_step end if end if ! !  After getting on scale, step size changes are more restricted. ! alpha = min ( alpha , comm % rs ) if ( failed ) alpha = min ( alpha , one ) alpha = max ( alpha , comm % rs1 ) comm % h_old = comm % h ; comm % h = alpha * comm % h ! !  For the diagnosis of stiffness, an average accepted step size, H_AVERAGE, !  must be computed. ! if ( comm % at_t_start ) then comm % h_average = comm % h_old else comm % h_average = pt9 * comm % h_average + pt1 * comm % h_old end if ! comm % at_t_start = . false .; comm % errold = err ; comm % t_old = comm % t ! !  Take care that T is set to precisely T_END when the end of the !  integration is reached. ! if ( comm % at_t_end ) then comm % t = comm % t_end else comm % t = comm % t + comm % h_old end if ! !  Increment counter on accepted steps.  Note that successful steps !  that are repeated whilst getting on scale are not counted. ! comm % step_count = comm % step_count + 1 ! !  Advance the current solution and its derivative. Note that the previous !  derivative will overwrite Y_NEW (see pointer assignments in SETUP). ! comm % y_old = comm % y ; comm % y = comm % y_new comm % yp_old = comm % yp ! if ( comm % fsal ) then ! !  When FSAL = .TRUE., YP is the last stage of the step. ! comm % yp = comm % stages (:, comm % last_stage ) else ! !  Call F to evaluate YP. ! comm % yp = f ( comm % t , comm % y ); comm % f_count = comm % f_count + 1 end if ! !  If global error assessment is desired, advance the secondary !  integration from TOLD to T. ! if ( comm % erason ) then call truerr_r1 ( comm , f , ier ) if ( ier == 6 ) then ! !  The global error estimating procedure has broken down. Treat it as a !  failed step. The solution and derivative are reset to their values at !  the beginning of the step since the last valid error assessment refers !  to them. ! comm % step_count = comm % step_count - 1 ; comm % erasfl = . true . comm % at_t_end = . false . comm % t = comm % t_old ; comm % h = comm % h_old comm % y = comm % y_old ; comm % yp = comm % yp_old if ( comm % step_count > 0 ) then nrec = 2 ; write ( comm % rec , \"(a/a,e13.5/a)\" ) & \" ** The global error assessment may not be reliable for T past \" ,& \" ** T_NOW = \" , comm % t , \". The integration is being terminated.\" exit body else nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** The global error assessment algorithm failed at the start of the \" ,& \" ** integration.  The integration is being terminated.\" exit body end if end if end if exit take_step end do take_step exit body end do body ! !  Exit point for STEP_INTEGRATE !  Set the output variables and flag that interpolation is permitted ! if ( ier < fatal ) then t_now = comm % t ; comm % at_t_end = t_now == comm % t_end comm % chkeff = comm % at_t_end ; y_now = comm % y ; yderiv_now = comm % yp comm % ymax = max ( abs ( comm % y ), comm % ymax ) if ( ier == just_fine ) then state = usable ; call set_saved_state_r1 ( \"INTERPOLATE\" , state , comm ) end if end if ! !  Call RKMSG_R1 to report what happened and set FLAG. ! call rkmsg_r1 ( ier , srname , nrec , comm , flag ) ! end subroutine step_integrate_r1"},{"title":"truerr_r1 – ISOFT","tags":"","loc":"proc/truerr_r1.html","text":"private subroutine truerr_r1(comm, f, ier) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) integer, intent(inout) :: ier Calls proc~~truerr_r1~~CallsGraph proc~truerr_r1 truerr_r1 proc~step_r1 step_r1 proc~truerr_r1->proc~step_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~truerr_r1~~CalledByGraph proc~truerr_r1 truerr_r1 proc~step_integrate_r1 step_integrate_r1 proc~step_integrate_r1->proc~truerr_r1 interface~step_integrate step_integrate interface~step_integrate->proc~step_integrate_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->interface~step_integrate interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate var panproctruerr_r1CalledByGraph = svgPanZoom('#proctruerr_r1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code truerr_r1 Source Code subroutine truerr_r1 ( comm , f , ier ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ) :: comm integer , intent ( inout ) :: ier ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! real ( kind = wp ) :: hmin , hsec !indep! real ( kind = wp ) :: diff , errmax , mxerlc , tsec , ge_err , ge_test1 , ge_test2 integer :: istep , level ! integer , parameter :: just_fine = 1 real ( kind = wp ), parameter :: pt1 = 0.1_wp , ten = 1 0.0_wp real ( kind = wp ), dimension (:,:), pointer :: ge_stages !dep! real ( kind = wp ), dimension (:), pointer :: ge_y , ge_yp , ge_y_new !dep! real ( kind = wp ), dimension (:), pointer :: ge_err_estimates , y !dep! real ( kind = wp ), dimension (:), pointer :: ge_assess , weights !shp-dep! ! ge_stages => comm % ge_stages ge_y => comm % ge_y ge_yp => comm % ge_yp ge_y_new => comm % ge_y_new ge_err_estimates => comm % ge_err_estimates ge_assess => comm % ge_assess y => comm % y weights => comm % weights ! tsec = comm % t - comm % h_old hsec = comm % h_old / real ( comm % no_of_ge_steps , kind = wp ) hmin = max ( comm % sqtiny , comm % toosml * max ( abs ( tsec ), abs ( comm % t ))) body : do if ( abs ( hsec ) < hmin ) then ier = 6 ; exit body end if ge_test1 = comm % tol / real ( comm % no_of_ge_steps , kind = wp ) ge_test2 = comm % tol / ten ; level = 0 ! !  The subroutine STEP is used to take a step. ! !  Perform secondary integration. ! do istep = 1 , comm % no_of_ge_steps ! !  Take a step. call step_r1 ( comm , f , tsec , ge_y , ge_yp , ge_stages , ge_test1 , hsec , ge_y_new , & ge_err_estimates , ge_err ) ! !  The primary integration is using a step size of H_OLD and the !  secondary integration is using the smaller step size !      HSEC = H_OLD/(NO_OF_GE_STEPS). !  If steps of this size were taken from the same starting point and the !  asymptotic behavior were evident, the smaller step size would result in !  a local error that is considerably smaller, namely by a factor of !  1/(NO_OF_GE_STEPSSEC**(ORDER+1)).  If the two approximate solutions are !  close and TOL is neither too large nor too small, this should be !  approximately true.  The step size is chosen in the primary integration !  so that the local error ERR is no larger than TOL.  The local error, !  GE_ERR, of the secondary integration is compared to TOL in an attempt to !  diagnose a secondary integration that is not rather more accurate than !  the primary integration. ! if ( ge_err >= ge_test1 ) then level = 2 else if ( ge_err > ge_test2 ) then level = level + 1 end if if ( level >= 2 ) then ier = 6 ; exit body end if ! !  Advance TSEC and the dependent variables GE_Y and GE_YP. ! tsec = comm % t - real ( comm % no_of_ge_steps - istep , kind = wp ) * hsec ge_y = ge_y_new ! if ( comm % fsal ) then ! !  When FSAL = .TRUE., the derivative GE_YP is the last stage of the step. ! ge_yp = ge_stages (:, comm % last_stage ) else ! !  Call F to evaluate GE_YP. ! ge_yp = f ( tsec , ge_y ); comm % ge_f_count = comm % ge_f_count + 1 end if ! end do ! !  Update the maximum error seen, GE_MAX_CONTRIB, and its location, !  T_GE_MAX_CONTRIB. Use local variables ERRMAX and MXERLC. ! errmax = comm % ge_max_contrib ; mxerlc = comm % t_ge_max_contrib ; diff = maxval ( abs ( ge_y - y ) / weights ) !spec-ar! if ( diff > errmax ) then errmax = diff ; mxerlc = comm % t end if ! !  If the global error is greater than 0.1, the solutions have diverged so !  far that comparing them may not provide a reliable estimate of the global !  error. The test is made before GE_ASSESS and GE_MAX_CONTRIB, !  T_GE_MAX_CONTRIB are updated so that on a failure, they refer to the !  last reliable results. ! if ( errmax > pt1 ) then ier = 6 else comm % ge_max_contrib = errmax ; comm % t_ge_max_contrib = mxerlc ; ge_assess = ge_assess + ( abs ( ge_y - y ) / weights ) ** 2 ier = just_fine end if exit body ! end do body ! end subroutine truerr_r1"},{"title":"step_r1 – ISOFT","tags":"","loc":"proc/step_r1.html","text":"private subroutine step_r1(comm, f, tnow, y, yp, stages, tol, htry, y_new, errest, err, hmin, phase_2) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout), target :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(in) :: tnow real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: yp real(kind=wp), intent(out), dimension(:,:) :: stages real(kind=wp), intent(in) :: tol real(kind=wp), intent(inout) :: htry real(kind=wp), intent(out), dimension(:) :: y_new real(kind=wp), intent(out), dimension(:) :: errest real(kind=wp), intent(out) :: err real(kind=wp), intent(in), optional :: hmin logical, intent(inout), optional :: phase_2 Called by proc~~step_r1~~CalledByGraph proc~step_r1 step_r1 proc~step_integrate_r1 step_integrate_r1 proc~step_integrate_r1->proc~step_r1 proc~truerr_r1 truerr_r1 proc~step_integrate_r1->proc~truerr_r1 proc~truerr_r1->proc~step_r1 interface~step_integrate step_integrate interface~step_integrate->proc~step_integrate_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->interface~step_integrate interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate var panprocstep_r1CalledByGraph = svgPanZoom('#procstep_r1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code step_r1 Source Code subroutine step_r1 ( comm , f , tnow , y , yp , stages , tol , htry , y_new , & errest , err , hmin , phase_2 ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ), target :: comm real ( kind = wp ), intent ( out ) :: err real ( kind = wp ), intent ( inout ) :: htry !indep! real ( kind = wp ), intent ( in ) :: tnow !indep! real ( kind = wp ), intent ( in ) :: tol real ( kind = wp ), intent ( in ), optional :: hmin !indep! logical , intent ( inout ), optional :: phase_2 ! real ( kind = wp ), dimension (:), intent ( in ) :: y , yp !dep! real ( kind = wp ), dimension (:), intent ( out ) :: errest , y_new !dep! real ( kind = wp ), dimension (:,:), intent ( out ) :: stages !dep! ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! real ( kind = wp ) :: tstg !indep! integer :: i , j logical :: cutbak , main ! intrinsic abs , max , sign ! real ( kind = wp ), dimension (:), pointer :: weights , thresh !shp-dep! real ( kind = wp ), dimension (:,:), pointer :: a !real! real ( kind = wp ), dimension (:), pointer :: b , bhat , c !real! integer , dimension (:), pointer :: ptr !integer! ! real ( kind = wp ), parameter :: zero = 0.0_wp , half = 0.5_wp , one = 1.0_wp ! !  ERREST is used for working storage in this computation. ! weights => comm % weights thresh => comm % thresh a => comm % a b => comm % b bhat => comm % bhat c => comm % c ptr => comm % ptr ! main = present ( hmin ) . and . present ( phase_2 ) attempt_step : do ! if ( main ) then if ( comm % phase2 ) weights = max ( thresh , abs ( y )) end if ! do i = 2 , comm % no_of_stages errest = a ( i , 1 ) * yp do j = 2 , i - 1 if ( a ( i , j ) /= zero ) errest = errest + a ( i , j ) * stages (:, ptr ( j )) end do y_new = y + htry * errest ! !  METHOD = 'M' is special in that an estimate of the local error can be !  formed before the step is completed.  If the step is a failure, !  return immediately.  Otherwise, complete the step and compute a more !  accurate error estimate. ! if ( comm % rk_method == 2 . and . i == 7 ) then call stepb if ( err > tol ) return end if ! tstg = tnow + c ( i ) * htry if ( main . and . comm % at_t_end . and . c ( i ) == one ) tstg = comm % t_end stages (:, ptr ( i )) = f ( tstg , y_new ) ! !  Increment the counter for the number of function evaluations !  depending on whether the primary or secondary integration is taking !  place. ! if ( main ) then comm % f_count = comm % f_count + 1 else comm % ge_f_count = comm % ge_f_count + 1 end if ! !  When PHASE2 is .TRUE. we are in the second phase of the automatic !  selection of the initial step size.  The results of the first three !  stages are monitored in the subroutine STEPA for evidence that H is !  too large -- instability and/or an unreliable estimate of the error !  of the step is then possible.  When the subroutine believes H to be !  too large, it returns CUTBAK = .TRUE. and a suitably reduced H for !  another try. ! if ( main ) then if ( phase_2 ) then if ( i <= 3 . and . abs ( htry ) > hmin ) then call stepa ( stages (:, ptr ( i )), htry , cutbak ) if ( cutbak ) then comm % at_t_end = . false . ! !  Make sure that STEPA does not reduce the step size below the !  minimum. If it does, reset H to HMIN and deactivate PHASE2. ! if ( abs ( htry ) <= hmin ) then htry = sign ( hmin , htry ); comm % phase2 = . false . end if cycle attempt_step end if end if end if end if ! end do ! !  Some formulas are constructed so that the last stage represents !  the result of the step (FSAL=.TRUE.), hence if the step is acceptable, !  it will be the first stage for the next step. When FSAL=.FALSE., we !  have to complete the computation of the step. ! if (. not . comm % fsal ) then errest = bhat ( 1 ) * yp do i = 2 , comm % no_of_stages if ( bhat ( i ) /= zero ) errest = errest + bhat ( i ) * stages (:, ptr ( i )) end do y_new = y + htry * errest end if ! !  Form an estimate of the error in the lower order formula by comparing !  it to the higher order formula of the pair. ERREST has been used !  as working storage above.  The higher order approximation has been !  formed as Y_NEW = Y + HTRY*ERREST where ERREST is a linear !  combination of the stages of the formula. The lower order result also !  has the form Y plus HTRY times a different linear combination of !  the stages. Hence, this different linear combination of stages for !  the lower order formula can just be subtracted from the combination !  stored in ERREST to produce the errors. The result is then !  multiplied by HTRY to obtain the error estimate. ! if ( b ( 1 ) /= zero ) errest = errest - b ( 1 ) * yp do i = 2 , comm % no_of_stages if ( b ( i ) /= zero ) errest = errest - b ( i ) * stages (:, ptr ( i )) end do errest = htry * errest ! !  The error in a solution component is measured relative to a weight !  that is the larger of a threshold and the size of the solution over !  the step.  Using the magnitude of a solution component at both ends !  of the step in the definition of \"size\" increases the robustness of !  the test. When global error estimation is specified, the weight !  vector WEIGHTS is defined by the primary integration and is then !  used in the secondary integration. ! if ( main ) weights = max ( half * ( abs ( y ) + abs ( y_new )), thresh ) ! err = maxval ( abs ( errest / weights )) !spec-ar! ! exit attempt_step ! end do attempt_step ! contains ! subroutine stepa ( ypnew , htry , cutbak ) ! real ( kind = wp ), intent ( inout ) :: htry !indep! real ( kind = wp ), dimension (:), intent ( in ) :: ypnew !dep! logical , intent ( out ) :: cutbak ! real ( kind = wp ) :: argdif , fdiff , scl , tdiff , twt , ynrm , ystgnm ! !  Update the weights to account for the current intermediate solution !  approximation Y_NEW.  Compute the sizes of Y and Y_NEW in the !  new norm.  The size of the Lipschitz constant is assessed by a difference !  in the arguments Y, Y_NEW and a difference in the function evaluated !  at these arguments. ! weights = max ( weights , abs ( y_new )) ynrm = maxval ( abs ( y ) / weights ) !spec-ar! ystgnm = maxval ( abs ( y_new ) / weights ) !spec-ar! argdif = maxval ( abs ( y_new - y ) / weights ) !spec-ar! fdiff = maxval ( abs ( ypnew - yp ) / weights ) !spec-ar! ! !  The transformation of the equation to autonomous form is done !  implicitly.  The difference of the arguments must take into account !  the difference between the values of the independent variable T and !  TSTG. The difference of the corresponding component of the function !  is zero because of the way the standard transformation is done. ! tdiff = tstg - tnow twt = abs ( comm % t_end - tnow ) ynrm = max ( ynrm , abs ( tnow ) / twt ) ystgnm = max ( ystgnm , abs ( tstg ) / twt ) argdif = max ( argdif , abs ( tdiff ) / twt ) ! !  The ratio FDIFF/ARGDIF is a lower bound for, and an approximation to, !  a Lipschitz constant L for the differential equation written in !  autonomous form.  First we must ask if the difference ARGDIF is !  significant in the precision available.  If it appears to be, we insist !  that abs(HTRY)*L be less than an approximate radius, STABILITY_RADIUS, !  of the stability region of the method.  This is more stringent than !  necessary for stability, possibly a lot more stringent, but the aim is !  to get an HTRY small enough that the error estimate for the step is !  credible.  The reduction is required to be at least as much as the step !  control parameter RS1. It is necessary to limit the reduction of HTRY !  at any one time because we may be misled in the size of the reduction !  that is appropriate due to nonlinearity of the differential equation !  and to inaccurate weights caused by HTRY much too large.  The reduction !  is not permitted to be more than the step control parameter RS4. ! cutbak = . false . if ( argdif > comm % round_off * max ( ynrm , ystgnm )) then if (( abs ( htry ) * fdiff ) > ( comm % stability_radius * argdif )) then scl = max ( comm % rs4 , min ( comm % rs1 , & ( comm % stability_radius * argdif ) / ( abs ( htry ) * fdiff ))) htry = scl * htry ; cutbak = . true . end if end if ! end subroutine stepa ! subroutine stepb ! real ( kind = wp ), dimension (:), pointer :: e !real! ! e => comm % e ! if ( main ) then err = maxval ( abs ( e ( 1 ) * yp + e ( 3 ) * stages (:, ptr ( 3 )) + & !spec-ar! e ( 4 ) * stages (:, ptr ( 4 )) + e ( 5 ) * stages (:, ptr ( 5 )) + & e ( 6 ) * stages (:, ptr ( 6 )) ) / & max ( half * ( abs ( y ) + abs ( y_new )), thresh ) ) else err = maxval ( abs ( e ( 1 ) * yp + e ( 3 ) * stages (:, ptr ( 3 )) + & !spec-ar! e ( 4 ) * stages (:, ptr ( 4 )) + e ( 5 ) * stages (:, ptr ( 5 )) + & e ( 6 ) * stages (:, ptr ( 6 )) ) / weights ) end if ! err = abs ( comm % h ) * err ! end subroutine stepb ! end subroutine step_r1"},{"title":"stiff_r1 – ISOFT","tags":"","loc":"proc/stiff_r1.html","text":"private subroutine stiff_r1(comm, f, toomch, sure_stiff) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout), target :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) logical, intent(in) :: toomch logical, intent(out) :: sure_stiff Called by proc~~stiff_r1~~CalledByGraph proc~stiff_r1 stiff_r1 proc~step_integrate_r1 step_integrate_r1 proc~step_integrate_r1->proc~stiff_r1 interface~step_integrate step_integrate interface~step_integrate->proc~step_integrate_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->interface~step_integrate interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate var panprocstiff_r1CalledByGraph = svgPanZoom('#procstiff_r1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code stiff_r1 Source Code subroutine stiff_r1 ( comm , f , toomch , sure_stiff ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ), target :: comm logical , intent ( in ) :: toomch logical , intent ( out ) :: sure_stiff ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! logical :: maybe_stiff , lots_of_fails ! real ( kind = wp ) :: alpha1 , alpha2 , beta1 , beta2 !dep! real ( kind = wp ) :: rold , v1v0 , v2v0 , v2v1 , v3v1 , v3v2 !dep! real ( kind = wp ) :: dist , res2 , scale , v0nrm , v3nrm , ynrm , rho , v0v0 , v1v1 , & v2v2 , v3v3 , yy , det1 , det2 integer :: ntry complex ( kind = wp ), dimension ( 2 ) :: root_pair , prv_root_pair integer , parameter :: bigr = 1 , smlr = 2 real ( kind = wp ), dimension (:), pointer :: v0 , v1 , v2 , v3 , y , y_old !dep! real ( kind = wp ), dimension (:), pointer :: weights , thresh !shp-dep! ! integer , parameter :: max_f_count = 5000 real ( kind = wp ), parameter :: zero = 0.0_wp , pt001 = 0.001_wp , pt9 = 0.9_wp , & fifth = 0.2_wp , half = 0.5_wp , one = 1.0_wp , two = 2.0_wp , five = 5.0_wp , & large = 1.0e+10_wp ! v0 => comm % v0 v1 => comm % v1 v2 => comm % v2 v3 => comm % v3 weights => comm % weights thresh => comm % thresh y => comm % y y_old => comm % y_old ! sure_stiff = . false . lots_of_fails = . false . ! if ( mod ( comm % step_count - 10 , 40 ) == 0 ) then lots_of_fails = comm % stiff_bad_step_count >= 10 comm % stiff_bad_step_count = 0 end if ! !  If either too much work has been done or there are lots of failed steps, !  test for stiffness. ! maybe_stiff = toomch . or . lots_of_fails if ( maybe_stiff ) then ! !  Regenerate weight vector ! weights = max ( half * ( abs ( y ) + abs ( y_old )), thresh ) maybe_stiff = fifth < abs ( comm % h / comm % h_average ) . and . & abs ( comm % h / comm % h_average ) < five if ( maybe_stiff ) then ! !  The average step size is used to predict the cost in function evaluations !  of finishing the integration to T_END.  If this cost is no more than !  MAX_F_COUNT, the problem is declared not stiff. If the step size is !  being restricted on grounds of stability, it will stay close to H_AVERAGE. !  The prediction will then be good, but the cost is too low to consider !  the problem stiff.  If the step size is not close to H_AVERAGE, the !  problem is not stiff.  Either way there is no point to testing for a step !  size restriction due to stability. ! maybe_stiff = comm % cost * abs (( comm % t_end - comm % t ) / comm % h_average ) > & real ( max_f_count , kind = wp ) if ( maybe_stiff ) then ! !  There have been many step failures or a lot of work has been done.  Now !  we must determine if this is due to the stability characteristics of the !  formula.  This is done by calculating the dominant eigenvalues of the !  local Jacobian and then testing whether H_AVERAGE corresponds to being !  on the boundary of the stability region. !  The size of Y provides scale information needed to approximate !  the Jacobian by differences. ! v0v0 = wt_inner_prod ( v0 , v0 ) yy = wt_inner_prod ( y , y ) ynrm = sqrt ( yy ) scale = ynrm * comm % sqrrmc if ( scale == zero ) then ! !  Degenerate case.  Y is (almost) the zero vector so the scale is not !  defined.  The input vector V0 is the difference between Y and a !  lower order approximation to the solution that is within the error !  tolerance.  When Y vanishes, V0 is itself an acceptable approximate !  solution, so we take SCALE from it, if this is possible. ! scale = v0v0 * comm % sqrrmc maybe_stiff = scale > zero end if end if end if end if ! if (. not . maybe_stiff ) return ! if ( v0v0 == zero ) then ! !  Degenerate case.  V0 is (almost) the zero vector so cannot !  be used to define a direction for an increment to Y.  Try a !  \"random\" direction. ! v0 = one ; v0v0 = wt_inner_prod ( v0 , v0 ) end if ! v0nrm = sqrt ( v0v0 ) v0 = v0 / v0nrm ; v0v0 = one ! !  Use a nonlinear power method to estimate the two dominant eigenvalues. !  V0 is often very rich in the two associated eigenvectors.  For this !  reason the computation is organized with the expectation that a minimal !  number of iterations will suffice.  Indeed, it is necessary to recognize !  a kind of degeneracy when there is a dominant eigenvalue.  The function !  DOMINANT_EIGENVALUE does this.  In the first try, NTRY = 1, a Rayleigh !  quotient for such an eigenvalue is initialized as ROLD.  After each !  iteration, DOMINANT_EIGENVALUE computes a new Rayleigh quotient and !  tests whether the two approximations agree to one tenth of one per cent !  and the eigenvalue, eigenvector pair satisfy a stringent test on the !  residual. ! ntry = 1 do ! v1 = approx_jacobian ( f , v0 , v0v0 ) v1v1 = wt_inner_prod ( v1 , v1 ) ! !  The quantity SQRT(V1V1/V0V0) is a lower bound for the product of H_AVERAGE !  and a Lipschitz constant.  If it should be LARGE, stiffness is not !  restricting the step size to the stability region.  The principle is !  clear enough, but the real reason for this test is to recognize an !  extremely inaccurate computation of V1V1 due to finite precision !  arithmetic in certain degenerate circumstances. ! if ( sqrt ( v1v1 ) > large * sqrt ( v0v0 )) return ! v1v0 = wt_inner_prod ( v1 , v0 ) if ( ntry == 1 ) then rold = v1v0 / v0v0 ! !  This is the first Rayleigh quotient approximating the product of H_AVERAGE !  and a dominant eigenvalue.  If it should be very small, the !  problem is not stiff.  It is important to test for this possibility so !  as to prevent underflow and degeneracies in the subsequent iteration. ! if ( abs ( rold ) < comm % cubrmc ) return else ! if ( dominant_eigenvalue ( v1v1 , v1v0 , v0v0 )) exit end if ! v2 = approx_jacobian ( f , v1 , v1v1 ) v2v2 = wt_inner_prod ( v2 , v2 ) v2v0 = wt_inner_prod ( v2 , v0 ) v2v1 = wt_inner_prod ( v2 , v1 ) if ( dominant_eigenvalue ( v2v2 , v2v1 , v1v1 )) exit ! !  Fit a quadratic in the eigenvalue to the three successive iterates !  V0,V1,V2 of the power method to get a first approximation to !  a pair of eigenvalues.  A test made earlier in DOMINANT_EIGENVALUE !  implies that the quantity DET1 here will not be too small. ! det1 = v0v0 * v1v1 - v1v0 * rev_wt_inner_prod ( v1v0 ) alpha1 = ( - v0v0 * v2v1 + rev_wt_inner_prod ( v1v0 ) * v2v0 ) / det1 beta1 = ( v1v0 * v2v1 - v1v1 * v2v0 ) / det1 ! !  Iterate again to get V3, test again for degeneracy, and then fit a !  quadratic to V1,V2,V3 to get a second approximation to a pair !  of eigenvalues. ! v3 = approx_jacobian ( f , v2 , v2v2 ) v3v3 = wt_inner_prod ( v3 , v3 ) v3v1 = wt_inner_prod ( v3 , v1 ) v3v2 = wt_inner_prod ( v3 , v2 ) if ( dominant_eigenvalue ( v3v3 , v3v2 , v2v2 )) exit ! det2 = v1v1 * v2v2 - v2v1 * rev_wt_inner_prod ( v2v1 ) alpha2 = ( - v1v1 * v3v2 + rev_wt_inner_prod ( v2v1 ) * v3v1 ) / det2 beta2 = ( v2v1 * v3v2 - v2v2 * v3v1 ) / det2 ! !  First test the residual of the quadratic fit to see if we might !  have determined a pair of eigenvalues. ! res2 = abs ( v3v3 + rev_wt_inner_prod ( alpha2 ) * v3v2 + & rev_wt_inner_prod ( beta2 ) * v3v1 + & alpha2 * rev_wt_inner_prod ( v3v2 ) + & alpha2 * rev_wt_inner_prod ( alpha2 ) * v2v2 + & alpha2 * rev_wt_inner_prod ( beta2 ) * v2v1 + & beta2 * rev_wt_inner_prod ( v3v1 ) + & beta2 * rev_wt_inner_prod ( alpha2 ) * rev_wt_inner_prod ( v2v1 ) + & beta2 * rev_wt_inner_prod ( beta2 ) * v1v1 ) if ( res2 <= abs ( v3v3 ) * pt001 ** 2 ) then ! !  Calculate the two approximate pairs of eigenvalues. ! prv_root_pair ( 1 : 2 ) = quadratic_roots ( alpha1 , beta1 ) root_pair ( 1 : 2 ) = quadratic_roots ( alpha2 , beta2 ) ! !  The test for convergence is done on the larger root of the second !  approximation.  It is complicated by the fact that one pair of roots !  might be real and the other complex.  First calculate the spectral !  radius RHO of HAVG*J as the magnitude of ROOT1.  Then see if one of !  the roots R1,R2 is within one per cent of ROOT1.  A subdominant root !  may be very poorly approximated if its magnitude is much smaller than !  RHO -- this does not matter in our use of these eigenvalues. ! rho = abs ( prv_root_pair ( bigr )) dist = min ( abs ( root_pair ( bigr ) - prv_root_pair ( bigr )), & abs ( root_pair ( bigr ) - prv_root_pair ( smlr )) ) if ( dist <= pt001 * rho ) exit end if ! !  Do not have convergence yet.  Because the iterations are cheap, and !  because the convergence criterion is stringent, we are willing to try !  a few iterations. ! ntry = ntry + 1 if ( ntry > comm % max_stiff_iters ) return v3nrm = sqrt ( v3v3 ) v0 = v3 / v3nrm v0v0 = one ! end do ! !  We now have the dominant eigenvalues.  Decide if the average step !  size is being restricted on grounds of stability.  Check the real !  parts of the eigenvalues.  First see if the dominant eigenvalue is !  in the left half plane -- there won't be a stability restriction !  unless it is. If there is another eigenvalue of comparable magnitude !  with a positive real part, the problem is not stiff. If the dominant !  eigenvalue is too close to the imaginary axis, we cannot diagnose !  stiffness. ! if ( real ( root_pair ( bigr )) < zero ) then if ( . not . ( abs ( root_pair ( smlr )) >= pt9 * rho . and . & real ( root_pair ( smlr )) > zero ) ) then if ( abs ( aimag ( root_pair ( bigr ))) <= & abs ( real ( root_pair ( bigr ))) * comm % tan_angle ) then ! !  If the average step size corresponds to being well within the !  stability region, the step size is not being restricted because !  of stability. ! sure_stiff = rho >= pt9 * comm % stability_radius end if end if end if ! contains function approx_jacobian ( f , v , vdotv ) ! real ( kind = wp ), intent ( in ) :: vdotv real ( kind = wp ), dimension (:), intent ( in ) :: v !dep! real ( kind = wp ), dimension ( size ( v , 1 )) :: approx_jacobian !dep! ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! real ( kind = wp ) :: temp1 ! !  Scale V so that it can be used as an increment to Y !  for an accurate difference approximation to the Jacobian. ! temp1 = scale / sqrt ( vdotv ) comm % vtemp = y + temp1 * v ! approx_jacobian = f ( comm % t , comm % vtemp ) comm % f_count = comm % f_count + 1 ! !  Form the difference approximation.  At the same time undo !  the scaling of V and introduce the factor of H_AVERAGE. ! approx_jacobian = & ( comm % h_average / temp1 ) * ( approx_jacobian - comm % yp ) ! end function approx_jacobian function quadratic_roots ( alpha , beta ) ! real ( kind = wp ), intent ( in ) :: alpha , beta !dep! complex ( kind = wp ), dimension ( 2 ) :: quadratic_roots ! complex ( kind = wp ) :: temp , sqdisc , r1 , r2 ! !  For types other than real/complex, this procedure must be constructed !  such that temp and sqdisc are evaluated as compelx quantities ! temp = alpha / two ; sqdisc = sqrt ( temp ** 2 - beta ) ! ! Do we have double root? ! if ( sqdisc == zero ) then quadratic_roots = ( / - temp , - temp / ) ! ! Distinct roots ! else r1 = - temp + sqdisc ; r2 = - temp + sqdisc if ( abs ( r1 ) > abs ( r2 )) then quadratic_roots = ( / r1 , r2 / ) else quadratic_roots = ( / r2 , r1 / ) end if end if ! end function quadratic_roots function dominant_eigenvalue ( v1v1 , v1v0 , v0v0 ) ! real ( kind = wp ), intent ( in ) :: v0v0 , v1v1 real ( kind = wp ), intent ( in ) :: v1v0 !dep! logical :: dominant_eigenvalue ! real ( kind = wp ) :: ratio !dep! real ( kind = wp ) :: res , det logical :: big ! ratio = v1v0 / v0v0 ; rho = abs ( ratio ) det = v0v0 * v1v1 - v1v0 * rev_wt_inner_prod ( v1v0 ); res = abs ( det / v0v0 ) ! big = det == zero . or . & ( res <= abs ( v1v1 ) * pt001 ** 2 . and . abs ( ratio - rold ) <= pt001 * rho ) ! if ( big ) then root_pair ( bigr ) = cmplx ( ratio ) root_pair ( smlr ) = cmplx ( zero ) end if ! rold = ratio dominant_eigenvalue = big ! end function dominant_eigenvalue function wt_inner_prod ( vec_1 , vec_2 ) ! real ( kind = wp ), dimension (:), intent ( in ) :: vec_1 , vec_2 !dep! real ( kind = wp ) :: wt_inner_prod !dep! ! ! wt_inner_prod = sum ( ( vec_1 / weights ) * ( vec_2 / weights ) ) !spec-ar! ! end function wt_inner_prod function rev_wt_inner_prod ( value ) ! real ( kind = wp ), intent ( in ) :: value !dep! real ( kind = wp ) :: rev_wt_inner_prod !dep! ! ! given result of inner product value = v1.v0 ! must return the reverse, ie v0.v1 ! ! for real variables the value is the same ! for complex need to conjugate ! rev_wt_inner_prod = value !spec-line! ! end function rev_wt_inner_prod end subroutine stiff_r1"},{"title":"statistics_r1 – ISOFT","tags":"","loc":"proc/statistics_r1.html","text":"private subroutine statistics_r1(comm, total_f_calls, step_cost, waste, num_succ_steps, h_next, y_maxvals) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm integer, intent(out), optional :: total_f_calls integer, intent(out), optional :: step_cost real(kind=wp), intent(out), optional :: waste integer, intent(out), optional :: num_succ_steps real(kind=wp), intent(out), optional :: h_next real(kind=wp), intent(out), optional dimension(:) :: y_maxvals Calls proc~~statistics_r1~~CallsGraph proc~statistics_r1 statistics_r1 proc~rkmsg_r1 rkmsg_r1 proc~statistics_r1->proc~rkmsg_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~statistics_r1->proc~get_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~statistics_r1~~CalledByGraph proc~statistics_r1 statistics_r1 interface~statistics statistics interface~statistics->proc~statistics_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code statistics_r1 Source Code subroutine statistics_r1 ( comm , total_f_calls , step_cost , waste , num_succ_steps ,& h_next , y_maxvals ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ) :: comm real ( kind = wp ), optional , intent ( out ) :: h_next !indep! real ( kind = wp ), optional , intent ( out ) :: waste real ( kind = wp ), dimension (:), optional , intent ( out ) :: y_maxvals !shp-dep! integer , optional , intent ( out ) :: step_cost , num_succ_steps , total_f_calls ! character ( len =* ), parameter :: srname = \"STATISTICS\" ! integer :: ier , nrec , state ! integer , parameter :: not_ready =- 1 , not_reusable =- 3 , fatal = 911 , & catastrophe = 912 , just_fine = 1 logical , parameter :: ask = . true . real ( kind = wp ), parameter :: zero = 0.0_wp ! ier = just_fine ; nrec = 0 ! body : do ! !  Is it permissible to call STATISTICS? ! state = get_saved_state_r1 ( srname , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( state == not_reusable ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have already made a call to STATISTICS after a hard failure was \" , & \" ** reported from the integrator. You cannot call STATISTICS again.\" exit body end if state = get_saved_state_r1 ( \"STEP_INTEGRATE\" , comm % save_states ) if ( state == not_ready ) then ier = fatal ; nrec = 1 if ( comm % use_range ) then write ( comm % rec , \"(a)\" ) & \" ** You have not called RANGE_INTEGRATE, so you cannot use STATISTICS.\" else write ( comm % rec , \"(a)\" ) & \" ** You have not called STEP_INTEGRATE, so you cannot use STATISTICS.\" end if exit body end if if ( present ( y_maxvals )) then if ( any ( shape ( y_maxvals ) /= shape ( comm % y ))) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,i6,a/a,i6,a)\" ) & \" ** The shape of Y_MAXVALS is not consistent with the shape of the\" , & \" ** dependent variables.\" exit body end if end if ! !  Set flag so that the routine can only be called once after a hard !  failure from the integrator. ! if ( state == 5 . or . state == 6 ) ier = not_reusable ! if ( present ( total_f_calls )) then total_f_calls = comm % full_f_count + comm % f_count !      if (comm%erason) total_f_calls = total_f_calls + comm%ge_f_count end if if ( present ( step_cost )) step_cost = comm % cost if ( present ( num_succ_steps )) num_succ_steps = comm % step_count if ( present ( waste )) then if ( comm % step_count <= 1 ) then waste = zero else waste = real ( comm % bad_step_count , kind = wp ) / & real ( comm % bad_step_count + comm % step_count , kind = wp ) end if end if if ( present ( h_next )) h_next = comm % h if ( present ( y_maxvals )) y_maxvals = comm % ymax exit body end do body ! call rkmsg_r1 ( ier , srname , nrec , comm ) ! end subroutine statistics_r1"},{"title":"global_error_r1 – ISOFT","tags":"","loc":"proc/global_error_r1.html","text":"private subroutine global_error_r1(comm, rms_error, max_error, t_max_error) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm real(kind=wp), intent(out), optional dimension(:) :: rms_error real(kind=wp), intent(out), optional :: max_error real(kind=wp), intent(out), optional :: t_max_error Calls proc~~global_error_r1~~CallsGraph proc~global_error_r1 global_error_r1 proc~rkmsg_r1 rkmsg_r1 proc~global_error_r1->proc~rkmsg_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~global_error_r1->proc~get_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~global_error_r1~~CalledByGraph proc~global_error_r1 global_error_r1 interface~global_error global_error interface~global_error->proc~global_error_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code global_error_r1 Source Code subroutine global_error_r1 ( comm , rms_error , max_error , t_max_error ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ) :: comm real ( kind = wp ), optional , intent ( out ) :: max_error real ( kind = wp ), optional , intent ( out ) :: t_max_error !indep! real ( kind = wp ), dimension (:), optional , intent ( out ) :: rms_error !shp-dep! ! character ( len =* ), parameter :: srname = \"GLOBAL_ERROR\" ! integer :: ier , nrec , state ! intrinsic sqrt ! integer , parameter :: not_ready =- 1 , not_reusable =- 3 , fatal = 911 , & catastrophe = 912 , just_fine = 1 logical , parameter :: ask = . true . ! ier = just_fine ; nrec = 0 ! body : do ! !  Is it permissible to call GLOBAL_ERROR? ! state = get_saved_state_r1 ( srname , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( state == not_reusable ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have already made a call to GLOBAL_ERROR after a hard failure was\" , & \" ** reported from the integrator. You cannot call GLOBAL_ERROR again.\" exit body end if state = get_saved_state_r1 ( \"STEP_INTEGRATE\" , comm % save_states ) if ( state == not_ready ) then ier = fatal ; nrec = 1 if ( comm % use_range ) then write ( comm % rec , \"(a)\" ) & \" ** You have not yet called RANGE_INTEGRATE, so you cannot call GLOBAL_ERROR.\" else write ( comm % rec , \"(a)\" ) & \" ** You have not yet called STEP_INTEGRATE, so you cannot call GLOBAL_ERROR.\" end if exit body end if ! !  Set flag so that the routine can only be called once after a hard !  failure from the integrator. ! if ( state == 5 . or . state == 6 ) ier = not_reusable ! !  Check that ERROR_ASSESS was set properly for error assessment in SETUP. ! if (. not . comm % erason ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a/a)\" ) & \" ** No error assessment is available since you did not ask for it in your\" ,& \" ** call to the routine SETUP. Check your program carefully.\" exit body end if ! ! Check size of RMS_ERROR ! if ( present ( rms_error )) then if ( any ( shape ( rms_error ) /= shape ( comm % y ))) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,a)\" ) & \" ** The shape of RMS_ERROR is not consistent with the shape of the\" , & \" ** dependent variables.\" exit body end if end if ! !  Check to see if the integrator has not actually taken a step. ! if ( comm % step_count == 0 ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** The integrator has not actually taken any successful steps. You cannot\" ,& \" ** call GLOBAL_ERROR in this circumstance. Check your program carefully.\" exit body end if ! !  Compute RMS error and set output variables. ! if ( present ( max_error )) max_error = comm % ge_max_contrib if ( present ( t_max_error )) t_max_error = comm % t_ge_max_contrib if ( present ( rms_error )) rms_error = & sqrt ( comm % ge_assess / real ( comm % step_count , kind = wp )) ! exit body end do body ! call rkmsg_r1 ( ier , srname , nrec , comm ) ! end subroutine global_error_r1"},{"title":"reset_t_end_r1 – ISOFT","tags":"","loc":"proc/reset_t_end_r1.html","text":"private subroutine reset_t_end_r1(comm, t_end_new) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm real(kind=wp), intent(in) :: t_end_new Calls proc~~reset_t_end_r1~~CallsGraph proc~reset_t_end_r1 reset_t_end_r1 proc~rkmsg_r1 rkmsg_r1 proc~reset_t_end_r1->proc~rkmsg_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~reset_t_end_r1->proc~get_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~reset_t_end_r1~~CalledByGraph proc~reset_t_end_r1 reset_t_end_r1 interface~reset_t_end reset_t_end interface~reset_t_end->proc~reset_t_end_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->interface~reset_t_end interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code reset_t_end_r1 Source Code subroutine reset_t_end_r1 ( comm , t_end_new ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( in ) :: t_end_new !indep! type ( rk_comm_real_1d ), intent ( inout ) :: comm ! character ( len =* ), parameter :: srname = \"RESET_T_END\" ! real ( kind = wp ) :: hmin , tdiff !indep! integer :: ier , nrec , state ! integer , parameter :: not_ready =- 1 , usable =- 2 , fatal = 911 , catastrophe = 912 , & just_fine = 1 logical , parameter :: ask = . true . real ( kind = wp ), parameter :: zero = 0.0_wp ! ier = just_fine ; nrec = 0 ! !  Is it permissible to call RESET_T_END? ! body : do ! state = get_saved_state_r1 ( \"STEP_INTEGRATE\" , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( comm % use_range ) then if ( get_saved_state_r1 ( \"RANGE_INTEGRATE\" , comm % save_states ) /= usable ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have called RESET_T_END after you specified to SETUP that you were\" ,& \" ** going to use RANGE_INTEGRATE. This is not permitted.\" exit body end if end if if ( state == not_ready ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** You have not called STEP_INTEGRATE, so you cannot use RESET_T_END.\" exit body end if if ( state == 5 . or . state == 6 ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a,i1,a/a)\" ) & \" ** STEP_INTEGRATE has returned with FLAG =  \" , STATE , \" You cannot call\" ,& \" ** RESET_T_END inthis circumstance.\" exit body end if ! !  Check value of T_END_NEW ! if ( comm % dir > zero . and . t_end_new <= comm % t ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a,e13.5/a,e13.5,a)\" ) & \" ** Integration is proceeding in the positive direction. The current value\" ,& \" ** for the independent variable is \" , comm % T , \" and you have set T_END_NEW =\" ,& \" ** \" , T_END_NEW , \".  T_END_NEW must be greater than T.\" exit body else if ( comm % dir < zero . and . t_end_new >= comm % t ) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a/a,e13.5/a,e13.5,a)\" ) & \" ** Integration is proceeding in the negative direction. The current value\" ,& \" ** for the independent variable is \" , comm % T , \" and you have set T_END_NEW =\" ,& \" ** \" , T_END_NEW , \".  T_END_NEW must be less than T.\" exit body else hmin = max ( comm % sqtiny , comm % toosml * max ( abs ( comm % t ), abs ( t_end_new ))) tdiff = abs ( t_end_new - comm % t ) if ( tdiff < hmin ) then ier = fatal ; nrec = 4 write ( comm % rec , \"(a,e13.5,a/a,e13.5,a/a/a,e13.5,a)\" )& \" ** The current value of the independent variable T is \" , comm % T , \". The\" ,& \" ** T_END_NEW you supplied has ABS(T_END_NEW-T) = \" , TDIFF , \". For the METHOD\" ,& \" ** and the precision of the computer being used, this difference must be\" ,& \" ** at least \" , HMIN , \".\" exit body end if end if ! comm % t_end = t_end_new ; comm % at_t_end = . false . ! exit body end do body ! call rkmsg_r1 ( ier , srname , nrec , comm ) ! end subroutine reset_t_end_r1"},{"title":"interpolate_r1 – ISOFT","tags":"","loc":"proc/interpolate_r1.html","text":"private subroutine interpolate_r1(comm, f, t_want, y_want, yderiv_want) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout), target :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(in) :: t_want real(kind=wp), intent(out), optional dimension(:) :: y_want real(kind=wp), intent(out), optional dimension(:) :: yderiv_want Calls proc~~interpolate_r1~~CallsGraph proc~interpolate_r1 interpolate_r1 proc~rkmsg_r1 rkmsg_r1 proc~interpolate_r1->proc~rkmsg_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~interpolate_r1->proc~get_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpolate_r1~~CalledByGraph proc~interpolate_r1 interpolate_r1 interface~interpolate interpolate interface~interpolate->proc~interpolate_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->interface~interpolate interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolate_r1 Source Code subroutine interpolate_r1 ( comm , f , t_want , y_want , yderiv_want ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! real ( kind = wp ), intent ( in ) :: t_want !indep! type ( rk_comm_real_1d ), intent ( inout ), target :: comm real ( kind = wp ), dimension (:), intent ( out ), optional :: y_want !dep! real ( kind = wp ), dimension (:), intent ( out ), optional :: yderiv_want !dep! ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! character ( len =* ), parameter :: srname = \"INTERPOLATE\" integer :: ier , jer , nrec , state , npcls logical :: intrp_initialised ! integer , parameter :: not_ready =- 1 , usable =- 2 , fatal = 911 , catastrophe = 912 , & just_fine = 1 logical , parameter :: ask = . true . ! ier = just_fine ; nrec = 0 ! body : do ! !  Is it permissible to call INTERPOLATE? ! state = get_saved_state_r1 ( \"STEP_INTEGRATE\" , comm % save_states ) if ( state == fatal ) then ier = catastrophe ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** A catastrophic error has already been detected elsewhere.\" exit body end if if ( comm % use_range ) then if ( get_saved_state_r1 ( \"RANGE_INTEGRATE\" , comm % save_states ) /= usable ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** You have called INTERPOLATE after you specified to SETUP that you were\" ,& \" ** going to use RANGE_INTEGRATE. This is not permitted.\" exit body end if end if if ( state == not_ready ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** You have not called STEP_INTEGRATE, so you cannot use INTERPOLATE.\" exit body end if if ( state > just_fine ) then ier = fatal ; nrec = 2 ; write ( comm % rec , \"(a/a)\" ) & \" ** STEP_INTEGRATE has returned with a flag value greater than 1. You\" , & \" ** cannot call INTERPOLATE in this circumstance.\" exit body end if ! !  Check sizes of arrays ! if ( present ( y_want )) then if ( any ( shape ( y_want ) /= shape ( comm % y ))) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a,i6,a/a,i6,a/a)\" ) & \" ** The shape of the array Y_WANT is not consistent with the shape of the \" , & \" ** dependent variables.\" exit body end if end if if ( present ( yderiv_want )) then if ( any ( shape ( yderiv_want ) /= shape ( comm % y ))) then ier = fatal ; nrec = 3 ; write ( comm % rec , \"(a,i6,a/a,i6,a/a)\" ) & \" ** The shape of the array YDERIV_WANT is not consistent with the shape of\" , & \" ** the dependent variables.\" exit body end if end if ! !  Check METHOD is ok to interpolate with ! if ( comm % rk_method == 3 ) then ier = fatal ; nrec = 5 ; write ( comm % rec , \"(a/a/a/a/a)\" ) & \" ** You have been using STEP_INTEGRATE with METHOD = 'H' to integrate your\" ,& \" ** equations. You have just called INTERPOLATE, but interpolation is not\" ,& \" ** available for this METHOD. Either use METHOD = 'M', for which\" ,& \" ** interpolation is available, or use RESET_T_END to make STEP_INTEGRATE\" ,& \" ** step exactly to the points where you want output.\" exit body end if ! !  Get some workspace - !     can overwrite STAGES in METHOD 'L' since they're not requird for the !     interpolant ! select case ( comm % rk_method ) case ( 1 ) if (. not . associated ( comm % p )) comm % p => comm % stages (:, 1 : 2 ) npcls = 2 if (. not . associated ( comm % ytemp )) comm % p => comm % stages (:, 1 : 3 ) case ( 2 ) jer = 0 if (. not . associated ( comm % xstage )) then allocate ( comm % xstage ( size ( comm % y , 1 )), stat = jer ) !alloc! end if if (. not . associated ( comm % ytemp )) then allocate ( comm % ytemp ( size ( comm % y , 1 )), stat = jer ) !alloc! end if if (. not . associated ( comm % p )) then allocate ( comm % p ( size ( comm % y , 1 ), 5 ), stat = jer ) !alloc! end if npcls = 5 if ( jer /= 0 ) then ier = fatal ; nrec = 1 ; write ( comm % rec , \"(a)\" ) & \" ** Not enough storage available to create workspace required internally.\" exit body end if end select ! !  Check data to see if interpolant has already been calculated for this !  step ! intrp_initialised = get_saved_state_r1 ( srname , comm % save_states ) /= usable ! !  Some initialization must be done before interpolation is possible. ! if (. not . intrp_initialised ) call form_intrp ( f , comm % p ) ! !  The actual evaluation of the interpolating polynomial and/or its first !  derivative is done in EVALUATE_INTRP. ! call evaluate_intrp ( comm % p , y_want , yderiv_want ) exit body ! end do body ! call rkmsg_r1 ( ier , srname , nrec , comm ) ! contains ! subroutine form_intrp ( f , p ) ! real ( kind = wp ), intent ( out ), dimension (:,:) :: p !dep! ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! real ( kind = wp ), dimension (:,:), pointer :: r !real! real ( kind = wp ), dimension (:,:), pointer :: stages !dep! real ( kind = wp ), dimension (:), pointer :: y , yp , y_old , yp_old !dep! real ( kind = wp ), dimension (:), pointer :: xstage !dep! ! stages => comm % stages r => comm % r y => comm % y yp => comm % yp y_old => comm % y_old yp_old => comm % yp_old xstage => comm % xstage ! select case ( comm % rk_method ) case ( 1 ) ! !  METHOD = 'L'.  Use the cubic Hermite interpolant that is fully !  specified by the values and slopes at the two ends of the step. ! p (:, 2 ) = y - y_old p (:, 1 ) = comm % h_old * yp - p (:, 2 ) p (:, 2 ) = p (:, 1 ) - ( p (:, 2 ) - comm % h_old * yp_old ) p (:, 1 ) = p (:, 1 ) + p (:, 2 ) ! case ( 2 ) ! !  METHOD = 'M'. ! if (. not . intrp_initialised ) call extra_stages ( f , comm % ytemp , comm % xstage ) ! !  Form the coefficients of the interpolating polynomial in its shifted !  and scaled form.  The transformation from the form in which the !  polynomial is derived can be somewhat ill-conditioned.  The terms !  are grouped so as to minimize the errors of the transformation. ! !  Coefficient of SIGMA**6 p (:, 5 ) = r ( 5 , 6 ) * stages (:, 4 ) + & (( r ( 10 , 6 ) * xstage + r ( 8 , 6 ) * yp ) + & ( r ( 7 , 6 ) * stages (:, 6 ) + r ( 6 , 6 ) * stages (:, 5 ))) + & (( r ( 4 , 6 ) * stages (:, 3 ) + r ( 9 , 6 ) * stages (:, 7 )) + & ( r ( 3 , 6 ) * stages (:, 2 ) + r ( 11 , 6 ) * stages (:, 1 )) + & r ( 1 , 6 ) * yp_old ) ! !  Coefficient of SIGMA**5 p (:, 4 ) = ( r ( 10 , 5 ) * xstage + r ( 9 , 5 ) * stages (:, 7 )) + & (( r ( 7 , 5 ) * stages (:, 6 ) + r ( 6 , 5 ) * stages (:, 5 )) + & r ( 5 , 5 ) * stages (:, 4 )) + (( r ( 4 , 5 ) * stages (:, 3 ) + & r ( 8 , 5 ) * yp ) + ( r ( 3 , 5 ) * stages (:, 2 ) + r ( 11 , 5 ) * & stages (:, 1 )) + r ( 1 , 5 ) * yp_old ) ! !  Coefficient of SIGMA**4 p (:, 3 ) = (( r ( 4 , 4 ) * stages (:, 3 ) + r ( 8 , 4 ) * yp ) + & ( r ( 7 , 4 ) * stages (:, 6 ) + r ( 6 , 4 ) * stages (:, 5 )) + & r ( 5 , 4 ) * stages (:, 4 )) + (( r ( 10 , 4 ) * xstage + & r ( 9 , 4 ) * stages (:, 7 )) + ( r ( 3 , 4 ) * stages (:, 2 ) + & r ( 11 , 4 ) * stages (:, 1 )) + r ( 1 , 4 ) * yp_old ) ! !  Coefficient of SIGMA**3 p (:, 2 ) = r ( 5 , 3 ) * stages (:, 4 ) + r ( 6 , 3 ) * stages (:, 5 ) + & (( r ( 3 , 3 ) * stages (:, 2 ) + r ( 9 , 3 ) * stages (:, 7 )) + & ( r ( 10 , 3 ) * xstage + r ( 8 , 3 ) * yp ) + r ( 1 , 3 ) * & yp_old ) + (( r ( 4 , 3 ) * stages (:, 3 ) + r ( 11 , 3 ) * & stages (:, 1 )) + r ( 7 , 3 ) * stages (:, 6 )) ! !  Coefficient of SIGMA**2 p (:, 1 ) = r ( 5 , 2 ) * stages (:, 4 ) + (( r ( 6 , 2 ) * stages (:, 5 ) + & r ( 8 , 2 ) * yp ) + r ( 1 , 2 ) * yp_old ) + & (( r ( 3 , 2 ) * stages (:, 2 ) + r ( 9 , 2 ) * stages (:, 7 )) + & r ( 10 , 2 ) * xstage ) + (( r ( 4 , 2 ) * stages (:, 3 ) + & r ( 11 , 2 ) * stages (:, 1 )) + r ( 7 , 2 ) * stages (:, 6 )) ! !  Scale all the coefficients by the step size. p (:,:) = comm % h_old * p (:,:) ! end select ! end subroutine form_intrp subroutine evaluate_intrp ( p , y_want , yderiv_want ) ! real ( kind = wp ), dimension (:), optional , intent ( out ) :: y_want !dep! real ( kind = wp ), dimension (:), optional , intent ( out ) :: yderiv_want !dep! real ( kind = wp ), dimension (:,:), intent ( in ) :: p !dep! ! real :: sigma integer :: i ! sigma = ( t_want - comm % t ) / comm % h_old ! if ( present ( y_want )) then y_want = p (:, comm % intrp_degree - 1 ) * sigma do i = comm % intrp_degree - 2 , 1 , - 1 y_want = ( y_want + p (:, i )) * sigma end do y_want = ( y_want + comm % h_old * comm % yp ) * sigma + comm % y end if ! if ( present ( yderiv_want )) then yderiv_want = comm % intrp_degree * p (:, comm % intrp_degree - 1 ) * sigma do i = comm % intrp_degree - 1 , 2 , - 1 yderiv_want = ( yderiv_want + i * p (:, i - 1 )) * sigma end do yderiv_want = ( yderiv_want + comm % h_old * comm % yp ) / comm % h_old end if ! end subroutine evaluate_intrp subroutine extra_stages ( f , ytemp , xstage ) ! real ( kind = wp ), dimension (:), intent ( out ) :: ytemp , xstage !dep! ! interface function f ( t , y ) use rksuite_90_prec , only : wp real ( kind = wp ), intent ( in ) :: t !indep! real ( kind = wp ), dimension (:), intent ( in ) :: y !dep! real ( kind = wp ), dimension ( size ( y , 1 )) :: f !dep! end function f end interface ! real ( kind = wp ), dimension (:,:), pointer :: stages !dep! real ( kind = wp ), dimension (:), pointer :: yp , y_old , yp_old !dep! ! real ( kind = wp ), dimension (:,:), pointer :: a !real! real ( kind = wp ), dimension (:), pointer :: c !real! real ( kind = wp ), pointer :: h_old , t_old !indep! ! integer :: i , j ! a => comm % a stages => comm % stages c => comm % c yp => comm % yp y_old => comm % y_old yp_old => comm % yp_old h_old => comm % h_old t_old => comm % t_old ! !  Compute the extra stages needed for interpolation using the facts that !       1. Stage 1 is YP_OLD. !       2. Stage i (i>1) is stored in STAGES(...,i-1). !       3. This pair is FSAL, i.e. STAGES(...,7)=YP, which frees !          up STAGES(...,7) for use by stage 9. !       4. XSTAGE is used for stage 10. !       5. The coefficient of stage 2 in the interpolant is always 0, so !          STAGES(...,1) is used for stage 11. ! do i = 9 , 11 do j = 1 , i - 1 select case ( j ) case ( 1 ); ytemp = a ( i , 1 ) * yp_old ! could have used matmul here but that prevents increasing rank of dep-var case ( 2 : 7 ); ytemp = ytemp + a ( i , j ) * stages (:, j - 1 ) case ( 8 ); ytemp = ytemp + a ( i , j ) * yp case ( 9 ); ytemp = ytemp + a ( i , j ) * stages (:, 7 ) case ( 10 ); ytemp = ytemp + a ( i , j ) * xstage end select end do ytemp = y_old + h_old * ytemp select case ( i ) case ( 9 ) stages (:, 7 ) = f ( t_old + c ( i ) * h_old , ytemp ) case ( 10 ) xstage = f ( t_old + c ( i ) * h_old , ytemp ) case ( 11 ) stages (:, 1 ) = f ( t_old + c ( i ) * h_old , ytemp ) end select comm % f_count = comm % f_count + 1 end do ! end subroutine extra_stages end subroutine interpolate_r1"},{"title":"rkmsg_r1 – ISOFT","tags":"","loc":"proc/rkmsg_r1.html","text":"private subroutine rkmsg_r1(ier, srname, nrec, comm, flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ier character(len=*), intent(in) :: srname integer, intent(in) :: nrec type( rk_comm_real_1d ), intent(inout) :: comm integer, intent(out), optional :: flag Calls proc~~rkmsg_r1~~CallsGraph proc~rkmsg_r1 rkmsg_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rkmsg_r1~~CalledByGraph proc~rkmsg_r1 rkmsg_r1 proc~step_integrate_r1 step_integrate_r1 proc~step_integrate_r1->proc~rkmsg_r1 proc~interpolate_r1 interpolate_r1 proc~interpolate_r1->proc~rkmsg_r1 proc~global_error_r1 global_error_r1 proc~global_error_r1->proc~rkmsg_r1 proc~setup_r1 setup_r1 proc~setup_r1->proc~rkmsg_r1 proc~reset_t_end_r1 reset_t_end_r1 proc~reset_t_end_r1->proc~rkmsg_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->proc~rkmsg_r1 interface~reset_t_end reset_t_end proc~range_integrate_r1->interface~reset_t_end interface~interpolate interpolate proc~range_integrate_r1->interface~interpolate interface~step_integrate step_integrate proc~range_integrate_r1->interface~step_integrate proc~statistics_r1 statistics_r1 proc~statistics_r1->proc~rkmsg_r1 interface~reset_t_end->proc~reset_t_end_r1 interface~interpolate->proc~interpolate_r1 interface~step_integrate->proc~step_integrate_r1 interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 interface~global_error global_error interface~global_error->proc~global_error_r1 interface~statistics statistics interface~statistics->proc~statistics_r1 interface~setup setup interface~setup->proc~setup_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate proc~upstream_calculate->interface~setup var panprocrkmsg_r1CalledByGraph = svgPanZoom('#procrkmsg_r1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code rkmsg_r1 Source Code subroutine rkmsg_r1 ( ier , srname , nrec , comm , flag ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! integer , intent ( in ) :: ier , nrec integer , intent ( out ), optional :: flag character ( len =* ), intent ( in ) :: srname type ( rk_comm_real_1d ), intent ( inout ) :: comm ! logical :: ok , on , range_call ! integer , parameter :: fatal = 911 , catastrophe = 912 , just_fine = 1 logical , parameter :: tell = . false . ! !  Check where the call came from - if it is an indirect call from !  RANGE_INTEGRATE the run is not STOPped. ! range_call = ( srname == \"RESET_T_END\" . or . srname == \"STEP_INTEGRATE\" . or . & srname == \"INTERPOLATE\" ) . and . comm % use_range ! !  Check if can continue with integrator. ! ok = ( srname == \"STEP_INTEGRATE\" . or . srname == \"RANGE_INTEGRATE\" ) . and . & ( ier == 2 . or . ier == 3 . or . ier == 4 ) ! !  Check if program termination has been overridden. ! on = get_stop_on_fatal_r1 ( comm ) ! if (( comm % print_message . and . ier > just_fine ) . or . ier >= fatal ) then write ( comm % outch , \"(/a)\" ) \" **\" write ( comm % outch , \"(a)\" ) comm % rec ( 1 : nrec ) if ( ier >= fatal ) then write ( comm % outch , \"(a/a,a,a/a/)\" ) & \" **\" ,& \" ** Catastrophic error detected in \" , srname , \".\" ,& \" **\" if ((. not . range_call . and . on . and . ier == fatal ) . or . ier == catastrophe ) then write ( comm % outch , \"(a/a/a)\" ) & \" **\" ,& \" ** Execution of your program is being terminated.\" ,& \" **\" stop end if else if ( ok ) then write ( comm % outch , \"(a/a,a,a,i2,a/a/a)\" ) & \" **\" , & \" ** Warning from routine \" , srname , \" with flag set \" , ier , \".\" ,& \" ** You can continue integrating this problem.\" ,& \" **\" else write ( comm % outch , \"(a/a,a,a,i2,a/a/a)\" ) & \" **\" , & \" ** Warning from routine \" , srname , \" with flag set \" , ier , \".\" , & \" ** You cannot continue integrating this problem.\" , & \" **\" end if if (. not . present ( flag )) then write ( comm % outch , \"(a/a/a)\" ) & \" **\" ,& \" ** Execution of your program is being terminated.\" ,& \" **\" stop end if end if end if ! if ( present ( flag )) flag = ier comm % rec ( nrec + 1 : 10 ) = \" \" ! !  Save the status of the routine associated with SRNAME ! call set_saved_state_r1 ( srname , ier , comm ) ! !  Indicate that a catastrophic error has been detected ! !call set_saved_fatal_r1(comm,ier >= catastrophe) ! end subroutine rkmsg_r1"},{"title":"set_saved_state_r1 – ISOFT","tags":"","loc":"proc/set_saved_state_r1.html","text":"private subroutine set_saved_state_r1(srname, state, comm) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: srname integer, intent(in) :: state type( rk_comm_real_1d ), intent(inout) :: comm Called by proc~~set_saved_state_r1~~CalledByGraph proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1 rkmsg_r1 proc~rkmsg_r1->proc~set_saved_state_r1 proc~step_integrate_r1 step_integrate_r1 proc~step_integrate_r1->proc~set_saved_state_r1 proc~step_integrate_r1->proc~rkmsg_r1 proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->proc~set_saved_state_r1 proc~range_integrate_r1->proc~rkmsg_r1 interface~step_integrate step_integrate proc~range_integrate_r1->interface~step_integrate interface~reset_t_end reset_t_end proc~range_integrate_r1->interface~reset_t_end interface~interpolate interpolate proc~range_integrate_r1->interface~interpolate proc~interpolate_r1 interpolate_r1 proc~interpolate_r1->proc~rkmsg_r1 interface~step_integrate->proc~step_integrate_r1 interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~setup_r1 setup_r1 proc~setup_r1->proc~rkmsg_r1 proc~reset_t_end_r1 reset_t_end_r1 proc~reset_t_end_r1->proc~rkmsg_r1 proc~global_error_r1 global_error_r1 proc~global_error_r1->proc~rkmsg_r1 proc~statistics_r1 statistics_r1 proc~statistics_r1->proc~rkmsg_r1 interface~reset_t_end->proc~reset_t_end_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate interface~setup setup proc~upstream_calculate->interface~setup interface~interpolate->proc~interpolate_r1 interface~global_error global_error interface~global_error->proc~global_error_r1 interface~statistics statistics interface~statistics->proc~statistics_r1 interface~setup->proc~setup_r1 var panprocset_saved_state_r1CalledByGraph = svgPanZoom('#procset_saved_state_r1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code set_saved_state_r1 Source Code subroutine set_saved_state_r1 ( srname , state , comm ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! integer , intent ( in ) :: state type ( rk_comm_real_1d ), intent ( inout ) :: comm character ( len =* ), intent ( in ) :: srname ! integer :: name ! integer , parameter :: fatal = 911 ! select case ( srname ) case ( \"SETUP\" ); name = 1 case ( \"RANGE_INTEGRATE\" ); name = 2 case ( \"STATISTICS\" ); name = 3 case ( \"GLOBAL_ERROR\" ); name = 4 case ( \"STEP_INTEGRATE\" ); name = 5 case ( \"INTERPOLATE\" ); name = 6 case ( \"RESET_T_END\" ); name = 7 case default ; name = 0 end select ! comm % save_states ( name ) = state comm % saved_fatal_err = state >= fatal ! end subroutine set_saved_state_r1"},{"title":"set_stop_on_fatal_r1 – ISOFT","tags":"","loc":"proc/set_stop_on_fatal_r1.html","text":"private subroutine set_stop_on_fatal_r1(comm, action) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm logical, intent(in) :: action Called by proc~~set_stop_on_fatal_r1~~CalledByGraph proc~set_stop_on_fatal_r1 set_stop_on_fatal_r1 interface~set_stop_on_fatal set_stop_on_fatal interface~set_stop_on_fatal->proc~set_stop_on_fatal_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code set_stop_on_fatal_r1 Source Code subroutine set_stop_on_fatal_r1 ( comm , action ) ! ! Part of rksuite_90 v1.0 (Aug 1994) !         software for initial value problems in ODEs ! ! Authors: R.W. Brankin (NAG Ltd., Oxford, England) !          I. Gladwell  (Math Dept., SMU, Dallas, TX, USA) !          see main doc for contact details ! type ( rk_comm_real_1d ), intent ( inout ) :: comm logical , intent ( in ) :: action ! comm % stop_on_fatal = action ! end subroutine set_stop_on_fatal_r1"},{"title":"setup – ISOFT","tags":"","loc":"interface/setup.html","text":"public interface setup Calls interface~~setup~~CallsGraph interface~setup setup proc~setup_r1 setup_r1 interface~setup->proc~setup_r1 proc~rkmsg_r1 rkmsg_r1 proc~setup_r1->proc~rkmsg_r1 proc~machine_const machine_const proc~setup_r1->proc~machine_const proc~method_const method_const proc~setup_r1->proc~method_const proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~setup~~CalledByGraph interface~setup setup proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures setup_r1 Module Procedures private subroutine setup_r1 (comm, t_start, y_start, t_end, tolerance, thresholds, method, task, error_assess, h_start, message) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ) :: comm real(kind=wp), intent(in) :: t_start real(kind=wp), intent(in), dimension(:) :: y_start real(kind=wp), intent(in) :: t_end real(kind=wp), intent(in) :: tolerance real(kind=wp), intent(in), dimension(:) :: thresholds character(len=*), intent(in), optional :: method character(len=*), intent(in), optional :: task logical, intent(in), optional :: error_assess real(kind=wp), intent(in), optional :: h_start logical, intent(in), optional :: message"},{"title":"range_integrate – ISOFT","tags":"","loc":"interface/range_integrate.html","text":"public interface range_integrate Calls interface~~range_integrate~~CallsGraph interface~range_integrate range_integrate proc~range_integrate_r1 range_integrate_r1 interface~range_integrate->proc~range_integrate_r1 interface~reset_t_end reset_t_end proc~range_integrate_r1->interface~reset_t_end interface~interpolate interpolate proc~range_integrate_r1->interface~interpolate interface~step_integrate step_integrate proc~range_integrate_r1->interface~step_integrate proc~set_saved_state_r1 set_saved_state_r1 proc~range_integrate_r1->proc~set_saved_state_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~range_integrate_r1->proc~get_saved_state_r1 proc~rkmsg_r1 rkmsg_r1 proc~range_integrate_r1->proc~rkmsg_r1 proc~get_saved_fatal_r1 get_saved_fatal_r1 proc~range_integrate_r1->proc~get_saved_fatal_r1 proc~reset_t_end_r1 reset_t_end_r1 interface~reset_t_end->proc~reset_t_end_r1 proc~interpolate_r1 interpolate_r1 interface~interpolate->proc~interpolate_r1 proc~step_integrate_r1 step_integrate_r1 interface~step_integrate->proc~step_integrate_r1 proc~rkmsg_r1->proc~set_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~step_integrate_r1->proc~set_saved_state_r1 proc~step_integrate_r1->proc~get_saved_state_r1 proc~step_integrate_r1->proc~rkmsg_r1 proc~stiff_r1 stiff_r1 proc~step_integrate_r1->proc~stiff_r1 proc~step_r1 step_r1 proc~step_integrate_r1->proc~step_r1 proc~truerr_r1 truerr_r1 proc~step_integrate_r1->proc~truerr_r1 proc~interpolate_r1->proc~get_saved_state_r1 proc~interpolate_r1->proc~rkmsg_r1 proc~reset_t_end_r1->proc~get_saved_state_r1 proc~reset_t_end_r1->proc~rkmsg_r1 proc~truerr_r1->proc~step_r1 var paninterfacerange_integrateCallsGraph = svgPanZoom('#interfacerange_integrateCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~range_integrate~~CalledByGraph interface~range_integrate range_integrate proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures range_integrate_r1 Module Procedures private recursive subroutine range_integrate_r1 (comm, f, t_want, t_got, y_got, yderiv_got, flag) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(in) :: t_want real(kind=wp), intent(out) :: t_got real(kind=wp), intent(out), dimension(:) :: y_got real(kind=wp), intent(out), dimension(:) :: yderiv_got integer, intent(out), optional :: flag"},{"title":"step_integrate – ISOFT","tags":"","loc":"interface/step_integrate.html","text":"public interface step_integrate Calls interface~~step_integrate~~CallsGraph interface~step_integrate step_integrate proc~step_integrate_r1 step_integrate_r1 interface~step_integrate->proc~step_integrate_r1 proc~truerr_r1 truerr_r1 proc~step_integrate_r1->proc~truerr_r1 proc~stiff_r1 stiff_r1 proc~step_integrate_r1->proc~stiff_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~step_integrate_r1->proc~set_saved_state_r1 proc~step_r1 step_r1 proc~step_integrate_r1->proc~step_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~step_integrate_r1->proc~get_saved_state_r1 proc~rkmsg_r1 rkmsg_r1 proc~step_integrate_r1->proc~rkmsg_r1 proc~truerr_r1->proc~step_r1 proc~rkmsg_r1->proc~set_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~step_integrate~~CalledByGraph interface~step_integrate step_integrate proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->interface~step_integrate interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures step_integrate_r1 Module Procedures private recursive subroutine step_integrate_r1 (comm, f, t_now, y_now, yderiv_now, flag) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(out) :: t_now real(kind=wp), intent(out), dimension(:) :: y_now real(kind=wp), intent(out), dimension(:) :: yderiv_now integer, intent(out), optional :: flag"},{"title":"statistics – ISOFT","tags":"","loc":"interface/statistics.html","text":"public interface statistics Calls interface~~statistics~~CallsGraph interface~statistics statistics proc~statistics_r1 statistics_r1 interface~statistics->proc~statistics_r1 proc~rkmsg_r1 rkmsg_r1 proc~statistics_r1->proc~rkmsg_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~statistics_r1->proc~get_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures statistics_r1 Module Procedures private subroutine statistics_r1 (comm, total_f_calls, step_cost, waste, num_succ_steps, h_next, y_maxvals) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm integer, intent(out), optional :: total_f_calls integer, intent(out), optional :: step_cost real(kind=wp), intent(out), optional :: waste integer, intent(out), optional :: num_succ_steps real(kind=wp), intent(out), optional :: h_next real(kind=wp), intent(out), optional dimension(:) :: y_maxvals"},{"title":"global_error – ISOFT","tags":"","loc":"interface/global_error.html","text":"public interface global_error Calls interface~~global_error~~CallsGraph interface~global_error global_error proc~global_error_r1 global_error_r1 interface~global_error->proc~global_error_r1 proc~rkmsg_r1 rkmsg_r1 proc~global_error_r1->proc~rkmsg_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~global_error_r1->proc~get_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures global_error_r1 Module Procedures private subroutine global_error_r1 (comm, rms_error, max_error, t_max_error) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm real(kind=wp), intent(out), optional dimension(:) :: rms_error real(kind=wp), intent(out), optional :: max_error real(kind=wp), intent(out), optional :: t_max_error"},{"title":"reset_t_end – ISOFT","tags":"","loc":"interface/reset_t_end.html","text":"public interface reset_t_end Calls interface~~reset_t_end~~CallsGraph interface~reset_t_end reset_t_end proc~reset_t_end_r1 reset_t_end_r1 interface~reset_t_end->proc~reset_t_end_r1 proc~rkmsg_r1 rkmsg_r1 proc~reset_t_end_r1->proc~rkmsg_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~reset_t_end_r1->proc~get_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~reset_t_end~~CalledByGraph interface~reset_t_end reset_t_end proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->interface~reset_t_end interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures reset_t_end_r1 Module Procedures private subroutine reset_t_end_r1 (comm, t_end_new) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm real(kind=wp), intent(in) :: t_end_new"},{"title":"interpolate – ISOFT","tags":"","loc":"interface/interpolate.html","text":"public interface interpolate Calls interface~~interpolate~~CallsGraph interface~interpolate interpolate proc~interpolate_r1 interpolate_r1 interface~interpolate->proc~interpolate_r1 proc~rkmsg_r1 rkmsg_r1 proc~interpolate_r1->proc~rkmsg_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~interpolate_r1->proc~get_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~set_saved_state_r1 set_saved_state_r1 proc~rkmsg_r1->proc~set_saved_state_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~interpolate~~CalledByGraph interface~interpolate interpolate proc~range_integrate_r1 range_integrate_r1 proc~range_integrate_r1->interface~interpolate interface~range_integrate range_integrate interface~range_integrate->proc~range_integrate_r1 proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~range_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures interpolate_r1 Module Procedures private subroutine interpolate_r1 (comm, f, t_want, y_want, yderiv_want) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout), target :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(in) :: t_want real(kind=wp), intent(out), optional dimension(:) :: y_want real(kind=wp), intent(out), optional dimension(:) :: yderiv_want"},{"title":"set_stop_on_fatal – ISOFT","tags":"","loc":"interface/set_stop_on_fatal.html","text":"public interface set_stop_on_fatal Calls interface~~set_stop_on_fatal~~CallsGraph interface~set_stop_on_fatal set_stop_on_fatal proc~set_stop_on_fatal_r1 set_stop_on_fatal_r1 interface~set_stop_on_fatal->proc~set_stop_on_fatal_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures set_stop_on_fatal_r1 Module Procedures private subroutine set_stop_on_fatal_r1 (comm, action) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm logical, intent(in) :: action"},{"title":"get_saved_fatal – ISOFT","tags":"","loc":"interface/get_saved_fatal.html","text":"public interface get_saved_fatal Calls interface~~get_saved_fatal~~CallsGraph interface~get_saved_fatal get_saved_fatal proc~get_saved_fatal_r1 get_saved_fatal_r1 interface~get_saved_fatal->proc~get_saved_fatal_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures get_saved_fatal_r1 Module Procedures private function get_saved_fatal_r1 (comm) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(in) :: comm Return Value logical"},{"title":"collect_garbage – ISOFT","tags":"","loc":"interface/collect_garbage.html","text":"public interface collect_garbage Calls interface~~collect_garbage~~CallsGraph interface~collect_garbage collect_garbage proc~collect_garbage_r1 collect_garbage_r1 interface~collect_garbage->proc~collect_garbage_r1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~collect_garbage~~CalledByGraph interface~collect_garbage collect_garbage proc~upstream_calculate upstream_calculate proc~upstream_calculate->interface~collect_garbage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures collect_garbage_r1 Module Procedures private subroutine collect_garbage_r1 (comm) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ) :: comm"},{"title":"glacier_integrate – ISOFT","tags":"","loc":"proc/glacier_integrate.html","text":"private subroutine glacier_integrate(this, old_states, basal_melt, basal_drag, water_density, time, success) Integrates the glacier's state to time . This is done using the\n NITSOL package of iterative Krylov solvers. If a different\n algorithm for the integration is desired, then this method may\n be overridden in the concrete implementations of the glacier\n type. $    if (flag == 6 .and. input(9) > -1) then\n$      input(9) = -1\n$      call logger%trivia('glacier%integrate','Backtracking failed in NITSOL '// &\n$                         'at simulation time '//str(time)//'. Trying again '//  &\n$                         'without backtracking.')\n$      call nitsol(nval, state, nitsol_residual, nitsol_precondition, &\n$                  1.e-7_r8, 1.e-7_r8, input, info, work, real_param, &\n$                  int_param, flag, ddot, dnrm2)\n$    end if Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. class(scalar_field), intent(in) :: basal_melt The melt rate that the bottom of the glacier experiences\n during this time step. class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise Calls proc~~glacier_integrate~~CallsGraph proc~glacier_integrate glacier_integrate interface~nitsol nitsol proc~glacier_integrate->interface~nitsol str str proc~glacier_integrate->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code glacier_integrate Source Code subroutine glacier_integrate ( this , old_states , basal_melt , basal_drag , & water_density , time , success ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Integrates the glacier's state to `time`. This is done using the ! NITSOL package of iterative Krylov solvers. If a different ! algorithm for the integration is desired, then this method may ! be overridden in the concrete implementations of the glacier ! type. ! class ( glacier ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: old_states !! Previous states of the glacier, with the most recent one !! first. class ( scalar_field ), intent ( in ) :: basal_melt !! The melt rate that the bottom of the glacier experiences !! during this time step. class ( scalar_field ), intent ( in ) :: basal_drag !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier. real ( r8 ), intent ( in ) :: time !! The time to which the glacier should be integrated logical , intent ( out ) :: success !! True if the integration is successful, false otherwise logical :: first_call integer , save :: nval , kdmax = 20 real ( r8 ), dimension (:), allocatable :: state integer , dimension ( 10 ) :: input integer , dimension ( 6 ) :: info real ( r8 ), dimension (:), allocatable , save :: work real ( r8 ), dimension ( 1 ) :: real_param integer , dimension ( 1 ) :: int_param integer :: flag call basal_melt % guard_temp (); call basal_drag % guard_temp () first_call = . true . nval = this % data_size () if ( allocated ( work )) then if ( size ( work ) < nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 )) then deallocate ( work ) allocate ( work ( nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 ))) end if else allocate ( work ( nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 ))) end if state = this % state_vector () call this % set_time ( time ) input = 0 input ( 4 ) = kdmax input ( 5 ) = 1 input ( 9 ) = - 1 input ( 10 ) = 3 etafixed = 0.3_r8 #ifdef DEBUG call logger % debug ( 'glacier%integrate' , 'Calling NITSOL (nonlinear solver)' ) #endif call nitsol ( nval , state , nitsol_residual , nitsol_precondition , & 1.e-10_r8 * nval , 1.e-10_r8 * nval , input , info , work , & real_param , int_param , flag , ddot , dnrm2 ) call this % update ( state ) !!$    if (flag == 6 .and. input(9) > -1) then !!$      input(9) = -1 !!$      call logger%trivia('glacier%integrate','Backtracking failed in NITSOL '// & !!$                         'at simulation time '//str(time)//'. Trying again '//  & !!$                         'without backtracking.') !!$      call nitsol(nval, state, nitsol_residual, nitsol_precondition, & !!$                  1.e-7_r8, 1.e-7_r8, input, info, work, real_param, & !!$                  int_param, flag, ddot, dnrm2) !!$    end if #ifdef DEBUG call logger % debug ( 'glacier%integrate' , 'NITSOL required ' // & trim ( str ( info ( 5 ))) // ' nonlinear iterations ' // & 'and ' // trim ( str ( info ( 1 ))) // ' function calls.' ) #endif select case ( flag ) case ( 0 ) call logger % trivia ( 'glacier%integrate' , 'Integrated glacier to time ' // & trim ( str ( time ))) success = . true . case ( 1 ) call logger % error ( 'glacier%integrate' , 'Reached maximum number of' // & ' iterations integrating glacier' ) success = . false . !case(5) !  call logger%debug('glacier%integrate','Solution diverging. Trying '// & !                    'again with backtracking.') !  state = old_states(1)%state_vector() !  input(9) = 0 !  call nitsol(nval, state, nitsol_residual, nitsol_precondition, & !              1.e-7_r8, 1.e-7_r8, input, info, work, real_param, & !              int_param, flag, ddot, dnrm2) !  call this%update(state) !  if (flag == 0) then !    call logger%trivia('glacier%integrate','Integrated glacier to time '// & !                       trim(str(time))) !    success = .true. !  else !    call logger%error('glacier%integrate','NITSOL failed when integrating'// & !                      ' glacier with error code '//trim(str(flag))) !    success = .false. !  end if case default call logger % error ( 'glacier%integrate' , 'NITSOL failed when integrating' // & ' glacier with error code ' // trim ( str ( flag ))) success = . false . end select if ( success ) then call this % integrate_layers ( old_states , time , success ) end if call basal_melt % clean_temp (); call basal_drag % clean_temp () contains subroutine nitsol_residual ( n , xcur , fcur , rpar , ipar , itrmf ) !! A routine matching the interface expected by NITSOL which !! returns the residual for the glacier. integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( out ) :: fcur !! Array of length `n` containing f(xcur) on output real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array integer , intent ( out ) :: itrmf !! Termination flag. 0 means normal termination, 1 means !! failure to produce f(xcur) logical :: success ! If this is the first call of this routine then the ! basal_surface object will already be in the same state as ! reflected in xcur if ( first_call ) then first_call = . false . else call this % update ( xcur ( 1 : n )) end if call this % solve_velocity ( basal_drag , success ) if (. not . success ) then itrmf = 1 return end if fcur ( 1 : n ) = this % residual ( old_states , basal_melt , basal_drag , water_density ) !print*, fcur(1:n) itrmf = 0 end subroutine nitsol_residual subroutine nitsol_precondition ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! A subroutine matching the interface expected by NITSOL, which !! acts as a preconditioner. integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of lenght `n` containing the current $x$ value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of lenght `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flat indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce $J\\vec{v}$, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} if ( ijob /= 1 ) then itrmjv = 0 return end if z ( 1 : n ) = this % precondition ( old_states , basal_melt , basal_drag , & water_density , v ( 1 : n )) itrmjv = 0 end subroutine nitsol_precondition end subroutine glacier_integrate"},{"title":"glacier_integrate_layers – ISOFT","tags":"","loc":"proc/glacier_integrate_layers.html","text":"private subroutine glacier_integrate_layers(this, old_states, time, success) Dummy routine which does nothing. Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise Contents Source Code glacier_integrate_layers Source Code subroutine glacier_integrate_layers ( this , old_states , time , success ) !* Author: Chris MacMackin !  Date: September 2018 ! ! Dummy routine which does nothing. ! class ( glacier ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: old_states !! Previous states of the glacier, with the most recent one !! first. real ( r8 ), intent ( in ) :: time !! The time to which the glacier should be integrated logical , intent ( out ) :: success !! True if the integration is successful, false otherwise continue end subroutine glacier_integrate_layers"},{"title":"alpha_du – ISOFT","tags":"","loc":"interface/alpha_du.html","text":"interface public function alpha_du(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{DU} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)dy for the given shelf\n slope."},{"title":"alpha_du2 – ISOFT","tags":"","loc":"interface/alpha_du2.html","text":"interface public function alpha_du2(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{DU&#94;2} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)&#94;2dy for the given shelf\n slope."},{"title":"alpha_d2 – ISOFT","tags":"","loc":"interface/alpha_d2.html","text":"interface public function alpha_d2(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{D&#94;2} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)&#94;2dy for the given shelf\n slope."},{"title":"alpha_dv – ISOFT","tags":"","loc":"interface/alpha_dv.html","text":"interface public function alpha_dv(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{DV} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_V(y)dy for the given shelf\n slope."},{"title":"alpha_duv – ISOFT","tags":"","loc":"interface/alpha_duv.html","text":"interface public function alpha_duv(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{DUV} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)f_V(y)dy for the given shelf\n slope."},{"title":"alpha_uvecu – ISOFT","tags":"","loc":"interface/alpha_uvecu.html","text":"interface public function alpha_uvecu(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{|\\vec{U}|U} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_{|\\vec{U}|}(y)f_U(y)dy for the given\n shelf slope."},{"title":"alpha_uvecv – ISOFT","tags":"","loc":"interface/alpha_uvecv.html","text":"interface public function alpha_uvecv(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{|\\vec{U}|V} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_{|\\vec{U}|}(y)f_V(y)dy for the given\n shelf slope."},{"title":"alpha_dus – ISOFT","tags":"","loc":"interface/alpha_dus.html","text":"interface public function alpha_dus(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{DUS} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)f_S(y)dy for the given shelf\n slope."},{"title":"alpha_dut – ISOFT","tags":"","loc":"interface/alpha_dut.html","text":"interface public function alpha_dut(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{DUT} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)f_T(y)dy for the given shelf\n slope."},{"title":"alpha_uvect – ISOFT","tags":"","loc":"interface/alpha_uvect.html","text":"interface public function alpha_uvect(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{|\\vec{U}|T} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_{|\\vec{U}|}(y)f_{T}(y)dy for the given shelf\n slope."},{"title":"alpha_ds – ISOFT","tags":"","loc":"interface/alpha_ds.html","text":"interface public function alpha_ds(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{DS} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_S(y)dy for the given shelf\n slope."},{"title":"alpha_dt – ISOFT","tags":"","loc":"interface/alpha_dt.html","text":"interface public function alpha_dt(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\alpha_{DT} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_T(y)dy for the given shelf\n slope."},{"title":"alpha_ds_t – ISOFT","tags":"","loc":"interface/alpha_ds_t.html","text":"interface public function alpha_ds_t(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value real Description Interpolates the value of \\tilde{\\alpha}_{DS} = \\frac{1}{\\Delta\n y\\alpha_{D&#94;2}}\\int&#94;{y_2}_{y_1}f_D(y)&#94;2f_S(y)dy for the\n given shelf slope."},{"title":"alpha_dt_t – ISOFT","tags":"","loc":"interface/alpha_dt_t.html","text":"interface public function alpha_dt_t(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of \\tilde{\\alpha}_{DT} = \\frac{1}{\\Delta\n y\\alpha_{D&#94;2}}\\int&#94;{y_2}_{y_1}f_D(y)&#94;2f_T(y)dy for the\n given shelf slope."},{"title":"f_d – ISOFT","tags":"","loc":"interface/f_d.html","text":"interface public function f_d(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of $f_D(y_2)$ for the given shelf\n slope."},{"title":"f_u – ISOFT","tags":"","loc":"interface/f_u.html","text":"interface public function f_u(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of $f_U(y_2)$ for the given shelf\n slope."},{"title":"f_v – ISOFT","tags":"","loc":"interface/f_v.html","text":"interface public function f_v(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of $f_V(y_2)$ for the given shelf\n slope."},{"title":"f_s – ISOFT","tags":"","loc":"interface/f_s.html","text":"interface public function f_s(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of $f_S(y_2)$ for the given shelf\n slope."},{"title":"f_t – ISOFT","tags":"","loc":"interface/f_t.html","text":"interface public function f_t(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of $f_T(y_2)$ for the given shelf\n slope."},{"title":"f_u_p – ISOFT","tags":"","loc":"interface/f_u_p.html","text":"interface public function f_u_p(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of $f'_U(y_2)$ for the given shelf\n slope."},{"title":"f_v_p – ISOFT","tags":"","loc":"interface/f_v_p.html","text":"interface public function f_v_p(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of $f'_V(y_2)$ for the given shelf\n slope."},{"title":"f_s_p – ISOFT","tags":"","loc":"interface/f_s_p.html","text":"interface public function f_s_p(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of $f'_S(y_2)$ for the given shelf\n slope."},{"title":"f_t_p – ISOFT","tags":"","loc":"interface/f_t_p.html","text":"interface public function f_t_p(b_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer Description Interpolates the value of $f'_T(y_2)$ for the given shelf\n slope."},{"title":"splev – ISOFT","tags":"","loc":"interface/splev.html","text":"interface private subroutine splev(t, n, c, k, x, y, m, e, ier) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(*) :: t Array, length n, which contains the position of the knots. integer, intent(in) :: n Integer, giving the total number of knots of s(x). real(kind=r8), intent(in), dimension(*) :: c Array, length n, which contains the b-spline coefficients. integer, intent(in) :: k Integer, giving the degree of s(x). real(kind=r8), intent(in), dimension(*) :: x Array, length m, which contains the points where s(x) must\n be evaluated. real(kind=r8), intent(out), dimension(*) :: y Array, length m, giving the value of s(x) at the different\n points. integer, intent(in) :: m Integer, giving the number of points where s(x) must be\n evaluated. integer, intent(in) :: e integer, if 0 the spline is extrapolated from the end\n spans for points not in the support, if 1 the spline\n evaluates to zero for those points, if 2 ier is set to\n 1 and the subroutine returns, and if 3 the spline evaluates\n to the value of the nearest boundary point. integer, intent(out) :: ier Error flag: ier = 0: normal return ier = 1: argument out of bounds and e == 2 ier =10: invalid input data (see restrictions) Description Subroutine splev evaluates in a number of points x(i),i=1,2,...,m\n  a spline s(x) of degree k, given in its b-spline representation."},{"title":"asym_plume_melt – ISOFT","tags":"","loc":"proc/asym_plume_melt.html","text":"private function asym_plume_melt(this) result(melt) Computes and returns the melt rate at the bottom of the ice\n shelf due to interaction with the plume. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice shelf. Contents Source Code asym_plume_melt Source Code function asym_plume_melt ( this ) result ( melt ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the melt rate at the bottom of the ice ! shelf due to interaction with the plume. ! class ( asym_plume ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate at the base of the ice shelf. melt => this % melt_formulation % melt_rate () #ifdef DEBUG call logger % debug ( 'asym_plume%melt' , 'Returned melt rate.' ) #endif end function asym_plume_melt"},{"title":"asym_plume_drag_parameter – ISOFT","tags":"","loc":"proc/asym_plume_drag_parameter.html","text":"private function asym_plume_drag_parameter(this) result(drag) Computes and returns a quantity which may be necessary to determine\n the frictional drag the plume exerts on the bottom of the ice\n shelf. The plume would actually tend to exert no drag on the bottom\n of the ice shelf, but this method is present so that there is a\n consistent interface with the ground data type. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. Calls proc~~asym_plume_drag_parameter~~CallsGraph proc~asym_plume_drag_parameter asym_plume_drag_parameter uniform_scalar_field uniform_scalar_field proc~asym_plume_drag_parameter->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code asym_plume_drag_parameter Source Code function asym_plume_drag_parameter ( this ) result ( drag ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns a quantity which may be necessary to determine ! the frictional drag the plume exerts on the bottom of the ice ! shelf. The plume would actually tend to exert no drag on the bottom ! of the ice shelf, but this method is present so that there is a ! consistent interface with the [[ground(type)]] data type. ! class ( asym_plume ), intent ( in ) :: this class ( scalar_field ), pointer :: drag !! The melt rate at the base of the ice sheet. type ( uniform_scalar_field ) :: dummy call dummy % allocate_scalar_field ( drag ) drag = uniform_scalar_field ( 0.0_r8 ) call drag % set_temp () #ifdef DEBUG call logger % debug ( 'asym_plume%drag_parameter' , 'Returned plume drag parameter.' ) #endif end function asym_plume_drag_parameter"},{"title":"asym_plume_water_density – ISOFT","tags":"","loc":"proc/asym_plume_water_density.html","text":"private function asym_plume_water_density(this) result(density) Computes and returns the density of the plume water beneath the ice\n shelf. The density of this water would vary depending on how much \n saline ambient water has been entrained into the plume versus how\n much fresh water has been released due to melting. However, the\n Boussinesq approximation is used here and only a single reference \n density is returned. Note Based on my approach to non-dimensionalisation, I'm pretty\n sure the density should always be 1, making this method\n unneccessary. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value real(kind=r8) The density of the water at the base of the ice sheet. Contents Source Code asym_plume_water_density Source Code function asym_plume_water_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the density of the plume water beneath the ice ! shelf. The density of this water would vary depending on how much ! saline ambient water has been entrained into the plume versus how ! much fresh water has been released due to melting. However, the ! Boussinesq approximation is used here and only a single reference ! density is returned. ! ! @NOTE Based on my approach to non-dimensionalisation, I'm pretty ! sure the density should always be 1, making this method ! unneccessary. ! class ( asym_plume ), intent ( in ) :: this real ( r8 ) :: density !! The density of the water at the base of the ice sheet. density = 1.0_r8 #ifdef DEBUG call logger % debug ( 'asym_plume%water_density' , 'Plume has average density ' // & trim ( str ( density )) // '.' ) #endif end function asym_plume_water_density"},{"title":"asym_plume_data_size – ISOFT","tags":"","loc":"proc/asym_plume_data_size.html","text":"private function asym_plume_data_size(this) Returns the number of elements in the plume's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value integer The number of elements in the plume's state vector. Contents Source Code asym_plume_data_size Source Code function asym_plume_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the plume's state vector. ! This is the size of the vector returned by ! [[asym_plume(type):state_vector]] and taken as an argument by ! [[plume(type):update]]. ! class ( asym_plume ), intent ( in ) :: this integer :: asym_plume_data_size !! The number of elements in the plume's state vector. asym_plume_data_size = this % thickness % raw_size () + this % velocity % raw_size () + & this % velocity_dx % raw_size () + this % temperature % raw_size () + & this % temperature_dx % raw_size () + this % salinity % raw_size () + & this % salinity_dx % raw_size () #ifdef DEBUG call logger % debug ( 'asym_plume%data_size' , 'Plume shelf has ' // & trim ( str ( asym_plume_data_size )) // ' elements ' // & 'in its state vector.' ) #endif end function asym_plume_data_size"},{"title":"asym_plume_state_vector – ISOFT","tags":"","loc":"proc/asym_plume_state_vector.html","text":"private function asym_plume_state_vector(this) result(state_vector) Returns the state vector for the current state of the plume. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:),allocatable The state vector describing the plume. Contents Source Code asym_plume_state_vector Source Code function asym_plume_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the plume. ! This takes the form of a 1D array. ! class ( asym_plume ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the plume. state_vector = [ this % thickness % raw (), this % velocity % raw (), & this % velocity_dx % raw (), this % temperature % raw (), & this % temperature_dx % raw (), this % salinity % raw (), & this % salinity_dx % raw ()] #ifdef DEBUG call logger % debug ( 'asym_plume%state_vector' , 'Returning state vector ' // & 'for plume.' ) #endif end function asym_plume_state_vector"},{"title":"asym_plume_initialise – ISOFT","tags":"","loc":"proc/asym_plume_initialise.html","text":"private subroutine asym_plume_initialise(this, domain, resolution, thickness, velocity, temperature, salinity, shape, entrainment_formulation, melt_formulation, ambient_conds, eos, boundaries, delta, nu, mu, r_val, phi, dy) Instantiates an asym_plume object with initial\n coniditions provided by the arguments.At present only a 1D model\n is supported. If information is provided for higher dimensions\n then it will be ignored. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(out) :: this A plume object with its domain and initial conditions set according\n to the arguments of the constructor function. real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the plume. The first index represents the dimension for which the\n boundaries apply. If the second index is 1 then it corresponds to\n the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( scalar_func ) :: thickness A function which calculates the initial value of the thickness of \n the plume at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the water at a given location in a plume. procedure( scalar_func ) :: temperature A function which calculates the initial value of the temperature of \n the plume at a given location. procedure( scalar_func ) :: salinity A function which calculates the initial value of the salinity of \n the plume at a given location. type( plume_shape ), intent(in), optional :: shape An object with components describing the transverse profile\n of the plume. Default is a plume that is uniform in the\n transverse direction. class( abstract_entrainment ), intent(inout), optional allocatable :: entrainment_formulation An object which calculates entrainment into the plume. Will\n be unallocated on exit. Defaults to that used by Jenkins\n (1991) with the coefficient $E_0 = 1$. class( abstract_melt_relationship ), intent(inout), optional allocatable :: melt_formulation An object which calculates melting and the resulting thermal\n transfer into/out of the plume. Will be unallocated on\n exit. Defaults to that used by Dallaston et al. (2015),\n scaled to be consistent with the nondimensionalisation used\n here. class( ambient_conditions ), intent(inout), optional allocatable :: ambient_conds An object specifying the salinity and temperature of the\n ambient ocean. Will be unallocated on exit. Defaults to\n uniform ambient salinity and temperature, both of which are\n set to 0 (as temperature and salinity are measured relative\n to some reference value). class( equation_of_state ), intent(inout), optional allocatable :: eos An object specifying the equation of state for the water in\n the plume. Will be unallocated on exit. Defaults to\n linearised equation of state with no temperature dependence\n and a haline contraction coefficient of 1. The reference\n density is set to be 1 in the dimensionless units when\n salinity and temeprature are 0. class( plume_boundary ), intent(inout), optional allocatable :: boundaries An object providing the boundary conditions for the\n plume. Will be unallocated on exit. Defaults to those used by\n Dallaston et al. (2015). real(kind=r8), intent(in), optional :: delta The dimensionless ratio \\delta \\equiv\n \\frac{D_0}{h_0} . Defaults to 0.036. real(kind=r8), intent(in), optional :: nu The dimensionless ratio \\nu \\equiv\n \\frac{\\kappa_0}{x_0U_o} . Defaults to 0. real(kind=r8), intent(in), optional :: mu The dimensionless ratio \\mu \\equiv\n \\frac{C_dx_0}{D_0} . Defaults to 0. real(kind=r8), intent(in), optional :: r_val The dimensionless ratio of the water density to the ice shelf\n density, r = \\rho_0/\\rho_i. Defaults to 1.12. real(kind=r8), intent(in), optional :: phi The inverse Rossby number, \\Phi \\equiv\n \\frac{fx_0}{U_0} . Defaults to 0. real(kind=r8), intent(in), optional :: dy The width over which the plume has been averaged. Defualts to 1. Calls proc~~asym_plume_initialise~~CallsGraph proc~asym_plume_initialise asym_plume_initialise cheb1d_scalar_field cheb1d_scalar_field proc~asym_plume_initialise->cheb1d_scalar_field cheb1d_vector_field cheb1d_vector_field proc~asym_plume_initialise->cheb1d_vector_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code asym_plume_initialise Source Code subroutine asym_plume_initialise ( this , domain , resolution , & thickness , velocity , temperature , & salinity , shape , entrainment_formulation , & melt_formulation , ambient_conds , eos , & boundaries , delta , nu , mu , r_val , phi , dy ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Instantiates an [[asym_plume(type)]] object with initial ! coniditions provided by the arguments.At present only a 1D model ! is supported. If information is provided for higher dimensions ! then it will be ignored. ! class ( asym_plume ), intent ( out ) :: this !! A plume object with its domain and initial conditions set according !! to the arguments of the constructor function. real ( r8 ), dimension (:,:), intent ( in ) :: domain !! An array containing the upper and lower limits of the domain for !! the plume. The first index represents the dimension for which the !! boundaries apply. If the second index is 1 then it corresponds to !! the lower bound. If the second index is 2 then it corresponds to !! the upper bound. integer , dimension (:), intent ( in ) :: resolution !! The number of data points in each dimension procedure ( scalar_func ) :: thickness !! A function which calculates the initial value of the thickness of !! the plume at a given location. procedure ( velocity_func ) :: velocity !! A function which calculates the initial value of the velocity !! (vector) of the water at a given location in a plume. procedure ( scalar_func ) :: temperature !! A function which calculates the initial value of the temperature of !! the plume at a given location. procedure ( scalar_func ) :: salinity !! A function which calculates the initial value of the salinity of !! the plume at a given location. type ( plume_shape ), optional , intent ( in ) :: shape !! An object with components describing the transverse profile !! of the plume. Default is a plume that is uniform in the !! transverse direction. class ( abstract_entrainment ), allocatable , optional , & intent ( inout ) :: entrainment_formulation !! An object which calculates entrainment into the plume. Will !! be unallocated on exit. Defaults to that used by Jenkins !! (1991) with the coefficient $E_0 = 1$. class ( abstract_melt_relationship ), allocatable , optional , & intent ( inout ) :: melt_formulation !! An object which calculates melting and the resulting thermal !! transfer into/out of the plume. Will be unallocated on !! exit. Defaults to that used by Dallaston et al. (2015), !! scaled to be consistent with the nondimensionalisation used !! here. class ( ambient_conditions ), allocatable , optional , & intent ( inout ) :: ambient_conds !! An object specifying the salinity and temperature of the !! ambient ocean. Will be unallocated on exit. Defaults to !! uniform ambient salinity and temperature, both of which are !! set to 0 (as temperature and salinity are measured relative !! to some reference value). class ( equation_of_state ), allocatable , optional , & intent ( inout ) :: eos !! An object specifying the equation of state for the water in !! the plume. Will be unallocated on exit. Defaults to !! linearised equation of state with no temperature dependence !! and a haline contraction coefficient of 1. The reference !! density is set to be 1 in the dimensionless units when !! salinity and temeprature are 0. class ( plume_boundary ), allocatable , optional , & intent ( inout ) :: boundaries !! An object providing the boundary conditions for the !! plume. Will be unallocated on exit. Defaults to those used by !! Dallaston et al. (2015). real ( r8 ), optional , intent ( in ) :: delta !! The dimensionless ratio \\delta \\equiv !! \\frac{D_0}{h_0}. Defaults to 0.036. real ( r8 ), optional , intent ( in ) :: nu !! The dimensionless ratio \\nu \\equiv !! \\frac{\\kappa_0}{x_0U_o}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: mu !! The dimensionless ratio \\mu \\equiv !! \\frac{C_dx_0}{D_0}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: r_val !! The dimensionless ratio of the water density to the ice shelf !! density,  r = \\rho_0/\\rho_i.  Defaults to 1.12. real ( r8 ), optional , intent ( in ) :: phi !! The inverse Rossby number, \\Phi \\equiv !! \\frac{fx_0}{U_0}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: dy !! The width over which the plume has been averaged. Defualts to 1. integer :: i , btype_l , btype_u , bdepth_l , bdepth_u this % vel_dims = size ( velocity ([ 0._r8 ])) this % thickness = cheb1d_scalar_field ( resolution ( 1 ), thickness , domain ( 1 , 1 ), domain ( 1 , 2 )) this % velocity = cheb1d_vector_field ( resolution ( 1 ), velocity , domain ( 1 , 1 ), domain ( 1 , 2 ), this % vel_dims - 1 ) this % temperature = cheb1d_scalar_field ( resolution ( 1 ), temperature , domain ( 1 , 1 ), domain ( 1 , 2 )) this % salinity = cheb1d_scalar_field ( resolution ( 1 ), salinity , domain ( 1 , 1 ), domain ( 1 , 2 )) this % thickness_size = this % thickness % raw_size () this % velocity_size = this % velocity % raw_size () this % temperature_size = this % temperature % raw_size () this % salinity_size = this % salinity % raw_size () this % velocity_dx = this % velocity % d_dx ( 1 ) this % salinity_dx = this % salinity % d_dx ( 1 ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( present ( shape )) this % shape = shape if ( present ( entrainment_formulation )) then call move_alloc ( entrainment_formulation , this % entrainment_formulation ) else allocate ( jenkins1991_entrainment :: this % entrainment_formulation ) end if if ( present ( melt_formulation )) then call move_alloc ( melt_formulation , this % melt_formulation ) else allocate ( dallaston2015_melt :: this % melt_formulation ) end if if ( present ( ambient_conds )) then call move_alloc ( ambient_conds , this % ambient_conds ) else allocate ( uniform_ambient_conditions :: this % ambient_conds ) end if if ( present ( eos )) then call move_alloc ( eos , this % eos ) else allocate ( linear_eos :: this % eos ) end if if ( present ( boundaries )) then call move_alloc ( boundaries , this % boundaries ) else allocate ( simple_plume_boundary :: this % boundaries ) end if if ( present ( delta )) then this % delta = delta else this % delta = 0.036_r8 end if if ( present ( nu )) then this % nu = nu else this % nu = 0.0_r8 end if if ( present ( mu )) then this % mu = mu else this % mu = 0.0_r8 end if if ( present ( r_val )) then this % r_val = r_val else this % r_val = 1.12_r8 end if if ( present ( phi )) then this % phi = phi else this % phi = 0.0_r8 end if if ( present ( dy )) then this % dy = dy else this % dy = 1.0_r8 end if this % time = 0.0_r8 ! Initialise preconditioner this % precond = pseudospec_block ( this % thickness ) ! Store information on boundary conditions call this % boundaries % thickness_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % thickness_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower thickness boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper thickness boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if #endif select case ( btype_l ) case ( free_boundary ) case ( dirichlet ) this % lower_bounds ( 1 ) = . true . case default error stop ( 'Only free, and Dirichlet boundary conditions ' // & 'supported for asym_plume thickness.' ) end select select case ( btype_u ) case ( free_boundary ) case ( dirichlet ) this % upper_bounds ( 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for asym_plume.' ) end select call this % boundaries % velocity_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % velocity_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower velocity boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper velocity boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 2 ) call this % boundaries % temperature_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % temperature_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower temperature boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper temperature boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 4 ) call this % boundaries % salinity_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % salinity_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower salinity boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper salinity boundary has depth greater than 1, ' // & 'which is not supported by asym_plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 6 ) if ( this % phi /= 0._r8 ) then associate ( velbound => btype_l , dvelbound => btype_u ) if ( this % lower_bounds ( 2 )) then velbound = - 1 else if ( this % upper_bounds ( 2 )) then velbound = 1 end if if ( this % lower_bounds ( 3 )) then dvelbound = - 1 else if ( this % upper_bounds ( 3 )) then dvelbound = 1 end if this % vel_precond = coriolis_block ( this % phi , this % nu , velbound , & dvelbound , 1 , this % thickness ) end associate end if #ifdef DEBUG call logger % debug ( 'asym_plume' , 'Initialised new ice shelf object.' ) #endif contains subroutine set_preconditioners ( ltype , utype , comp_id ) integer , intent ( in ) :: ltype , utype , comp_id select case ( ltype ) case ( free_boundary ) case ( dirichlet ) this % lower_bounds ( comp_id ) = . true . case ( neumann ) this % lower_bounds ( comp_id + 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for asym_plume.' ) end select select case ( utype ) case ( free_boundary ) case ( dirichlet ) this % upper_bounds ( comp_id ) = . true . case ( neumann ) this % upper_bounds ( comp_id + 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for asym_plume.' ) end select end subroutine set_preconditioners end subroutine asym_plume_initialise"},{"title":"asym_plume_update – ISOFT","tags":"","loc":"proc/asym_plume_update.html","text":"private subroutine asym_plume_update(this, state_vector, ice_thickness) Updates the state of the plume from its state vector. The state\n vector is a real array containing the value of each of the plume's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n plume. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate. Contents Source Code asym_plume_update Source Code subroutine asym_plume_update ( this , state_vector , ice_thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the plume from its state vector. The state ! vector is a real array containing the value of each of the plume's ! properties at each of the locations on the grid used in discretization. ! class ( asym_plume ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! plume. class ( scalar_field ), optional , intent ( in ) :: ice_thickness !! The ice thickness which, if present, will be used to update !! the calculation of the melt rate. integer :: i !TODO: Add some assertion-like checks that the state vector is the right size call this % thickness % set_from_raw ( state_vector ( 1 : this % thickness_size )) i = 1 + this % thickness_size call this % velocity % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % velocity_dx % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % temperature % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % temperature_dx % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % salinity % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) i = i + this % salinity_size call this % salinity_dx % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) if ( present ( ice_thickness )) then call this % melt_formulation % solve_for_melt ( this % velocity , & - ice_thickness / this % r_val , & this % temperature , & this % salinity , & this % thickness , & this % time ) end if #ifdef DEBUG call logger % debug ( 'asym_plume%update' , 'Updated state of plume.' ) #endif end subroutine asym_plume_update"},{"title":"asym_plume_read_data – ISOFT","tags":"","loc":"proc/asym_plume_read_data.html","text":"private subroutine asym_plume_read_data(this, file_id, group_name, error) Reads the state of the plume object from an HDF file in the\n specified group. This sets the thickness, velocity, temperature,\n salinity dataset, and parameter values. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Calls proc~~asym_plume_read_data~~CallsGraph proc~asym_plume_read_data asym_plume_read_data h5ltget_attribute_string_f h5ltget_attribute_string_f proc~asym_plume_read_data->h5ltget_attribute_string_f h5gopen_f h5gopen_f proc~asym_plume_read_data->h5gopen_f h5gclose_f h5gclose_f proc~asym_plume_read_data->h5gclose_f str str proc~asym_plume_read_data->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code asym_plume_read_data Source Code subroutine asym_plume_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the plume object from an HDF file in the ! specified group. This sets the thickness, velocity, temperature, ! salinity dataset, and parameter values. ! class ( asym_plume ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err real ( r8 ), dimension ( 1 ) :: param character ( len = 50 ) :: base_type ret_err = 0 call h5gopen_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % error ( 'asym_plume%read_data' , 'Could not open HDF group \"' // & group_name // '\", so no IO performed.' ) return end if call h5ltget_attribute_string_f ( file_id , group_name , hdf_type_attr , & base_type , error ) if ( trim ( base_type ) /= hdf_type_name ) then call logger % error ( 'asym_plume%read_data' , 'Trying to read data from ' // & 'basal_surface of type other than plume.' ) error = - 1 return end if !call h5ltget_attribute_double_f(file_id, group_name, hdf_delta, & !                                param, error) !this%delta = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_nu, & !                                param, error) !this%nu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_mu, & !                                param, error) !this%mu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_r, & !                                param, error) !this%r_val = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_phi, & !                                param, error) !this%phi = param(1) !if (error /= 0) then !  call logger%warning('plume%read_data','Error code '//     & !                      trim(str(error))//' returned when '//  & !                      'reading attributes from HDF group '// & !                      group_name) !  ret_err = error !end if call this % thickness % read_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume thickness field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % read_hdf ( group_id , hdf_velocity , error ) this % velocity_dx = this % velocity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume velocity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % read_hdf ( group_id , hdf_temperature , error ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume temperature field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % read_hdf ( group_id , hdf_salinity , error ) this % salinity_dx = this % salinity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume salinity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err call logger % trivia ( 'asym_plume%read_data' , 'Read plume data from HDF group ' // & group_name ) end subroutine asym_plume_read_data"},{"title":"asym_plume_write_data – ISOFT","tags":"","loc":"proc/asym_plume_write_data.html","text":"private subroutine asym_plume_write_data(this, file_id, group_name, error) Writes the state of the plume object to an HDF file in the\n specified group. This will consist of a thickness, a velocity, a\n temperature, and a salinity dataset. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Calls proc~~asym_plume_write_data~~CallsGraph proc~asym_plume_write_data asym_plume_write_data str str proc~asym_plume_write_data->str h5ltset_attribute_string_f h5ltset_attribute_string_f proc~asym_plume_write_data->h5ltset_attribute_string_f h5gclose_f h5gclose_f proc~asym_plume_write_data->h5gclose_f h5gcreate_f h5gcreate_f proc~asym_plume_write_data->h5gcreate_f h5ltset_attribute_double_f h5ltset_attribute_double_f proc~asym_plume_write_data->h5ltset_attribute_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code asym_plume_write_data Source Code subroutine asym_plume_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the plume object to an HDF file in the ! specified group. This will consist of a thickness, a velocity, a ! temperature, and a salinity dataset. ! class ( asym_plume ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err ret_err = 0 call h5gcreate_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned ' // & 'when creating HDF group \"' // group_name // '\"' ) call logger % error ( 'asym_plume%write_data' , 'Data IO not performed for plume' ) return end if call h5ltset_attribute_string_f ( file_id , group_name , hdf_type_attr , & hdf_type_name , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_delta , & [ this % delta ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_nu , & [ this % nu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_mu , & [ this % mu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_r , & [ this % r_val ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_phi , & [ this % phi ], 1_size_t , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing attribute to HDF group ' // & group_name ) ret_err = error end if call this % thickness % write_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume thickness field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % write_hdf ( group_id , hdf_velocity , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume velocity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % write_hdf ( group_id , hdf_temperature , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume temperature field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % write_hdf ( group_id , hdf_salinity , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume salinity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'asym_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err #ifdef DEBUG call logger % debug ( 'asym_plume%write_data' , 'Wrote plume data to HDF group ' // & group_name ) #endif end subroutine asym_plume_write_data"},{"title":"asym_plume_solve – ISOFT","tags":"","loc":"proc/asym_plume_solve.html","text":"private subroutine asym_plume_solve(this, ice_thickness, ice_density, ice_temperature, time, success) Solves the state of the plume for the specified ice properties,\n at the specified time. This is done using the a\n quasilinearisation method and a GMRES iterative linear solver. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise Calls proc~~asym_plume_solve~~CallsGraph proc~asym_plume_solve asym_plume_solve str str proc~asym_plume_solve->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code asym_plume_solve Source Code subroutine asym_plume_solve ( this , ice_thickness , ice_density , ice_temperature , & time , success ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Solves the state of the plume for the specified ice properties, ! at the specified time. This is done using the a ! quasilinearisation method and a GMRES iterative linear solver. ! class ( asym_plume ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: ice_thickness !! Thickness of the ice above the basal surface real ( r8 ), intent ( in ) :: ice_density !! The density of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: ice_temperature !! The temperature of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: time !! The time to which the basal surface should be solved logical , intent ( out ) :: success !! True if the solver is successful, false otherwise real ( r8 ), dimension (:), allocatable :: solution real ( r8 ) :: residual integer , dimension ( 5 ) :: info integer :: flag class ( scalar_field ), pointer :: b call ice_thickness % guard_temp () b => - ice_thickness / this % r_val call b % guard_temp () select type ( bound => this % boundaries ) class is ( upstream_plume_boundary ) call bound % calculate ( time , non_diff_terms , b ) class default call bound % set_time ( time ) end select solution = this % state_vector () #ifdef DEBUG call logger % debug ( 'asym_plume%solve' , 'Calling QLM ODE solver' ) #endif call quasilinear_solve ( L , f , jac_prod , solution , 1 , residual , flag , info , & 1.e-9_r8 * size ( solution ), precond = preconditioner , & iter_max = 100 , krylov_dim = 85 , gmres_iter_max = 5000 ) call this % update ( solution ) #ifdef DEBUG call logger % debug ( 'plume%solve' , 'QLM solver required ' // & trim ( str ( info ( 5 ))) // ' nonlinear iterations ' // & 'and ' // trim ( str ( info ( 1 ) + info ( 2 ))) // & ' function calls.' ) #endif select case ( flag ) case ( 0 ) call logger % trivia ( 'asym_plume%solver' , 'Solved plume at time ' // trim ( str ( time ))) success = . true . this % time = time case ( 1 ) call logger % warning ( 'asym_plume%solver' , 'Plume solver stagnated with ' // & 'residual of ' // trim ( str ( residual ))) success = . false . case ( 2 ) call logger % error ( 'asym_plume%solver' , 'Reached maximum number of ' // & 'iterations solving plume' ) success = . false . case ( 3 ) call logger % error ( 'asym_plume%solver' , 'Plume solution began to diverge.' ) success = . false . case default call logger % error ( 'asym_plume%solve' , 'QLM solver failed for plume with ' // & 'error code ' // trim ( str ( flag ))) success = . false . end select call ice_thickness % clean_temp (); call b % clean_temp () contains function L ( v ) !! The linear differentiation operator real ( r8 ), dimension (:), intent ( in ) :: v !! The state vector for the system of differential equations real ( r8 ), dimension ( size ( v )) :: L integer :: st , en , btype_l , btype_u , bdepth_l , bdepth_u type ( cheb1d_scalar_field ) :: scalar_tmp , ctmp ( 2 ) type ( cheb1d_vector_field ) :: vector_tmp type ( cheb1d_vector_field ) :: coriolis call this % update ( v ) ! Thickness scalar_tmp = this % thickness % d_dx ( 1 ) call this % boundaries % thickness_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % thickness_bound_info ( 1 , btype_u , bdepth_u ) if ( this % lower_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % thickness % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % thickness % get_boundary ( 1 , 1 )) end if st = 1 en = st + this % thickness_size - 1 L ( st : en ) = scalar_tmp % raw () ! Velocity vector_tmp = this % velocity % d_dx ( 1 ) - this % velocity_dx if ( this % lower_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % velocity_size - 1 L ( st : en ) = vector_tmp % raw () if ( this % phi /= 0._r8 ) then ctmp ( 1 ) = - this % phi * this % shape % a_DV / ( this % nu * this % shape % a_DU ) & * this % velocity % component ( 2 ) ctmp ( 2 ) = this % phi * this % shape % a_DU / ( this % nu * this % shape % a_DV ) & * this % velocity % component ( 1 ) coriolis = ctmp vector_tmp = this % velocity_dx % d_dx ( 1 ) - coriolis else vector_tmp = this % velocity_dx % d_dx ( 1 ) end if if ( this % lower_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % velocity_size - 1 L ( st : en ) = vector_tmp % raw () !     print*,vector_tmp%raw() ! Temperature scalar_tmp = this % temperature % d_dx ( 1 ) - this % temperature_dx if ( this % lower_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % temperature_size - 1 L ( st : en ) = scalar_tmp % raw () scalar_tmp = this % temperature_dx % d_dx ( 1 ) if ( this % lower_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % temperature_size - 1 L ( st : en ) = scalar_tmp % raw () ! Salinity scalar_tmp = this % salinity % d_dx ( 1 ) - this % salinity_dx if ( this % lower_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % salinity_size - 1 L ( st : en ) = scalar_tmp % raw () scalar_tmp = this % salinity_dx % d_dx ( 1 ) if ( this % lower_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % salinity_size - 1 L ( st : en ) = scalar_tmp % raw () end function L subroutine non_diff_terms ( D , Uvec , T , S , b , DU_x , DUU_x , DUT_x , DUS_x ) !! Computes the values of (DU)_x, (DU\\vec{U})_x, !! (DUT)_x, (DUS)_x, when diffusion is not !! included. This should be able to handle uniform field types, !! for use in an ODE solver when integrating near the boundary. class ( scalar_field ), intent ( in ) :: D !! The plume thickness class ( vector_field ), intent ( in ) :: Uvec !! The plume velocity class ( scalar_field ), intent ( in ) :: T !! The plume temperature class ( scalar_field ), intent ( in ) :: S !! The plume salinity class ( scalar_field ), intent ( in ) :: b !! The debth of the base of the ice shelf class ( scalar_field ), intent ( out ) :: DU_x !! The derivative of the product DU class ( vector_field ), intent ( out ) :: DUU_x !! The derivative of the product DUU class ( scalar_field ), intent ( out ) :: DUT_x !! The derivative of the product DUT class ( scalar_field ), intent ( out ) :: DUS_x !! The derivative of the product DUS class ( scalar_field ), pointer :: m , rho_b , rho_t , e , S_a , U , V , & T_a , rho_a , rho_x , Unorm class ( scalar_field ), allocatable , dimension (:) :: tmp type ( cheb1d_vector_field ) :: coriolis call D % guard_temp (); call Uvec % guard_temp (); call T % guard_temp () call S % guard_temp (); call b % guard_temp () S_a => this % ambient_conds % ambient_salinity ( b , time ) T_a => this % ambient_conds % ambient_temperature ( b , time ) select type ( eos => this % eos ) class is ( ave_linear_eos ) rho_b => eos % water_density_ave1 ( T , S ) rho_t => eos % water_density_ave2 ( T , S ) class default rho_b => eos % water_density ( T , S ) rho_t => rho_b end select U => Uvec % component ( 1 ) V => Uvec % component ( 2 ) call S_a % guard_temp (); call T_a % guard_temp (); call rho_b % guard_temp () call rho_t % guard_temp (); call U % guard_temp (); call V % guard_temp () rho_a => this % eos % water_density ( T_a , S_a ) call rho_a % guard_temp () e => this % entrainment_formulation % entrainment_rate ( Uvec , D , b , rho_a - rho_b , time ) call e % guard_temp () call this % melt_formulation % solve_for_melt ( Uvec , b , T , S , D , time ) m => this % melt_formulation % melt_rate () call m % guard_temp () associate ( f_D1 => this % shape % f_D1 , f_D2 => this % shape % f_D2 , & f_U2 => this % shape % f_U2 , f_V2 => this % shape % f_V2 , & f_S1 => this % shape % f_S1 , f_S2 => this % shape % f_S2 , & f_T1 => this % shape % f_T1 , f_T2 => this % shape % f_T2 , & a_DU => this % shape % a_DU , a_DU2 => this % shape % a_DU2 , & a_DUV => this % shape % a_DUV , a_DUS => this % shape % a_DUS , & a_DUT => this % shape % a_DUT , a_D2 => this % shape % a_D2 , & a_DV => this % shape % a_DV , a_UabsU => this % shape % a_UabsU , & a_UabsV => this % shape % a_UabsV , dy => this % dy ) DU_x = ( e + m - f_D2 * D * f_V2 * V / dy ) / a_DU if ( this % melt_formulation % has_heat_terms ()) then DUT_x = ( e * T_a - f_D2 * D * f_V2 * V * f_T2 * T / dy - & this % melt_formulation % heat_equation_terms ()) / a_DUT else DUT_x = ( e * T_a - f_D2 * D * f_V2 * V * f_T2 * T / dy ) / a_DUT end if if ( this % melt_formulation % has_salt_terms ()) then DUS_x = ( e * S_a - f_D2 * D * f_V2 * V * f_S2 * S / dy - & this % melt_formulation % salt_equation_terms ()) / a_DUS else DUS_x = ( e * S_a - f_D2 * D * f_V2 * V * f_S2 * S / dy ) / a_DUS end if Unorm => Uvec % norm () call Unorm % guard_temp () select type ( Uvec ) class is ( uniform_vector_field ) rho_x => this % eos % water_density_derivative ( T , ( DUT_x - DU_x * T ) / ( D * U ), & S , ( DUS_x - DU_x * S ) / ( D * U ), 1 ) call rho_x % guard_temp () allocate ( tmp ( this % vel_dims ), mold = D ) tmp ( 1 ) = ( D * ( rho_a - rho_b ) * b % d_dx ( 1 ) & - 2._r8 * D * this % delta * a_D2 * ( rho_a - rho_t ) * DU_x / U & + 0.5 * this % delta * a_D2 * D ** 2 * rho_x & - this % mu * a_UabsU * Unorm * U & + this % phi * a_DV * D * V & - f_D2 * D * f_U2 * U * f_V2 * V / dy ) / & ( a_DU2 - this % delta * a_D2 * D * ( rho_a - rho_t ) / U ** 2 ) if ( this % vel_dims > 1 ) then ! Use entrainment and melt as work-arrays to hold the ! upper and lower boundary density values. Should be able ! to just multiply the function results directly, but ! there's a compiler bug. call e % clean_temp (); call m % clean_temp () e => this % eos % water_density ( f_T2 * T , f_S2 * S ) m => this % eos % water_density ( f_T1 * T , f_S1 * S ) call e % guard_temp (); call m % guard_temp () tmp ( 2 ) = (( f_D2 ** 2 * ( e - rho_a ) - f_D1 ** 2 * ( m - rho_a )) * & 0.5_r8 * this % delta / dy * D ** 2 - this % mu * a_UabsV * Unorm * V & - a_DU * this % phi * D * U - f_D2 * D * f_V2 ** 2 * V ** 2 / dy ) / a_DUV end if DUU_x = tmp call rho_x % clean_temp () class default allocate ( tmp ( this % vel_dims ), mold = D ) tmp ( 1 ) = b % d_dx ( 1 ) tmp ( 1 ) = ( D * ( rho_a - rho_b ) * b % d_dx ( 1 ) & - a_D2 * D * ( rho_a - rho_t ) * this % delta * D % d_dx ( 1 ) & + 0.5_r8 * a_D2 * this % delta * D ** 2 * rho_t % d_dx ( 1 ) & - this % mu * a_UabsU * U * Unorm & - f_D2 * D * f_V2 * V * f_U2 * U / dy ) / a_DU2 if ( this % vel_dims > 1 ) then ! Use entrainment and melt as work-arrays to hold the ! upper and lower boundary density values. Should be able ! to just multiply the function results directly, but ! there's a compiler bug. call e % clean_temp (); call m % clean_temp () e => this % eos % water_density ( f_T2 * T , f_S2 * S ) m => this % eos % water_density ( f_T1 * T , f_S1 * S ) call e % guard_temp (); call m % guard_temp () tmp ( 2 ) = (( f_D2 ** 2 * ( e - rho_a ) - f_D1 ** 2 * ( m - rho_a )) * & 0.5_r8 * this % delta / dy * D ** 2 - this % mu * a_UabsV * V * Unorm & - f_D2 * D * f_V2 ** 2 * V ** 2 / dy ) / a_DUV end if DUU_x = tmp end select call Unorm % clean_temp () end associate call e % clean_temp (); call S_a % clean_temp (); call T_a % clean_temp () call rho_b % clean_temp (); call m % clean_temp (); call rho_a % clean_temp () call rho_t % clean_temp (); call U % clean_temp (); call V % clean_temp () call D % clean_temp (); call Uvec % clean_temp (); call T % clean_temp () call S % clean_temp (); call b % clean_temp () end subroutine non_diff_terms function f ( v ) !! The nonlinear operator real ( r8 ), dimension (:,:), intent ( in ) :: v !! The state vector for the system of differential equations, !! and its derivatives. Column i represents the i-1 !! derivative. real ( r8 ), dimension ( size ( v , 1 )) :: f call this % update ( v (:, 1 )) call nonlinear ( f , . false .) end function f function jac_prod ( v , dv ) !! The product of the Jacobian of the nonlienar operator at v, !! multiplying dv. real ( r8 ), dimension (:,:), intent ( in ) :: v !! The state vector for the system of differential equations, !! and its derivatives. Column i represents the i-1 !! derivative. real ( r8 ), dimension (:,:), intent ( in ) :: dv !! The state vector for the system of differential equations, !! and its derivatives, to be multiplied by the !! Jacobian. Column i represents the i-1 derivative. real ( r8 ), dimension ( size ( v , 1 )) :: jac_prod type ( cheb1d_scalar_field ) :: stmp type ( cheb1d_vector_field ) :: vtmp integer :: i call this % update ( v (:, 1 )) call stmp % assign_meta_data ( this % thickness ) call vtmp % assign_meta_data ( this % velocity ) call stmp % set_from_raw ( dv ( 1 : this % thickness_size , 1 )) call this % thickness % set_derivative ( stmp ) i = 1 + this % thickness_size call vtmp % set_from_raw ( dv ( i : i + this % velocity_size - 1 , 1 )) call this % velocity % set_derivative ( vtmp ) i = i + this % velocity_size call vtmp % set_from_raw ( dv ( i : i + this % velocity_size - 1 , 1 )) call this % velocity_dx % set_derivative ( vtmp ) i = i + this % velocity_size call stmp % set_from_raw ( dv ( i : i + this % temperature_size - 1 , 1 )) call this % temperature % set_derivative ( stmp ) i = i + this % temperature_size call stmp % set_from_raw ( dv ( i : i + this % temperature_size - 1 , 1 )) call this % temperature_dx % set_derivative ( stmp ) i = i + this % temperature_size call stmp % set_from_raw ( dv ( i : i + this % salinity_size - 1 , 1 )) call this % salinity % set_derivative ( stmp ) i = i + this % salinity_size call stmp % set_from_raw ( dv ( i : i + this % salinity_size - 1 , 1 )) call this % salinity_dx % set_derivative ( stmp ) call nonlinear ( jac_prod , . true .) call this % thickness % unset_derivative () call this % velocity % unset_derivative () call this % velocity_dx % unset_derivative () call this % temperature % unset_derivative () call this % temperature_dx % unset_derivative () call this % salinity % unset_derivative () call this % salinity_dx % unset_derivative () end function jac_prod subroutine nonlinear ( f , deriv ) real ( r8 ), dimension (:), intent ( out ) :: f logical , intent ( in ) :: deriv !! If true, return Jacobian product, otherwise return result !! of nonlienar operator. integer :: st , en type ( cheb1d_scalar_field ) :: scalar_tmp , D_x , D_nd , S_nd , T_nd type ( cheb1d_scalar_field ), allocatable , dimension (:) :: vtmp type ( cheb1d_vector_field ) :: vector_tmp , U_nd class ( scalar_field ), pointer :: U , V , U_x , V_x ! Use same or similar notation for variables as used in equations associate ( D => this % thickness , Uvec => this % velocity , & Uvec_x => this % velocity_dx , S => this % salinity , & S_x => this % salinity_dx , T => this % temperature , & T_x => this % temperature_dx , mf => this % melt_formulation , & h => ice_thickness , delta => this % delta , nu => this % nu , & mu => this % mu , r => this % r_val , bounds => this % boundaries ,& a_DU2 => this % shape % a_DU2 , a_DUV => this % shape % a_DUV , & a_DUS => this % shape % a_DUS , a_DUT => this % shape % a_DUT , & a_DU => this % shape % a_DU , a_DV => this % shape % a_DV , & a_DS => this % shape % a_DS , a_DT => this % shape % a_DT , & f_D2 => this % shape % f_D2 , f_Up => this % shape % f_Up , & f_Vp => this % shape % f_Vp , f_Sp => this % shape % f_Sp , & f_Tp => this % shape % f_Tp , dy => this % dy ) call non_diff_terms ( D , Uvec , T , S , b , D_nd , U_nd , T_nd , S_nd ) U => this % velocity % component ( 1 ) U_x => this % velocity_dx % component ( 1 ) call U % guard_temp (); call U_x % guard_temp () if ( this % vel_dims > 1 ) then V => this % velocity % component ( 2 ) V_x => this % velocity_dx % component ( 2 ) call V % guard_temp (); call V_x % guard_temp () end if ! Thickness scalar_tmp = ( D_nd - D * U_x ) / U D_x = scalar_tmp if ( this % lower_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % thickness_bound ( - 1 )) end if if ( this % upper_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % thickness_bound ( 1 )) end if st = 1 en = st + this % thickness_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () ! Velocity vector_tmp = 0._r8 * Uvec if ( this % lower_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( - 1 )) end if if ( this % upper_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( 1 )) end if st = en + 1 en = st + this % velocity_size - 1 if ( deriv ) then vector_tmp = vector_tmp % get_derivative () end if f ( st : en ) = vector_tmp % raw () allocate ( vtmp ( this % vel_dims ), mold = D ) vtmp ( 1 ) = ( a_DU2 * ( 2._r8 * D * U * U_x + D_x * U ** 2 - U_nd % component ( 1 )) & - nu * a_DU * D_x * U_x - nu * f_D2 * D * f_Up * U / dy ) / ( nu * a_DU * D ) if ( this % vel_dims > 1 ) then vtmp ( 2 ) = ( a_DUV * ( D * U * V_x + D * U_x * V + D_x * U * V - U_nd % component ( 2 )) & - nu * a_DV * D_x * V_x - nu * f_D2 * D * f_Vp * V / dy ) / ( nu * a_DV * D ) end if vector_tmp = vtmp if ( this % lower_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( - 1 )) end if if ( this % upper_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( 1 )) end if st = en + 1 en = st + this % velocity_size - 1 if ( deriv ) then vector_tmp = vector_tmp % get_derivative () end if f ( st : en ) = vector_tmp % raw () ! Temperature scalar_tmp = uniform_scalar_field ( 0._r8 ) if ( this % lower_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( - 1 )) end if if ( this % upper_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( 1 )) end if st = en + 1 en = st + this % temperature_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () scalar_tmp = ( a_DUT * ( D * U * T_x + D * U_x * T + D_x * U * T - T_nd ) - & nu * a_DT * D_x * T_x - nu * f_D2 * D * f_Tp * T / dy ) / ( nu * a_DT * D ) if ( this % lower_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( - 1 )) end if if ( this % upper_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () ! Salinity scalar_tmp = uniform_scalar_field ( 0._r8 ) if ( this % lower_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( - 1 )) end if if ( this % upper_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () scalar_tmp = ( a_DUS * ( D * U * S_x + D * U_x * S + D_x * U * S - S_nd ) - & nu * a_DS * D_x * S_x - nu * f_D2 * D * f_Sp * S / dy ) / ( nu * a_DS * D ) if ( this % lower_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( - 1 )) end if if ( this % upper_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () call U % clean_temp (); call U_x % clean_temp () if ( this % vel_dims > 0 ) then call V % clean_temp (); call V_x % clean_temp () end if end associate end subroutine nonlinear function preconditioner ( v , state , L_op , f_op , fcur , rhs ) !! The preconditioner, which approximates an inverse of `L`. real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be preconditioned. real ( r8 ), dimension (:,:), intent ( in ) :: state !! The current state vector for the system of differential !! equations, and its derivatives. Column i represents the !! i-1 derivative. procedure ( L ) :: L_op !! The linear, left-hand-side of the ODE being solved. procedure ( f ) :: f_op !! The nonlinear, right-hand-side of the ODE being solved. real ( r8 ), dimension (:), intent ( in ) :: fcur !! The result of `f(u)` real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being !! preconditioned. real ( r8 ), dimension ( size ( v )) :: preconditioner !! The result of applying the preconditioner. integer :: st , en , ust , uen , pst , pen integer :: bloc , i real ( r8 ) :: nu type ( asym_plume ) :: v_plume type ( cheb1d_scalar_field ) :: scalar_tmp type ( cheb1d_vector_field ) :: vector_tmp , tmp2 class ( scalar_field ), pointer :: U , U_x v_plume % thickness_size = this % thickness_size call v_plume % thickness % assign_meta_data ( this % thickness ) v_plume % velocity_size = this % velocity_size call v_plume % velocity % assign_meta_data ( this % velocity ) call v_plume % velocity_dx % assign_meta_data ( this % velocity_dx ) v_plume % temperature_size = this % temperature_size call v_plume % temperature % assign_meta_data ( this % temperature ) call v_plume % temperature_dx % assign_meta_data ( this % temperature_dx ) v_plume % salinity_size = this % salinity_size call v_plume % salinity % assign_meta_data ( this % salinity ) call v_plume % salinity_dx % assign_meta_data ( this % salinity_dx ) call v_plume % update ( v ) nu = this % nu bloc = get_bound_loc ( 1 ) v_plume % thickness = this % precond % solve_for ( v_plume % thickness , bloc , & v_plume % thickness % get_boundary ( 1 , 1 ), - 1 ) st = 1 en = st + this % thickness_size - 1 preconditioner ( st : en ) = v_plume % thickness % raw () bloc = get_bound_loc ( 3 ) v_plume % velocity_dx = this % precond % solve_for ( v_plume % velocity_dx , bloc , & v_plume % velocity_dx % get_boundary ( 1 , 1 ), - 1 ) bloc = get_bound_loc ( 2 ) vector_tmp = v_plume % velocity + v_plume % velocity_dx v_plume % velocity = this % precond % solve_for ( vector_tmp , bloc , & v_plume % velocity % get_boundary ( 1 , 1 ), - 1 ) st = en + 1 en = st + this % velocity_size - 1 preconditioner ( st : en ) = v_plume % velocity % raw () st = en + 1 en = st + this % velocity_size - 1 preconditioner ( st : en ) = v_plume % velocity_dx % raw () ! Precondition T_x terms before T st = en + 1 en = st + this % temperature_size - 1 pst = st pen = en bloc = get_bound_loc ( 5 ) v_plume % temperature_dx = this % precond % solve_for ( v_plume % temperature_dx , bloc , & v_plume % temperature_dx % get_boundary ( 1 , 1 ), - 1 ) st = en + 1 en = st + this % temperature_size - 1 preconditioner ( st : en ) = v_plume % temperature_dx % raw () bloc = get_bound_loc ( 4 ) v_plume % temperature = this % precond % solve_for ( v_plume % temperature + & v_plume % temperature_dx , bloc , v_plume % temperature % get_boundary ( 1 , 1 ), - 1 ) preconditioner ( pst : pen ) = v_plume % temperature % raw () ! Precondition S_x terms before S st = en + 1 en = st + this % salinity_size - 1 pst = st pen = en bloc = get_bound_loc ( 7 ) v_plume % salinity_dx = this % precond % solve_for ( v_plume % salinity_dx , bloc , & v_plume % salinity_dx % get_boundary ( 1 , 1 ), - 1 ) st = en + 1 en = st + this % temperature_size - 1 preconditioner ( st : en ) = v_plume % salinity_dx % raw () bloc = get_bound_loc ( 6 ) v_plume % salinity = this % precond % solve_for ( v_plume % salinity + v_plume % salinity_dx , bloc , & v_plume % salinity % get_boundary ( 1 , 1 ), - 1 ) preconditioner ( pst : pen ) = v_plume % salinity % raw () end function preconditioner integer function get_bound_loc ( component_id ) integer :: component_id if ( this % lower_bounds ( component_id )) then get_bound_loc = - 1 else if ( this % upper_bounds ( component_id )) then get_bound_loc = 1 else get_bound_loc = 0 end if end function get_bound_loc end subroutine asym_plume_solve"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor.html","text":"private pure function constructor(ref_rho, ref_t, ref_s, beta_t, beta_s) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: ref_rho The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), intent(in) :: ref_t The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), intent(in) :: ref_s The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), intent(in) :: beta_t The thermal contraction coefficient, \\beta_T . real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S . Return Value type( linear_eos ) Called by proc~~constructor~~CalledByGraph proc~constructor constructor interface~linear_eos linear_eos interface~linear_eos->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( ref_rho , ref_t , ref_s , beta_t , beta_s ) result ( this ) real ( r8 ), intent ( in ) :: ref_rho !! The density for the temperature and salinity about which the !! equation of state was linearised, \\rho_0. real ( r8 ), intent ( in ) :: ref_t !! The temperature about which the equation of state was !! linearised, T_0. real ( r8 ), intent ( in ) :: ref_s !! The salinity about which the equation of state was !! linearised, S_0. real ( r8 ), intent ( in ) :: beta_t !! The thermal contraction coefficient, \\beta_T. real ( r8 ), intent ( in ) :: beta_s !! The haline contraction coefficient, \\beta_S. type ( linear_eos ) :: this this % ref_rho = ref_rho this % ref_t = ref_t this % ref_s = ref_s this % beta_t = beta_t this % beta_s = beta_s end function constructor"},{"title":"linear_water_density – ISOFT","tags":"","loc":"proc/linear_water_density.html","text":"private function linear_water_density(this, temperature, salinity) result(density) Calculates the density of the water from the temperature and\n salinity, using a linear equatino of state, \\rho =\n \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)]. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water Contents Source Code linear_water_density Source Code function linear_water_density ( this , temperature , salinity ) result ( density ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Calculates the density of the water from the temperature and ! salinity, using a linear equatino of state,  \\rho = ! \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)].  class ( linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call salinity % allocate_scalar_field ( density ) density = this % ref_rho * ( 1.0_r8 - this % beta_t * ( temperature - this % ref_t ) & + this % beta_s * ( salinity - this % ref_s )) call temperature % clean_temp (); call salinity % clean_temp () call density % set_temp () end function linear_water_density"},{"title":"linear_water_deriv – ISOFT","tags":"","loc":"proc/linear_water_deriv.html","text":"private function linear_water_deriv(this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Calculates the derivative of the water density from the\n temperature and salinity, using a linear equatino of state, \\rho = \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)]. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the density of the water Contents Source Code linear_water_deriv Source Code function linear_water_deriv ( this , temperature , d_temperature , salinity , & d_salinity , dir ) result ( d_density ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Calculates the derivative of the water density from the ! temperature and salinity, using a linear equatino of state,  ! \\rho = \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)].  class ( linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: d_temperature !! A field containing the derivative of the temperature of the !! water, in teh same direction as `dir` class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), intent ( in ) :: d_salinity !! A field containing the derivative of the salinity of the !! water, in the same direction as `dir` integer , intent ( in ) :: dir !! The direction in which to take the derivative class ( scalar_field ), pointer :: d_density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call d_temperature % guard_temp (); call d_salinity % guard_temp () call salinity % allocate_scalar_field ( d_density ) d_density = this % ref_rho * ( this % beta_s * d_salinity - this % beta_t * d_temperature ) call temperature % clean_temp (); call salinity % clean_temp () call d_temperature % clean_temp (); call d_salinity % clean_temp () call d_density % set_temp () end function linear_water_deriv"},{"title":"linear_haline_contraction – ISOFT","tags":"","loc":"proc/linear_haline_contraction.html","text":"private function linear_haline_contraction(this, temperature, salinity) result(coef) Returns the haline contraction coefficient. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Calls proc~~linear_haline_contraction~~CallsGraph proc~linear_haline_contraction linear_haline_contraction uniform_scalar_field uniform_scalar_field proc~linear_haline_contraction->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code linear_haline_contraction Source Code function linear_haline_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: June 2017 ! ! Returns the haline contraction coefficient. ! class ( linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( this % ref_rho * this % beta_s ) end function linear_haline_contraction"},{"title":"linear_thermal_contraction – ISOFT","tags":"","loc":"proc/linear_thermal_contraction.html","text":"private function linear_thermal_contraction(this, temperature, salinity) result(coef) Returns the thermal contraction coefficient. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Calls proc~~linear_thermal_contraction~~CallsGraph proc~linear_thermal_contraction linear_thermal_contraction uniform_scalar_field uniform_scalar_field proc~linear_thermal_contraction->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code linear_thermal_contraction Source Code function linear_thermal_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: June 2017 ! ! Returns the thermal contraction coefficient. ! class ( linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( this % ref_rho * this % beta_t ) end function linear_thermal_contraction"},{"title":"linear_eos – ISOFT","tags":"","loc":"interface/linear_eos.html","text":"public interface linear_eos Calls interface~~linear_eos~~CallsGraph interface~linear_eos linear_eos proc~constructor constructor interface~linear_eos->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (ref_rho, ref_t, ref_s, beta_t, beta_s) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: ref_rho The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), intent(in) :: ref_t The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), intent(in) :: ref_s The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), intent(in) :: beta_t The thermal contraction coefficient, \\beta_T . real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S . Return Value type( linear_eos )"},{"title":"bis_secant – ISOFT","tags":"","loc":"proc/bis_secant.html","text":"public subroutine bis_secant(error, fnctn, maxerr, maxsteps, steps, xcur, xleft, xright) A root finder using the hybrid bisection-secant algorithm.\n Returns a computed value of the root within xleft and xright\n once error < maxerr or has run maximum number of iterations. Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: error A real variable in which an estimate of the error in the\n computed root will be stored and returned. public pure function fnctn(x) The Fortran function for which the root will be\n found. Must take only one real argument, return a\n real argument. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x Return Value real(kind=8) real(kind=8), intent(in) :: maxerr A real value which specifies the the maximum allowable\n error in the computed root. The subroutine terminates\n once the error passes below this level. integer, intent(in) :: maxsteps An integer value for the maximum number of iterations\n applied to the algorithm before terminating. integer, intent(out) :: steps Returns the number of iterations needed before error\n falls below maxerr (or returns maxsteps if that many\n iterations occur first). real(kind=8), intent(out) :: xcur A real variable in which the computed value of the root\n will be returned. real(kind=8), intent(inout) :: xleft A real value specifying lower bound within which to\n search for root. real(kind=8), intent(inout) :: xright A real value specifying upper bound within which to\n search for root. Contents Source Code bis_secant Source Code PURE SUBROUTINE bis_secant ( error , fnctn , maxerr , maxsteps , & steps , xcur , xleft , xright ) !! A root finder using the hybrid bisection-secant algorithm. !! Returns a computed value of the root within xleft and xright !! once error < maxerr or has run maximum number of iterations. IMPLICIT NONE interface pure function fnctn ( x ) !! The Fortran function for which the root will be !! found. Must take only one real argument, return a !! real argument. real ( 8 ), intent ( in ) :: x real ( 8 ) :: fnctn end function fnctn end interface integer , intent ( in ) :: maxsteps !! An integer value for the maximum number of iterations !! applied to the algorithm before terminating. real ( 8 ), intent ( in ) :: maxerr !! A real value which specifies the the maximum allowable !! error in the computed root. The subroutine terminates !! once the error passes below this level. real ( 8 ), intent ( inout ) :: xleft !! A real value specifying lower bound within which to !! search for root. real ( 8 ), intent ( inout ) :: xright !! A real value specifying upper bound within which to !! search for root. integer , intent ( out ) :: steps !! Returns the number of iterations needed before error !! falls below maxerr (or returns maxsteps if that many !! iterations occur first). real ( 8 ), intent ( out ) :: error !! A real variable in which an estimate of the error in the !! computed root will be stored and returned. real ( 8 ), intent ( out ) :: xcur !! A real variable in which the computed value of the root !! will be returned. ! Other variables: REAL ( 8 ) :: dfxcur , & fxcur , & fxleft , & fxprev1 , & fxright , & xnext , & xprev1 !------------------------------------------------------------------! ! Initialize variables fxleft = fnctn ( xleft ) fxright = fnctn ( xright ) dfxcur = 0.d0 fxcur = 0.d0 fxprev1 = 0.d0 xnext = 0.d0 xprev1 = 0.d0 ! Check that there is a root bracketed by 'xleft' and 'xright' IF ( fxleft * fxright > 0.0d0 ) THEN error stop ( 'No root in specified interval.' ) END IF ! Initialize variables) xcur = xleft fxcur = fxleft xprev1 = xright fxprev1 = fxright ! Iterate until root converges or reach 'maxsteps' DO steps = 1 , maxsteps ! If not 1st iteration, update variables for next iteration IF ( steps /= 1 ) THEN fxprev1 = fxcur fxcur = fnctn ( xcur ) IF ( fxleft * fxcur < 0.d0 ) THEN xright = xcur fxright = fxcur ELSE xleft = xcur fxleft = fxcur END IF END IF ! Compute a secant and use to find 'xnext' dfxcur = ( fxcur - fxprev1 ) / ( xcur - xprev1 ) xnext = xcur - fxcur / dfxcur ! If this 'xnext' value is outside of left or right bounds, ! instead use a bisection to find 'xnext' IF ( ( xnext < xleft ) . OR . ( xnext > xright ) ) THEN xnext = 5.d-1 * ( xleft + xright ) END IF ! Estimate error in approximating root and update variables error = ABS ( xnext - xcur ) xprev1 = xcur xcur = xnext ! If error less than tolerance, return IF ( error < maxerr ) RETURN END DO ! If reached maximum iterations, print a warning message error stop ( 'No solution found in specified number of steps.' ) END SUBROUTINE bis_secant"},{"title":"global_bis_sec – ISOFT","tags":"","loc":"proc/global_bis_sec.html","text":"public subroutine global_bis_sec(dx, error, fnctn, maxerr, maxsteps, numroots, roots, steps, verbose, xmax, xmin) A subroutine which finds the values of all roots of a\n function (or as many as will fit into the provided arrays)\n within a given range of values. This subroutine uses the\n hybrid bisection-secant root-finding algorithm. Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: dx The initial size of increment to use when examining\n function.  Minimum interval will be 0.01 of this. real(kind=8), intent(out), dimension(:) :: error A real array in which an estimate of the error in each\n computed root will be stored and returned. public pure function fnctn(x) The Fortran function for which the root will be\n found. Must take only one real argument, return a\n real argument. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x Return Value real(kind=8) real(kind=8), intent(in) :: maxerr A real value which specifies the the maximum allowable\n error in the computed root. The subroutine terminates\n once the error passes below this level. integer, intent(in) :: maxsteps An integer value for the maximum number of iterations\n applied to the algorithm before terminating. integer, intent(out) :: numroots An integer value which will return the number of roots\n for which brackets were found. A negative number\n indicates that an error occurred. real(kind=8), intent(out), dimension(:) :: roots A real array in which the computed values of each root\n will be returned. integer, intent(out), dimension(:) :: steps An integer array in which the number of iterations needed\n before error falls below maxerr for each root is stored\n and returned. logical, intent(in) :: verbose A logical variable which specifies whether to print\n progress to stdout as brackets found and at each\n iteration as root found. Also says whether to print a\n warning if 'dx' set to 'dxmin' during 'globrack' routine\n and if maximum number of iterations reached while finding\n root. real(kind=8), intent(in) :: xmax The upper limit of the range on which the subroutine will\n search for roots and brackets. real(kind=8), intent(in) :: xmin The lower limit of the range on which the subroutine will\n search for roots and brackets. Calls proc~~global_bis_sec~~CallsGraph proc~global_bis_sec global_bis_sec proc~global_brackets global_brackets proc~global_bis_sec->proc~global_brackets Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code global_bis_sec Source Code SUBROUTINE global_bis_sec ( dx , error , fnctn , maxerr , & maxsteps , numroots , roots , steps , & verbose , xmax , xmin ) !! A subroutine which finds the values of all roots of a !! function (or as many as will fit into the provided arrays) !! within a given range of values. This subroutine uses the !! hybrid bisection-secant root-finding algorithm. IMPLICIT NONE interface pure function fnctn ( x ) !! The Fortran function for which the root will be !! found. Must take only one real argument, return a !! real argument. real ( 8 ), intent ( in ) :: x real ( 8 ) :: fnctn end function fnctn end interface ! Input and output variables: integer , intent ( in ) :: maxsteps !! An integer value for the maximum number of iterations !! applied to the algorithm before terminating. logical , intent ( in ) :: verbose !! A logical variable which specifies whether to print !! progress to stdout as brackets found and at each !! iteration as root found. Also says whether to print a !! warning if 'dx' set to 'dxmin' during 'globrack' routine !! and if maximum number of iterations reached while finding !! root. real ( 8 ), intent ( in ) :: maxerr !! A real value which specifies the the maximum allowable !! error in the computed root. The subroutine terminates !! once the error passes below this level. real ( 8 ), intent ( in ) :: xmax !! The upper limit of the range on which the subroutine will !! search for roots and brackets. real ( 8 ), intent ( in ) :: xmin !! The lower limit of the range on which the subroutine will !! search for roots and brackets. real ( 8 ), intent ( inout ) :: dx !! The initial size of increment to use when examining !! function.  Minimum interval will be 0.01 of this. integer , intent ( out ) :: numroots !! An integer value which will return the number of roots !! for which brackets were found. A negative number !! indicates that an error occurred. integer , intent ( out ), dimension (:) :: steps !! An integer array in which the number of iterations needed !! before error falls below maxerr for each root is stored !! and returned. real ( 8 ), intent ( out ), dimension (:) :: error !! A real array in which an estimate of the error in each !! computed root will be stored and returned. real ( 8 ), intent ( out ), dimension (:) :: roots !! A real array in which the computed values of each root !! will be returned. ! Other variables: INTEGER :: counter = 0 , & maxroots = 0 REAL ( 8 ), DIMENSION (:,:), ALLOCATABLE :: brackets !------------------------------------------------------------------! ! Maximum number of roots is given by the size of the smallest ! of the arrays 'error', 'roots', and 'steps' (of course, if ! it is written properly then the calling program should have ! made these all the same size) maxroots = MIN ( SIZE ( error ), SIZE ( roots ), SIZE ( steps )) ALLOCATE ( brackets ( 2 , maxroots )) brackets = 0.d0 ! Get the sets of bracket pairs for the roots of 'fnctn', using ! the 'globrack' subroutine CALL global_brackets ( brackets , dx , fnctn , numroots , verbose , & xmax , xmin ) ! For each bracket pair, find the enclosed root using the ! 'biscnt' subroutine DO counter = 1 , numroots CALL bis_secant ( error ( counter ), fnctn , maxerr , maxsteps , & steps ( counter ), roots ( counter ), & brackets ( 1 , counter ), brackets ( 2 , counter )) END DO RETURN END SUBROUTINE global_bis_sec"},{"title":"global_brackets – ISOFT","tags":"","loc":"proc/global_brackets.html","text":"public subroutine global_brackets(brackets, dx, fnctn, numroots, verbose, xmax, xmin) A global bracket finder. For a given function it finds values\n on each side of each of the function's roots within a given\n range. Arguments Type Intent Optional Attributes Name real(kind=8), intent(out), dimension(:,:) :: brackets A 2 by n real array in which the left and right brackets\n will be stored and returned. Will find up to n sets of\n brackets. real(kind=8), intent(inout) :: dx The initial size of increment to use when examining\n function.  Minimum interval will be 0.01 of this. public pure function fnctn(x) The Fortran function for which the brackets will be\n found. Must take only one real argument, return a\n real argument. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x Return Value real(kind=8) integer, intent(out) :: numroots An integer value which will return the number of roots\n for which brackets were found. A negative number\n indicates that an error occurred. logical, intent(in) :: verbose A logical variable which specifies whether to print to\n stdout any bracket values which are found and warning\n messages when 'dx' set to 'dxmin'. real(kind=8), intent(in) :: xmax The upper limit of the range on which the subroutine will\n search for roots and brackets. real(kind=8), intent(in) :: xmin The lower limit of the range on which the subroutine will\n search for roots and brackets. Called by proc~~global_brackets~~CalledByGraph proc~global_brackets global_brackets proc~global_bis_sec global_bis_sec proc~global_bis_sec->proc~global_brackets Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code global_brackets Source Code SUBROUTINE global_brackets ( brackets , dx , fnctn , numroots , & verbose , xmax , xmin ) !! A global bracket finder. For a given function it finds values !! on each side of each of the function's roots within a given !! range. IMPLICIT NONE interface pure real ( 8 ) function fnctn ( x ) !!The Fortran function for which the brackets will be !! found. Must take only one real argument, return a !! real argument. real ( 8 ), intent ( in ) :: x end function fnctn end interface ! Input and output variables: logical , intent ( in ) :: verbose !! A logical variable which specifies whether to print to !! stdout any bracket values which are found and warning !! messages when 'dx' set to 'dxmin'. real ( 8 ), intent ( in ) :: xmax !! The upper limit of the range on which the subroutine will !! search for roots and brackets. real ( 8 ), intent ( in ) :: xmin !! The lower limit of the range on which the subroutine will !! search for roots and brackets. real ( 8 ), intent ( inout ) :: dx !! The initial size of increment to use when examining !! function.  Minimum interval will be 0.01 of this. integer , intent ( out ) :: numroots !! An integer value which will return the number of roots !! for which brackets were found. A negative number !! indicates that an error occurred. real ( 8 ), intent ( out ), dimension (:,:) :: brackets !! A 2 by n real array in which the left and right brackets !! will be stored and returned. Will find up to n sets of !! brackets. ! Other variables: REAL ( 8 ) :: dfdx = 0.d0 , & dfdxh = 0.d0 , & dldx = 0.d0 , & dldxh = 0.d0 , & dxmin = 0.d0 , & dxh = 0.d0 , & fleft = 0.d0 , & fmid = 0.d0 , & fright = 0.d0 , & scaleval = 0.d0 , & xleft = 0.d0 , & xright = 0.d0 , & xmid = 0.d0 !------------------------------------------------------------------! ! Check if passed array is big enough to hold returned data IF ( SIZE ( brackets , 1 ) < 2 ) THEN numroots = - 1 WRITE ( 0 , 2000 ) RETURN END IF ! Initialize variables dxmin = 1.d-2 * dx numroots = 0 xleft = xmin fleft = fnctn ( xmin ) ! Repeat this loop until have traversed range [xmin:xmax], or ! until brackets array is filled DO WHILE ( xleft <= xmax ) ! Make sure that xright <= xmax dx = MIN ( dx , xmax - xmin ) ! Get values and derivatives for next step along the ! function xright = xleft + dx fright = fnctn ( xright ) scaleval = MAX ( 1.0d0 , ABS ( xleft )) / MAX ( ABS ( fleft ), & ABS ( fright )) dfdx = scaleval * ( fright - fleft ) / dx dldx = SIGN ( 1.0d0 , dfdx ) * SQRT ( 1.0d0 + dfdx ** 2.d0 ) ! Find derivative of secant length (called 'dldx' when found ! above) at midpoint between 'xleft' and 'xright' ('dldxh'). ! If difference between 'dldx' and 'dldxh' is too great, ! reduce 'dx' and repeat. DO dxh = 5 d - 1 * dx xmid = xleft + dxh fmid = fnctn ( xmid ) dfdxh = scaleval * ( fmid - fleft ) / dxh dldxh = SIGN ( 1.0d0 , dfdxh ) * SQRT ( 1.0d0 + dfdxh ** 2 ) IF ( ( ABS ( dldx - dldxh ) > 5.d-1 * ABS ( dldx ) ) & . AND . ( dxh > dxmin ) ) THEN dx = dxh xright = xmid fright = fmid dldx = dldxh ELSE EXIT END IF END DO ! If difference between 'dldx' and 'dldxh' is too small, ! make step-size larger for next iteration IF ( ABS ( dldx - dldxh ) < 1.d-1 * ABS ( dldx ) ) THEN dx = 1.5d0 * dx ! If diference between 'dldx' and 'dldxh' is too small, but ! can't go smaller without falling below 'dxmin', set 'dx = ! dxmin' and print warning message ELSE IF ( ( ABS ( dldx - dldxh ) > 5.d-1 * ABS ( dldx ) ) & . AND . ( dxh < dxmin ) ) THEN dx = dxmin xright = xleft + dx fright = fnctn ( xright ) IF ( verbose . EQV . . TRUE . ) WRITE ( 6 , 2010 ) dxmin END IF ! Otherwise keep 'dx' the same (no action needs to be taken) ! If the signs of 'fleft' and 'fright' are opposite, and if ! signs of 'fright' and the derivative of 'fnctn(xleft)' are ! the same, then 'xleft' and 'xright' bracket a root IF ( ( fleft * fright < 0 ) . AND . ( fright * ( fleft - & fnctn ( xleft - dxmin ) ) > 0 ) ) THEN numroots = numroots + 1 brackets ( 1 : 2 , numroots ) = ( / xleft , xright / ) IF ( verbose . EQV . . TRUE . ) WRITE ( 6 , 2020 ) xleft , xright ! If have filled 'brackets', then leave loop IF ( numroots >= SIZE ( brackets , 2 ) ) EXIT END IF ! Update variables for next iteration xleft = xright fleft = fright END DO !--------------------------------------------------------------! !                    Write format statements                   ! !--------------------------------------------------------------! 2000 FORMAT ( 'GLOBRACK: ERROR: Passed array too small to hold ' ,& 'returned values. Must have at least 2 columns.' ) 2010 FORMAT ( 'GLOBRACK: WARNING: Value of dx set to minimum ' & , 'value: ' , 1 PG22 . 15 ) 2020 FORMAT ( 'GLOBRACK: Found root bracketed by ' , 1 PG22 . 15 , & ' and' , / , & 'GLOBRACK: ' , 1 PG22 . 15 ) !--------------------------------------------------------------! RETURN END SUBROUTINE global_brackets"},{"title":"static_plume_melt – ISOFT","tags":"","loc":"proc/static_plume_melt.html","text":"private function static_plume_melt(this) result(melt) Computes and returns the melt rate at the bottom of the ice\n shelf due to interaction with the plume. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice shelf. Contents Source Code static_plume_melt Source Code function static_plume_melt ( this ) result ( melt ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the melt rate at the bottom of the ice ! shelf due to interaction with the plume. ! class ( static_plume ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate at the base of the ice shelf. melt => this % melt_formulation % melt_rate () end function static_plume_melt"},{"title":"static_plume_drag_parameter – ISOFT","tags":"","loc":"proc/static_plume_drag_parameter.html","text":"private function static_plume_drag_parameter(this) result(drag) Computes and returns a quantity which may be necessary to determine\n the frictional drag the plume exerts on the bottom of the ice\n shelf. The plume would actually tend to exert no drag on the bottom\n of the ice shelf, but this method is present so that there is a\n consistent interface with the ground data type. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. Calls proc~~static_plume_drag_parameter~~CallsGraph proc~static_plume_drag_parameter static_plume_drag_parameter uniform_scalar_field uniform_scalar_field proc~static_plume_drag_parameter->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code static_plume_drag_parameter Source Code function static_plume_drag_parameter ( this ) result ( drag ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns a quantity which may be necessary to determine ! the frictional drag the plume exerts on the bottom of the ice ! shelf. The plume would actually tend to exert no drag on the bottom ! of the ice shelf, but this method is present so that there is a ! consistent interface with the [[ground(type)]] data type. ! class ( static_plume ), intent ( in ) :: this class ( scalar_field ), pointer :: drag !! The melt rate at the base of the ice sheet. type ( uniform_scalar_field ) :: dummy call dummy % allocate_scalar_field ( drag ) drag = uniform_scalar_field ( 0.0_r8 ) call drag % set_temp () #ifdef DEBUG call logger % debug ( 'static_plume%drag_parameter' , 'Returned plume drag parameter.' ) #endif end function static_plume_drag_parameter"},{"title":"static_plume_water_density – ISOFT","tags":"","loc":"proc/static_plume_water_density.html","text":"private function static_plume_water_density(this) result(density) Computes and returns the density of the plume water beneath the ice\n shelf. The density of this water would vary depending on how much \n saline ambient water has been entrained into the plume versus how\n much fresh water has been released due to melting. However, the\n Boussinesq approximation is used here and only a single reference \n density is returned. Note Based on my approach to non-dimensionalisation, I'm pretty\n sure the density should always be 1, making this method\n unneccessary. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value real(kind=r8) The density of the water at the base of the ice sheet. Contents Source Code static_plume_water_density Source Code function static_plume_water_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the density of the plume water beneath the ice ! shelf. The density of this water would vary depending on how much ! saline ambient water has been entrained into the plume versus how ! much fresh water has been released due to melting. However, the ! Boussinesq approximation is used here and only a single reference ! density is returned. ! ! @NOTE Based on my approach to non-dimensionalisation, I'm pretty ! sure the density should always be 1, making this method ! unneccessary. ! class ( static_plume ), intent ( in ) :: this real ( r8 ) :: density !! The density of the water at the base of the ice sheet. density = 1.0_r8 #ifdef DEBUG call logger % debug ( 'static_plume%water_density' , 'static_plume has average density ' // & trim ( str ( density )) // '.' ) #endif end function static_plume_water_density"},{"title":"static_plume_data_size – ISOFT","tags":"","loc":"proc/static_plume_data_size.html","text":"private function static_plume_data_size(this) Returns the number of elements in the plume's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value integer The number of elements in the plume's state vector. Contents Source Code static_plume_data_size Source Code function static_plume_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the plume's state vector. ! This is the size of the vector returned by ! [[static_plume(type):state_vector]] and taken as an argument by ! [[static_plume(type):update]]. ! class ( static_plume ), intent ( in ) :: this integer :: static_plume_data_size !! The number of elements in the plume's state vector. static_plume_data_size = this % thickness % raw_size () + this % velocity % raw_size () + & this % velocity_dx % raw_size () + this % temperature % raw_size () + & this % temperature_dx % raw_size () + this % salinity % raw_size () + & this % salinity_dx % raw_size () #ifdef DEBUG call logger % debug ( 'static_plume%data_size' , 'static_plume shelf has ' // & trim ( str ( static_plume_data_size )) // ' elements ' // & 'in its state vector.' ) #endif end function static_plume_data_size"},{"title":"static_plume_state_vector – ISOFT","tags":"","loc":"proc/static_plume_state_vector.html","text":"private function static_plume_state_vector(this) result(state_vector) Returns the state vector for the current state of the plume. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:),allocatable The state vector describing the plume. Contents Source Code static_plume_state_vector Source Code function static_plume_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the plume. ! This takes the form of a 1D array. ! class ( static_plume ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the plume. state_vector = [ this % thickness % raw (), this % velocity % raw (), & this % velocity_dx % raw (), this % temperature % raw (), & this % temperature_dx % raw (), this % salinity % raw (), & this % salinity_dx % raw ()] #ifdef DEBUG call logger % debug ( 'static_plume%state_vector' , 'Returning state vector ' // & 'for plume.' ) #endif end function static_plume_state_vector"},{"title":"static_plume_initialise – ISOFT","tags":"","loc":"proc/static_plume_initialise.html","text":"private subroutine static_plume_initialise(this, domain, resolution, thickness, velocity, temperature, salinity, entrainment_formulation, melt_formulation, ambient_conds, eos, boundaries, delta, nu, mu, r_val, phi) Instantiates a plume object with initial coniditions\n provided by the arguments.At present only a 1D model is\n supported. If information is provided for higher dimensions then\n it will be ignored. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(out) :: this A plume object with its domain and initial conditions set according\n to the arguments of the constructor function. real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the plume. The first index represents the dimension for which the\n boundaries apply. If the second index is 1 then it corresponds to\n the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( scalar_func ) :: thickness A function which calculates the initial value of the thickness of \n the plume at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the water at a given location in a plume. procedure( scalar_func ) :: temperature A function which calculates the initial value of the temperature of \n the plume at a given location. procedure( scalar_func ) :: salinity A function which calculates the initial value of the salinity of \n the plume at a given location. class( abstract_entrainment ), intent(inout), optional allocatable :: entrainment_formulation An object which calculates entrainment into the plume. Will\n be unallocated on exit. Defaults to that used by Jenkins\n (1991) with the coefficient $E_0 = 1$. class( abstract_melt_relationship ), intent(inout), optional allocatable :: melt_formulation An object which calculates melting and the resulting thermal\n transfer into/out of the plume. Will be unallocated on\n exit. Defaults to that used by Dallaston et al. (2015),\n scaled to be consistent with the nondimensionalisation used\n here. class( ambient_conditions ), intent(inout), optional allocatable :: ambient_conds An object specifying the salinity and temperature of the\n ambient ocean. Will be unallocated on exit. Defaults to\n uniform ambient salinity and temperature, both of which are\n set to 0 (as temperature and salinity are measured relative\n to some reference value). class( equation_of_state ), intent(inout), optional allocatable :: eos An object specifying the equation of state for the water in\n the plume. Will be unallocated on exit. Defaults to\n linearised equation of state with no temperature dependence\n and a haline contraction coefficient of 1. The reference\n density is set to be 1 in the dimensionless units when\n salinity and temeprature are 0. class( plume_boundary ), intent(inout), optional allocatable :: boundaries An object providing the boundary conditions for the\n plume. Will be unallocated on exit. Defaults to those used by\n Dallaston et al. (2015). real(kind=r8), intent(in), optional :: delta The dimensionless ratio \\delta \\equiv\n \\frac{D_0}{h_0} . Defaults to 0.036. real(kind=r8), intent(in), optional :: nu The dimensionless ratio \\nu \\equiv\n \\frac{\\kappa_0}{x_0U_o} . Defaults to 0. real(kind=r8), intent(in), optional :: mu The dimensionless ratio \\mu \\equiv\n \\frac{\\C_dx_0}{D_0} . Defaults to 0. real(kind=r8), intent(in), optional :: r_val The dimensionless ratio of the water density to the ice shelf\n density, r = \\rho_0/\\rho_i. Defaults to 1.12. real(kind=r8), intent(in), optional :: phi The inverse Rossby number, \\Phi \\equif\n \\frac{fx_0}{U_0} . Defaults to 0. Calls proc~~static_plume_initialise~~CallsGraph proc~static_plume_initialise static_plume_initialise cheb1d_scalar_field cheb1d_scalar_field proc~static_plume_initialise->cheb1d_scalar_field cheb1d_vector_field cheb1d_vector_field proc~static_plume_initialise->cheb1d_vector_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code static_plume_initialise Source Code subroutine static_plume_initialise ( this , domain , resolution , thickness , velocity , & temperature , salinity , entrainment_formulation , & melt_formulation , ambient_conds , eos , boundaries , & delta , nu , mu , r_val , phi ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Instantiates a [[plume(type)]] object with initial coniditions ! provided by the arguments.At present only a 1D model is ! supported. If information is provided for higher dimensions then ! it will be ignored. ! class ( static_plume ), intent ( out ) :: this !! A plume object with its domain and initial conditions set according !! to the arguments of the constructor function. real ( r8 ), dimension (:,:), intent ( in ) :: domain !! An array containing the upper and lower limits of the domain for !! the plume. The first index represents the dimension for which the !! boundaries apply. If the second index is 1 then it corresponds to !! the lower bound. If the second index is 2 then it corresponds to !! the upper bound. integer , dimension (:), intent ( in ) :: resolution !! The number of data points in each dimension procedure ( scalar_func ) :: thickness !! A function which calculates the initial value of the thickness of !! the plume at a given location. procedure ( velocity_func ) :: velocity !! A function which calculates the initial value of the velocity !! (vector) of the water at a given location in a plume. procedure ( scalar_func ) :: temperature !! A function which calculates the initial value of the temperature of !! the plume at a given location. procedure ( scalar_func ) :: salinity !! A function which calculates the initial value of the salinity of !! the plume at a given location. class ( abstract_entrainment ), allocatable , optional , & intent ( inout ) :: entrainment_formulation !! An object which calculates entrainment into the plume. Will !! be unallocated on exit. Defaults to that used by Jenkins !! (1991) with the coefficient $E_0 = 1$. class ( abstract_melt_relationship ), allocatable , optional , & intent ( inout ) :: melt_formulation !! An object which calculates melting and the resulting thermal !! transfer into/out of the plume. Will be unallocated on !! exit. Defaults to that used by Dallaston et al. (2015), !! scaled to be consistent with the nondimensionalisation used !! here. class ( ambient_conditions ), allocatable , optional , & intent ( inout ) :: ambient_conds !! An object specifying the salinity and temperature of the !! ambient ocean. Will be unallocated on exit. Defaults to !! uniform ambient salinity and temperature, both of which are !! set to 0 (as temperature and salinity are measured relative !! to some reference value). class ( equation_of_state ), allocatable , optional , & intent ( inout ) :: eos !! An object specifying the equation of state for the water in !! the plume. Will be unallocated on exit. Defaults to !! linearised equation of state with no temperature dependence !! and a haline contraction coefficient of 1. The reference !! density is set to be 1 in the dimensionless units when !! salinity and temeprature are 0. class ( plume_boundary ), allocatable , optional , & intent ( inout ) :: boundaries !! An object providing the boundary conditions for the !! plume. Will be unallocated on exit. Defaults to those used by !! Dallaston et al. (2015). real ( r8 ), optional , intent ( in ) :: delta !! The dimensionless ratio \\delta \\equiv !! \\frac{D_0}{h_0}. Defaults to 0.036. real ( r8 ), optional , intent ( in ) :: nu !! The dimensionless ratio \\nu \\equiv !! \\frac{\\kappa_0}{x_0U_o}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: mu !! The dimensionless ratio \\mu \\equiv !! \\frac{\\C_dx_0}{D_0}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: r_val !! The dimensionless ratio of the water density to the ice shelf !! density,  r = \\rho_0/\\rho_i.  Defaults to 1.12. real ( r8 ), optional , intent ( in ) :: phi !! The inverse Rossby number, \\Phi \\equif !! \\frac{fx_0}{U_0}. Defaults to 0. integer :: i , btype_l , btype_u , bdepth_l , bdepth_u i = size ( velocity ([ 0._r8 ])) this % thickness = cheb1d_scalar_field ( resolution ( 1 ), thickness , domain ( 1 , 1 ), domain ( 1 , 2 )) this % velocity = cheb1d_vector_field ( resolution ( 1 ), velocity , domain ( 1 , 1 ), domain ( 1 , 2 ), i - 1 ) this % temperature = cheb1d_scalar_field ( resolution ( 1 ), temperature , domain ( 1 , 1 ), domain ( 1 , 2 )) this % salinity = cheb1d_scalar_field ( resolution ( 1 ), salinity , domain ( 1 , 1 ), domain ( 1 , 2 )) this % thickness_size = this % thickness % raw_size () this % velocity_size = this % velocity % raw_size () this % temperature_size = this % temperature % raw_size () this % salinity_size = this % salinity % raw_size () this % velocity_dx = this % velocity % d_dx ( 1 ) this % salinity_dx = this % salinity % d_dx ( 1 ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( present ( entrainment_formulation )) then call move_alloc ( entrainment_formulation , this % entrainment_formulation ) else allocate ( jenkins1991_entrainment :: this % entrainment_formulation ) end if if ( present ( melt_formulation )) then call move_alloc ( melt_formulation , this % melt_formulation ) else allocate ( dallaston2015_melt :: this % melt_formulation ) end if if ( present ( ambient_conds )) then call move_alloc ( ambient_conds , this % ambient_conds ) else allocate ( uniform_ambient_conditions :: this % ambient_conds ) end if if ( present ( eos )) then call move_alloc ( eos , this % eos ) else allocate ( linear_eos :: this % eos ) end if if ( present ( boundaries )) then call move_alloc ( boundaries , this % boundaries ) else allocate ( simple_plume_boundary :: this % boundaries ) end if if ( present ( delta )) then this % delta = delta else this % delta = 0.036_r8 end if if ( present ( nu )) then this % nu = nu else this % nu = 0.0_r8 end if if ( present ( mu )) then this % mu = mu else this % mu = 0.0_r8 end if if ( present ( r_val )) then this % r_val = r_val else this % r_val = 1.12_r8 end if if ( present ( phi )) then this % phi = phi else this % phi = 0.0_r8 end if this % time = 0.0_r8 #ifdef DEBUG call logger % debug ( 'static_plume' , 'Initialised new ice shelf object.' ) #endif end subroutine static_plume_initialise"},{"title":"static_plume_update – ISOFT","tags":"","loc":"proc/static_plume_update.html","text":"private subroutine static_plume_update(this, state_vector, ice_thickness) Updates the state of the plume from its state vector. The state\n vector is a real array containing the value of each of the plume's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n plume. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate. Contents Source Code static_plume_update Source Code subroutine static_plume_update ( this , state_vector , ice_thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the plume from its state vector. The state ! vector is a real array containing the value of each of the plume's ! properties at each of the locations on the grid used in discretization. ! class ( static_plume ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! plume. class ( scalar_field ), optional , intent ( in ) :: ice_thickness !! The ice thickness which, if present, will be used to update !! the calculation of the melt rate. integer :: i !TODO: Add some assertion-like checks that the state vector is the right size call this % thickness % set_from_raw ( state_vector ( 1 : this % thickness_size )) i = 1 + this % thickness_size call this % velocity % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % velocity_dx % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % temperature % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % temperature_dx % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % salinity % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) i = i + this % salinity_size call this % salinity_dx % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) if ( present ( ice_thickness )) then call this % melt_formulation % solve_for_melt ( this % velocity , & - ice_thickness / this % r_val , & this % temperature , & this % salinity , & this % thickness , & this % time ) end if #ifdef DEBUG call logger % debug ( 'static_plume%update' , 'Updated state of plume.' ) #endif end subroutine static_plume_update"},{"title":"static_plume_read_data – ISOFT","tags":"","loc":"proc/static_plume_read_data.html","text":"private subroutine static_plume_read_data(this, file_id, group_name, error) Reads the state of the plume object from an HDF file in the\n specified group. This sets the thickness, velocity, temperature,\n salinity dataset, and parameter values. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Calls proc~~static_plume_read_data~~CallsGraph proc~static_plume_read_data static_plume_read_data h5ltget_attribute_string_f h5ltget_attribute_string_f proc~static_plume_read_data->h5ltget_attribute_string_f h5gopen_f h5gopen_f proc~static_plume_read_data->h5gopen_f h5gclose_f h5gclose_f proc~static_plume_read_data->h5gclose_f str str proc~static_plume_read_data->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code static_plume_read_data Source Code subroutine static_plume_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the plume object from an HDF file in the ! specified group. This sets the thickness, velocity, temperature, ! salinity dataset, and parameter values. ! class ( static_plume ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err real ( r8 ), dimension ( 1 ) :: param character ( len = 50 ) :: base_type ret_err = 0 call h5gopen_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % error ( 'static_plume%read_data' , 'Could not open HDF group \"' // & group_name // '\", so no IO performed.' ) return end if call h5ltget_attribute_string_f ( file_id , group_name , hdf_type_attr , & base_type , error ) if ( trim ( base_type ) /= hdf_type_name ) then call logger % error ( 'static_plume%read_data' , 'Trying to read data from ' // & 'basal_surface of type other than plume.' ) error = - 1 return end if !call h5ltget_attribute_double_f(file_id, group_name, hdf_delta, & !                                param, error) !this%delta = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_nu, & !                                param, error) !this%nu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_mu, & !                                param, error) !this%mu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_r, & !                                param, error) !this%r_val = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_phi, & !                                param, error) !this%phi = param(1) !if (error /= 0) then !  call logger%warning('static_plume%read_data','Error code '//     & !                      trim(str(error))//' returned when '//  & !                      'reading attributes from HDF group '// & !                      group_name) !  ret_err = error !end if call this % thickness % read_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume thickness field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % read_hdf ( group_id , hdf_velocity , error ) this % velocity_dx = this % velocity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'static_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume velocity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % read_hdf ( group_id , hdf_temperature , error ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'static_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume temperature field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % read_hdf ( group_id , hdf_salinity , error ) this % salinity_dx = this % salinity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'static_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume salinity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err call logger % trivia ( 'static_plume%read_data' , 'Read plume data from HDF group ' // & group_name ) end subroutine static_plume_read_data"},{"title":"static_plume_write_data – ISOFT","tags":"","loc":"proc/static_plume_write_data.html","text":"private subroutine static_plume_write_data(this, file_id, group_name, error) Writes the state of the plume object to an HDF file in the\n specified group. This will consist of a thickness, a velocity, a\n temperature, and a salinity dataset. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Calls proc~~static_plume_write_data~~CallsGraph proc~static_plume_write_data static_plume_write_data str str proc~static_plume_write_data->str h5ltset_attribute_string_f h5ltset_attribute_string_f proc~static_plume_write_data->h5ltset_attribute_string_f h5gclose_f h5gclose_f proc~static_plume_write_data->h5gclose_f h5gcreate_f h5gcreate_f proc~static_plume_write_data->h5gcreate_f h5ltset_attribute_double_f h5ltset_attribute_double_f proc~static_plume_write_data->h5ltset_attribute_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code static_plume_write_data Source Code subroutine static_plume_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the plume object to an HDF file in the ! specified group. This will consist of a thickness, a velocity, a ! temperature, and a salinity dataset. ! class ( static_plume ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err ret_err = 0 call h5gcreate_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned ' // & 'when creating HDF group \"' // group_name // '\"' ) call logger % error ( 'static_plume%write_data' , 'Data IO not performed for plume' ) return end if call h5ltset_attribute_string_f ( file_id , group_name , hdf_type_attr , & hdf_type_name , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_delta , & [ this % delta ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_nu , & [ this % nu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_mu , & [ this % mu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_r , & [ this % r_val ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_phi , & [ this % phi ], 1_size_t , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing attribute to HDF group ' // & group_name ) ret_err = error end if call this % thickness % write_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume thickness field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % write_hdf ( group_id , hdf_velocity , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume velocity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % write_hdf ( group_id , hdf_temperature , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume temperature field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % write_hdf ( group_id , hdf_salinity , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume salinity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'static_plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err #ifdef DEBUG call logger % debug ( 'static_plume%write_data' , 'Wrote plume data to HDF group ' // & group_name ) #endif end subroutine static_plume_write_data"},{"title":"static_plume_solve – ISOFT","tags":"","loc":"proc/static_plume_solve.html","text":"private subroutine static_plume_solve(this, ice_thickness, ice_density, ice_temperature, time, success) Would normally solve, but for this static implementation of the\n plume it does nothing. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise Contents Source Code static_plume_solve Source Code subroutine static_plume_solve ( this , ice_thickness , ice_density , ice_temperature , & time , success ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Would normally solve, but for this static implementation of the ! plume it does nothing. ! class ( static_plume ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: ice_thickness !! Thickness of the ice above the basal surface real ( r8 ), intent ( in ) :: ice_density !! The density of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: ice_temperature !! The temperature of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: time !! The time to which the basal surface should be solved logical , intent ( out ) :: success !! True if the solver is successful, false otherwise call ice_thickness % guard_temp () this % time = time call this % melt_formulation % solve_for_melt ( this % velocity , & - ice_thickness / this % r_val , & this % temperature , & this % salinity , & this % thickness , & time ) success = . true . call ice_thickness % clean_temp () end subroutine static_plume_solve"},{"title":"time_step – ISOFT","tags":"","loc":"proc/time_step.html","text":"private function time_step(this) Calculates an appropriate time step with which to integrate the\n cryosphere so as not to cause numerical instability. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this Return Value real(kind=r8) Contents Source Code time_step Source Code function time_step ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Calculates an appropriate time step with which to integrate the ! cryosphere so as not to cause numerical instability. ! class ( cryosphere ), intent ( inout ) :: this real ( r8 ) :: time_step time_step = this % dt_factor * this % ice % time_step () end function time_step"},{"title":"state_vector – ISOFT","tags":"","loc":"proc/state_vector.html","text":"private function state_vector(this) Returns the state vector for the current state of the\n cryosphere. This takes the form of a 1D array. This routine is\n mainly useful for unit-testing. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:),allocatable Contents Source Code state_vector Source Code function state_vector ( this ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Returns the state vector for the current state of the ! cryosphere. This takes the form of a 1D array. This routine is ! mainly useful for unit-testing. ! class ( cryosphere ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector state_vector = [ this % ice % state_vector (), this % sub_ice % state_vector ()] end function state_vector"},{"title":"get_time – ISOFT","tags":"","loc":"proc/get_time.html","text":"private pure function get_time(this) Returns the current time of the cryosphere system. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(in) :: this Return Value real(kind=r8) Contents Source Code get_time Source Code pure function get_time ( this ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Returns the current time of the cryosphere system. ! class ( cryosphere ), intent ( in ) :: this real ( r8 ) :: get_time get_time = this % time end function get_time"},{"title":"initialise – ISOFT","tags":"","loc":"proc/initialise.html","text":"private subroutine initialise(this, ice, sub_ice) Initialise a cryosphere object from the provided\n components. This object will model the evolution of a\n glacier/ice shelf/ice sheet and its surroundings. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(out) :: this class( glacier ), intent(inout), allocatable :: ice An object modelling the ice sheet or shelf component of this\n system. Will be deallocated on return. class( basal_surface ), intent(inout), allocatable :: sub_ice An object modelling the component of this system beneath the\n ice. Will be deallocated on return. Contents Source Code initialise Source Code subroutine initialise ( this , ice , sub_ice ) !* Author: Christopher MacMackin !  Date: November 2016 ! ! Initialise a cryosphere object from the provided ! components. This object will model the evolution of a ! glacier/ice shelf/ice sheet and its surroundings. ! class ( cryosphere ), intent ( out ) :: this class ( glacier ), allocatable , intent ( inout ) :: ice !! An object modelling the ice sheet or shelf component of this !! system. Will be deallocated on return. class ( basal_surface ), allocatable , intent ( inout ) :: sub_ice !! An object modelling the component of this system beneath the !! ice. Will be deallocated on return. call move_alloc ( ice , this % ice ) call move_alloc ( sub_ice , this % sub_ice ) this % time = 0.0_r8 this % first_integration = . true . #ifdef DEBUG call logger % debug ( 'cryosphere' , 'Instantiated new cryosphere object.' ) #endif end subroutine initialise"},{"title":"reduce_time_step – ISOFT","tags":"","loc":"proc/reduce_time_step.html","text":"private subroutine reduce_time_step(this) Reuces the time step by a factor of 2, unless doing so would\n take it below the minimum value. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this Calls proc~~reduce_time_step~~CallsGraph proc~reduce_time_step reduce_time_step str str proc~reduce_time_step->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code reduce_time_step Source Code subroutine reduce_time_step ( this ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Reuces the time step by a factor of 2, unless doing so would ! take it below the minimum value. ! class ( cryosphere ), intent ( inout ) :: this real ( r8 ) :: new_factor new_factor = 0.7_r8 * this % dt_factor if ( new_factor < this % min_dt_factor ) then this % dt_factor = this % min_dt_factor call logger % warning ( 'cryosphere%reduce_time_step' , 'Attempting to ' // & 'reduce time step factor below minimum value ' // & 'of ' // trim ( str ( this % min_dt_factor ))) else this % dt_factor = new_factor end if #ifdef DEBUG call logger % debug ( 'cryosphere%reduce_time_step' , 'Reducing time ' // & 'step by factor of ' // trim ( str ( this % dt_factor ))) #endif end subroutine reduce_time_step"},{"title":"increase_time_step – ISOFT","tags":"","loc":"proc/increase_time_step.html","text":"private subroutine increase_time_step(this) Increases the time step by a factor of 2, unless doing so would\n take it above the maximum. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this Contents Source Code increase_time_step Source Code subroutine increase_time_step ( this ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Increases the time step by a factor of 2, unless doing so would ! take it above the maximum. ! class ( cryosphere ), intent ( inout ) :: this this % dt_factor = min ( 1.2_r8 * this % dt_factor , 1._r8 ) #ifdef DEBUG call logger % debug ( 'cryosphere%increase_time_step' , 'Reducing time ' // & 'step by factor of ' // trim ( str ( this % dt_factor ))) #endif end subroutine increase_time_step"},{"title":"integrate – ISOFT","tags":"","loc":"proc/integrate.html","text":"private subroutine integrate(this, time) Integrates the cryosphere forward until the specified time is\n reached. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this real(kind=r8), intent(in) :: time The time to which to integrate the cryosphere Calls proc~~integrate~~CallsGraph proc~integrate integrate str str proc~integrate->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code integrate Source Code subroutine integrate ( this , time ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Integrates the cryosphere forward until the specified `time` is ! reached. ! class ( cryosphere ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time !! The time to which to integrate the cryosphere class ( glacier ), dimension (:), allocatable :: old_glaciers logical :: success , past_fail real ( r8 ) :: t , old_t , dt real ( r8 ), allocatable , dimension (:) :: sub_state past_fail = . false . if ( time <= this % time ) then call logger % warning ( 'cryosphere%integrate' , 'Request made to ' // & 'integrate cryosphere to earlier time ' // & 'than present state. No action taken.' ) return end if ! Normally the plume should be solved at the end of the previous ! iteration, but in the first iteration obviously there hasn't ! been a chance for this to happen yet. if ( this % first_integration ) then ! As I am integrating only semi-implicitly and solving the plume ! for the current (rather than future) state, I think I should ! pass the current time. I only *think* that this is correct, ! however. call this % sub_ice % solve ( this % ice % ice_thickness (), this % ice % ice_density (), & this % ice % ice_temperature (), this % time , success ) this % first_integration = . false . if (. not . success ) then call logger % fatal ( 'cryosphere%integrate' , 'Failed to solve plume ' // & 'with initial ice configuration. Writing ' // & 'cryosphere state to file \"' // hdf_crash_file // '\".' ) call this % write_data ( hdf_crash_file ) error stop end if end if allocate ( old_glaciers ( 1 ), mold = this % ice ) old_t = this % time dt = this % time_step () if ( dt < 0.5_r8 * ( time - this % time )) then t = old_t + dt else if ( t + dt > time ) then t = time else t = 0.5_r8 * ( time + old_t ) end if do while ( t <= time ) old_glaciers ( 1 ) = this % ice call this % ice % integrate ( old_glaciers , this % sub_ice % basal_melt (), & this % sub_ice % basal_drag_parameter (), & this % sub_ice % water_density (), t , success ) if ( past_fail ) then call this % write_data ( 'isoft_post_failure.h5' ) past_fail = . false . end if if (. not . success ) then this % ice = old_glaciers ( 1 ) if ( this % dt_factor > this % min_dt_factor ) then call logger % warning ( 'cryosphere%integrate' , 'Failure in nonlinear ' // & 'solver. Reducing time step and trying again.' ) call this % reduce_time_step () dt = this % time_step () if ( dt < 0.5_r8 * ( time - old_t )) then t = old_t + dt else if ( old_t + dt > time ) then t = time else t = 0.5_r8 * ( time + old_t ) end if cycle else call logger % fatal ( 'cryosphere%integrate' , 'Failed to integrate ' // & 'glacier to time ' // trim ( str ( t )) // '! Writing ' // & 'cryosphere state to file \"' // hdf_crash_file // '\".' ) call this % write_data ( hdf_crash_file ) iplvl = 2 t = min ( old_t + this % ice % time_step (), time , 0.5_r8 * ( time + old_t )) call this % ice % integrate ( old_glaciers , this % sub_ice % basal_melt (), & this % sub_ice % basal_drag_parameter (), & this % sub_ice % water_density (), t , success ) error stop end if end if ! Solve the plume so that it is ready for use in the next step of ! the time integration. sub_state = this % sub_ice % state_vector () call this % sub_ice % solve ( this % ice % ice_thickness (), this % ice % ice_density (), & this % ice % ice_temperature (), t , success ) if ( success ) then call logger % trivia ( 'cryosphere%integrate' , 'Successfully integrated ' // & 'cryosphere to time ' // trim ( str ( t ))) else call this % write_data ( 'isoft_failed_state.h5' ) this % ice = old_glaciers ( 1 ) call this % sub_ice % update ( sub_state , this % ice % ice_thickness ()) if ( this % dt_factor > this % min_dt_factor ) then call logger % warning ( 'cryosphere%integrate' , 'Failure in plume ' // & 'solver. Reducing time step and trying again.' ) call this % reduce_time_step () dt = this % time_step () if ( dt < 0.5_r8 * ( time - old_t )) then t = old_t + dt else if ( old_t + dt > time ) then t = time else t = 0.5_r8 * ( time + old_t ) end if call this % write_data ( 'isoft_pre_failure.h5' ) past_fail = . true . cycle else call logger % fatal ( 'cryosphere%integrate' , 'Failed to solve plume ' // & 'at time ' // trim ( str ( t )) // '! Writing cryosphere ' // & 'state to file \"' // hdf_crash_file // '\".' ) call this % write_data ( hdf_crash_file ) error stop end if end if call this % increase_time_step () if ( t >= time ) exit old_t = t dt = this % time_step () if ( dt < 0.5_r8 * ( time - t )) then t = t + dt else if ( t + dt > time ) then t = time else t = 0.5_r8 * ( time + t ) end if this % time = old_t end do this % time = time call logger % info ( 'cryosphere%integrate' , 'Successfully integrated ' // & 'cryosphere to time ' // trim ( str ( t ))) end subroutine integrate"},{"title":"read_data – ISOFT","tags":"","loc":"proc/read_data.html","text":"private subroutine read_data(this, infile, set_time) Reads the data describing the cryosphere from an HDF5 file on\n the disc. h5open_f must have been called once prior to using\n this method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this character(len=*), intent(in) :: infile The file from which to read the data describing the state of the \n cryosphere logical, intent(in), optional :: set_time If present and .true. then set the simulation time of the\n cryosphere to be the same as that in the HDF file. Otherwise,\n leave it unchanged. Calls proc~~read_data~~CallsGraph proc~read_data read_data interface~version version proc~read_data->interface~version str str proc~read_data->str h5fopen_f h5fopen_f proc~read_data->h5fopen_f h5ltget_attribute_string_f h5ltget_attribute_string_f proc~read_data->h5ltget_attribute_string_f h5ltget_attribute_double_f h5ltget_attribute_double_f proc~read_data->h5ltget_attribute_double_f h5fclose_f h5fclose_f proc~read_data->h5fclose_f proc~version version interface~version->proc~version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_data Source Code subroutine read_data ( this , infile , set_time ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Reads the data describing the cryosphere from an HDF5 file on ! the disc. `h5open_f` must have been called once prior to using ! this method. After the method has been used, `h5close_f` must be ! called once before the end of the program. ! class ( cryosphere ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: infile !! The file from which to read the data describing the state of the !! cryosphere logical , optional , intent ( in ) :: set_time !! If present and `.true.` then set the simulation time of the !! cryosphere to be the same as that in the HDF file. Otherwise, !! leave it unchanged. logical :: set_t integer ( hid_t ) :: file_id , error_code character ( len = 50 ) :: string real ( r8 ), dimension ( 1 ) :: sim_time if ( present ( set_time )) then set_t = set_time else set_t = . false . end if call h5fopen_f ( infile , H5F_ACC_RDONLY_F , file_id , error_code ) if ( error_code /= 0 ) then call logger % fatal ( 'cryosphere%read_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'opening HDF5 file ' // infile ) error stop end if ! Read any whole-system data... call h5ltget_attribute_string_f ( file_id , '/' , hdf_version , string , error_code ) if ( trim ( string ) /= version ()) then call logger % warning ( 'cryosphere%read_data' , 'Reading HDF data produced ' // & 'by different ISOFT version: ' // version ()) end if call h5ltget_attribute_double_f ( file_id , '/' , hdf_simulation_time , sim_time , & error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'reading attributes from HDF5 file ' // infile ) end if ! Call for subobjects call this % ice % read_data ( file_id , hdf_glacier , error_code ) call this % sub_ice % read_data ( file_id , hdf_basal , error_code ) ! Close the file call h5fclose_f ( file_id , error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'closing HDF5 file ' // infile ) end if ! Set the time, if necessary if ( set_t ) then this % time = sim_time ( 1 ) call this % ice % set_time ( this % time ) call logger % info ( 'cryosphere%read_data' , 'Read cryosphere data ' // & 'from HDF file ' // infile // ', with simulation ' // & 'time ' // trim ( str ( this % time ))) else call logger % info ( 'cryosphere%read_data' , 'Read cryosphere data from ' // & 'HDF file ' // infile ) end if end subroutine read_data"},{"title":"read_ice – ISOFT","tags":"","loc":"proc/read_ice.html","text":"private subroutine read_ice(this, infile, set_time) Reads the data describing the ice component of the cryosphere\n from an HDF5 file on the disc. Data on anything below the ice is\n ignored. h5open_f must have been called once prior to using\n this method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this character(len=*), intent(in) :: infile The file from which to read the data describing the state of the \n cryosphere logical, intent(in), optional :: set_time If present and .true. then set the simulation time of the\n cryosphere to be the same as that in the HDF file. Otherwise,\n leave it unchanged. Calls proc~~read_ice~~CallsGraph proc~read_ice read_ice interface~version version proc~read_ice->interface~version str str proc~read_ice->str h5fopen_f h5fopen_f proc~read_ice->h5fopen_f h5ltget_attribute_string_f h5ltget_attribute_string_f proc~read_ice->h5ltget_attribute_string_f h5ltget_attribute_double_f h5ltget_attribute_double_f proc~read_ice->h5ltget_attribute_double_f h5fclose_f h5fclose_f proc~read_ice->h5fclose_f proc~version version interface~version->proc~version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_ice Source Code subroutine read_ice ( this , infile , set_time ) !* Author: Christopher MacMackin !  Date: December 2017 ! ! Reads the data describing the ice component of the cryosphere ! from an HDF5 file on the disc. Data on anything below the ice is ! ignored. `h5open_f` must have been called once prior to using ! this method. After the method has been used, `h5close_f` must be ! called once before the end of the program. ! class ( cryosphere ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: infile !! The file from which to read the data describing the state of the !! cryosphere logical , optional , intent ( in ) :: set_time !! If present and `.true.` then set the simulation time of the !! cryosphere to be the same as that in the HDF file. Otherwise, !! leave it unchanged. logical :: set_t integer ( hid_t ) :: file_id , error_code character ( len = 50 ) :: string real ( r8 ), dimension ( 1 ) :: sim_time if ( present ( set_time )) then set_t = set_time else set_t = . false . end if call h5fopen_f ( infile , H5F_ACC_RDONLY_F , file_id , error_code ) if ( error_code /= 0 ) then call logger % fatal ( 'cryosphere%read_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'opening HDF5 file ' // infile ) error stop end if ! Read any whole-system data... call h5ltget_attribute_string_f ( file_id , '/' , hdf_version , string , error_code ) if ( trim ( string ) /= version ()) then call logger % warning ( 'cryosphere%read_ice' , 'Reading HDF data produced ' // & 'by different ISOFT version: ' // version ()) end if call h5ltget_attribute_double_f ( file_id , '/' , hdf_simulation_time , sim_time , & error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'reading attributes from HDF5 file ' // infile ) end if ! Call for subobjects call this % ice % read_data ( file_id , hdf_glacier , error_code ) ! Close the file call h5fclose_f ( file_id , error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'closing HDF5 file ' // infile ) end if ! Set the time, if necessary if ( set_t ) then this % time = sim_time ( 1 ) call this % ice % set_time ( this % time ) call logger % info ( 'cryosphere%read_ice' , 'Read cryosphere data ' // & 'from HDF file ' // infile // ', with simulation ' // & 'time ' // trim ( str ( this % time ))) else call logger % info ( 'cryosphere%read_ice' , 'Read cryosphere data from ' // & 'HDF file ' // infile ) end if end subroutine read_ice"},{"title":"read_sub_ice – ISOFT","tags":"","loc":"proc/read_sub_ice.html","text":"private subroutine read_sub_ice(this, infile, set_time) Reads the data describing the part of the cryosphere beneath the\n ice from an HDF5 file on the disc. Data on the ice itself is\n ignored. h5open_f must have been called once prior to using\n this method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this character(len=*), intent(in) :: infile The file from which to read the data describing the state of the \n cryosphere logical, intent(in), optional :: set_time If present and .true. then set the simulation time of the\n cryosphere to be the same as that in the HDF file. Otherwise,\n leave it unchanged. Calls proc~~read_sub_ice~~CallsGraph proc~read_sub_ice read_sub_ice interface~version version proc~read_sub_ice->interface~version str str proc~read_sub_ice->str h5fopen_f h5fopen_f proc~read_sub_ice->h5fopen_f h5ltget_attribute_string_f h5ltget_attribute_string_f proc~read_sub_ice->h5ltget_attribute_string_f h5ltget_attribute_double_f h5ltget_attribute_double_f proc~read_sub_ice->h5ltget_attribute_double_f h5fclose_f h5fclose_f proc~read_sub_ice->h5fclose_f proc~version version interface~version->proc~version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_sub_ice Source Code subroutine read_sub_ice ( this , infile , set_time ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Reads the data describing the part of the cryosphere beneath the ! ice from an HDF5 file on the disc. Data on the ice itself is ! ignored. `h5open_f` must have been called once prior to using ! this method. After the method has been used, `h5close_f` must be ! called once before the end of the program. ! class ( cryosphere ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: infile !! The file from which to read the data describing the state of the !! cryosphere logical , optional , intent ( in ) :: set_time !! If present and `.true.` then set the simulation time of the !! cryosphere to be the same as that in the HDF file. Otherwise, !! leave it unchanged. logical :: set_t integer ( hid_t ) :: file_id , error_code character ( len = 50 ) :: string real ( r8 ), dimension ( 1 ) :: sim_time if ( present ( set_time )) then set_t = set_time else set_t = . false . end if call h5fopen_f ( infile , H5F_ACC_RDONLY_F , file_id , error_code ) if ( error_code /= 0 ) then call logger % fatal ( 'cryosphere%read_sub_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'opening HDF5 file ' // infile ) error stop end if ! Read any whole-system data... call h5ltget_attribute_string_f ( file_id , '/' , hdf_version , string , error_code ) if ( trim ( string ) /= version ()) then call logger % warning ( 'cryosphere%read_sub_ice' , 'Reading HDF data produced ' // & 'by different ISOFT version: ' // version ()) end if call h5ltget_attribute_double_f ( file_id , '/' , hdf_simulation_time , sim_time , & error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_sub_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'reading attributes from HDF5 file ' // infile ) end if ! Call for subobjects call this % sub_ice % read_data ( file_id , hdf_basal , error_code ) ! Close the file call h5fclose_f ( file_id , error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%read_sub_ice' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'closing HDF5 file ' // infile ) end if ! Set the time, if necessary if ( set_t ) then this % time = sim_time ( 1 ) call this % ice % set_time ( this % time ) call logger % info ( 'cryosphere%read_sub_ice' , 'Read cryosphere data ' // & 'from HDF file ' // infile // ', with simulation ' // & 'time ' // trim ( str ( this % time ))) else call logger % info ( 'cryosphere%read_sub_ice' , 'Read cryosphere data from ' // & 'HDF file ' // infile ) end if end subroutine read_sub_ice"},{"title":"write_data – ISOFT","tags":"","loc":"proc/write_data.html","text":"private subroutine write_data(this, outfile) Writes the data describing the cryosphere to the disc as an HDF5\n file. h5open_f must have been called once prior to using this\n method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(in) :: this character(len=*), intent(in) :: outfile The file to which to write the data describing the state of the \n cryosphere Calls proc~~write_data~~CallsGraph proc~write_data write_data proc~current_time current_time proc~write_data->proc~current_time interface~version version proc~write_data->interface~version str str proc~write_data->str h5ltset_attribute_double_f h5ltset_attribute_double_f proc~write_data->h5ltset_attribute_double_f h5fcreate_f h5fcreate_f proc~write_data->h5fcreate_f h5fclose_f h5fclose_f proc~write_data->h5fclose_f interface~compile_time compile_time proc~write_data->interface~compile_time proc~version version interface~version->proc~version proc~compile_time compile_time interface~compile_time->proc~compile_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_data Source Code subroutine write_data ( this , outfile ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Writes the data describing the cryosphere to the disc as an HDF5 ! file. `h5open_f` must have been called once prior to using this ! method. After the method has been used, `h5close_f` must be ! called once before the end of the program. ! class ( cryosphere ), intent ( in ) :: this character ( len =* ), intent ( in ) :: outfile !! The file to which to write the data describing the state of the !! cryosphere integer ( hid_t ) :: file_id , error_code call h5fcreate_f ( outfile , H5F_ACC_TRUNC_F , file_id , error_code ) if ( error_code /= 0 ) then call logger % error ( 'cryosphere%write_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'creating HDF5 file ' // outfile ) return end if ! Write any whole-system data... call h5ltset_attribute_string_f ( file_id , '/' , hdf_version , version (), error_code ) call h5ltset_attribute_string_f ( file_id , '/' , hdf_comp_time , compile_time (), & error_code ) call h5ltset_attribute_string_f ( file_id , '/' , hdf_write_time , current_time (), & error_code ) call h5ltset_attribute_double_f ( file_id , '/' , hdf_simulation_time ,[ this % time ], & 1_size_t , error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%write_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'writing attributes to HDF5 file ' // outfile ) end if ! Call for subobjects call this % ice % write_data ( file_id , hdf_glacier , error_code ) call this % sub_ice % write_data ( file_id , hdf_basal , error_code ) call h5fclose_f ( file_id , error_code ) if ( error_code /= 0 ) then call logger % warning ( 'cryosphere%write_data' , 'Error code ' // & trim ( str ( error_code )) // ' returned when ' // & 'closing HDF5 file ' // outfile ) end if #ifdef DEBUG call logger % debug ( 'cryosphere%write_data' , 'Wrote cryosphere data to ' // & 'HDF file ' // outfile // ' at simulation time ' // & trim ( str ( this % time ))) #endif end subroutine write_data"},{"title":"bound_array – ISOFT","tags":"","loc":"proc/bound_array.html","text":"private pure function bound_array(this) Default implementation of the method getting lower and upper\n boundary information, which is then passed to the methods for\n getting and setting raw representations of fields. It returns a\n 1D array of length 2, indicating free boundaries (the raw data\n should represent all cells contained in the field, not excluding\n any near the boundaries). Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) Contents Source Code bound_array Source Code pure function bound_array ( this ) !* Author: Chris MacMackin !  Date: September 2016 ! ! Default implementation of the method getting lower and upper ! boundary information, which is then passed to the methods for ! getting and setting raw representations of fields. It returns a ! 1D array of length 2, indicating free boundaries (the raw data ! should represent all cells contained in the field, not excluding ! any near the boundaries). ! class ( glacier_boundary ), intent ( in ) :: this integer , dimension ( 2 ) :: bound_array bound_array = 0 end function bound_array"},{"title":"boundary_residuals – ISOFT","tags":"","loc":"proc/boundary_residuals.html","text":"private function boundary_residuals(this, thickness, velocity, viscosity, t) result(residuals) Default implementation of the boundary_residuals method. It returns a zero-length array, effectively indicating free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this class(scalar_field), intent(in) :: thickness A field containing the thickness of the glacier class(vector_field), intent(in) :: velocity A field containing the flow velocity of the glacier class(scalar_field), intent(in) :: viscosity A field containing the viscosity of the ice in the glacier. real(kind=r8), intent(in) :: t The time at which the boundary conditions are to be\n calculated. Return Value real(kind=r8),\n  allocatable,dimension(:) An array containing the difference between the required\n boundary values and those which are actually present. They\n are stored in the order: lower thickness boundary, upper\n thickness boundary, lower velocity boundary, and upper\n velocity boundary. Contents Source Code boundary_residuals Source Code function boundary_residuals ( this , thickness , velocity , viscosity , t ) & result ( residuals ) !* Author: Chris MacMackin !  Date: September 2016 ! ! Default implementation of the ! [[glacier_boundary(type):boundary_residuals]] ! method. It returns a zero-length array, effectively indicating free ! boundaries. ! class ( glacier_boundary ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: thickness !! A field containing the thickness of the glacier class ( vector_field ), intent ( in ) :: velocity !! A field containing the flow velocity of the glacier class ( scalar_field ), intent ( in ) :: viscosity !! A field containing the viscosity of the ice in the glacier. real ( r8 ), intent ( in ) :: t !! The time at which the boundary conditions are to be !! calculated. real ( r8 ), allocatable , dimension (:) :: residuals !! An array containing the difference between the required !! boundary values and those which are actually present. They !! are stored in the order: lower thickness boundary, upper !! thickness boundary, lower velocity boundary, and upper !! velocity boundary. allocate ( residuals ( 0 )) end function boundary_residuals"},{"title":"bound_type – ISOFT","tags":"","loc":"proc/bound_type.html","text":"private pure function bound_type(this) Default implementation of the methods getting the boundary types\n for a glacier.  It returns an array which indicates free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:),allocatable Contents Source Code bound_type Source Code pure function bound_type ( this ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Default implementation of the methods getting the boundary types ! for a glacier.  It returns an array which indicates free ! boundaries. ! class ( glacier_boundary ), intent ( in ) :: this integer , dimension (:), allocatable :: bound_type bound_type = [ free_boundary , free_boundary ] end function bound_type"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~2.html","text":"private pure function constructor(ref_rho, ref_t, ref_s, beta_t, beta_s, a_DS, a_DT, a_DS_t, a_DT_t) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: ref_rho The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), intent(in) :: ref_t The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), intent(in) :: ref_s The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), intent(in) :: beta_t The thermal contraction coefficient, \\beta_T . real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S . real(kind=r8), intent(in), optional :: a_DS The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_S dy, where f_{D}(y) and f_S(y) are the shapes of the variables D and S in\n the transverse direction. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DT The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_T dy, where f_{D}(y) and f_T(y) are the shapes of the variables D and T in\n the transverse direction. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DS_t The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DS} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S\n dy, where f_{D}(y) and f_S(y) are the shapes of\n the variables D and S in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DT_t The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DT} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T\n dy, where f_{D}(y) and f_T(y) are the shapes of\n the variables D and T in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. Return Value type( ave_linear_eos ) Called by proc~~constructor~2~~CalledByGraph proc~constructor~2 constructor interface~ave_linear_eos ave_linear_eos interface~ave_linear_eos->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( ref_rho , ref_t , ref_s , beta_t , beta_s , a_DS , & a_DT , a_DS_t , a_DT_t ) result ( this ) real ( r8 ), intent ( in ) :: ref_rho !! The density for the temperature and salinity about which the !! equation of state was linearised, \\rho_0. real ( r8 ), intent ( in ) :: ref_t !! The temperature about which the equation of state was !! linearised, T_0. real ( r8 ), intent ( in ) :: ref_s !! The salinity about which the equation of state was !! linearised, S_0. real ( r8 ), intent ( in ) :: beta_t !! The thermal contraction coefficient, \\beta_T. real ( r8 ), intent ( in ) :: beta_s !! The haline contraction coefficient, \\beta_S. real ( r8 ), intent ( in ), optional :: a_DS !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{D}f_S dy,  where f_{D}(y) and !! f_S(y) are the shapes of the variables D and S in !! the transverse direction. Defualt value is 1. real ( r8 ), intent ( in ), optional :: a_DT !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{D}f_T dy,  where f_{D}(y) and !! f_T(y) are the shapes of the variables D and T in !! the transverse direction. Defualt value is 1. real ( r8 ), intent ( in ), optional :: a_DS_t !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\tilde{\\alpha}_{DS} = !! \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S !! dy,  where f_{D}(y) and f_S(y) are the shapes of !! the variables D and S in the transverse direction and !! \\alpha_{D&#94;2} = \\frac{1}{y_2 - !! y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. real ( r8 ), intent ( in ), optional :: a_DT_t !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\tilde{\\alpha}_{DT} = !! \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T !! dy,  where f_{D}(y) and f_T(y) are the shapes of !! the variables D and T in the transverse direction and !! \\alpha_{D&#94;2} = \\frac{1}{y_2 - !! y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. type ( ave_linear_eos ) :: this this % ref_rho = ref_rho this % ref_t = ref_t this % ref_s = ref_s this % beta_t = beta_t this % beta_s = beta_s if ( present ( a_DS )) this % a_DS = a_DS if ( present ( a_DT )) this % a_DT = a_DT if ( present ( a_DS_t )) this % a_DS_t = a_DS_t if ( present ( a_DT_t )) this % a_DT_t = a_DT_t end function constructor"},{"title":"linear_water_density – ISOFT","tags":"","loc":"proc/linear_water_density~2.html","text":"private function linear_water_density(this, temperature, salinity) result(density) Calculates the density of the water from the temperature and\n salinity, using a linear equation of state, \\rho(x,y) =\n \\rho_0[1-\\beta_T(T(x,y)-T_0) + \\beta_S(S(x,y)-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water Contents Source Code linear_water_density Source Code function linear_water_density ( this , temperature , salinity ) result ( density ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Calculates the density of the water from the temperature and ! salinity, using a linear equation of state,  \\rho(x,y) = ! \\rho_0[1-\\beta_T(T(x,y)-T_0) + \\beta_S(S(x,y)-S_0)].  class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call salinity % allocate_scalar_field ( density ) density = this % ref_rho * ( 1.0_r8 - this % beta_t * ( temperature - this % ref_t ) & + this % beta_s * ( salinity - this % ref_s )) call temperature % clean_temp (); call salinity % clean_temp () call density % set_temp () end function linear_water_density"},{"title":"linear_water_density_ave1 – ISOFT","tags":"","loc":"proc/linear_water_density_ave1.html","text":"private function linear_water_density_ave1(this, temperature, salinity) result(density) Calculates one form of the horizontally-averaged density of the\n water from the temperature and salinity, using a linear equation\n of state, \\bar{rho}(x) =\n \\rho_0[1-\\beta_T(\\alpha_{DT}T(x)-T_0) +\n \\beta_S(\\alpha_{DS}S(x)-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water Contents Source Code linear_water_density_ave1 Source Code function linear_water_density_ave1 ( this , temperature , salinity ) result ( density ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Calculates one form of the horizontally-averaged density of the ! water from the temperature and salinity, using a linear equation ! of state,  \\bar{rho}(x) = ! \\rho_0[1-\\beta_T(\\alpha_{DT}T(x)-T_0) + ! \\beta_S(\\alpha_{DS}S(x)-S_0)].  class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call salinity % allocate_scalar_field ( density ) density = this % ref_rho * ( 1.0_r8 - this % beta_t * ( this % a_DT * temperature - this % ref_t ) & + this % beta_s * ( this % a_DS * salinity - this % ref_s )) call temperature % clean_temp (); call salinity % clean_temp () call density % set_temp () end function linear_water_density_ave1"},{"title":"linear_water_density_ave2 – ISOFT","tags":"","loc":"proc/linear_water_density_ave2.html","text":"private function linear_water_density_ave2(this, temperature, salinity) result(density) Calculates another form of the horizontally-averaged density of\n the water from the temperature and salinity, using a linear\n equation of state, \\tilde{\\rho}(x) =\n \\rho_0[1-\\beta_T(\\tilde{\\alpha}_{DT}T(x)-T_0) +\n \\beta_S(\\tilde{\\alpha}_{DS}S(x)-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water Contents Source Code linear_water_density_ave2 Source Code function linear_water_density_ave2 ( this , temperature , salinity ) result ( density ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Calculates another form of the horizontally-averaged density of ! the water from the temperature and salinity, using a linear ! equation of state,  \\tilde{\\rho}(x) = ! \\rho_0[1-\\beta_T(\\tilde{\\alpha}_{DT}T(x)-T_0) + ! \\beta_S(\\tilde{\\alpha}_{DS}S(x)-S_0)].  class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call salinity % allocate_scalar_field ( density ) density = this % ref_rho * ( 1.0_r8 - this % beta_t * ( temperature - this % ref_t ) & + this % beta_s * ( salinity - this % ref_s )) call temperature % clean_temp (); call salinity % clean_temp () call density % set_temp () end function linear_water_density_ave2"},{"title":"linear_water_deriv – ISOFT","tags":"","loc":"proc/linear_water_deriv~2.html","text":"private function linear_water_deriv(this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Calculates the derivative of the average water density from the\n temperature and salinity, using a linear equation of state with\n the second type of averaging, \\tilde{\\rho} =\n \\rho_0[1-\\beta_T(\\tilde{\\alpha}_{DT}T-T_0) +\n \\beta_S(\\tilde{\\alpha}_{DS}S-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the density of the water Contents Source Code linear_water_deriv Source Code function linear_water_deriv ( this , temperature , d_temperature , salinity , & d_salinity , dir ) result ( d_density ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Calculates the derivative of the average water density from the ! temperature and salinity, using a linear equation of state with ! the second type of averaging,  \\tilde{\\rho} = ! \\rho_0[1-\\beta_T(\\tilde{\\alpha}_{DT}T-T_0) + ! \\beta_S(\\tilde{\\alpha}_{DS}S-S_0)].  class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: d_temperature !! A field containing the derivative of the temperature of the !! water, in teh same direction as `dir` class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), intent ( in ) :: d_salinity !! A field containing the derivative of the salinity of the !! water, in the same direction as `dir` integer , intent ( in ) :: dir !! The direction in which to take the derivative class ( scalar_field ), pointer :: d_density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call d_temperature % guard_temp (); call d_salinity % guard_temp () call salinity % allocate_scalar_field ( d_density ) d_density = this % ref_rho * ( this % a_DS_t * this % beta_s * d_salinity - & this % a_DT_t * this % beta_t * d_temperature ) call temperature % clean_temp (); call salinity % clean_temp () call d_temperature % clean_temp (); call d_salinity % clean_temp () call d_density % set_temp () end function linear_water_deriv"},{"title":"linear_haline_contraction – ISOFT","tags":"","loc":"proc/linear_haline_contraction~2.html","text":"private function linear_haline_contraction(this, temperature, salinity) result(coef) Returns the haline contraction coefficient. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Calls proc~~linear_haline_contraction~2~~CallsGraph proc~linear_haline_contraction~2 linear_haline_contraction uniform_scalar_field uniform_scalar_field proc~linear_haline_contraction~2->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code linear_haline_contraction Source Code function linear_haline_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Returns the haline contraction coefficient. ! class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( this % ref_rho * this % beta_s ) end function linear_haline_contraction"},{"title":"linear_thermal_contraction – ISOFT","tags":"","loc":"proc/linear_thermal_contraction~2.html","text":"private function linear_thermal_contraction(this, temperature, salinity) result(coef) Returns the thermal contraction coefficient. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Calls proc~~linear_thermal_contraction~2~~CallsGraph proc~linear_thermal_contraction~2 linear_thermal_contraction uniform_scalar_field uniform_scalar_field proc~linear_thermal_contraction~2->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code linear_thermal_contraction Source Code function linear_thermal_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: August 2018 ! ! Returns the thermal contraction coefficient. ! class ( ave_linear_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( this % ref_rho * this % beta_t ) end function linear_thermal_contraction"},{"title":"ave_linear_eos – ISOFT","tags":"","loc":"interface/ave_linear_eos.html","text":"public interface ave_linear_eos Calls interface~~ave_linear_eos~~CallsGraph interface~ave_linear_eos ave_linear_eos proc~constructor~2 constructor interface~ave_linear_eos->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (ref_rho, ref_t, ref_s, beta_t, beta_s, a_DS, a_DT, a_DS_t, a_DT_t) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: ref_rho The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), intent(in) :: ref_t The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), intent(in) :: ref_s The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), intent(in) :: beta_t The thermal contraction coefficient, \\beta_T . real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S . real(kind=r8), intent(in), optional :: a_DS The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_S dy, where f_{D}(y) and f_S(y) are the shapes of the variables D and S in\n the transverse direction. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DT The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_T dy, where f_{D}(y) and f_T(y) are the shapes of the variables D and T in\n the transverse direction. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DS_t The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DS} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S\n dy, where f_{D}(y) and f_S(y) are the shapes of\n the variables D and S in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DT_t The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DT} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T\n dy, where f_{D}(y) and f_T(y) are the shapes of\n the variables D and T in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. Return Value type( ave_linear_eos )"},{"title":"shelf_thickness – ISOFT","tags":"","loc":"proc/shelf_thickness.html","text":"private function shelf_thickness(this) result(thickness) Returns the thickness of the ice shelf across its domain. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value class(scalar_field),\n  pointer The ice thickness. Contents Source Code shelf_thickness Source Code function shelf_thickness ( this ) result ( thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the thickness of the ice shelf across its domain. ! class ( ice_shelf ), intent ( in ) :: this class ( scalar_field ), pointer :: thickness !! The ice thickness. call this % thickness % allocate_scalar_field ( thickness ) thickness = this % thickness #ifdef DEBUG call logger % debug ( 'ice_shelf%thickness' , 'Returned ice shelf thickness' ) #endif end function shelf_thickness"},{"title":"shelf_velocity – ISOFT","tags":"","loc":"proc/shelf_velocity.html","text":"private function shelf_velocity(this) result(velocity) Returns the velocity of the ice shelf across its domain. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value class(vector_field),\n  pointer The ice velocity. Contents Source Code shelf_velocity Source Code function shelf_velocity ( this ) result ( velocity ) !* Author: Christopher MacMackin !  Date: July 2016 ! ! Returns the velocity of the ice shelf across its domain. ! class ( ice_shelf ), intent ( in ) :: this class ( vector_field ), pointer :: velocity !! The ice velocity. call this % velocity % allocate_vector_field ( velocity ) velocity = this % velocity #ifdef DEBUG call logger % debug ( 'ice_shelf%velocity' , 'Returned ice shelf velocity' ) #endif end function shelf_velocity"},{"title":"shelf_density – ISOFT","tags":"","loc":"proc/shelf_density.html","text":"private pure function shelf_density(this) result(density) Returns the density of the ice in the shelf, which is assumed to be\n uniform across its domain. Note Based on my approach to non-dimensionalisation, I'm pretty\n sure the density should always be 1, making this method\n unneccessary. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8) The ice density. Contents Source Code shelf_density Source Code pure function shelf_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the density of the ice in the shelf, which is assumed to be ! uniform across its domain. ! ! @NOTE Based on my approach to non-dimensionalisation, I'm pretty ! sure the density should always be 1, making this method ! unneccessary. ! class ( ice_shelf ), intent ( in ) :: this real ( r8 ) :: density !! The ice density. density = 1.0_r8 / 1.12_r8 !TODO: Will probably want to change this at some point #ifdef DEBUG call logger % debug ( 'ice_shelf%density' , 'Ice shelf has density ' // & trim ( str ( density )) // '.' ) #endif end function shelf_density"},{"title":"shelf_temperature – ISOFT","tags":"","loc":"proc/shelf_temperature.html","text":"private pure function shelf_temperature(this) result(temperature) Returns the density of the ice in the shelf, which is assumed to be\n uniform across its domain. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8) The ice density. Contents Source Code shelf_temperature Source Code pure function shelf_temperature ( this ) result ( temperature ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the density of the ice in the shelf, which is assumed to be ! uniform across its domain. ! class ( ice_shelf ), intent ( in ) :: this real ( r8 ) :: temperature !! The ice density. temperature = - 1 5.0_r8 !TODO: Will probably want to change this at some point. #ifdef DEBUG call logger % debug ( 'ice_shelf%temperature' , 'Ice shelf has temperature ' // & trim ( str ( temperature ))) #endif end function shelf_temperature"},{"title":"shelf_residual – ISOFT","tags":"","loc":"proc/shelf_residual.html","text":"private function shelf_residual(this, previous_states, melt_rate, basal_drag_parameter, water_density) result(residual) Returns the residual when the current state of the glacier is run\n through the system of equations describing it. The residual takes the\n form of a 1D array, with each element respresenting the residual for\n one of the equations in the system. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most recent\n state, but the fact that this is an array allows potential\n other implementations to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier. class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate the\n drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. Return Value real(kind=r8),\n  dimension(:),allocatable The residual of the system of equations describing the glacier. Contents Source Code shelf_residual Source Code function shelf_residual ( this , previous_states , melt_rate , & basal_drag_parameter , water_density ) result ( residual ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the residual when the current state of the glacier is run ! through the system of equations describing it. The residual takes the ! form of a 1D array, with each element respresenting the residual for ! one of the equations in the system. ! class ( ice_shelf ), intent ( in ) :: this class ( glacier ), dimension (:), intent ( in ) :: previous_states !! The states of the glacier in the previous time steps. The !! first element of the array should be the most recent. The !! default implementation will only make use of the most recent !! state, but the fact that this is an array allows potential !! other implementations to use older states for higher-order !! integration methods. class ( scalar_field ), intent ( in ) :: melt_rate !! Thickness of the ice above the glacier. class ( scalar_field ), intent ( in ) :: basal_drag_parameter !! A paramter, e.g. coefficient of friction, needed to calculate the !! drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier. real ( r8 ), dimension (:), allocatable :: residual !! The residual of the system of equations describing the glacier. type ( cheb1d_scalar_field ) :: scalar_tmp integer :: start , finish , bounds_start , bounds_finish integer , dimension (:), allocatable :: lower , upper real ( r8 ), dimension (:), allocatable :: bounds logical :: success call melt_rate % guard_temp (); call basal_drag_parameter % guard_temp () allocate ( residual ( this % data_size ())) start = 1 ! Use same or similar notation for variables as in equations select type ( previous_states ) class is ( ice_shelf ) associate ( h => this % thickness , h_old => previous_states ( 1 )% thickness , & uvec => this % velocity , m => melt_rate , eta => this % eta , & lambda => this % lambda , t_old => previous_states ( 1 )% time ) ! Boundary conditions if ( this % stale_eta ) then bounds = this % boundaries % boundary_residuals ( h , uvec , & this % viscosity_law % ice_viscosity ( uvec , this % ice_temperature (), & this % time ), this % time ) else bounds = this % boundaries % boundary_residuals ( h , uvec , eta , this % time ) end if ! Continuity equation scalar_tmp = ( h - h_old ) / ( this % time - t_old ) + . div .( h * uvec ) + lambda * m lower = this % boundaries % thickness_lower_bound () upper = this % boundaries % thickness_upper_bound () ! TODO: Figure out how to make this independent of order which ! values are stored in the field finish = start + this % thickness_upper_bound_size - 1 bounds_start = this % thickness_lower_bound_size + 1 bounds_finish = this % thickness_lower_bound_size & + this % thickness_upper_bound_size residual ( start : finish ) = bounds ( bounds_start : bounds_finish ) start = finish + 1 finish = start + scalar_tmp % raw_size ( lower , upper ) - 1 residual ( start : finish ) = scalar_tmp % raw ( lower , upper ) start = finish + 1 finish = start + this % thickness_lower_bound_size - 1 bounds_start = 1 bounds_finish = this % thickness_lower_bound_size residual ( start : finish ) = bounds ( bounds_start : bounds_finish ) start = finish + 1 end associate class default call logger % fatal ( 'ice_shelf%residual' , 'Type other than `ice_shelf` ' // & 'passed to `ice_shelf` object as a previous state.' ) error stop end select call melt_rate % clean_temp (); call basal_drag_parameter % clean_temp () #ifdef DEBUG call logger % debug ( 'ice_shelf%residual' , 'Calculated residual of ice shelf.' ) #endif end function shelf_residual"},{"title":"shelf_precondition – ISOFT","tags":"","loc":"proc/shelf_precondition.html","text":"private function shelf_precondition(this, previous_states, melt_rate, basal_drag_parameter, water_density, delta_state) result(preconditioned) Provides a preconditioner for the nonlinear solver trying to\n bring the residual to zero. The Jacobian is approximated as a\n block matrix, where each block is a tridiagonal matrix using a\n finite difference method for differentiation. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier real(kind=r8), intent(in), dimension(:) :: delta_state The change to the state vector which is being preconditioned. Return Value real(kind=r8),\n  dimension(:),allocatable The result of applying the preconditioner to delta_state . Contents Source Code shelf_precondition Source Code function shelf_precondition ( this , previous_states , melt_rate , & basal_drag_parameter , water_density , & delta_state ) result ( preconditioned ) !* Author: Chris MacMackin !  Date: January 2016 ! ! Provides a preconditioner for the nonlinear solver trying to ! bring the residual to zero. The Jacobian is approximated as a ! block matrix, where each block is a tridiagonal matrix using a ! finite difference method for differentiation. ! class ( ice_shelf ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: previous_states !! The states of the glacier in the previous time steps. The !! first element of the array should be the most recent. The !! default implementation will only make use of the most !! recent state, but the fact that this is an array allows !! overriding methods to use older states for higher-order !! integration methods. class ( scalar_field ), intent ( in ) :: melt_rate !! Thickness of the ice above the glacier class ( scalar_field ), intent ( in ) :: basal_drag_parameter !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier real ( r8 ), dimension (:), intent ( in ) :: delta_state !! The change to the state vector which is being preconditioned. real ( r8 ), dimension (:), allocatable :: preconditioned !! The result of applying the preconditioner to `delta_state`. type ( cheb1d_scalar_field ) :: delta_h integer :: i , sl , el , su , eu integer , dimension (:), allocatable :: boundary_locations real ( r8 ) :: delta_t call melt_rate % guard_temp (); call basal_drag_parameter % guard_temp () allocate ( preconditioned ( size ( delta_state ))) select type ( previous_states ) class is ( ice_shelf ) delta_t = this % time - previous_states ( 1 )% time class default call logger % fatal ( 'ice_shelf%precondition' , 'Type other than `ice_shelf` ' // & 'passed to `ice_shelf` object as a previous state.' ) error stop end select call delta_h % assign_meta_data ( this % thickness ) call delta_h % set_from_raw ( delta_state ) associate ( jac => this % thickness_jacobian , uvec => this % velocity ) if ( this % stale_jacobian ) then sl = this % thickness_size - this % thickness_lower_bound_size + 1 el = this % thickness_size su = 1 eu = this % thickness_upper_bound_size boundary_locations = [( i , i = sl , el ), ( i , i = su , eu )] jac = jacobian_block ( uvec % component ( 1 ), 1 , boundary_locs = boundary_locations ) & + 1._r8 / delta_t this % stale_jacobian = . false . end if delta_h = jac % solve_for ( delta_h ) end associate preconditioned = delta_h % raw () call melt_rate % clean_temp (); call basal_drag_parameter % clean_temp () #ifdef DEBUG call logger % debug ( 'ice_shelf%precondition' , 'Applied preconditioner for ice shelf.' ) #endif end function shelf_precondition"},{"title":"shelf_data_size – ISOFT","tags":"","loc":"proc/shelf_data_size.html","text":"private pure function shelf_data_size(this) Returns the number of elements in the ice shelf's state vector.\n This is the size of the vector returned by residual and state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value integer The number of elements in the ice shelf's state vector. Contents Source Code shelf_data_size Source Code pure function shelf_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the ice shelf's state vector. ! This is the size of the vector returned by [[ice_shelf:residual]] ! and [[ice_shelf:state_vector]] and taken as an argument by ! [[ice_shelf:update]]. ! class ( ice_shelf ), intent ( in ) :: this integer :: shelf_data_size !! The number of elements in the ice shelf's state vector. shelf_data_size = this % thickness_size #ifdef DEBUG call logger % debug ( 'ice_shelf%data_size' , 'Ice shelf has ' // & trim ( str ( shelf_data_size )) // ' elements ' // & 'in its state vector.' ) #endif end function shelf_data_size"},{"title":"shelf_state_vector – ISOFT","tags":"","loc":"proc/shelf_state_vector.html","text":"private function shelf_state_vector(this) result(state_vector) Returns the state vector for the current state of the ice shelf. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:),allocatable The state vector describing the ice shelf. Contents Source Code shelf_state_vector Source Code function shelf_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the ice shelf. ! This takes the form of a 1D array. ! class ( ice_shelf ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the ice shelf. state_vector = this % thickness % raw () #ifdef DEBUG call logger % debug ( 'ice_shelf%state_vector' , 'Returning state vector ' // & 'for ice shelf.' ) #endif end function shelf_state_vector"},{"title":"shelf_kappa_vector – ISOFT","tags":"","loc":"proc/shelf_kappa_vector.html","text":"private function shelf_kappa_vector(this) result(kappa_vector) Returns the a vector representing the current state of the\n internal reflectors in the ice shelf.  This takes the form of a\n 1D array. The routien is only used for debugging purposes. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:),allocatable The state vector describing the ice shelf. Contents Source Code shelf_kappa_vector Source Code function shelf_kappa_vector ( this ) result ( kappa_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the a vector representing the current state of the ! internal reflectors in the ice shelf.  This takes the form of a ! 1D array. The routien is only used for debugging purposes. ! class ( ice_shelf ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: kappa_vector !! The state vector describing the ice shelf. integer :: i if ( allocated ( this % kappa )) then allocate ( kappa_vector ( this % thickness_size * size ( this % kappa ))) do i = 1 , size ( this % kappa ) kappa_vector (( i - 1 ) * this % thickness_size + 1 : this % thickness_size * i ) = this % kappa ( i )% raw () end do end if #ifdef DEBUG call logger % debug ( 'ice_shelf%state_vector' , 'Returning state vector ' // & 'for ice shelf.' ) #endif end function shelf_kappa_vector"},{"title":"shelf_time_step – ISOFT","tags":"","loc":"proc/shelf_time_step.html","text":"private function shelf_time_step(this) result(dt) Calculates the time step for integrating the ice shelf, using\n the CFL condition. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8) The time-step to use Calls proc~~shelf_time_step~~CallsGraph proc~shelf_time_step shelf_time_step str str proc~shelf_time_step->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code shelf_time_step Source Code function shelf_time_step ( this ) result ( dt ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Calculates the time step for integrating the ice shelf, using ! the CFL condition. ! class ( ice_shelf ), intent ( in ) :: this class ( scalar_field ), pointer :: u , dx1 class ( vector_field ), pointer :: dx real ( r8 ) :: dt !! The time-step to use u => this % velocity % component ( 1 ) dx => this % velocity % grid_spacing () dx1 => dx % component ( 1 ) call dx1 % guard_temp () dt = min ( minval ( abs ( this % courant * dx1 / u )), this % max_dt ) call dx1 % clean_temp () call logger % trivia ( 'ice_shelf%time_step' , 'Calculated time step of ' // & trim ( str ( dt )) // ' using Courant number of ' // & trim ( str ( this % courant ))) end function shelf_time_step"},{"title":"shelf_initialise – ISOFT","tags":"","loc":"proc/shelf_initialise.html","text":"private subroutine shelf_initialise(this, domain, resolution, thickness, velocity, temperature, viscosity_law, boundaries, lambda, chi, zeta, courant, max_dt, kappa, n_kappa) Initialises an ice_shelf object with initial conditions provided\n by the arguments. At present only a 1D model is supported. If\n information is provided for higher dimensions then it will be ignored. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(out) :: this real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the ice shelf. The first index represents the dimension for which\n the boundaries apply. If the second index is 1 then it corresponds\n to the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension. procedure( thickness_func ) :: thickness A function which calculates the initial value of the thickness of \n the ice shelf at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the ice at a given location in an ice shelf. real(kind=r8), intent(in), optional :: temperature The temperature of the ice in the ice shelf. class( abstract_viscosity ), intent(inout), optional allocatable :: viscosity_law An object which calculates the viscosity of the ice. If not\n specified, then Glen's law will be used with $n=3$. Will be\n unallocated on return. class( glacier_boundary ), intent(inout), optional allocatable :: boundaries An object specifying the boundary conditions for the ice\n shelf. Will be unallocated on return. real(kind=r8), intent(in), optional :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_ih_0u_0}$. real(kind=r8), intent(in), optional :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}\\left(1 -\n \\frac{\\rho_i}{\\rho_0}\\right)$. real(kind=r8), intent(in), optional :: zeta The dimensionless ratio $\\zeta \\equiv\n \\frac{\\rho_iu_0x_0}{\\eta_0}$, corresponding to the Reynolds\n number. Currently this is unused and always treated as 0. real(kind=r8), intent(in), optional :: courant The Courant number to use when calculating the time\n step. Defaults to 100. Too large a value will pose\n difficulties for the nonlinear solver, while too small a\n value can be numerically unstable. Typically, smaller values\n are needed for lower resolution. real(kind=r8), intent(in), optional :: max_dt The maximum allowable time step. This defaults to 1\\times\n 10&#94;{99} (effectively no maximum). procedure( kappa_init_func ), optional :: kappa A function which specifies the initial values of the Taylor\n coefficients describing the vertical distribution of internal\n reflectors within the ice. The initial conditions at the\n grounding line will provide the boundary conditions there\n throughout the simulation. If this parameter is not provided\n then these layers will not be included in the\n integration. Both this parameter and n_kappa must be\n specified for the calculation to take place. integer, intent(in), optional :: n_kappa The number of Taylor coefficients used to describe internal\n reflectors. If not provided then these reflectors will not be\n included in the integration. Both this parameter and kappa must be specified for the calculation to take place. Calls proc~~shelf_initialise~~CallsGraph proc~shelf_initialise shelf_initialise cheb1d_scalar_field cheb1d_scalar_field proc~shelf_initialise->cheb1d_scalar_field cheb1d_vector_field cheb1d_vector_field proc~shelf_initialise->cheb1d_vector_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code shelf_initialise Source Code subroutine shelf_initialise ( this , domain , resolution , thickness , velocity , & temperature , viscosity_law , boundaries , lambda , & chi , zeta , courant , max_dt , kappa , n_kappa ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Initialises an [[ice_shelf]] object with initial conditions provided ! by the arguments. At present only a 1D model is supported. If ! information is provided for higher dimensions then it will be ignored. ! class ( ice_shelf ), intent ( out ) :: this real ( r8 ), dimension (:,:), intent ( in ) :: domain !! An array containing the upper and lower limits of the domain for !! the ice shelf. The first index represents the dimension for which !! the boundaries apply. If the second index is 1 then it corresponds !! to the lower bound. If the second index is 2 then it corresponds to !! the upper bound. integer , dimension (:), intent ( in ) :: resolution !! The number of data points in each dimension. procedure ( thickness_func ) :: thickness !! A function which calculates the initial value of the thickness of !! the ice shelf at a given location. procedure ( velocity_func ) :: velocity !! A function which calculates the initial value of the velocity !! (vector) of the ice at a given location in an ice shelf. real ( r8 ), intent ( in ), optional :: temperature !! The temperature of the ice in the ice shelf. class ( abstract_viscosity ), allocatable , optional , & intent ( inout ) :: viscosity_law !! An object which calculates the viscosity of the ice. If not !! specified, then Glen's law will be used with $n=3$. Will be !! unallocated on return. class ( glacier_boundary ), allocatable , optional , & intent ( inout ) :: boundaries !! An object specifying the boundary conditions for the ice !! shelf. Will be unallocated on return. real ( r8 ), intent ( in ), optional :: lambda !! The dimensionless ratio !! $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_ih_0u_0}$. real ( r8 ), intent ( in ), optional :: chi !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}\\left(1 - !! \\frac{\\rho_i}{\\rho_0}\\right)$. real ( r8 ), intent ( in ), optional :: zeta !! The dimensionless ratio $\\zeta \\equiv !! \\frac{\\rho_iu_0x_0}{\\eta_0}$, corresponding to the Reynolds !! number. Currently this is unused and always treated as 0. real ( r8 ), intent ( in ), optional :: courant !! The Courant number to use when calculating the time !! step. Defaults to 100. Too large a value will pose !! difficulties for the nonlinear solver, while too small a !! value can be numerically unstable. Typically, smaller values !! are needed for lower resolution. real ( r8 ), intent ( in ), optional :: max_dt !! The maximum allowable time step. This defaults to 1\\times !! 10&#94;{99} (effectively no maximum). procedure ( kappa_init_func ), optional :: kappa !! A function which specifies the initial values of the Taylor !! coefficients describing the vertical distribution of internal !! reflectors within the ice. The initial conditions at the !! grounding line will provide the boundary conditions there !! throughout the simulation. If this parameter is not provided !! then these layers will not be included in the !! integration. Both this parameter and `n_kappa` must be !! specified for the calculation to take place. integer , optional , intent ( in ) :: n_kappa !! The number of Taylor coefficients used to describe internal !! reflectors. If not provided then these reflectors will not be !! included in the integration. Both this parameter and `kappa` !! must be specified for the calculation to take place. integer :: n integer , dimension (:), allocatable :: lower , upper this % thickness = cheb1d_scalar_field ( resolution ( 1 ), thickness , domain ( 1 , 1 ), & domain ( 1 , 2 )) this % velocity = cheb1d_vector_field ( resolution ( 1 ), velocity , domain ( 1 , 1 ), & domain ( 1 , 2 )) this % eta = cheb1d_scalar_field ( resolution ( 1 ), lower_bound = domain ( 1 , 1 ), & upper_bound = domain ( 1 , 2 )) this % thickness_size = this % thickness % raw_size () this % velocity_size = this % velocity % raw_size () if ( present ( kappa ) . and . present ( n_kappa )) then allocate ( this % kappa ( n_kappa )) do n = 1 , n_kappa this % kappa ( n ) = cheb1d_scalar_field ( resolution ( 1 ), kappa_func , domain ( 1 , 1 ), & domain ( 1 , 2 )) end do end if if ( present ( temperature )) then continue ! This doesn't do anything at the moment else continue ! Again, doesn't do anything at the moment end if if ( present ( viscosity_law )) then call move_alloc ( viscosity_law , this % viscosity_law ) else allocate ( newtonian_viscosity :: this % viscosity_law ) end if if ( present ( boundaries )) then call move_alloc ( boundaries , this % boundaries ) else allocate ( dallaston2015_glacier_boundary :: this % boundaries ) end if if ( present ( lambda )) then this % lambda = lambda else this % lambda = 0.37_r8 end if if ( present ( chi )) then this % chi = chi else this % chi = 4.0_r8 end if if ( present ( zeta )) then this % zeta = zeta else this % zeta = 1.3e-11_r8 end if if ( present ( courant )) then this % courant = courant else this % courant = 1 e2_r8 end if if ( present ( max_dt )) then this % max_dt = max_dt else this % max_dt = 1 e99_r8 end if lower = this % boundaries % thickness_lower_bound () upper = this % boundaries % thickness_upper_bound () this % thickness_lower_bound_size = this % thickness_size & - this % thickness % raw_size ( lower ) this % thickness_upper_bound_size = this % thickness_size & - this % thickness % raw_size ( upper ) lower = this % boundaries % velocity_lower_bound () upper = this % boundaries % velocity_upper_bound () this % velocity_lower_bound_size = this % velocity_size & - this % velocity % raw_size ( lower ) this % velocity_upper_bound_size = this % velocity_size & - this % velocity % raw_size ( upper ) this % boundary_start = this % thickness_size + this % velocity_size + 1 & - this % thickness_lower_bound_size & - this % thickness_upper_bound_size & - this % velocity_lower_bound_size & - this % velocity_upper_bound_size this % time = 0.0_r8 this % stale_eta = . true . this % stale_jacobian = . true . #ifdef DEBUG call logger % debug ( 'ice_shelf' , 'Initialised new ice shelf object' ) #endif contains pure function kappa_func ( location ) result ( thickness ) !* Author: Chris MacMackin !  Date: April 2016 ! ! Wrapper around user-provided `kappa` routine, converting it to ! the form needed to initialise field-types. ! real ( r8 ), dimension (:), intent ( in ) :: location !! The position $\\vec{x}$ at which to compute the thickness real ( r8 ) :: thickness !! The thickness of the glacier at `location` thickness = kappa ( n , location ) end function kappa_func end subroutine shelf_initialise"},{"title":"shelf_update – ISOFT","tags":"","loc":"proc/shelf_update.html","text":"private subroutine shelf_update(this, state_vector) Updates the state of the ice shelf from its state vector. The state\n vector is a real array containing the value of each of the ice shelf's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n glacier. Contents Source Code shelf_update Source Code subroutine shelf_update ( this , state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the ice shelf from its state vector. The state ! vector is a real array containing the value of each of the ice shelf's ! properties at each of the locations on the grid used in discretization. ! class ( ice_shelf ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! glacier. !TODO: Add some assertion-like checks that the state vector is the right size call this % thickness % set_from_raw ( state_vector ( 1 : this % thickness_size )) this % stale_jacobian = . true . #ifdef DEBUG call logger % debug ( 'ice_shelf%update' , 'Updated state of ice shelf.' ) #endif end subroutine shelf_update"},{"title":"shelf_set_time – ISOFT","tags":"","loc":"proc/shelf_set_time.html","text":"private subroutine shelf_set_time(this, time) Sets the time information held by the ice shelf object. This is\n the time at which the ice sheet is in its current state. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the glacier is in the present state. Contents Source Code shelf_set_time Source Code subroutine shelf_set_time ( this , time ) !* Author: Christopher MacMackin !  Date: November 2016 ! ! Sets the time information held by the ice shelf object. This is ! the time at which the ice sheet is in its current state. ! class ( ice_shelf ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time !! The time at which the glacier is in the present state. this % time = time #ifdef DEBUG call logger % debug ( 'ice_shelf%set_time' , 'Updating time for ice shelf to ' // & trim ( str ( time ))) #endif end subroutine shelf_set_time"},{"title":"shelf_read_data – ISOFT","tags":"","loc":"proc/shelf_read_data.html","text":"private subroutine shelf_read_data(this, file_id, group_name, error) Reads the state of the ice shelf object from the specified group\n in an HDF5 file. This sets the thickness, the velocity, and\n parameter values. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Calls proc~~shelf_read_data~~CallsGraph proc~shelf_read_data shelf_read_data h5gopen_f h5gopen_f proc~shelf_read_data->h5gopen_f str str proc~shelf_read_data->str h5ltget_attribute_int_f h5ltget_attribute_int_f proc~shelf_read_data->h5ltget_attribute_int_f h5ltget_attribute_string_f h5ltget_attribute_string_f proc~shelf_read_data->h5ltget_attribute_string_f h5ltget_attribute_double_f h5ltget_attribute_double_f proc~shelf_read_data->h5ltget_attribute_double_f h5gclose_f h5gclose_f proc~shelf_read_data->h5gclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code shelf_read_data Source Code subroutine shelf_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the ice shelf object from the specified group ! in an HDF5 file. This sets the thickness, the velocity, and ! parameter values. ! class ( ice_shelf ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err , i , nkap real ( r8 ), dimension ( 1 ) :: param integer , dimension ( 1 ) :: iparam character ( len = 20 ) :: fieldname character ( len = 50 ) :: ice_type ret_err = 0 call h5gopen_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % error ( 'ice_shelf%read_data' , 'Could not open HDF group \"' // & group_name // '\", so no IO performed.' ) return end if call h5ltget_attribute_string_f ( file_id , group_name , hdf_type_attr , & ice_type , error ) if ( trim ( ice_type ) /= hdf_type_name ) then call logger % error ( 'ice_shelf%read_data' , 'Trying to read data from ' // & 'glacier of type other than ice_shelf.' ) error = - 1 return end if call h5ltget_attribute_double_f ( file_id , group_name , hdf_lambda , & param , error ) this % lambda = param ( 1 ) call h5ltget_attribute_double_f ( file_id , group_name , hdf_chi , & param , error ) this % chi = param ( 1 ) call h5ltget_attribute_double_f ( file_id , group_name , hdf_zeta , & param , error ) this % zeta = param ( 1 ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading attributes from HDF group ' // & group_name ) ret_err = error end if call h5ltget_attribute_int_f ( file_id , group_name , hdf_n_kappa , & iparam , error ) if ( error /= 0 ) then ! For backwards compatibility, don't crash if this attribute is ! not present. Instead just realise there is no internal layer ! data in the HDF file. nkap = 0 else nkap = iparam ( 1 ) end if call this % thickness % read_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when reading ' // & 'ice shelf thickness field from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % read_hdf ( group_id , hdf_velocity , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading ice shelf velocity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if if ( nkap > 0 ) allocate ( this % kappa ( nkap )) do i = 1 , nkap write ( fieldname , hdf_kappa ) i call this % kappa ( i )% read_hdf ( group_id , fieldname , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when reading ' // & 'ice shelf kappa field from HDF file' ) if ( ret_err == 0 ) ret_err = error end if end do call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err #ifdef DEBUG call logger % debug ( 'ice_shelf%read_data' , 'Read ice shelf data from ' // & 'HDF group ' // group_name ) #endif end subroutine shelf_read_data"},{"title":"shelf_write_data – ISOFT","tags":"","loc":"proc/shelf_write_data.html","text":"private subroutine shelf_write_data(this, file_id, group_name, error) Writes the state of the ice shelf object to an HDF file in the\n specified group. This will consist of a thickness and a velocity\n dataset. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Calls proc~~shelf_write_data~~CallsGraph proc~shelf_write_data shelf_write_data h5ltset_attribute_string_f h5ltset_attribute_string_f proc~shelf_write_data->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~shelf_write_data->h5gcreate_f h5ltset_attribute_int_f h5ltset_attribute_int_f proc~shelf_write_data->h5ltset_attribute_int_f str str proc~shelf_write_data->str h5ltset_attribute_double_f h5ltset_attribute_double_f proc~shelf_write_data->h5ltset_attribute_double_f h5gclose_f h5gclose_f proc~shelf_write_data->h5gclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code shelf_write_data Source Code subroutine shelf_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the ice shelf object to an HDF file in the ! specified group. This will consist of a thickness and a velocity ! dataset. ! class ( ice_shelf ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err , i , nkap character ( len = 20 ) :: fieldname ret_err = 0 call h5gcreate_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'creating HDF group \"' // group_name // '\"' ) call logger % error ( 'ice_shelf%write_data' , 'Data IO not performed for ' // & 'ice shelf' ) return end if if ( allocated ( this % kappa )) then nkap = size ( this % kappa ) else nkap = 0 end if call h5ltset_attribute_string_f ( file_id , group_name , hdf_type_attr , & hdf_type_name , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_lambda , & [ this % lambda ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_chi , & [ this % chi ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_zeta , & [ this % zeta ], 1_size_t , error ) call h5ltset_attribute_int_f ( file_id , group_name , hdf_n_kappa , & [ nkap ], 1_size_t , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing attribute to HDF group ' // & group_name ) ret_err = error end if call this % thickness % write_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when writing ' // & 'ice shelf thickness field to HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % write_hdf ( group_id , hdf_velocity , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing ice shelf velocity field ' // & 'to HDF file' ) if ( ret_err == 0 ) ret_err = error end if do i = 1 , nkap write ( fieldname , hdf_kappa ) i call this % kappa ( i )% write_hdf ( group_id , trim ( fieldname ), error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing ice shelf kappa field ' // & 'to HDF file' ) if ( ret_err == 0 ) ret_err = error end if end do call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'ice_shelf%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err call logger % trivia ( 'ice_shelf%write_data' , 'Wrote ice shelf data to ' // & 'HDF group ' // group_name ) end subroutine shelf_write_data"},{"title":"shelf_solve_velocity – ISOFT","tags":"","loc":"proc/shelf_solve_velocity.html","text":"private subroutine shelf_solve_velocity(this, basal_drag, success) Computes the ice shelf velocity at the current time with the\n current ice thickness. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. logical, intent(out) :: success True if the integration is successful, false otherwise Calls proc~~shelf_solve_velocity~~CallsGraph proc~shelf_solve_velocity shelf_solve_velocity interface~nitsol nitsol proc~shelf_solve_velocity->interface~nitsol str str proc~shelf_solve_velocity->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code shelf_solve_velocity Source Code subroutine shelf_solve_velocity ( this , basal_drag , success ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Computes the ice shelf velocity at the current time with the ! current ice thickness. ! class ( ice_shelf ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: basal_drag !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. logical , intent ( out ) :: success !! True if the integration is successful, false otherwise integer , save :: nval , kdmax = 20 real ( r8 ), dimension (:), allocatable :: state integer , dimension ( 10 ) :: input integer , dimension ( 6 ) :: info real ( r8 ), dimension (:), allocatable , save :: work real ( r8 ), dimension ( 1 ) :: real_param integer , dimension ( 1 ) :: int_param integer :: flag call basal_drag % guard_temp () nval = this % velocity % raw_size () if ( allocated ( work )) then if ( size ( work ) < nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 )) then deallocate ( work ) allocate ( work ( nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 ))) end if else allocate ( work ( nval * ( kdmax + 5 ) + kdmax * ( kdmax + 3 ))) end if input = 0 input ( 4 ) = kdmax input ( 5 ) = 1 input ( 9 ) = - 1 input ( 10 ) = 3 state = this % velocity % raw () call nitsol ( nval , state , nitsol_residual , nitsol_precondition , & 1.e-10_r8 * nval , 1.e-10_r8 * nval , input , info , work , & real_param , int_param , flag , ddot , dnrm2 ) call this % velocity % set_from_raw ( state ) this % eta = this % viscosity_law % ice_viscosity ( this % velocity , this % ice_temperature (), & this % time ) this % stale_jacobian = . true . select case ( flag ) case ( 0 ) call logger % trivia ( 'ice_shelf%solve_velocity' , 'Found ice velocity at time ' // & trim ( str ( this % time ))) success = . true . case ( 1 ) call logger % error ( 'ice_shelf%solve_velocity' , 'Reached maximum number of' // & ' iterations finding ice velocity' ) success = . false . case default call logger % error ( 'ice_shelf%solve_velocity' , 'NITSOL failed when finding' // & ' ice velocity with error code ' // trim ( str ( flag ))) success = . false . end select call basal_drag % clean_temp () contains subroutine nitsol_residual ( n , xcur , fcur , rpar , ipar , itrmf ) !! A routine matching the interface expected by NITSOL which !! returns the residual for the glacier. integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( out ) :: fcur !! Array of length `n` containing f(xcur) on output real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array integer , intent ( out ) :: itrmf !! Termination flag. 0 means normal termination, 1 means !! failure to produce f(xcur) type ( cheb1d_scalar_field ) :: scalar_tmp integer :: start , finish , bounds_start , bounds_finish integer , dimension (:), allocatable :: lower , upper real ( r8 ), dimension (:), allocatable :: bounds call this % velocity % set_from_raw ( xcur ) this % stale_jacobian = . true . associate ( h => this % thickness , uvec => this % velocity , chi => this % chi , & zeta => this % zeta , eta => this % eta ) eta = this % viscosity_law % ice_viscosity ( uvec , this % ice_temperature (), & this % time ) bounds = this % boundaries % boundary_residuals ( h , uvec , eta , this % time ) scalar_tmp = uvec % component ( 1 ) scalar_tmp = 4.0_r8 * eta * h * scalar_tmp % d_dx ( 1 ) scalar_tmp = - 2.0_r8 * chi * h * h % d_dx ( 1 ) + scalar_tmp % d_dx ( 1 ) lower = this % boundaries % velocity_lower_bound () upper = this % boundaries % velocity_upper_bound () ! TODO: Figure out how to make this independent of order which ! values are stored in the field start = 1 finish = start + this % velocity_upper_bound_size - 1 bounds_start = this % thickness_lower_bound_size & + this % thickness_upper_bound_size & + this % velocity_lower_bound_size + 1 bounds_finish = bounds_start + this % velocity_upper_bound_size - 1 fcur ( start : finish ) = bounds ( bounds_start : bounds_finish ) start = finish + 1 finish = start + scalar_tmp % raw_size ( lower , upper ) - 1 fcur ( start : finish ) = scalar_tmp % raw ( lower , upper ) start = finish + 1 finish = start + this % velocity_lower_bound_size - 1 bounds_start = this % thickness_lower_bound_size & + this % thickness_upper_bound_size + 1 bounds_finish = bounds_start + this % velocity_lower_bound_size - 1 fcur ( start : finish ) = bounds ( bounds_start : bounds_finish ) end associate itrmf = 0 end subroutine nitsol_residual subroutine nitsol_precondition ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! A subroutine matching the interface expected by NITSOL, which !! acts as a preconditioner. integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of lenght `n` containing the current $x$ value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of lenght `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flat indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce $J\\vec{v}$, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} type ( cheb1d_scalar_field ) :: delta_u , tmp integer :: i , sl , el , su , eu integer , dimension ( 2 ) :: upper_type , lower_type integer , dimension (:), allocatable :: boundary_types , boundary_locations real ( r8 ) :: eta_val if ( ijob /= 1 ) then itrmjv = 0 return end if call delta_u % assign_meta_data ( this % velocity ) call delta_u % set_from_raw ( v ) sl = this % velocity_size - this % velocity_lower_bound_size + 1 el = this % velocity_size su = 1 eu = this % velocity_upper_bound_size boundary_locations = [( i , i = sl , el ), ( i , i = su , eu )] upper_type = this % boundaries % velocity_upper_type () lower_type = this % boundaries % velocity_lower_type () boundary_types = [( lower_type ( 1 ), i = sl , el ), ( upper_type ( 1 ), i = su , eu )] associate ( h => this % thickness , chi => this % chi , zeta => this % zeta , & jac => this % velocity_jacobian , eta => this % eta ) if ( this % stale_jacobian ) then ! Mathematically, it should be 4._r8*eta*h which I pass, but ! this sometimes results in an ill-conditioned Jacobian (for ! reasons I'm not clear on). If eta ~ 1 then turns out I get ! good results just ignoring it. select type ( visc => this % viscosity_law ) class is ( newtonian_viscosity ) eta_val = eta % get_element ( 1 ) if ( eta_val <= 0._r8 ) eta_val = 1._r8 jac = jacobian_block ( 4._r8 * eta * h , 1 , 1 , boundary_locs = boundary_locations , & boundary_types = boundary_types ) class default jac = jacobian_block ( 4._r8 * h , 1 , 1 , boundary_locs = boundary_locations , & boundary_types = boundary_types ) end select this % stale_jacobian = . false . end if delta_u = jac % solve_for ( delta_u ) z ( 1 : n ) = delta_u % raw () end associate itrmjv = 0 end subroutine nitsol_precondition end subroutine shelf_solve_velocity"},{"title":"shelf_integrate – ISOFT","tags":"","loc":"proc/shelf_integrate.html","text":"private subroutine shelf_integrate(this, old_states, basal_melt, basal_drag, water_density, time, success) Integrates the glacier's state forward to time . This is done\n using an explicit method for the thickness and a Newton's solver\n for velocity. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. class(scalar_field), intent(in) :: basal_melt The melt rate that the bottom of the glacier experiences\n during this time step. class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise Contents Source Code shelf_integrate Source Code subroutine shelf_integrate ( this , old_states , basal_melt , basal_drag , & water_density , time , success ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Integrates the glacier's state forward to `time`. This is done ! using an explicit method for the thickness and a Newton's solver ! for velocity. ! class ( ice_shelf ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: old_states !! Previous states of the glacier, with the most recent one !! first. class ( scalar_field ), intent ( in ) :: basal_melt !! The melt rate that the bottom of the glacier experiences !! during this time step. class ( scalar_field ), intent ( in ) :: basal_drag !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier. real ( r8 ), intent ( in ) :: time !! The time to which the glacier should be integrated logical , intent ( out ) :: success !! True if the integration is successful, false otherwise associate ( h => this % thickness , uvec => this % velocity , m => basal_melt , & lambda => this % lambda , chi => this % chi , zeta => this % zeta , & t_old => this % time ) this % thickness = this % thickness - ( time - t_old ) * ( lambda * m + . div .( h * uvec )) end associate end subroutine shelf_integrate"},{"title":"shelf_assign – ISOFT","tags":"","loc":"proc/shelf_assign.html","text":"private subroutine shelf_assign(this, rhs) Copies the data from one ice shelf into another. This is only\n needed due to a bug in gfortran which means that the intrinsic\n assignment for glacier types is not using the appropriate\n defined assignment for the field components. It does not assign the Jacobian object as it would take up quite\n a bit of extra space and it is unlikely that it would ever be\n needed without first having to be recalculated. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(out) :: this class( glacier ), intent(in) :: rhs The ice shelf to be assigned to this one. Contents Source Code shelf_assign Source Code subroutine shelf_assign ( this , rhs ) !* Author: Chris MacMackin !  Date: February 2017 ! ! Copies the data from one ice shelf into another. This is only ! needed due to a bug in gfortran which means that the intrinsic ! assignment for glacier types is not using the appropriate ! defined assignment for the field components. ! ! It does not assign the Jacobian object as it would take up quite ! a bit of extra space and it is unlikely that it would ever be ! needed without first having to be recalculated. ! class ( ice_shelf ), intent ( out ) :: this class ( glacier ), intent ( in ) :: rhs !! The ice shelf to be assigned to this one. select type ( rhs ) class is ( ice_shelf ) this % thickness = rhs % thickness this % velocity = rhs % velocity this % eta = rhs % eta this % lambda = rhs % lambda this % chi = rhs % chi this % zeta = rhs % zeta this % courant = rhs % courant this % max_dt = rhs % max_dt allocate ( this % viscosity_law , source = rhs % viscosity_law ) allocate ( this % boundaries , source = rhs % boundaries ) this % time = rhs % time this % thickness_size = rhs % thickness_size this % velocity_size = rhs % velocity_size this % boundary_start = rhs % boundary_start this % thickness_lower_bound_size = rhs % thickness_lower_bound_size this % thickness_upper_bound_size = rhs % thickness_upper_bound_size this % velocity_lower_bound_size = rhs % velocity_lower_bound_size this % velocity_upper_bound_size = rhs % velocity_upper_bound_size this % stale_jacobian = . true . this % stale_eta = . true . if ( allocated ( rhs % kappa )) then allocate ( this % kappa ( size ( rhs % kappa ))) this % kappa = rhs % kappa end if class default call logger % fatal ( 'ice_shelf%assign' , 'Type other than `ice_shelf` ' // & 'requested to be assigned.' ) error stop end select #ifdef DEBUG call logger % debug ( 'ice_shelf%assign' , 'Copied ice shelf data.' ) #endif end subroutine shelf_assign"},{"title":"ice_shelf_integrate_layers – ISOFT","tags":"","loc":"proc/ice_shelf_integrate_layers.html","text":"private subroutine ice_shelf_integrate_layers(this, old_states, time, success) Integrate the Taylor coefficients representing the vertical\n structure of internal reflectors forward to the specified\n time. This is done using an implicit method, with the resulting\n linear system solved using GMRES. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the ice_shelf, with the most recent one\n first. real(kind=r8), intent(in) :: time The time to which the ice_shelf should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise Calls proc~~ice_shelf_integrate_layers~~CallsGraph proc~ice_shelf_integrate_layers ice_shelf_integrate_layers str str proc~ice_shelf_integrate_layers->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ice_shelf_integrate_layers Source Code subroutine ice_shelf_integrate_layers ( this , old_states , time , success ) !* Author: Chris MacMackin !  Date: September 2018 ! ! Integrate the Taylor coefficients representing the vertical ! structure of internal reflectors forward to the specified ! time. This is done using an implicit method, with the resulting ! linear system solved using GMRES. ! class ( ice_shelf ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: old_states !! Previous states of the ice_shelf, with the most recent one !! first. real ( r8 ), intent ( in ) :: time !! The time to which the ice_shelf should be integrated logical , intent ( out ) :: success !! True if the integration is successful, false otherwise integer :: n , flag real ( r8 ), dimension (:), allocatable :: solution real ( r8 ) :: dt , resid type ( jacobian_block ) :: precond_block if (. not . allocated ( this % kappa )) return select type ( old_states ) class is ( ice_shelf ) dt = time - old_states ( 1 )% time do n = 1 , size ( this % kappa ) solution = this % kappa ( n )% raw () precond_block = jacobian_block ( dt * this % velocity % component ( 1 ), 1 , & boundary_locs = [ this % thickness_size ], & boundary_types = [ dirichlet ], & coef = real ( - n , r8 )) + 1._r8 call gmres_solve ( solution , operator , old_states ( 1 )% kappa ( n )% raw (), resid , & flag , precond = preconditioner , krylov_dim = 40 ) call this % kappa ( n )% set_from_raw ( solution ) if ( flag /= 0 ) then call logger % error ( 'ice_shelf%integrate_layers' , 'GMRES solver ' // & 'returned with error code ' // str ( flag )) success = . false . return end if call this % kappa ( n )% set_from_raw ( solution ) end do class default call logger % fatal ( 'ice_shelf%integrate_layers' , 'Type other than `ice_shelf` ' // & 'passed to `ice_shelf` object as a previous state.' ) error stop end select contains function operator ( v , xcur , rhs , rpar , ipar , success ) real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be multiplied real ( r8 ), dimension (:), intent ( in ) :: xcur !! Array containing the current estimate of the independent !! variables in the linear system. This may not be needed, but !! is provided just in case. real ( r8 ), dimension (:), intent ( in ) :: rhs !! Array containing the right hand side of the linear !! system. This may not be needed, but is provided just in !! case. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array logical , intent ( out ) :: success !! Indicates whether operation was completed succesfully real ( r8 ), dimension ( size ( xcur )) :: operator !! Result of the operation type ( cheb1d_scalar_field ) :: kappa class ( scalar_field ), pointer :: tmp call kappa % assign_meta_data ( this % kappa ( n )) call kappa % set_from_raw ( v ) tmp => dt * this % velocity . dot . (. grad . kappa ) kappa = ( 1._r8 - n * dt * (. div . this % velocity )) * kappa + tmp operator = kappa % raw () operator ( this % thickness_size ) = v ( this % thickness_size ) success = . true . end function operator function preconditioner ( v , xcur , rhs , rpar , ipar , success ) real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be multiplied real ( r8 ), dimension (:), intent ( in ) :: xcur !! Array containing the current estimate of the independent !! variables in the linear system. This may not be needed, but !! is provided just in case. real ( r8 ), dimension (:), intent ( in ) :: rhs !! Array containing the right hand side of the linear !! system. This may not be needed, but is provided just in !! case. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array logical , intent ( out ) :: success !! Indicates whether operation was completed succesfully real ( r8 ), dimension ( size ( xcur )) :: preconditioner !! Result of the operation type ( cheb1d_scalar_field ) :: tmp call tmp % assign_meta_data ( this % kappa ( n )) call tmp % set_from_raw ( v ) tmp = precond_block % solve_for ( tmp ) preconditioner = tmp % raw () success = . true . end function preconditioner end subroutine ice_shelf_integrate_layers"},{"title":"ei – ISOFT","tags":"","loc":"proc/ei.html","text":"public elemental function ei(x) * * * * * * * * * * * *80 EI evaluates the exponential integral Ei(X). Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x Return Value real(kind=8) Calls proc~~ei~~CallsGraph proc~ei ei proc~calcei calcei proc~ei->proc~calcei Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None"},{"title":"calcei – ISOFT","tags":"","loc":"proc/calcei.html","text":"public elemental subroutine calcei(arg, result, jint) * * * * * * * * * * * *80 CALCEI computes various exponential integrals. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: arg real(kind=8), intent(out) :: result integer(kind=4), intent(in) :: jint Called by proc~~calcei~~CalledByGraph proc~calcei calcei proc~ei ei proc~ei->proc~calcei Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~3.html","text":"private function constructor(val, grad) result(this) Creates a new scalar field with a uniform value across all of\n space but a non-zero gradient. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: val The value of the field real(kind=r8), intent(in), dimension(:) :: grad An array in which the i th element contains the gradient in\n the _i_th direction. Directions corresponding to values of i greater than the size of the array are taken to have a\n gradient of zero. Return Value type( uniform_gradient_field ) A scalar field initated based on teh arguments of this\n function. Calls proc~~constructor~3~~CallsGraph proc~constructor~3 constructor uniform_scalar_field uniform_scalar_field proc~constructor~3->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~constructor~3~~CalledByGraph proc~constructor~3 constructor interface~uniform_gradient_field uniform_gradient_field interface~uniform_gradient_field->proc~constructor~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code function constructor ( val , grad ) result ( this ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Creates a new scalar field with a uniform value across all of ! space but a non-zero gradient. ! real ( r8 ), intent ( in ) :: val !! The value of the field real ( r8 ), dimension (:), intent ( in ) :: grad !! An array in which the `i`th element contains the gradient in !! the _i_th direction. Directions corresponding to values of !! `i` greater than the size of the array are taken to have a !! gradient of zero. type ( uniform_gradient_field ) :: this !! A scalar field initated based on teh arguments of this !! function. this % uniform_scalar_field = uniform_scalar_field ( val ) this % grad = grad end function constructor"},{"title":"uniform_gradient_d_dx – ISOFT","tags":"","loc":"proc/uniform_gradient_d_dx.html","text":"private function uniform_gradient_d_dx(this, dir, order) result(res) \\frac{\\partial&#94;{\\rm order}}{\\partial x_{\\rm dir}&#94;{\\rm order}}{\\rm field} Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(in) :: this integer, intent(in) :: dir Direction in which to differentiate integer, intent(in), optional :: order Order of the derivative, default = 1 Return Value class(scalar_field),\n  pointer Calls proc~~uniform_gradient_d_dx~~CallsGraph proc~uniform_gradient_d_dx uniform_gradient_d_dx uniform_scalar_field uniform_scalar_field proc~uniform_gradient_d_dx->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code uniform_gradient_d_dx Source Code function uniform_gradient_d_dx ( this , dir , order ) result ( res ) !* Author: Chris MacMackin !  Date: July 2017 ! ! \\frac{\\partial&#94;{\\rm order}}{\\partial x_{\\rm dir}&#94;{\\rm order}}{\\rm field} ! class ( uniform_gradient_field ), intent ( in ) :: this integer , intent ( in ) :: dir !! Direction in which to differentiate integer , optional , intent ( in ) :: order !! Order of the derivative, default = 1 class ( scalar_field ), pointer :: res integer :: ord call this % guard_temp () call this % allocate_scalar_field ( res ) if ( present ( order )) then ord = order else ord = 1 end if select type ( res ) class is ( uniform_scalar_field ) if ( ord == 1 ) then if ( dir > 0 . and . dir <= size ( this % grad )) then res = uniform_scalar_field ( this % grad ( dir )) else res = uniform_scalar_field ( 0.0_r8 ) end if else res = uniform_scalar_field ( 0.0_r8 ) end if class default error stop ( 'Non-uniform_gradient_field type allocated by ' // & '`allocate_scalar_field` routine.' ) end select call res % set_temp () ! Shouldn't need to call this, but for some ! rason being set as non-temporary when ! assignment subroutine returns. call this % clean_temp () end function uniform_gradient_d_dx"},{"title":"uniform_gradient_gradient – ISOFT","tags":"","loc":"proc/uniform_gradient_gradient.html","text":"private function uniform_gradient_gradient(this) result(res) \\nabla{\\rm field} Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(in) :: this Return Value class(vector_field),\n  pointer The result of this operation Calls proc~~uniform_gradient_gradient~~CallsGraph proc~uniform_gradient_gradient uniform_gradient_gradient uniform_vector_field uniform_vector_field proc~uniform_gradient_gradient->uniform_vector_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code uniform_gradient_gradient Source Code function uniform_gradient_gradient ( this ) result ( res ) !* Author: Chris MacMackin !  Date: July 2017 ! ! \\nabla{\\rm field} ! class ( uniform_gradient_field ), intent ( in ) :: this class ( vector_field ), pointer :: res !! The result of this operation call this % guard_temp () call this % allocate_vector_field ( res ) select type ( res ) class is ( uniform_vector_field ) res = uniform_vector_field ( this % grad ) class default error stop ( 'Non-uniform_vector_field type allocated by ' // & '`allocate_vector_field` routine.' ) end select call this % clean_temp () end function uniform_gradient_gradient"},{"title":"uniform_gradient_is_equal – ISOFT","tags":"","loc":"proc/uniform_gradient_is_equal.html","text":"private function uniform_gradient_is_equal(this, rhs) result(iseq) Evaluates whether two scalar fields are equal within a tolerance,\n specified by set_tol . Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(in) :: this class(scalar_field), intent(in) :: rhs Return Value logical Calls proc~~uniform_gradient_is_equal~~CallsGraph proc~uniform_gradient_is_equal uniform_gradient_is_equal get_tol get_tol proc~uniform_gradient_is_equal->get_tol is_nan is_nan proc~uniform_gradient_is_equal->is_nan Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code uniform_gradient_is_equal Source Code logical function uniform_gradient_is_equal ( this , rhs ) result ( iseq ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Evaluates whether two scalar fields are equal within a tolerance, ! specified by `set_tol`. ! class ( uniform_gradient_field ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: rhs real ( r8 ) :: normalization integer :: i call this % guard_temp (); call rhs % guard_temp () iseq = . true . select type ( rhs ) class is ( uniform_gradient_field ) iseq = ( this % uniform_scalar_field == rhs % uniform_scalar_field ) do i = 1 , size ( this % grad ) if (. not . iseq ) return normalization = abs ( this % grad ( i )) if ( normalization < get_tol ()) normalization = 1.0_r8 iseq = iseq . and .( (( this % grad ( i ) - rhs % grad ( i )) / normalization < & get_tol ()) . or . ( is_nan ( this % grad ( i )). and . & is_nan ( rhs % grad ( i ))) ) end do class default iseq = ( rhs == this ) end select call this % clean_temp (); call rhs % clean_temp () end function uniform_gradient_is_equal"},{"title":"uniform_gradient_assign – ISOFT","tags":"","loc":"proc/uniform_gradient_assign.html","text":"private impure elemental subroutine uniform_gradient_assign(this, rhs) {\\rm field} = {\\rm field} Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(inout) :: this class(scalar_field), intent(in) :: rhs Contents Source Code uniform_gradient_assign Source Code impure elemental subroutine uniform_gradient_assign ( this , rhs ) !* Author: Chris MacMackin !  Date: July 2017 ! ! {\\rm field} = {\\rm field} ! class ( uniform_gradient_field ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: rhs call rhs % guard_temp () select type ( rhs ) class is ( uniform_gradient_field ) this % uniform_scalar_field = rhs % uniform_scalar_field if ( allocated ( rhs % grad )) then this % grad = rhs % grad else if ( allocated ( this % grad )) then deallocate ( this % grad ) end if call this % unset_temp () class is ( uniform_scalar_field ) this % uniform_scalar_field = rhs if ( allocated ( this % grad )) deallocate ( this % grad ) call this % unset_temp () class default error stop ( 'Assigning incompatible type to uniform_gradient_field' ) end select call rhs % clean_temp () end subroutine uniform_gradient_assign"},{"title":"uniform_gradient_field – ISOFT","tags":"","loc":"interface/uniform_gradient_field.html","text":"public interface uniform_gradient_field Calls interface~~uniform_gradient_field~~CallsGraph interface~uniform_gradient_field uniform_gradient_field proc~constructor~3 constructor interface~uniform_gradient_field->proc~constructor~3 uniform_scalar_field uniform_scalar_field proc~constructor~3->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private function constructor (val, grad) result(this) Author Chris MacMackin Date July 2017 Creates a new scalar field with a uniform value across all of\n space but a non-zero gradient. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: val The value of the field real(kind=r8), intent(in), dimension(:) :: grad An array in which the i th element contains the gradient in\n the _i_th direction. Directions corresponding to values of i greater than the size of the array are taken to have a\n gradient of zero. Return Value type( uniform_gradient_field ) A scalar field initated based on teh arguments of this\n function."},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~4.html","text":"private function constructor(tolerance, max_iterations) result(this) Create a preconditioner object with the desired tolerance and\n maximum number of iterations. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: tolerance The tolerance within which to apply the inverse Jacobian.\n Defaults to 0.001. integer, intent(in), optional :: max_iterations The maximum number of iterations to use when applying the\n preconditioner. Defaults to 20. Return Value type( preconditioner ) Called by proc~~constructor~4~~CalledByGraph proc~constructor~4 constructor interface~preconditioner preconditioner interface~preconditioner->proc~constructor~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code function constructor ( tolerance , max_iterations ) result ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Create a preconditioner object with the desired tolerance and ! maximum number of iterations. ! real ( r8 ), optional , intent ( in ) :: tolerance !! The tolerance within which to apply the inverse Jacobian. !! Defaults to 0.001. integer , optional , intent ( in ) :: max_iterations !! The maximum number of iterations to use when applying the !! preconditioner. Defaults to 20. type ( preconditioner ) :: this if ( present ( tolerance )) this % tolerance = tolerance if ( present ( max_iterations )) this % max_iterations = max_iterations end function constructor"},{"title":"preconditioner_apply – ISOFT","tags":"","loc":"proc/preconditioner_apply.html","text":"private subroutine preconditioner_apply(this, jacobian, vector, estimate) Use Picard iteration to approximately multiply the state vector\n by the inverse Jacobian. The details for this procedure are in\n the documentation of the preconditioner type. Arguments Type Intent Optional Attributes Name class( preconditioner ), intent(in) :: this class( jacobian_block ), intent(inout), dimension(:,:) :: jacobian An n\\times n matrix approximating the Jacobian for which\n the preconditioner is used. class(scalar_field), intent(in), dimension(:) :: vector A vector of size n which is to be preconditioned. class(scalar_field), intent(inout), dimension(:) :: estimate On entry, an initial guess for the preconditioned vector. On\n exit, the iteratively determined value of the preconditioned\n vector. Calls proc~~preconditioner_apply~~CallsGraph proc~preconditioner_apply preconditioner_apply str str proc~preconditioner_apply->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code preconditioner_apply Source Code subroutine preconditioner_apply ( this , jacobian , vector , estimate ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Use Picard iteration to approximately multiply the state vector ! by the inverse Jacobian. The details for this procedure are in ! the documentation of the [[preconditioner(type)]] type. ! class ( preconditioner ), intent ( in ) :: this class ( jacobian_block ), dimension (:,:), intent ( inout ) :: jacobian !! An n\\times n matrix approximating the Jacobian for which !! the preconditioner is used. class ( scalar_field ), dimension (:), intent ( in ) :: vector !! A vector of size n which is to be preconditioned. class ( scalar_field ), dimension (:), intent ( inout ) :: estimate !! On entry, an initial guess for the preconditioned vector. On !! exit, the iteratively determined value of the preconditioned !! vector. character ( len = 77 ), parameter :: success_format = '(\"Picard solver ' // & 'converged with error of \",es12.5,\" after \",i2,\" iterations.\")' character ( len = 77 ), parameter :: failure_format = '(\"Picard solver ' // & 'reached maximum (\",i3,\") iterations, with error \",es12.5,\".\")' integer , parameter :: msg_len = 72 class ( scalar_field ), dimension (:), allocatable :: prev_estimate integer :: i , j , k , n real ( r8 ) :: max_err , old_max_err class ( scalar_field ), allocatable :: tmp_field logical :: first character ( len = msg_len ) :: msg #ifdef DEBUG call logger % debug ( 'preconditioner_apply' , 'Entering function `precondition`.' ) #endif call vector % guard_temp (); call estimate % guard_temp () n = size ( vector ) allocate ( prev_estimate ( n ), mold = estimate ) allocate ( tmp_field , mold = vector ( 1 )) #ifdef DEBUG if ( size ( jacobian , 1 ) /= size ( jacobian , 2 )) then error stop ( 'Jacobian is not a square matrix.' ) end if if ( size ( jacobian , 1 ) /= size ( vector )) then error stop ( 'Vector is of different size than Jacobian.' ) end if if ( size ( estimate ) /= size ( vector )) then error stop ( 'Estimate is of different size than vector.' ) end if #endif ! Until reached maximum number of iterations... do i = 1 , this % max_iterations ! For each row of the Jacobian, solve for the diagonal block, ! with off-diagonal blocks applied to the previous guess and ! subtracted from the right-hand-side. max_err = 0._r8 prev_estimate = estimate do j = 1 , n first = . true . do k = 1 , n if ( k == j ) cycle if ( first ) then first = . false . tmp_field = jacobian ( j , k ) * estimate ( k ) else tmp_field = tmp_field + jacobian ( j , k ) * estimate ( k ) end if end do estimate ( j ) = jacobian ( j , j )% solve_for ( vector ( j ) - tmp_field ) max_err = max ( max_err , & maxval ( abs ( ( estimate ( j ) - prev_estimate ( j )) / ( prev_estimate ( j ) + 1 e - 10_r8 ) ))) end do ! If difference between result and previous guess is less than ! the tolerance, stop iterations if ( max_err < this % tolerance ) then write ( msg , success_format ) max_err , i #ifdef DEBUG call logger % debug ( 'preconditioner%apply' , msg ) call logger % debug ( 'preconditioner%apply' , 'Exiting function `precondition`.' ) #endif call vector % clean_temp (); call estimate % clean_temp () return end if if ( i > 1 . and . old_max_err <= max_err ) then call logger % trivia ( 'preconditioner%apply' , 'Iterations diverging. Exiting ' // & 'and returning previous iterate, with maximum error ' // & str ( old_max_err ) // '.' ) #ifdef DEBUG call logger % debug ( 'preconditioner%apply' , 'Exiting function `precondition`.' ) #endif estimate = prev_estimate call vector % clean_temp (); call estimate % clean_temp () return end if old_max_err = max_err end do write ( msg , failure_format ) this % max_iterations , max_err call logger % warning ( 'preconditioner%apply' , msg ) call vector % clean_temp (); call estimate % clean_temp () call logger % debug ( 'preconditioner%apply' , 'Exiting function `precondition`.' ) end subroutine preconditioner_apply"},{"title":"preconditioner – ISOFT","tags":"","loc":"interface/preconditioner.html","text":"public interface preconditioner Calls interface~~preconditioner~~CallsGraph interface~preconditioner preconditioner proc~constructor~4 constructor interface~preconditioner->proc~constructor~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private function constructor (tolerance, max_iterations) result(this) Author Chris MacMackin Date December 2016 Create a preconditioner object with the desired tolerance and\n maximum number of iterations. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: tolerance The tolerance within which to apply the inverse Jacobian.\n Defaults to 0.001. integer, intent(in), optional :: max_iterations The maximum number of iterations to use when applying the\n preconditioner. Defaults to 20. Return Value type( preconditioner )"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~5.html","text":"private function constructor(template) result(this) Builds a Chebyshsev pseudospectral differentiation matrix block\n which can be used to solve the inverse problem. The result can\n only be used with fields having the same grid as the template. Arguments Type Intent Optional Attributes Name class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. Return Value type( pseudospec_block ) Calls proc~~constructor~5~~CallsGraph proc~constructor~5 constructor collocation_points collocation_points proc~constructor~5->collocation_points Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~constructor~5~~CalledByGraph proc~constructor~5 constructor interface~pseudospec_block pseudospec_block interface~pseudospec_block->proc~constructor~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code function constructor ( template ) result ( this ) !* Author: Chris MacMackin !  Date: September 2017 ! ! Builds a Chebyshsev pseudospectral differentiation matrix block ! which can be used to solve the inverse problem. The result can ! only be used with fields having the same grid as the template. ! class ( abstract_field ), intent ( in ) :: template !! A scalar field with the same grid as any fields passed as !! arguments to the [[pseudospec_block(type):solve_for]] method. type ( pseudospec_block ) :: this real ( r8 ), dimension (:,:), allocatable :: domain domain = template % domain () this % xvals => collocation_points ( template % elements () - 1 , domain ( 1 , 1 ), & domain ( 1 , 2 )) end function constructor"},{"title":"pseudospec_block_solve_scalar – ISOFT","tags":"","loc":"proc/pseudospec_block_solve_scalar.html","text":"private function pseudospec_block_solve_scalar(this, rhs, bound_loc, bound_val, good_bound) result(solution) Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a scalar field). Warning Currently this is only implemented for a 1-D field. Arguments Type Intent Optional Attributes Name class( pseudospec_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. integer, intent(in) :: bound_loc Which boundary is being set. The boundary will be the one\n normal to dimension of number abs(boundary) . If the\n argument is negative, then the lower boundary is returned. If\n positive, then the upper boundary is returned. class(scalar_field), intent(in) :: bound_val The value of the result at the specified boundary. integer, intent(in), optional :: good_bound If provided, indicates which boundary contains trusted\n information from which to calculate the power of the highest\n frequency mode. Defaults to the opposite of bound_loc . Return Value class(scalar_field),\n  pointer Calls proc~~pseudospec_block_solve_scalar~~CallsGraph proc~pseudospec_block_solve_scalar pseudospec_block_solve_scalar integrate_1d integrate_1d proc~pseudospec_block_solve_scalar->integrate_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pseudospec_block_solve_scalar Source Code function pseudospec_block_solve_scalar ( this , rhs , bound_loc , bound_val , & good_bound ) result ( solution ) !* Author: Chris MacMackin !  Date: September 2017 ! ! Solves the linear(ised) system represented by this finite ! difference block, for a given right hand side state vector ! (represented by a scalar field). ! ! @Warning Currently this is only implemented for a 1-D field. ! class ( pseudospec_block ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: rhs !! The right hand side of the linear(ised) system. integer , intent ( in ) :: bound_loc !! Which boundary is being set. The boundary will be the one !! normal to dimension of number `abs(boundary)`. If the !! argument is negative, then the lower boundary is returned. If !! positive, then the upper boundary is returned. class ( scalar_field ), intent ( in ) :: bound_val !! The value of the result at the specified boundary. integer , intent ( in ), optional :: good_bound !! If provided, indicates which boundary contains trusted !! information from which to calculate the power of the highest !! frequency mode. Defaults to the opposite of `bound_loc`. class ( scalar_field ), pointer :: solution real ( r8 ), dimension (:), allocatable :: sol_vector , bound_vec logical :: valid_bound integer :: bloc call rhs % guard_temp (); call bound_val % guard_temp () valid_bound = . true . select case ( bound_loc ) case ( 1 ) bloc = 1 case ( - 1 ) bloc = size ( this % xvals ) case default valid_bound = . false . !call logger%warning('pseudospec_block%solve_for', '1-D field does not '// & !                    'have boundary in dimension '//str(bound_loc)) end select sol_vector = rhs % raw () if ( valid_bound ) then bound_vec = bound_val % raw () call integrate_1d ( sol_vector , this % xvals , bloc , bound_vec ( 1 ), good_bound ) else call integrate_1d ( sol_vector , this % xvals , good_bound = good_bound ) end if #ifdef DEBUG call logger % debug ( 'pseudospec_block%solve_for' , & 'Successfully performed Chebyshev pseudospectral integration.' ) #endif call rhs % allocate_scalar_field ( solution ) call solution % unset_temp () call solution % assign_meta_data ( rhs ) call solution % set_from_raw ( sol_vector ) call rhs % clean_temp (); call bound_val % clean_temp () call solution % set_temp () end function pseudospec_block_solve_scalar"},{"title":"pseudospec_block_solve_vector – ISOFT","tags":"","loc":"proc/pseudospec_block_solve_vector.html","text":"private function pseudospec_block_solve_vector(this, rhs, bound_loc, bound_val, good_bound) result(solution) Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a vector field). Warning Currently this is only implemented for a 1-D field. Bug For some reason, calls to the vector_dimensions() method\n produce a segfault when rhs is class(vector_field) . Everything works fine if it is class(cheb1d_vector_field) , so this is used as a workaround. Arguments Type Intent Optional Attributes Name class( pseudospec_block ), intent(inout) :: this class(cheb1d_vector_field), intent(in) :: rhs The right hand side of the linear(ised) system. integer, intent(in) :: bound_loc Which boundary is being set. The boundary will be the one\n normal to dimension of number abs(boundary) . If the\n argument is negative, then the lower boundary is returned. If\n positive, then the upper boundary is returned. class(vector_field), intent(in) :: bound_val The value of the result at the specified boundary. integer, intent(in), optional :: good_bound If provided, indicates which boundary contains trusted\n information from which to calculate the power of the highest\n frequency mode. Defaults to the opposite of bound_loc . Return Value class(vector_field),\n  pointer Contents Source Code pseudospec_block_solve_vector Source Code function pseudospec_block_solve_vector ( this , rhs , bound_loc , bound_val , & good_bound ) result ( solution ) !* Author: Chris MacMackin !  Date: September 2017 ! ! Solves the linear(ised) system represented by this finite ! difference block, for a given right hand side state vector ! (represented by a vector field). ! ! @Warning Currently this is only implemented for a 1-D field. ! ! @Bug For some reason, calls to the `vector_dimensions()` method ! produce a segfault when `rhs` is ! `class(vector_field)`. Everything works fine if it is ! `class(cheb1d_vector_field)`, so this is used as a workaround. ! class ( pseudospec_block ), intent ( inout ) :: this class ( cheb1d_vector_field ), intent ( in ) :: rhs !! The right hand side of the linear(ised) system. integer , intent ( in ) :: bound_loc !! Which boundary is being set. The boundary will be the one !! normal to dimension of number `abs(boundary)`. If the !! argument is negative, then the lower boundary is returned. If !! positive, then the upper boundary is returned. class ( vector_field ), intent ( in ) :: bound_val !! The value of the result at the specified boundary. integer , intent ( in ), optional :: good_bound !! If provided, indicates which boundary contains trusted !! information from which to calculate the power of the highest !! frequency mode. Defaults to the opposite of `bound_loc`. class ( vector_field ), pointer :: solution real ( r8 ), dimension (:), allocatable :: sol_vector , bound_vec logical :: valid_bound integer :: bloc , n , i class ( scalar_field ), pointer :: bcomponent call rhs % guard_temp (); call bound_val % guard_temp () valid_bound = . true . n = size ( this % xvals ) select case ( bound_loc ) case ( 1 ) bloc = 1 case ( - 1 ) bloc = n case default valid_bound = . false . !call logger%warning('pseudospec_block%solve_for', '1-D field does not '// & !                    'have boundary in dimension '//str(bound_loc)) end select sol_vector = rhs % raw () call bound_val % allocate_scalar_field ( bcomponent ) call bcomponent % guard_temp () do i = 1 , rhs % vector_dimensions () bcomponent = bound_val % component ( i ) if ( valid_bound ) then bound_vec = bcomponent % raw () call integrate_1d ( sol_vector (( i - 1 ) * n + 1 : i * n ), this % xvals , & bloc , bound_vec ( 1 ), good_bound ) else call integrate_1d ( sol_vector (( i - 1 ) * n + 1 : i * n ), this % xvals , & good_bound = good_bound ) end if end do call bcomponent % clean_temp () #ifdef DEBUG call logger % debug ( 'pseudospec_block%solve_for' , & 'Successfully performed Chebyshev pseudospectral integration.' ) #endif call rhs % allocate_vector_field ( solution ) call solution % unset_temp () call solution % assign_meta_data ( rhs ) call solution % set_from_raw ( sol_vector ) call rhs % clean_temp (); call bound_val % clean_temp () call solution % set_temp () end function pseudospec_block_solve_vector"},{"title":"pseudospec_block – ISOFT","tags":"","loc":"interface/pseudospec_block.html","text":"public interface pseudospec_block Calls interface~~pseudospec_block~~CallsGraph interface~pseudospec_block pseudospec_block proc~constructor~5 constructor interface~pseudospec_block->proc~constructor~5 collocation_points collocation_points proc~constructor~5->collocation_points Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private function constructor (template) result(this) Author Chris MacMackin Date September 2017 Builds a Chebyshsev pseudospectral differentiation matrix block\n which can be used to solve the inverse problem. The result can\n only be used with fields having the same grid as the template. Arguments Type Intent Optional Attributes Name class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. Return Value type( pseudospec_block )"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~6.html","text":"private function constructor(source_field, direction, extra_derivative, boundary_locs, boundary_types, boundary_operations, coef) result(this) Build a block in a Jacobian matrix, with the form \\frac{\\partial F}{\\partial x_i} + F\\Delta_i, where F is\n a scalar field and \\Delta_i is the differentiation operator\n in the i -direction. Additionally, a further differentiation\n operator may be added to the right hand side of this matrix\n block.  Optional arguments allow for handling of boundary\n conditions. See the end of the documentation of the jacobian_block type for a description of how boundary\n conditions are treated. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: source_field A scalar field ( F ) making up this block of the Jacobian integer, intent(in) :: direction The direction in which field derivatives are taken. integer, intent(in), optional :: extra_derivative If present, specifies the direction of a differentiation\n operator to be added to the right hand side of this matrix\n block. integer, intent(in), optional dimension(:) :: boundary_locs The locations in the raw representation of rhs for which\n boundary conditions are specified. Defaults to there being\n none. integer, intent(in), optional dimension(:) :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. Defaults to Dirichlet. The\n order in which they are stored must match that of boundary_locs . procedure( jacobian_block_bounds ), optional :: boundary_operations A function specifying the values to place at the boundaries\n of the result when using the Jacobian block for\n multiplication. By default, all boundaries are set to 0. The\n order in which the resulting values are stored should match\n that of boundary_locs . real(kind=r8), intent(in), optional :: coef An optional coefficient by which the the \\partial\n F/\\partial x term in the operator will be\n multipled. Default value is 1. Return Value type( jacobian_block ) A new Jacobian block Called by proc~~constructor~6~~CalledByGraph proc~constructor~6 constructor interface~jacobian_block jacobian_block interface~jacobian_block->proc~constructor~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code function constructor ( source_field , direction , extra_derivative , & boundary_locs , boundary_types , & boundary_operations , coef ) result ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Build a block in a Jacobian matrix, with the form ! \\frac{\\partial F}{\\partial x_i} + F\\Delta_i, where F is ! a scalar field and \\Delta_i is the differentiation operator ! in the i-direction. Additionally, a further differentiation ! operator may be added to the right hand side of this matrix ! block.  Optional arguments allow for handling of boundary ! conditions. See the end of the documentation of the ! [[jacobian_block(type)]] type for a description of how boundary ! conditions are treated. ! class ( scalar_field ), intent ( in ) :: source_field !! A scalar field (F) making up this block of the Jacobian integer , intent ( in ) :: direction !! The direction in which field derivatives are taken. integer , intent ( in ), optional :: extra_derivative !! If present, specifies the direction of a differentiation !! operator to be added to the right hand side of this matrix !! block. integer , dimension (:), optional , intent ( in ) :: boundary_locs !! The locations in the raw representation of `rhs` for which !! boundary conditions are specified. Defaults to there being !! none. integer , dimension (:), optional , intent ( in ) :: boundary_types !! Integers specifying the type of boundary condition. The type !! of boundary condition corresponding to a given integer is !! specified in [[boundary_types_mod]]. Only Dirichlet and !! Neumann conditions are supported. Defaults to Dirichlet. The !! order in which they are stored must match that of !! `boundary_locs`. procedure ( jacobian_block_bounds ), optional :: boundary_operations !! A function specifying the values to place at the boundaries !! of the result when using the Jacobian block for !! multiplication. By default, all boundaries are set to 0. The !! order in which the resulting values are stored should match !! that of `boundary_locs`. real ( r8 ), optional , intent ( in ) :: coef !! An optional coefficient by which the the \\partial !! F/\\partial x  term in the operator will be !! multipled. Default value is 1. type ( jacobian_block ) :: this !! A new Jacobian block call source_field % guard_temp () allocate ( this % contents , mold = source_field ) allocate ( this % derivative , mold = source_field ) this % contents = source_field this % direction = direction this % derivative = this % contents % d_dx ( this % direction ) if ( present ( extra_derivative )) this % extra_derivative = extra_derivative if ( present ( coef )) this % coef = coef if ( present ( boundary_locs )) then this % boundary_locs = boundary_locs else allocate ( this % boundary_locs ( 0 )) end if if ( present ( boundary_types )) then this % boundary_types = boundary_types else allocate ( this % boundary_types ( size ( this % boundary_locs ))) this % boundary_types = dirichlet end if if ( present ( boundary_operations )) then this % get_boundaries => boundary_operations else this % get_boundaries => jacobian_block_bounds end if call source_field % clean_temp () #ifdef DEBUG call logger % debug ( 'jacobian_block' , 'Instantiated a Jacobian block object.' ) #endif end function constructor"},{"title":"jacobian_block_multiply – ISOFT","tags":"","loc":"proc/jacobian_block_multiply.html","text":"private recursive function jacobian_block_multiply(this, rhs) result(product) Provides a matrix multiplication operator between a Jacobian\n block and a scalar field (which corresponds to a state vector). Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class(scalar_field), intent(in) :: rhs A field corresponding to a state vector being multiplied by\n the Jacobian block. Return Value class(scalar_field),\n  pointer Contents Source Code jacobian_block_multiply Source Code recursive function jacobian_block_multiply ( this , rhs ) result ( product ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Provides a matrix multiplication operator between a Jacobian ! block and a scalar field (which corresponds to a state vector). ! class ( jacobian_block ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: rhs !! A field corresponding to a state vector being multiplied by !! the Jacobian block. class ( scalar_field ), pointer :: product class ( scalar_field ), pointer :: tmp real ( r8 ), dimension (:), allocatable :: bounds integer :: i call rhs % guard_temp () call this % contents % allocate_scalar_field ( product ) call product % unset_temp () if ( this % extra_derivative == no_extra_derivative ) then select case ( this % has_increment ) case ( 0 ) product = this % coef * this % derivative * rhs + this % contents * rhs % d_dx ( this % direction ) case ( 1 ) product = ( this % coef * this % derivative + this % real_increment ) * rhs & + this % contents * rhs % d_dx ( this % direction ) case ( 2 ) product = ( this % coef * this % derivative + this % field_increment ) * rhs & + this % contents * rhs % d_dx ( this % direction ) case default error stop ( 'Invalid increment has been added.' ) end select else call rhs % allocate_scalar_field ( tmp ) call tmp % guard_temp () tmp = rhs % d_dx ( this % extra_derivative ) select case ( this % has_increment ) case ( 0 ) product = this % coef * this % derivative * tmp + this % contents * tmp % d_dx ( this % direction ) case ( 1 ) product = this % coef * this % derivative * tmp + this % contents * tmp % d_dx ( this % direction ) & + this % real_increment * rhs case ( 2 ) product = this % coef * this % derivative * tmp + this % contents * tmp % d_dx ( this % direction ) & + this % field_increment * rhs case default error stop ( 'Invalid increment has been added.' ) end select call tmp % clean_temp () end if if ( associated ( this % block_increment )) then product = product + this % block_increment * rhs end if call this % get_boundaries ( this % contents , this % derivative , rhs , & this % boundary_locs , this % boundary_types , & bounds ) do i = 1 , size ( this % boundary_locs ) call product % set_element ( this % boundary_locs ( i ), bounds ( i )) end do call rhs % clean_temp () #ifdef DEBUG call logger % debug ( 'jacobian_block%multiply' , 'Multiplied vector by ' // & 'Jacobian block.' ) #endif call product % set_temp () end function jacobian_block_multiply"},{"title":"jacobian_block_add_real – ISOFT","tags":"","loc":"proc/jacobian_block_add_real.html","text":"private function jacobian_block_add_real(this, rhs) result(sum) Produces a Jacobian block which has been offset by some constant\n increment. Warning This operation will overwrite any previous sums which\n have been performed to produce this . Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this real(kind=r8), intent(in) :: rhs A scalar which should be added to this block Return Value type( jacobian_block ) Contents Source Code jacobian_block_add_real Source Code function jacobian_block_add_real ( this , rhs ) result ( sum ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Produces a Jacobian block which has been offset by some constant ! increment. ! ! @Warning This operation will overwrite any previous sums which ! have been performed to produce `this`. ! class ( jacobian_block ), intent ( in ) :: this real ( r8 ), intent ( in ) :: rhs !! A scalar which should be added to this block type ( jacobian_block ) :: sum sum = this sum % real_increment = rhs sum % has_increment = sum % has_increment + 1 #ifdef DEBUG call logger % debug ( 'jacobian_block%add' , 'Added real to a Jacobian block.' ) #endif end function jacobian_block_add_real"},{"title":"jacobian_block_add_field – ISOFT","tags":"","loc":"proc/jacobian_block_add_field.html","text":"private function jacobian_block_add_field(this, rhs) result(sum) Produces a Jacobian block which has been offset by a scalar\n field. Warning This operation will overwrite any previous sums which\n have been performed to produce this . Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class(scalar_field), intent(in) :: rhs A scalar which should be added to this block Return Value type( jacobian_block ) Contents Source Code jacobian_block_add_field Source Code function jacobian_block_add_field ( this , rhs ) result ( sum ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Produces a Jacobian block which has been offset by a scalar ! field. ! ! @Warning This operation will overwrite any previous sums which ! have been performed to produce `this`. ! class ( jacobian_block ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: rhs !! A scalar which should be added to this block type ( jacobian_block ) :: sum sum = this allocate ( sum % field_increment , mold = rhs ) sum % field_increment = rhs sum % has_increment = sum % has_increment + 2 #ifdef DEBUG call logger % debug ( 'jacobian_block%add' , 'Added field to a Jacobian block.' ) #endif end function jacobian_block_add_field"},{"title":"jacobian_block_add_block – ISOFT","tags":"","loc":"proc/jacobian_block_add_block.html","text":"private function jacobian_block_add_block(this, rhs) result(sum) Produces a Jacobian block which is the sum of two existing\n blocks. Boundary conditions are set by the first operand\n ( this ). Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class( jacobian_block ), intent(in), target :: rhs A second block which should be added to this block Return Value type( jacobian_block ) Contents Source Code jacobian_block_add_block Source Code function jacobian_block_add_block ( this , rhs ) result ( sum ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Produces a Jacobian block which is the sum of two existing ! blocks. Boundary conditions are set by the first operand ! (`this`). ! class ( jacobian_block ), intent ( in ) :: this class ( jacobian_block ), target , intent ( in ) :: rhs !! A second block which should be added to this block type ( jacobian_block ) :: sum sum = this sum % block_increment => rhs #ifdef DEBUG call logger % debug ( 'jacobian_block%add' , 'Added field to a Jacobian block.' ) #endif end function jacobian_block_add_block"},{"title":"jacobian_block_solve – ISOFT","tags":"","loc":"proc/jacobian_block_solve.html","text":"private function jacobian_block_solve(this, rhs) result(solution) Solves the linear(ised) system represented by this Jacobian\n block, for a given right hand side state vector (represented by\n a scalar field). Warning Currently this is only implemented for a 1-D field. The\n extra derivative must be in the direction along which the field\n varies. Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. Return Value class(scalar_field),\n  pointer Calls proc~~jacobian_block_solve~~CallsGraph proc~jacobian_block_solve jacobian_block_solve la_gtsvx la_gtsvx proc~jacobian_block_solve->la_gtsvx str str proc~jacobian_block_solve->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code jacobian_block_solve Source Code function jacobian_block_solve ( this , rhs ) result ( solution ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Solves the linear(ised) system represented by this Jacobian ! block, for a given right hand side state vector (represented by ! a scalar field). ! ! @Warning Currently this is only implemented for a 1-D field. The ! extra derivative must be in the direction along which the field ! varies. ! class ( jacobian_block ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: rhs !! The right hand side of the linear(ised) system. class ( scalar_field ), pointer :: solution real ( r8 ), dimension (:), allocatable :: sol_vector integer :: flag , n real ( r8 ) :: forward_err , & backward_err , & condition_num real ( r8 ), dimension (:), allocatable :: diag , subdiag , supdiag character ( len = 1 ) :: factor character ( len = :), allocatable :: msg call rhs % guard_temp () allocate ( sol_vector ( rhs % raw_size ())) ! Construct tridiagonal matrix for this operation, if necessary if (. not . allocated ( this % pivots )) then factor = 'N' ! Allocate the arrays used to hold the factorisation of the ! tridiagonal matrix call this % get_tridiag ( diag , subdiag , supdiag ) call move_alloc ( diag , this % diagonal ) call move_alloc ( subdiag , this % sub_diagonal ) call move_alloc ( supdiag , this % super_diagonal ) n = this % contents % raw_size () allocate ( this % l_multipliers ( n - 1 )) allocate ( this % u_diagonal ( n )) allocate ( this % u_superdiagonal1 ( n - 1 )) allocate ( this % u_superdiagonal2 ( n - 2 )) allocate ( this % pivots ( n )) else factor = 'F' end if !    print*,rhs%raw() call la_gtsvx ( this % sub_diagonal , this % diagonal , this % super_diagonal , & rhs % raw (), sol_vector , this % l_multipliers , this % u_diagonal , & this % u_superdiagonal1 , this % u_superdiagonal2 , this % pivots , & factor , 'N' , forward_err , backward_err , condition_num , & flag ) if ( flag /= 0 ) then msg = 'Tridiagonal matrix solver returned with flag ' // trim ( str ( flag )) !      print*,this%sub_diagonal !      print*, !      print*,this%diagonal !      print*, !      print*,this%super_diagonal CALL backtrace call logger % error ( 'jacobian_block%solve_for' , msg ) !print*,condition_num !      stop #ifdef DEBUG else msg = 'Tridiagonal matrix solver returned with estimated condition ' // & 'number ' // trim ( str ( condition_num )) call logger % debug ( 'jacobian_block%solve_for' , msg ) #endif end if call rhs % allocate_scalar_field ( solution ) call solution % unset_temp () call solution % assign_meta_data ( rhs ) call solution % set_from_raw ( sol_vector ) call rhs % clean_temp (); call solution % set_temp () end function jacobian_block_solve"},{"title":"jacobian_block_assign – ISOFT","tags":"","loc":"proc/jacobian_block_assign.html","text":"private subroutine jacobian_block_assign(this, rhs) Copies the contents of the rhs Jacobian block into this\n one. It will safely deallocate any data necessary. Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(out) :: this type( jacobian_block ), intent(in) :: rhs Contents Source Code jacobian_block_assign Source Code subroutine jacobian_block_assign ( this , rhs ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Copies the contents of the `rhs` Jacobian block into this ! one. It will safely deallocate any data necessary. ! class ( jacobian_block ), intent ( out ) :: this type ( jacobian_block ), intent ( in ) :: rhs this % direction = rhs % direction this % extra_derivative = rhs % extra_derivative allocate ( this % contents , mold = rhs % contents ) allocate ( this % derivative , mold = rhs % derivative ) this % contents = rhs % contents this % coef = rhs % coef this % derivative = rhs % derivative this % get_boundaries => rhs % get_boundaries if ( allocated ( rhs % diagonal )) then this % diagonal = rhs % diagonal this % super_diagonal = rhs % super_diagonal this % sub_diagonal = rhs % sub_diagonal this % l_multipliers = rhs % l_multipliers this % u_diagonal = rhs % u_diagonal this % u_superdiagonal1 = rhs % u_superdiagonal1 this % u_superdiagonal2 = rhs % u_superdiagonal2 this % pivots = rhs % pivots end if if ( allocated ( rhs % boundary_locs )) this % boundary_locs = rhs % boundary_locs if ( allocated ( rhs % boundary_types )) this % boundary_types = rhs % boundary_types this % real_increment = rhs % real_increment if ( allocated ( rhs % field_increment )) & allocate ( this % field_increment , source = rhs % field_increment ) if ( associated ( rhs % block_increment )) this % block_increment => rhs % block_increment this % has_increment = rhs % has_increment end subroutine jacobian_block_assign"},{"title":"jacobian_block_get_tridiag – ISOFT","tags":"","loc":"proc/jacobian_block_get_tridiag.html","text":"private recursive subroutine jacobian_block_get_tridiag(this, diagonal, subdiagonal, superdiagonal) Computes the tridiagonal matrix used to solve for this Jacobian block. Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this real(kind=r8), intent(out), dimension(:), allocatable :: diagonal real(kind=r8), intent(out), dimension(:), allocatable :: subdiagonal real(kind=r8), intent(out), dimension(:), allocatable :: superdiagonal Contents Source Code jacobian_block_get_tridiag Source Code recursive subroutine jacobian_block_get_tridiag ( this , diagonal , subdiagonal , & superdiagonal ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Computes the tridiagonal matrix used to solve for this Jacobian block. ! class ( jacobian_block ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable , intent ( out ) :: diagonal real ( r8 ), dimension (:), allocatable , intent ( out ) :: subdiagonal real ( r8 ), dimension (:), allocatable , intent ( out ) :: superdiagonal integer :: n , i , pos class ( vector_field ), pointer :: grid logical :: use_cached class ( scalar_field ), allocatable , save :: cached_field_type real ( r8 ), dimension (:), allocatable , save :: cached_dx_c , & cached_dx2_uc , & cached_dx2_ud , & cached_dx2_dc real ( r8 ), save :: cached_upper_bound , & cached_lower_bound real ( r8 ), dimension (:), allocatable :: cont , deriv , diag , & subdiag , supdiag real ( r8 ), dimension (:,:), allocatable :: domain n = this % contents % raw_size () domain = this % contents % domain () ! Try to use cached copy of inverse grid spacing, if available and suitable if ( allocated ( cached_field_type )) then use_cached = same_type_as ( this % contents , cached_field_type ) . and . & abs ( domain ( 1 , 1 ) - cached_lower_bound ) < 1 e - 10 . and . & abs ( domain ( 1 , 2 ) - cached_upper_bound ) < 1 e - 10 . and . & n == size ( cached_dx_c ) else use_cached = . false . end if ! Construct an array containing the distance between grid ! points, if necessary if (. not . use_cached ) then if ( allocated ( cached_field_type )) then deallocate ( cached_field_type ) deallocate ( cached_dx_c ) deallocate ( cached_dx2_uc ) deallocate ( cached_dx2_dc ) deallocate ( cached_dx2_ud ) end if #ifdef DEBUG call logger % debug ( 'jacobian_block%get_tridiag' , 'Calculating and caching ' // & 'grid spacings.' ) #endif cached_lower_bound = domain ( 1 , 1 ) cached_upper_bound = domain ( 1 , 2 ) allocate ( cached_field_type , mold = this % contents ) allocate ( cached_dx_c ( n )) allocate ( cached_dx2_uc ( n - 1 )) allocate ( cached_dx2_dc ( n - 1 )) allocate ( cached_dx2_ud ( n )) call this % contents % allocate_vector_field ( grid ) grid = this % contents % grid_spacing () ! Use this array to temporarily hold the grid spacings cached_dx_c = grid % raw () ! Work out the upwinded grid spacings cached_dx2_uc ( 1 ) = cached_dx_c ( 1 ) do i = 2 , n - 1 cached_dx2_uc ( i ) = 2 * cached_dx_c ( i ) - cached_dx2_uc ( i - 1 ) end do ! Work out the inverse of the downwinded grid spacings cached_dx2_dc ( 1 : n - 2 ) = 1._r8 / cached_dx2_uc ( 1 : n - 2 ) cached_dx2_dc ( n - 1 ) = 1._r8 / cached_dx_c ( n ) ! Work out the -2 times product of the inverse up- and ! down-winded grid spacings cached_dx2_ud ( 1 ) = cached_dx2_uc ( 1 ) ** ( - 2 ) cached_dx2_ud ( 2 : n - 1 ) = - 2 * cached_dx2_dc ( 2 : n - 1 ) / cached_dx2_uc ( 1 : n - 2 ) cached_dx2_ud ( n ) = cached_dx2_dc ( n - 1 ) ** 2 ! Work out the inverse of product of the up-winded and ! centred grid spacings cached_dx2_uc ( 1 ) = - cached_dx2_uc ( 1 ) ** ( - 2 ) cached_dx2_uc ( 2 : n - 1 ) = 1._r8 / ( cached_dx2_uc ( 2 : n - 1 ) * cached_dx_c ( 2 : n - 1 )) ! Work out the inverse of the product of the down-winded and ! centred grid spacings cached_dx2_dc ( 1 : n - 2 ) = cached_dx2_dc ( 1 : n - 2 ) / cached_dx_c ( 2 : n - 1 ) cached_dx2_dc ( n - 1 ) = - cached_dx2_dc ( n - 1 ) ** 2 ! Work out half the inverse of the grid spacing cached_dx_c ( 2 : n - 1 ) = 0.5_r8 / cached_dx_c ( 2 : n - 1 ) cached_dx_c ( 1 ) = 1._r8 / cached_dx_c ( 1 ) cached_dx_c ( n ) = 1._r8 / cached_dx_c ( n ) end if cont = this % contents % raw () if ( this % extra_derivative == no_extra_derivative ) then ! Create the tridiagonal matrix when there is no additional ! differentiation operator on the RHS diagonal = this % coef * this % derivative % raw () select case ( this % has_increment ) case ( 0 ) continue case ( 1 ) diagonal = diagonal + this % real_increment case ( 2 ) diagonal = diagonal + this % field_increment % raw () case default error stop ( 'Invalid increment has been added.' ) end select diagonal ( 1 ) = diagonal ( 1 ) - cont ( 1 ) * cached_dx_c ( 1 ) diagonal ( n ) = diagonal ( n ) + cont ( n ) * cached_dx_c ( n ) superdiagonal = cont ( 1 : n - 1 ) * cached_dx_c ( 1 : n - 1 ) subdiagonal = - cont ( 2 : n ) * cached_dx_c ( 2 : n ) else if ( this % extra_derivative == this % direction ) then ! Create the tridiagonal matrix when the additional ! differentiation operator on the RHS operates in the same ! direction as the derivative of the contents. deriv = this % coef * this % derivative % raw () allocate ( diagonal ( n )) diagonal ( 2 : n - 1 ) = cont ( 2 : n - 1 ) * cached_dx2_ud ( 2 : n - 1 ) diagonal ( 1 ) = cont ( 1 ) * cached_dx2_ud ( 1 ) & - deriv ( 1 ) * cached_dx_c ( 1 ) diagonal ( n ) = cont ( n ) * cached_dx2_ud ( n ) & + deriv ( n ) * cached_dx_c ( n ) !print*,diagonal(10) select case ( this % has_increment ) case ( 0 ) continue case ( 1 ) diagonal = diagonal + this % real_increment case ( 2 ) diagonal = diagonal + this % field_increment % raw () case default error stop ( 'Invalid increment has been added.' ) end select allocate ( superdiagonal ( n - 1 )) superdiagonal ( 2 : n - 1 ) = cont ( 2 : n - 1 ) * cached_dx2_uc ( 2 : n - 1 ) & + deriv ( 2 : n - 1 ) * cached_dx_c ( 2 : n - 1 ) superdiagonal ( 1 ) = - 2 * cont ( 1 ) * cached_dx2_uc ( 1 ) & + deriv ( 1 ) * cached_dx_c ( 1 ) allocate ( subdiagonal ( n - 1 )) subdiagonal ( 1 : n - 2 ) = cont ( 2 : n - 1 ) * cached_dx2_dc ( 1 : n - 2 ) & - deriv ( 2 : n - 1 ) * cached_dx_c ( 2 : n - 1 ) subdiagonal ( n - 1 ) = - 2 * cont ( n ) * cached_dx2_dc ( n - 1 ) & - deriv ( n ) * cached_dx_c ( n ) else call logger % fatal ( 'jacobian_block%solve_for' , 'Currently no support ' // & 'for extra derivatives other than in the 1-direction' ) error stop end if if ( associated ( this % block_increment )) then call this % block_increment % get_tridiag ( diag , subdiag , supdiag ) diagonal = diagonal + diag subdiagonal = subdiagonal + subdiag superdiagonal = superdiagonal + supdiag end if ! Set the boundary conditions for this problem do i = 1 , size ( this % boundary_locs ) pos = this % boundary_locs ( i ) if ( this % boundary_types ( i ) == dirichlet ) then diagonal ( pos ) = 1._r8 if ( pos < n ) superdiagonal ( pos ) = 0._r8 if ( pos > 1 ) subdiagonal ( pos - 1 ) = 0._r8 else if ( this % boundary_types ( i ) == neumann ) then if ( pos == n ) then diagonal ( n ) = cached_dx_c ( n ) subdiagonal ( n - 1 ) = - cached_dx_c ( n ) else if ( pos == 1 ) then diagonal ( 1 ) = - cached_dx_c ( 1 ) superdiagonal ( 1 ) = cached_dx_c ( 1 ) else superdiagonal ( pos ) = cached_dx_c ( pos ) subdiagonal ( pos - 1 ) = cached_dx_c ( pos ) diagonal ( pos ) = 0._r8 end if else call logger % fatal ( 'jacobian_block%solve_for' , 'Boundary condition of ' // & 'type other than Dirichlet or Neumann encountered.' ) error stop end if end do #ifdef DEBUG call logger % debug ( 'jacobian_block%get_tridiag' , 'Constructed tridiagonal matrix.' ) #endif end subroutine jacobian_block_get_tridiag"},{"title":"jacobian_block_bounds – ISOFT","tags":"","loc":"proc/jacobian_block_bounds.html","text":"private subroutine jacobian_block_bounds(contents, derivative, rhs, boundary_locs, boundary_types, boundary_values) A default implementation of the get_boundaries procedure\n pointer for the jacobian_block type. It corresponds to setting\n all boundaries to 0 when multiplying a field by the Jacobian\n block. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: contents The field used to construct the Jacobian block class(scalar_field), intent(in) :: derivative The first spatial derivative of the field used to construct\n the Jacobian block, in the direction specified class(scalar_field), intent(in) :: rhs The scalar field representing the vector being multiplied\n by Jacobian integer, intent(in), dimension(:), allocatable :: boundary_locs The locations in the raw representation of rhs containing\n the boundaries. integer, intent(in), dimension(:), allocatable :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. The storage order must\n correspond to that of boundary_locs . real(kind=r8), intent(out), dimension(:), allocatable :: boundary_values The values to go at the boundaries when multiplying a field\n by the Jacobian block. The storage order must be the same as\n for boundary_locs . Contents Source Code jacobian_block_bounds Source Code subroutine jacobian_block_bounds ( contents , derivative , rhs , & boundary_locs , boundary_types , & boundary_values ) !* Author: Chris MacMackin !  Date: January 2016 ! ! A default implementation of the `get_boundaries` procedure ! pointer for the `jacobian_block` type. It corresponds to setting ! all boundaries to 0 when multiplying a field by the Jacobian ! block. ! class ( scalar_field ), intent ( in ) :: contents !! The field used to construct the Jacobian block class ( scalar_field ), intent ( in ) :: derivative !! The first spatial derivative of the field used to construct !! the Jacobian block, in the direction specified class ( scalar_field ), intent ( in ) :: rhs !! The scalar field representing the vector being multiplied !! by Jacobian integer , dimension (:), allocatable , intent ( in ) :: boundary_locs !! The locations in the raw representation of `rhs` containing !! the boundaries. integer , dimension (:), allocatable , intent ( in ) :: boundary_types !! Integers specifying the type of boundary condition. The type !! of boundary condition corresponding to a given integer is !! specified in [[boundary_types_mod]]. Only Dirichlet and !! Neumann conditions are supported. The storage order must !! correspond to that of `boundary_locs`. real ( r8 ), dimension (:), allocatable , intent ( out ) :: boundary_values !! The values to go at the boundaries when multiplying a field !! by the Jacobian block. The storage order must be the same as !! for `boundary_locs`. allocate ( boundary_values ( size ( boundary_locs ))) boundary_values = 0._r8 end subroutine jacobian_block_bounds"},{"title":"jacobian_block – ISOFT","tags":"","loc":"interface/jacobian_block.html","text":"public interface jacobian_block Calls interface~~jacobian_block~~CallsGraph interface~jacobian_block jacobian_block proc~constructor~6 constructor interface~jacobian_block->proc~constructor~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private function constructor (source_field, direction, extra_derivative, boundary_locs, boundary_types, boundary_operations, coef) result(this) Author Chris MacMackin Date December 2016 Build a block in a Jacobian matrix, with the form \\frac{\\partial F}{\\partial x_i} + F\\Delta_i, where F is\n a scalar field and \\Delta_i is the differentiation operator\n in the i -direction. Additionally, a further differentiation\n operator may be added to the right hand side of this matrix\n block.  Optional arguments allow for handling of boundary\n conditions. See the end of the documentation of the jacobian_block type for a description of how boundary\n conditions are treated. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: source_field A scalar field ( F ) making up this block of the Jacobian integer, intent(in) :: direction The direction in which field derivatives are taken. integer, intent(in), optional :: extra_derivative If present, specifies the direction of a differentiation\n operator to be added to the right hand side of this matrix\n block. integer, intent(in), optional dimension(:) :: boundary_locs The locations in the raw representation of rhs for which\n boundary conditions are specified. Defaults to there being\n none. integer, intent(in), optional dimension(:) :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. Defaults to Dirichlet. The\n order in which they are stored must match that of boundary_locs . procedure( jacobian_block_bounds ), optional :: boundary_operations A function specifying the values to place at the boundaries\n of the result when using the Jacobian block for\n multiplication. By default, all boundaries are set to 0. The\n order in which the resulting values are stored should match\n that of boundary_locs . real(kind=r8), intent(in), optional :: coef An optional coefficient by which the the \\partial\n F/\\partial x term in the operator will be\n multipled. Default value is 1. Return Value type( jacobian_block ) A new Jacobian block"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~7.html","text":"private function constructor(phi, nu, velbound, dvelbound, integrate_bound, template) result(this) Builds a Coriolis block which can be used to solve the inverse\n problem for the linear components of the plume momentum\n equations. The result can only be used with fields having the\n same grid as the template. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: phi The dimensionless coriolis parameter real(kind=r8), intent(in) :: nu The dimensionless eddy diffusivity integer, intent(in) :: velbound Location code for the velocity's boundary condition. 1\n indicates upper boundary, -1 indicates lower boundary. integer, intent(in) :: dvelbound Location code for the velocity's boundary condition. 1\n indicates upper boundary, -1 indicates lower boundary. integer, intent(in) :: integrate_bound Location code for the boundary to perform integrations\n from. This should be the opposite boundary from where\n boundary data is stored. class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. Return Value type( coriolis_block ) Calls proc~~constructor~7~~CallsGraph proc~constructor~7 constructor uniform_scalar_field uniform_scalar_field proc~constructor~7->uniform_scalar_field la_gesvx la_gesvx proc~constructor~7->la_gesvx vinv_r vinv_r proc~constructor~7->vinv_r vinv_i vinv_i proc~constructor~7->vinv_i str str proc~constructor~7->str cheb1d_scalar_field cheb1d_scalar_field proc~constructor~7->cheb1d_scalar_field emdx_i emdx_i proc~constructor~7->emdx_i emdx_r emdx_r proc~constructor~7->emdx_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~constructor~7~~CalledByGraph proc~constructor~7 constructor interface~coriolis_block coriolis_block interface~coriolis_block->proc~constructor~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code function constructor ( phi , nu , velbound , dvelbound , integrate_bound , template ) & result ( this ) !* Author: Chris MacMackin !  Date: January 2018 ! ! Builds a Coriolis block which can be used to solve the inverse ! problem for the linear components of the plume momentum ! equations. The result can only be used with fields having the ! same grid as the template. ! real ( r8 ), intent ( in ) :: phi !! The dimensionless coriolis parameter real ( r8 ), intent ( in ) :: nu !! The dimensionless eddy diffusivity integer , intent ( in ) :: velbound !! Location code for the velocity's boundary condition. 1 !! indicates upper boundary, -1 indicates lower boundary. integer , intent ( in ) :: dvelbound !! Location code for the velocity's boundary condition. 1 !! indicates upper boundary, -1 indicates lower boundary. integer , intent ( in ) :: integrate_bound !! Location code for the boundary to perform integrations !! from. This should be the opposite boundary from where !! boundary data is stored. class ( abstract_field ), intent ( in ) :: template !! A scalar field with the same grid as any fields passed as !! arguments to the [[pseudospec_block(type):solve_for]] method. type ( coriolis_block ) :: this type ( cheb1d_scalar_field ) :: xvals integer :: i , j , info real ( r8 ) :: alpha , beta , rcond , s real ( r8 ), dimension (:,:), allocatable :: domain complex ( r8 ), dimension ( 4 ) :: dummy_in complex ( r8 ), dimension ( 4 ) :: dummy_out character ( len = :), allocatable :: msg call template % guard_temp () zero = uniform_scalar_field ( 0._r8 ) this % integrator = pseudospec_block ( template ) domain = template % domain () this % vel_bound_loc = velbound this % dvel_bound_loc = dvelbound if ( velbound == 1 ) then this % xbounds ( 1 : 2 ) = domain ( 1 , 2 ) else if ( velbound == - 1 ) then this % xbounds ( 1 : 2 ) = domain ( 1 , 1 ) else call logger % fatal ( 'coriolis_block' , & 'Only boundary location codes 1 or -1 are accepted.' ) error stop end if if ( dvelbound == 1 ) then this % xbounds ( 3 : 4 ) = domain ( 1 , 2 ) else if ( dvelbound == - 1 ) then this % xbounds ( 3 : 4 ) = domain ( 1 , 1 ) else call logger % fatal ( 'coriolis_block' , & 'Only boundary location codes 1 or -1 are accepted.' ) error stop end if this % integrate_bound = integrate_bound xvals = cheb1d_scalar_field ( template % elements (), linear , domain ( 1 , 1 ), & domain ( 1 , 2 )) ! Compute the diagonal elements of \\bm{B} alpha = sqrt ( abs ( 2 * phi / nu )) beta = sqrt ( abs ( 0.5_r8 * phi / nu )) s = sign ( 1._r8 , phi ) this % D_r = [ - beta , - beta , beta , beta ] this % D_i = [ - beta , beta , - beta , beta ] ! Use the associations as temporary work arrays, prior to ! computing their actual values associate ( emDx_r => this % eDx_r , emDx_i => this % eDx_i , & Vinv_r => this % V_r , Vinv_i => this % V_i ) ! Compute e&#94;{-\\bm{D}x}. Need to do this in two steps to avoid a compiler bug emDx_i = [( exp ( - this % D_r ( i ) * xvals ), i = 1 , 4 )] emDx_r = [( emDx_i ( i ) * cos ( - this % D_i ( i ) * xvals ), i = 1 , 4 )] emDx_i = [( emDx_i ( i ) * sin ( - this % D_i ( i ) * xvals ), i = 1 , 4 )] ! Compute \\bm{V}&#94;{-1} Vinv_r = 0.25_r8 * reshape ([ - s * beta , - s * beta , s * beta , s * beta , & - beta , - beta , beta , beta , & 0._r8 , 0._r8 , 0._r8 , 0._r8 , & 1._r8 , 1._r8 , 1._r8 , 1._r8 ], & [ 4 , 4 ]) Vinv_i = 0.25_r8 * reshape ([ s * beta , - s * beta , s * beta , - s * beta , & - beta , beta , - beta , beta , & - s , s , s , - s , & 0._r8 , 0._r8 , 0._r8 , 0._r8 ], & [ 4 , 4 ]) ! Compute e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1} this % emDxVinv_r = reshape ([(( emDx_r ( i ) * Vinv_r ( i , j ) - emDx_i ( i ) * Vinv_i ( i , j ), & i = 1 , 4 ), j = 1 , 4 )], [ 4 , 4 ]) this % emDxVinv_i = reshape ([(( emDx_r ( i ) * Vinv_i ( i , j ) + emDx_i ( i ) * Vinv_r ( i , j ), & i = 1 , 4 ), j = 1 , 4 )], [ 4 , 4 ]) end associate ! Compute e&#94;{\\bm{D}x}. Need to do this in two steps to avoid a compiler bug this % eDx_i = [( exp ( this % D_r ( i ) * xvals ), i = 1 , 4 )] this % eDx_r = [( this % eDx_i ( i ) * cos ( this % D_i ( i ) * xvals ), i = 1 , 4 )] this % eDx_i = [( this % eDx_i ( i ) * sin ( this % D_i ( i ) * xvals ), i = 1 , 4 )] ! Compute \\bm{V} this % V_r = reshape ([ - s / alpha , - 1._r8 / alpha , 0._r8 , 1._r8 , & - s / alpha , - 1._r8 / alpha , 0._r8 , 1._r8 , & s / alpha , 1._r8 / alpha , 0._r8 , 1._r8 , & s / alpha , 1._r8 / alpha , 0._r8 , 1._r8 ], & [ 4 , 4 ]) this % V_i = reshape ([ - s / alpha , 1._r8 / alpha , s , 0._r8 , & s / alpha , - 1._r8 / alpha , - s , 0._r8 , & - s / alpha , 1._r8 / alpha , - s , 0._r8 , & s / alpha , - 1._r8 / alpha , s , 0._r8 ], & [ 4 , 4 ]) ! Construct and factor matrix used for satisfying boundary conditions dummy_in = [( 1 , 0 ), ( 0 , 1 ), ( 0.5 , 0.5 ), ( - 0.5 , 0.5 )] this % bound_matrix = reshape ([(( cmplx ( this % V_r ( i , j ), this % V_i ( i , j ), r8 ) * & exp ( cmplx ( this % D_r ( j ), this % D_i ( j ), r8 ) * & this % xbounds ( i )), i = 1 , 4 ), j = 1 , 4 )], [ 4 , 4 ]) this % bound_matrix_scaled = this % bound_matrix call la_gesvx ( this % bound_matrix_scaled , dummy_in , dummy_out , & this % factored_matrix , this % pivots , 'E' , trans , & this % equed , this % r_scales , this % c_scales , & rcond = rcond , info = info ) if ( info /= 0 ) then msg = 'Tridiagonal matrix solver returned with flag ' // str ( info ) call logger % error ( 'coriolis_block' , msg ) end if msg = 'Boundary matrix factored with estimated condition ' // & 'number ' // str ( 1._r8 / rcond ) call logger % trivia ( 'coriolis_block' , msg ) #ifdef DEBUG call logger % debug ( 'coriolis_block' , & 'Successfully constructed Coriolis preconditioner block.' ) #endif call template % clean_temp () contains pure function linear ( x ) result ( scalar ) real ( r8 ), dimension (:), intent ( in ) :: x !! The position at which this function is evaluated real ( r8 ) :: scalar scalar = x ( 1 ) end function linear end function constructor"},{"title":"solve_for – ISOFT","tags":"","loc":"proc/solve_for.html","text":"private subroutine solve_for(this, velocity, velocity_dx) Inverts the linear portions of the plume momentum equation with\n the provided data. This is done by solving the linear ODE\n described in the documentation for the coriolis_block type. The block object must first have been initialised using\n the constructor. Warning Currently this is only implemented for a 1-D field. Arguments Type Intent Optional Attributes Name class( coriolis_block ), intent(inout) :: this class(vector_field), intent(inout) :: velocity On input, the velocity value being preconditioned. On output,\n the preconditioned velocity. class(vector_field), intent(inout) :: velocity_dx On input, the velocity derivative being preconditioned. On\n output, the preconditioned velocity derivative. Calls proc~~solve_for~~CallsGraph proc~solve_for solve_for m_i m_i proc~solve_for->m_i c_i c_i proc~solve_for->c_i la_gesvx la_gesvx proc~solve_for->la_gesvx emdxvinvf_r emdxvinvf_r proc~solve_for->emdxvinvf_r m_r m_r proc~solve_for->m_r emdxvinvf_i emdxvinvf_i proc~solve_for->emdxvinvf_i c_r c_r proc~solve_for->c_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code solve_for Source Code subroutine solve_for ( this , velocity , velocity_dx ) !* Author: Chris MacMackin !  Date: January 2018 ! ! Inverts the linear portions of the plume momentum equation with ! the provided data. This is done by solving the linear ODE ! described in the documentation for the [[coriolis_block]] ! type. The block object must first have been initialised using ! the constructor. ! ! @Warning Currently this is only implemented for a 1-D field. ! class ( coriolis_block ), intent ( inout ) :: this class ( vector_field ), intent ( inout ) :: velocity !! On input, the velocity value being preconditioned. On output, !! the preconditioned velocity. class ( vector_field ), intent ( inout ) :: velocity_dx !! On input, the velocity derivative being preconditioned. On !! output, the preconditioned velocity derivative. type ( cheb1d_scalar_field ), dimension ( 4 ) :: F , eDxC_r , eDxC_i , E_r , E_i integer :: i real ( r8 ), dimension ( 1 ) :: rtmp , ctmp real ( r8 ), dimension ( 4 ) :: bound_vals complex ( r8 ), dimension ( 4 ) :: rhs , B , C_bounds type ( cheb1d_scalar_field ) :: tmp integer :: info real ( r8 ) :: rcond call velocity % guard_temp (); call velocity_dx % guard_temp () ! Construct array of scalar matrices for easier manipulation F ( 1 ) = velocity % component ( 1 ) F ( 2 ) = velocity % component ( 2 ) F ( 3 ) = velocity_dx % component ( 1 ) F ( 4 ) = velocity_dx % component ( 2 ) ! Get boundary values tmp = F ( 1 )% get_boundary ( this % integrate_bound , 1 ) rtmp = tmp % raw () bound_vals ( 1 ) = rtmp ( 1 ) tmp = F ( 2 )% get_boundary ( this % integrate_bound , 1 ) rtmp = tmp % raw () bound_vals ( 2 ) = rtmp ( 1 ) tmp = F ( 3 )% get_boundary ( this % integrate_bound , 1 ) rtmp = tmp % raw () bound_vals ( 3 ) = rtmp ( 1 ) tmp = F ( 4 )% get_boundary ( this % integrate_bound , 1 ) rtmp = tmp % raw () bound_vals ( 4 ) = rtmp ( 1 ) ! If have boundary conditions at both boundaries, correct the ! input fields !    if (this%vel_bound_loc /= this%integrate_bound) then !      F(1) = this%integrator%solve_for(F(1), this%vel_bound_loc, zero) !      F(1) = F(1)%d_dx(1) !      F(2) = this%integrator%solve_for(F(2), this%vel_bound_loc, zero) !      F(2) = F(2)%d_dx(1) !    end if !    if (this%dvel_bound_loc /= this%integrate_bound) then !      F(3) = this%integrator%solve_for(F(3), this%dvel_bound_loc, zero) !      F(3) = F(3)%d_dx(1) !      F(4) = this%integrator%solve_for(F(4), this%dvel_bound_loc, zero) !      F(4) = F(4)%d_dx(1) !    end if ! Calculate e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1}\\bm{F}, aliasing variables ! which are not needed yet associate ( emDxVinvF_r => eDxC_r , emDxVinvF_i => eDxC_i , & M_r => this % emDxVinv_r , M_i => this % emDxVinv_i , & C_r => E_r , C_i => E_i ) emDxVinvF_r = [( M_r ( i , 1 ) * F ( 1 ) + M_r ( i , 2 ) * F ( 2 ) + M_r ( i , 3 ) * F ( 3 ) + & M_r ( i , 4 ) * F ( 4 ), i = 1 , 4 )] emDxVinvF_i = [( M_i ( i , 1 ) * F ( 1 ) + M_i ( i , 2 ) * F ( 2 ) + M_i ( i , 3 ) * F ( 3 ) + & M_i ( i , 4 ) * F ( 4 ), i = 1 , 4 )] ! Integrate e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1}\\bm{F} to get \\bm{C} C_r = [( this % integrator % solve_for ( emDxVinvF_r ( i ), this % integrate_bound , & zero ), i = 1 , 4 )] emDxVinvF_r ( 1 ) = C_r ( 4 )% d_dx ( 1 ) C_i = [( this % integrator % solve_for ( emDxVinvF_i ( i ), this % integrate_bound , & zero ), i = 1 , 4 )] ! Get the values of e&#94;{\\bm{D}x}\\bm{C} at the upper boundary do i = 1 , 4 tmp = C_r ( i )% get_boundary ( - this % integrate_bound , 1 ) rtmp = tmp % raw () tmp = C_i ( i )% get_boundary ( - this % integrate_bound , 1 ) ctmp = tmp % raw () C_bounds ( i ) = cmplx ( rtmp ( 1 ), ctmp ( 1 ), r8 ) end do ! Calculate e&#94;{\\bm{D}x}\\bm{C} eDxC_r = [( this % eDx_r ( i ) * C_r ( i ) - this % eDx_i ( i ) * C_i ( i ), i = 1 , 4 )] eDxC_i = [( this % eDx_r ( i ) * C_i ( i ) + this % eDx_i ( i ) * C_r ( i ), i = 1 , 4 )] end associate ! Compute RHS for the linear system satisfying the boundary conditions if ( this % vel_bound_loc == this % integrate_bound ) then rhs ( 1 : 2 ) = bound_vals ( 1 : 2 ) else rhs ( 1 : 2 ) = bound_vals ( 1 : 2 ) - matmul ( this % bound_matrix ( 1 : 2 ,:), & C_bounds ) end if if ( this % dvel_bound_loc == this % integrate_bound ) then rhs ( 3 : 4 ) = bound_vals ( 3 : 4 ) else rhs ( 3 : 4 ) = bound_vals ( 3 : 4 ) - matmul ( this % bound_matrix ( 3 : 4 ,:), & C_bounds ) end if ! Compute coefficients for inhomogeneous components of solution so ! that boundary conditions are satisfied call la_gesvx ( this % bound_matrix_scaled , rhs , B , this % factored_matrix , & this % pivots , 'F' , trans , this % equed , this % r_scales , & this % c_scales , info = i ) !print*,this%D_r !print*,this%D_i !print*,B ! Calculate \\bm{E} = e&#94;{\\bm{D}x}\\bm{B} + e&#94;{\\bm{D}x}\\bm{C} E_r = [( this % eDx_r ( i ) * real ( B ( i )) - this % eDx_i ( i ) * aimag ( B ( i )) + & eDxC_r ( i ), i = 1 , 4 )] E_i = [( this % eDx_i ( i ) * real ( B ( i )) + this % eDx_r ( i ) * aimag ( B ( i )) + & eDxC_i ( i ), i = 1 , 4 )] ! Transform back to proper basis to get proper solution F = [( this % V_r ( i , 1 ) * E_r ( 1 ) - this % V_i ( i , 1 ) * E_i ( 1 ) + & this % V_r ( i , 2 ) * E_r ( 2 ) - this % V_i ( i , 2 ) * E_i ( 2 ) + & this % V_r ( i , 3 ) * E_r ( 3 ) - this % V_i ( i , 3 ) * E_i ( 3 ) + & this % V_r ( i , 4 ) * E_r ( 4 ) - this % V_i ( i , 4 ) * E_i ( 4 ), i = 1 , 4 )] velocity = F ( 1 : 2 ) velocity_dx = F ( 3 : 4 ) call velocity % clean_temp (); call velocity_dx % clean_temp () end subroutine solve_for"},{"title":"assign – ISOFT","tags":"","loc":"proc/assign.html","text":"private subroutine assign(this, rhs) Safely assigns the value of one coriolis block to another. Arguments Type Intent Optional Attributes Name class( coriolis_block ), intent(inout) :: this class( coriolis_block ), intent(in) :: rhs The value being assigned Contents Source Code assign Source Code subroutine assign ( this , rhs ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Safely assigns the value of one coriolis block to another. ! class ( coriolis_block ), intent ( inout ) :: this class ( coriolis_block ), intent ( in ) :: rhs !! The value being assigned this % D_r = rhs % D_r this % D_i = rhs % D_i this % emDxVinv_r = rhs % emDxVinv_r this % emDxVinv_i = rhs % emDxVinv_i this % eDx_r = rhs % eDx_r this % eDx_i = rhs % eDx_i this % V_r = rhs % V_r this % V_i = rhs % V_i this % integrator = rhs % integrator this % vel_bound_loc = rhs % vel_bound_loc this % dvel_bound_loc = rhs % dvel_bound_loc this % integrate_bound = rhs % integrate_bound this % xbounds = rhs % xbounds this % bound_matrix = rhs % bound_matrix this % bound_matrix_scaled = rhs % bound_matrix_scaled this % factored_matrix = rhs % factored_matrix this % pivots = rhs % pivots this % r_scales = rhs % r_scales this % c_scales = rhs % c_scales this % equed = rhs % equed end subroutine assign"},{"title":"coriolis_block – ISOFT","tags":"","loc":"interface/coriolis_block.html","text":"public interface coriolis_block Calls interface~~coriolis_block~~CallsGraph interface~coriolis_block coriolis_block proc~constructor~7 constructor interface~coriolis_block->proc~constructor~7 uniform_scalar_field uniform_scalar_field proc~constructor~7->uniform_scalar_field la_gesvx la_gesvx proc~constructor~7->la_gesvx vinv_r vinv_r proc~constructor~7->vinv_r vinv_i vinv_i proc~constructor~7->vinv_i str str proc~constructor~7->str cheb1d_scalar_field cheb1d_scalar_field proc~constructor~7->cheb1d_scalar_field emdx_i emdx_i proc~constructor~7->emdx_i emdx_r emdx_r proc~constructor~7->emdx_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private function constructor (phi, nu, velbound, dvelbound, integrate_bound, template) result(this) Author Chris MacMackin Date January 2018 Builds a Coriolis block which can be used to solve the inverse\n problem for the linear components of the plume momentum\n equations. The result can only be used with fields having the\n same grid as the template. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: phi The dimensionless coriolis parameter real(kind=r8), intent(in) :: nu The dimensionless eddy diffusivity integer, intent(in) :: velbound Location code for the velocity's boundary condition. 1\n indicates upper boundary, -1 indicates lower boundary. integer, intent(in) :: dvelbound Location code for the velocity's boundary condition. 1\n indicates upper boundary, -1 indicates lower boundary. integer, intent(in) :: integrate_bound Location code for the boundary to perform integrations\n from. This should be the opposite boundary from where\n boundary data is stored. class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. Return Value type( coriolis_block )"},{"title":"quasilinear_solve – ISOFT","tags":"","loc":"proc/quasilinear_solve.html","text":"public subroutine quasilinear_solve(L, f, jac_prod, solution, order, resid_norm, flag, info, tol, precond, differentiate, iter_max, gmres_iter_max, krylov_dim) This is an iterative method to solve nonlinear systems of\n ODEs. Consider L&#94;{(n)}\\vec{u}(x) = \\vec{f}(\\vec{u}(x),\n \\vec{u}&#94;{(1)}(x), \\ldots, \\vec{u}&#94;{n-1}(x), x), \\qquad \\vec{u}\n \\in \\mathbb{R}&#94;{m}. For a domain from (0,b) , boundary\n conditions are specified by g_k(\\vec{u}(0) = 0,\n \\vec{u}&#94;{(1)}(0), \\ldots, \\vec{u}&#94;{n-1}(0)), \\qquad k = 1,\n \\ldots, l g_k(\\vec{u}(b), \\vec{u}&#94;{(1)}(b), \\ldots,\n \\vec{u}&#94;{n-1}(b)) = 0, \\qquad k = l+1, \\ldots, mn. Here, L&#94;{(n)} is an n th order ordinary differential operator,\n and \\vec{f}, g_1, g_2, \\ldots, g_{nm} are nonlinear\n functions of \\vec{u}(x) and its first n-1 derivatives. With quasilinearisation method, we iterate according to L&#94;{(n)}\\vec{u}_{r+1}(x) = \\vec{f}(\\vec{u}_r(x),\n \\vec{u}&#94;{(1)}_r(x), \\ldots, \\vec{u}&#94;{n-1}_r(x), x) + \\\\\n \\qquad\\sum_{s=0}&#94;{n-1}\\vec{f}_{\\vec{u}&#94;{(s)}}(\\vec{u}_r(x),\n \\vec{u}&#94;{(1)}_r(x), \\ldots, \\vec{u}&#94;{n-1}_r(x),\n x)(\\vec{u}&#94;{(s)}_{r+1}(x) - \\vec{u}&#94;{(s)}_r(x)). The boundary\n conditions are iterated according to \\sum_{s=0}&#94;{n-1}\n g_{k,\\vec{u}&#94;{(s)}}(\\vec{u}_r(0), \\vec{u}&#94;{(1)}_r(0), \\ldots,\n \\vec{u}&#94;{n-1}_r(0), x)\\cdot(\\vec{u}&#94;{(s)}_{r+1}(0) -\n \\vec{u}&#94;{(s)}_r(0)) = 0, k=1,\\ldots,l and \\sum_{s=0}&#94;{n-1}\n g_{k,\\vec{u}&#94;{(s)}}(\\vec{u}_r(b), \\vec{u}&#94;{(1)}_r(b), \\ldots,\n \\vec{u}&#94;{n-1}_r(b), x)\\cdot(\\vec{u}&#94;{(s)}_{r+1}(b) -\n \\vec{u}&#94;{(s)}_r(b)) = 0, k=l+1,\\ldots,mn. Here, \\vec{f}_{\\vec{u}&#94;{(s)}} is the derivative of \\vec{f} with respect to \\vec{u}&#94;{(s)} and is a tensor, while g_{k,\\vec{u}&#94;{(s)}} is the derivative of g_k with\n respect to \\vec{u}&#94;{(s)} and is a vector. The user must provide functions for L and \\vec{f} . Currently this implementation only handles linear\n boundary conditions, which remain the same between\n iterations. The boundary conditions should be handled in the\n functions passed as arguments. In most situations, a\n preconditioner will also be needed. A simple one is to\n approximate L&#94;{-1} . The derivatives of \\vec{f} and g_k are estimated using a finite-difference. Output parameters On output, the components of the info argument are as follows: info(1)   = nLe   (number of evaluations of `L`)\n info(2)   = nfe   (number of evaluations of `f`)\n info(3)   = nrpre (number of preconditioner evaluations)\n info(4)   = nli   (number of linear iterations)\n info(5)   = nni   (number of nonlinear iterations) Arguments Type Intent Optional Attributes Name procedure( L_intr ) :: L A function providing the linear, left-hand-side of the ODE\n being solved. procedure( f_intr ) :: f A function providing the nonlinear, right-hand-side of the\n ODE being solved. procedure( jac_intr ) :: jac_prod A function providing the product of the Jacobian of the\n nonlinear, right-hand-side of the ODE being solved and\n another vector. real(kind=r8), intent(inout), dimension(:) :: solution On input, an estimate of the solution to the ODE. On output,\n the actual solution. integer, intent(in) :: order The order of the derivative taken by L real(kind=r8), intent(out) :: resid_norm Norm of the residual of the final solution. integer, intent(out) :: flag Status flag indicating whether the iterations ended succesfully. < 0: |flag| is gmres_solve return code 0 Normal termination: acceptable solution found 1 Convergence, but residual greater than required tolerance 2 Solution did not converge within iter_max iterations 3 Solution began to diverge 4 No diff procedure provided when order > 1 integer, intent(out), optional dimension(5) :: info Array containing various outputs; see above real(kind=r8), intent(in), optional :: tol The required reduction in the solution residual. Default is size(solution) * 1e-8 . procedure( pre_intr ), optional :: precond A right-preconditioner which may be used to improve\n convergence of the solution. procedure( diff_intr ), optional :: differentiate A procedure which will evaluate the n th derivative of the\n state vector, when n is less than order . integer, intent(in), optional :: iter_max Maximum allowable number of quasilinearised\n iterations. Default is 15. integer, intent(in), optional :: gmres_iter_max Maximum allowable number of GMRES iterations. Default is\n 1000. integer, intent(in), optional :: krylov_dim Maximum Krylov subspace dimension; default 10. Larger values\n will allow for faster convergence (and in some cases be the\n difference between whether or not convergence is possible),\n but require more memory. Calls proc~~quasilinear_solve~~CallsGraph proc~quasilinear_solve quasilinear_solve interface~dnrm2 dnrm2 proc~quasilinear_solve->interface~dnrm2 proc~gmres_solve gmres_solve proc~quasilinear_solve->proc~gmres_solve str str proc~quasilinear_solve->str interface~nitgm2 nitgm2 proc~gmres_solve->interface~nitgm2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code quasilinear_solve Source Code subroutine quasilinear_solve ( L , f , jac_prod , solution , order , resid_norm , & flag , info , tol , precond , differentiate , & iter_max , gmres_iter_max , krylov_dim ) !* Author: Chris MacMackin !  Date: March 2017 ! ! This is an iterative method to solve nonlinear systems of ! ODEs. Consider  L&#94;{(n)}\\vec{u}(x) = \\vec{f}(\\vec{u}(x), ! \\vec{u}&#94;{(1)}(x), \\ldots, \\vec{u}&#94;{n-1}(x), x), \\qquad \\vec{u} ! \\in \\mathbb{R}&#94;{m}.  For a domain from  (0,b) , boundary ! conditions are specified by  g_k(\\vec{u}(0) = 0, ! \\vec{u}&#94;{(1)}(0), \\ldots, \\vec{u}&#94;{n-1}(0)), \\qquad k = 1, ! \\ldots, l   g_k(\\vec{u}(b), \\vec{u}&#94;{(1)}(b), \\ldots, ! \\vec{u}&#94;{n-1}(b)) = 0, \\qquad k = l+1, \\ldots, mn.  Here, ! L&#94;{(n)} is an nth order ordinary differential operator, ! and \\vec{f}, g_1, g_2, \\ldots, g_{nm} are nonlinear ! functions of \\vec{u}(x) and its first n-1 derivatives. ! ! With quasilinearisation method, we iterate according to  ! L&#94;{(n)}\\vec{u}_{r+1}(x) = \\vec{f}(\\vec{u}_r(x), ! \\vec{u}&#94;{(1)}_r(x), \\ldots, \\vec{u}&#94;{n-1}_r(x), x) + \\\\ ! \\qquad\\sum_{s=0}&#94;{n-1}\\vec{f}_{\\vec{u}&#94;{(s)}}(\\vec{u}_r(x), ! \\vec{u}&#94;{(1)}_r(x), \\ldots, \\vec{u}&#94;{n-1}_r(x), ! x)(\\vec{u}&#94;{(s)}_{r+1}(x) - \\vec{u}&#94;{(s)}_r(x)).  The boundary ! conditions are iterated according to  \\sum_{s=0}&#94;{n-1} ! g_{k,\\vec{u}&#94;{(s)}}(\\vec{u}_r(0), \\vec{u}&#94;{(1)}_r(0), \\ldots, ! \\vec{u}&#94;{n-1}_r(0), x)\\cdot(\\vec{u}&#94;{(s)}_{r+1}(0) - ! \\vec{u}&#94;{(s)}_r(0)) = 0, k=1,\\ldots,l and  \\sum_{s=0}&#94;{n-1} ! g_{k,\\vec{u}&#94;{(s)}}(\\vec{u}_r(b), \\vec{u}&#94;{(1)}_r(b), \\ldots, ! \\vec{u}&#94;{n-1}_r(b), x)\\cdot(\\vec{u}&#94;{(s)}_{r+1}(b) - ! \\vec{u}&#94;{(s)}_r(b)) = 0, k=l+1,\\ldots,mn. Here, ! \\vec{f}_{\\vec{u}&#94;{(s)}} is the derivative of \\vec{f} ! with respect to \\vec{u}&#94;{(s)} and is a tensor, while ! g_{k,\\vec{u}&#94;{(s)}} is the derivative of g_k with ! respect to \\vec{u}&#94;{(s)} and is a vector. ! ! The user must provide functions for L and ! \\vec{f}. Currently this implementation only handles linear ! boundary conditions, which remain the same between ! iterations. The boundary conditions should be handled in the ! functions passed as arguments. In most situations, a ! preconditioner will also be needed. A simple one is to ! approximate L&#94;{-1}. The derivatives of \\vec{f} and ! g_k are estimated using a finite-difference. ! !####Output parameters ! ! On output, the components of the `info` argument are as follows: ! !     info(1)   = nLe   (number of evaluations of `L`) !     info(2)   = nfe   (number of evaluations of `f`) !     info(3)   = nrpre (number of preconditioner evaluations) !     info(4)   = nli   (number of linear iterations) !     info(5)   = nni   (number of nonlinear iterations) ! procedure ( L_intr ) :: L !! A function providing the linear, left-hand-side of the ODE !! being solved. procedure ( f_intr ) :: f !! A function providing the nonlinear, right-hand-side of the !! ODE being solved. procedure ( jac_intr ) :: jac_prod !! A function providing the product of the Jacobian of the !! nonlinear, right-hand-side of the ODE being solved and !! another vector. real ( r8 ), dimension (:), intent ( inout ) :: solution !! On input, an estimate of the solution to the ODE. On output, !! the actual solution. integer , intent ( in ) :: order !! The order of the derivative taken by `L` real ( r8 ), intent ( out ) :: resid_norm !! Norm of the residual of the final solution. integer , intent ( out ) :: flag !! Status flag indicating whether the iterations ended succesfully. !! !!< 0: !!:    `|flag|` is [[gmres_solve]] return code !! !!0 !!:    Normal termination: acceptable solution found !! !!1 !!:    Convergence, but residual greater than required tolerance !! !!2 !!:    Solution did not converge within `iter_max` iterations !! !!3 !!:    Solution began to diverge !! !!4 !!:    No `diff` procedure provided when `order > 1` !! integer , dimension ( 5 ), intent ( out ), optional :: info !! Array containing various outputs; see above real ( r8 ), intent ( in ), optional :: tol !! The required reduction in the solution residual. Default is !! `size(solution) * 1e-8`. procedure ( pre_intr ), optional :: precond !! A right-preconditioner which may be used to improve !! convergence of the solution. procedure ( diff_intr ), optional :: differentiate !! A procedure which will evaluate the `n`th derivative of the !! state vector, when `n` is less than `order`. integer , intent ( in ), optional :: iter_max !! Maximum allowable number of quasilinearised !! iterations. Default is 15. integer , intent ( in ), optional :: gmres_iter_max !! Maximum allowable number of GMRES iterations. Default is !! 1000. integer , intent ( in ), optional :: krylov_dim !! Maximum Krylov subspace dimension; default 10. Larger values !! will allow for faster convergence (and in some cases be the !! difference between whether or not convergence is possible), !! but require more memory. integer :: npoints , itmax , gitmax , kdim real ( r8 ) :: eta , gmres_eta integer :: i , stagnant_iters , gmres_flag integer :: nlhs , nrpre , nli , tnlhs , tnrpre , tnli real ( r8 ) :: init_resid , old_resid , gmres_norm real ( r8 ), dimension ( size ( solution ), order ) :: u_prev real ( r8 ), dimension ( size ( solution )) :: f_prev , rhs tnlhs = 0 tnrpre = 0 tnli = 0 if (. not . present ( differentiate ) . and . order > 1 ) then flag = 3 call logger % error ( 'quasilinear_solve' , 'Did not provide routine ' // & 'to get derivative values.' ) return end if npoints = size ( solution ) if ( present ( tol )) then eta = tol else eta = 1.e-8_r8 * npoints end if if ( present ( iter_max )) then itmax = iter_max else itmax = 15 end if if ( present ( gmres_iter_max )) then gitmax = gmres_iter_max else gitmax = 1000 end if if ( present ( krylov_dim )) then kdim = krylov_dim else kdim = 10 end if i = 0 stagnant_iters = 0 u_prev = get_derivs ( solution ) f_prev = f ( u_prev ) resid_norm = dnrm2 ( npoints , L ( solution ) - f_prev , 1 ) init_resid = resid_norm old_resid = resid_norm * 1 e3_r8 do while ( resid_norm > eta ) call logger % trivia ( 'quasilinear_solve' , 'Nonlinear iteration ' // str ( i ) // & ', with ' // str ( tnli ) // 'linear iterations, and residual ' // str ( resid_norm )) i = i + 1 if ( abs ( old_resid - resid_norm ) / resid_norm < 1 e - 2_r8 ) then stagnant_iters = stagnant_iters + 1 else stagnant_iters = 0 end if if ( stagnant_iters > 3 ) then flag = 1 return end if if ( i > itmax ) then flag = 2 return end if if ( 20 * old_resid < resid_norm ) then flag = 3 return end if rhs = f_prev - jac_prod ( u_prev , u_prev ) gmres_eta = max ( min ( eta * 1 0._r8 ** min ( i + 2 , 6 ), 1 e - 4_r8 ), 1 e - 10_r8 ) gmres_eta = gmres_eta * 1 0._r8 ** ( - 2 * stagnant_iters ) call gmres_solve ( solution , lin_op , rhs , gmres_norm , gmres_flag , & nlhs , nrpre , nli , gmres_eta , preconditioner , & resid_update = 0 , iter_max = gitmax , krylov_dim = kdim ) tnlhs = tnlhs + nlhs tnrpre = tnrpre + nrpre tnli = tnli + nli if ( gmres_flag > 0 ) call logger % warning ( 'quasilinear_solve' , & 'GMRES solver returned with flag ' // str ( gmres_flag )) u_prev = get_derivs ( solution ) f_prev = f ( u_prev ) old_resid = resid_norm resid_norm = dnrm2 ( npoints , L ( solution ) - f_prev , 1 ) if ( gmres_flag /= 0 . and . ( resid_norm > 20 * old_resid . or . any ( isnan ( solution )))) then if ( present ( info )) then info ( 1 ) = i + tnlhs + tnrpre info ( 2 ) = 2 * i + tnlhs info ( 3 ) = tnrpre info ( 4 ) = tnli info ( 5 ) = i end if if ( init_resid < resid_norm ) then flag = 3 else flag = - gmres_flag end if return end if end do if ( present ( info )) then info ( 1 ) = 1 + i + tnlhs + tnrpre info ( 2 ) = 1 + 2 * i + tnlhs info ( 3 ) = tnrpre info ( 4 ) = tnli info ( 5 ) = i end if flag = 0 call logger % trivia ( 'quasilinear_solve' , 'Nonlinear iteration ' // str ( i ) // & ', with ' // str ( tnli ) // ' linear iterations, and residual ' // str ( resid_norm )) contains function get_derivs ( v ) !! Calculates the necessary number of derivatives and assembles !! them in 2-D array. real ( r8 ), dimension (:), intent ( in ) :: v real ( r8 ), dimension ( size ( v ), order ) :: get_derivs integer :: j get_derivs (:, 1 ) = v do j = 2 , order get_derivs (:, j ) = differentiate ( v , i - 1 ) end do end function get_derivs function lin_op ( v , xcur , rhs , rpar , ipar , success ) !! The linear operator for the quasilinearised system. real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be operated upon real ( r8 ), dimension (:), intent ( in ) :: xcur !! Array containing the current estimate of the independent !! variables in the linear system. This may not be needed, but !! is provided just in case. real ( r8 ), dimension (:), intent ( in ) :: rhs !! Array containing the right hand side of the linear !! system. This may not be needed, but is provided just in !! case. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array logical , intent ( out ) :: success !! Indicates whether operation was completed succesfully real ( r8 ), dimension ( size ( xcur )) :: lin_op !! Result of the operation real ( r8 ), dimension ( size ( xcur ), order ) :: v_derivs v_derivs = get_derivs ( v ) lin_op = L ( v ) - jac_prod ( u_prev , v_derivs ) success = . true . end function lin_op function preconditioner ( v , xcur , rhs , rpar , ipar , success ) !! The preconditioner for the quasilinearised system. real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be preconditioned real ( r8 ), dimension (:), intent ( in ) :: xcur !! Array containing the current estimate of the independent !! variables in the linear system. This may not be needed, but !! is provided just in case. real ( r8 ), dimension (:), intent ( in ) :: rhs !! Array containing the right hand side of the linear !! system. This may not be needed, but is provided just in !! case. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array logical , intent ( out ) :: success !! Indicates whether operation was completed succesfully real ( r8 ), dimension ( size ( xcur )) :: preconditioner !! Result of the operation preconditioner = precond ( v , reshape ( xcur , [ size ( xcur ), 1 ]), L , f , f_prev , rhs ) success = . true . end function preconditioner end subroutine quasilinear_solve"},{"title":"plume_melt – ISOFT","tags":"","loc":"proc/plume_melt.html","text":"private function plume_melt(this) result(melt) Computes and returns the melt rate at the bottom of the ice\n shelf due to interaction with the plume. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice shelf. Contents Source Code plume_melt Source Code function plume_melt ( this ) result ( melt ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the melt rate at the bottom of the ice ! shelf due to interaction with the plume. ! class ( plume ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate at the base of the ice shelf. melt => this % melt_formulation % melt_rate () end function plume_melt"},{"title":"plume_drag_parameter – ISOFT","tags":"","loc":"proc/plume_drag_parameter.html","text":"private function plume_drag_parameter(this) result(drag) Computes and returns a quantity which may be necessary to determine\n the frictional drag the plume exerts on the bottom of the ice\n shelf. The plume would actually tend to exert no drag on the bottom\n of the ice shelf, but this method is present so that there is a\n consistent interface with the ground data type. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. Calls proc~~plume_drag_parameter~~CallsGraph proc~plume_drag_parameter plume_drag_parameter uniform_scalar_field uniform_scalar_field proc~plume_drag_parameter->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code plume_drag_parameter Source Code function plume_drag_parameter ( this ) result ( drag ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns a quantity which may be necessary to determine ! the frictional drag the plume exerts on the bottom of the ice ! shelf. The plume would actually tend to exert no drag on the bottom ! of the ice shelf, but this method is present so that there is a ! consistent interface with the [[ground(type)]] data type. ! class ( plume ), intent ( in ) :: this class ( scalar_field ), pointer :: drag !! The melt rate at the base of the ice sheet. type ( uniform_scalar_field ) :: dummy call dummy % allocate_scalar_field ( drag ) drag = uniform_scalar_field ( 0.0_r8 ) call drag % set_temp () #ifdef DEBUG call logger % debug ( 'plume%drag_parameter' , 'Returned plume drag parameter.' ) #endif end function plume_drag_parameter"},{"title":"plume_water_density – ISOFT","tags":"","loc":"proc/plume_water_density.html","text":"private function plume_water_density(this) result(density) Computes and returns the density of the plume water beneath the ice\n shelf. The density of this water would vary depending on how much \n saline ambient water has been entrained into the plume versus how\n much fresh water has been released due to melting. However, the\n Boussinesq approximation is used here and only a single reference \n density is returned. Note Based on my approach to non-dimensionalisation, I'm pretty\n sure the density should always be 1, making this method\n unneccessary. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value real(kind=r8) The density of the water at the base of the ice sheet. Contents Source Code plume_water_density Source Code function plume_water_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the density of the plume water beneath the ice ! shelf. The density of this water would vary depending on how much ! saline ambient water has been entrained into the plume versus how ! much fresh water has been released due to melting. However, the ! Boussinesq approximation is used here and only a single reference ! density is returned. ! ! @NOTE Based on my approach to non-dimensionalisation, I'm pretty ! sure the density should always be 1, making this method ! unneccessary. ! class ( plume ), intent ( in ) :: this real ( r8 ) :: density !! The density of the water at the base of the ice sheet. density = 1.0_r8 #ifdef DEBUG call logger % debug ( 'plume%water_density' , 'Plume has average density ' // & trim ( str ( density )) // '.' ) #endif end function plume_water_density"},{"title":"plume_data_size – ISOFT","tags":"","loc":"proc/plume_data_size.html","text":"private function plume_data_size(this) Returns the number of elements in the plume's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value integer The number of elements in the plume's state vector. Contents Source Code plume_data_size Source Code function plume_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the plume's state vector. ! This is the size of the vector returned by ! [[plume(type):state_vector]] and taken as an argument by ! [[plume(type):update]]. ! class ( plume ), intent ( in ) :: this integer :: plume_data_size !! The number of elements in the plume's state vector. plume_data_size = this % thickness % raw_size () + this % velocity % raw_size () + & this % velocity_dx % raw_size () + this % temperature % raw_size () + & this % temperature_dx % raw_size () + this % salinity % raw_size () + & this % salinity_dx % raw_size () #ifdef DEBUG call logger % debug ( 'plume%data_size' , 'Plume shelf has ' // & trim ( str ( plume_data_size )) // ' elements ' // & 'in its state vector.' ) #endif end function plume_data_size"},{"title":"plume_state_vector – ISOFT","tags":"","loc":"proc/plume_state_vector.html","text":"private function plume_state_vector(this) result(state_vector) Returns the state vector for the current state of the plume. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:),allocatable The state vector describing the plume. Contents Source Code plume_state_vector Source Code function plume_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the plume. ! This takes the form of a 1D array. ! class ( plume ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the plume. state_vector = [ this % thickness % raw (), this % velocity % raw (), & this % velocity_dx % raw (), this % temperature % raw (), & this % temperature_dx % raw (), this % salinity % raw (), & this % salinity_dx % raw ()] #ifdef DEBUG call logger % debug ( 'plume%state_vector' , 'Returning state vector ' // & 'for plume.' ) #endif end function plume_state_vector"},{"title":"plume_initialise – ISOFT","tags":"","loc":"proc/plume_initialise.html","text":"private subroutine plume_initialise(this, domain, resolution, thickness, velocity, temperature, salinity, entrainment_formulation, melt_formulation, ambient_conds, eos, boundaries, delta, nu, mu, r_val, phi) Instantiates a plume object with initial coniditions\n provided by the arguments.At present only a 1D model is\n supported. If information is provided for higher dimensions then\n it will be ignored. Arguments Type Intent Optional Attributes Name class( plume ), intent(out) :: this A plume object with its domain and initial conditions set according\n to the arguments of the constructor function. real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the plume. The first index represents the dimension for which the\n boundaries apply. If the second index is 1 then it corresponds to\n the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( scalar_func ) :: thickness A function which calculates the initial value of the thickness of \n the plume at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the water at a given location in a plume. procedure( scalar_func ) :: temperature A function which calculates the initial value of the temperature of \n the plume at a given location. procedure( scalar_func ) :: salinity A function which calculates the initial value of the salinity of \n the plume at a given location. class( abstract_entrainment ), intent(inout), optional allocatable :: entrainment_formulation An object which calculates entrainment into the plume. Will\n be unallocated on exit. Defaults to that used by Jenkins\n (1991) with the coefficient $E_0 = 1$. class( abstract_melt_relationship ), intent(inout), optional allocatable :: melt_formulation An object which calculates melting and the resulting thermal\n transfer into/out of the plume. Will be unallocated on\n exit. Defaults to that used by Dallaston et al. (2015),\n scaled to be consistent with the nondimensionalisation used\n here. class( ambient_conditions ), intent(inout), optional allocatable :: ambient_conds An object specifying the salinity and temperature of the\n ambient ocean. Will be unallocated on exit. Defaults to\n uniform ambient salinity and temperature, both of which are\n set to 0 (as temperature and salinity are measured relative\n to some reference value). class( equation_of_state ), intent(inout), optional allocatable :: eos An object specifying the equation of state for the water in\n the plume. Will be unallocated on exit. Defaults to\n linearised equation of state with no temperature dependence\n and a haline contraction coefficient of 1. The reference\n density is set to be 1 in the dimensionless units when\n salinity and temeprature are 0. class( plume_boundary ), intent(inout), optional allocatable :: boundaries An object providing the boundary conditions for the\n plume. Will be unallocated on exit. Defaults to those used by\n Dallaston et al. (2015). real(kind=r8), intent(in), optional :: delta The dimensionless ratio \\delta \\equiv\n \\frac{D_0}{h_0} . Defaults to 0.036. real(kind=r8), intent(in), optional :: nu The dimensionless ratio \\nu \\equiv\n \\frac{\\kappa_0}{x_0U_o} . Defaults to 0. real(kind=r8), intent(in), optional :: mu The dimensionless ratio \\mu \\equiv\n \\frac{\\C_dx_0}{D_0} . Defaults to 0. real(kind=r8), intent(in), optional :: r_val The dimensionless ratio of the water density to the ice shelf\n density, r = \\rho_0/\\rho_i. Defaults to 1.12. real(kind=r8), intent(in), optional :: phi The inverse Rossby number, \\Phi \\equif\n \\frac{fx_0}{U_0} . Defaults to 0. Calls proc~~plume_initialise~~CallsGraph proc~plume_initialise plume_initialise cheb1d_scalar_field cheb1d_scalar_field proc~plume_initialise->cheb1d_scalar_field cheb1d_vector_field cheb1d_vector_field proc~plume_initialise->cheb1d_vector_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code plume_initialise Source Code subroutine plume_initialise ( this , domain , resolution , thickness , velocity , & temperature , salinity , entrainment_formulation , & melt_formulation , ambient_conds , eos , boundaries , & delta , nu , mu , r_val , phi ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Instantiates a [[plume(type)]] object with initial coniditions ! provided by the arguments.At present only a 1D model is ! supported. If information is provided for higher dimensions then ! it will be ignored. ! class ( plume ), intent ( out ) :: this !! A plume object with its domain and initial conditions set according !! to the arguments of the constructor function. real ( r8 ), dimension (:,:), intent ( in ) :: domain !! An array containing the upper and lower limits of the domain for !! the plume. The first index represents the dimension for which the !! boundaries apply. If the second index is 1 then it corresponds to !! the lower bound. If the second index is 2 then it corresponds to !! the upper bound. integer , dimension (:), intent ( in ) :: resolution !! The number of data points in each dimension procedure ( scalar_func ) :: thickness !! A function which calculates the initial value of the thickness of !! the plume at a given location. procedure ( velocity_func ) :: velocity !! A function which calculates the initial value of the velocity !! (vector) of the water at a given location in a plume. procedure ( scalar_func ) :: temperature !! A function which calculates the initial value of the temperature of !! the plume at a given location. procedure ( scalar_func ) :: salinity !! A function which calculates the initial value of the salinity of !! the plume at a given location. class ( abstract_entrainment ), allocatable , optional , & intent ( inout ) :: entrainment_formulation !! An object which calculates entrainment into the plume. Will !! be unallocated on exit. Defaults to that used by Jenkins !! (1991) with the coefficient $E_0 = 1$. class ( abstract_melt_relationship ), allocatable , optional , & intent ( inout ) :: melt_formulation !! An object which calculates melting and the resulting thermal !! transfer into/out of the plume. Will be unallocated on !! exit. Defaults to that used by Dallaston et al. (2015), !! scaled to be consistent with the nondimensionalisation used !! here. class ( ambient_conditions ), allocatable , optional , & intent ( inout ) :: ambient_conds !! An object specifying the salinity and temperature of the !! ambient ocean. Will be unallocated on exit. Defaults to !! uniform ambient salinity and temperature, both of which are !! set to 0 (as temperature and salinity are measured relative !! to some reference value). class ( equation_of_state ), allocatable , optional , & intent ( inout ) :: eos !! An object specifying the equation of state for the water in !! the plume. Will be unallocated on exit. Defaults to !! linearised equation of state with no temperature dependence !! and a haline contraction coefficient of 1. The reference !! density is set to be 1 in the dimensionless units when !! salinity and temeprature are 0. class ( plume_boundary ), allocatable , optional , & intent ( inout ) :: boundaries !! An object providing the boundary conditions for the !! plume. Will be unallocated on exit. Defaults to those used by !! Dallaston et al. (2015). real ( r8 ), optional , intent ( in ) :: delta !! The dimensionless ratio \\delta \\equiv !! \\frac{D_0}{h_0}. Defaults to 0.036. real ( r8 ), optional , intent ( in ) :: nu !! The dimensionless ratio \\nu \\equiv !! \\frac{\\kappa_0}{x_0U_o}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: mu !! The dimensionless ratio \\mu \\equiv !! \\frac{\\C_dx_0}{D_0}. Defaults to 0. real ( r8 ), optional , intent ( in ) :: r_val !! The dimensionless ratio of the water density to the ice shelf !! density,  r = \\rho_0/\\rho_i.  Defaults to 1.12. real ( r8 ), optional , intent ( in ) :: phi !! The inverse Rossby number, \\Phi \\equif !! \\frac{fx_0}{U_0}. Defaults to 0. integer :: i , btype_l , btype_u , bdepth_l , bdepth_u i = size ( velocity ([ 0._r8 ])) this % thickness = cheb1d_scalar_field ( resolution ( 1 ), thickness , domain ( 1 , 1 ), domain ( 1 , 2 )) this % velocity = cheb1d_vector_field ( resolution ( 1 ), velocity , domain ( 1 , 1 ), domain ( 1 , 2 ), i - 1 ) this % temperature = cheb1d_scalar_field ( resolution ( 1 ), temperature , domain ( 1 , 1 ), domain ( 1 , 2 )) this % salinity = cheb1d_scalar_field ( resolution ( 1 ), salinity , domain ( 1 , 1 ), domain ( 1 , 2 )) this % thickness_size = this % thickness % raw_size () this % velocity_size = this % velocity % raw_size () this % temperature_size = this % temperature % raw_size () this % salinity_size = this % salinity % raw_size () this % velocity_dx = this % velocity % d_dx ( 1 ) this % salinity_dx = this % salinity % d_dx ( 1 ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( present ( entrainment_formulation )) then call move_alloc ( entrainment_formulation , this % entrainment_formulation ) else allocate ( jenkins1991_entrainment :: this % entrainment_formulation ) end if if ( present ( melt_formulation )) then call move_alloc ( melt_formulation , this % melt_formulation ) else allocate ( dallaston2015_melt :: this % melt_formulation ) end if if ( present ( ambient_conds )) then call move_alloc ( ambient_conds , this % ambient_conds ) else allocate ( uniform_ambient_conditions :: this % ambient_conds ) end if if ( present ( eos )) then call move_alloc ( eos , this % eos ) else allocate ( linear_eos :: this % eos ) end if if ( present ( boundaries )) then call move_alloc ( boundaries , this % boundaries ) else allocate ( simple_plume_boundary :: this % boundaries ) end if if ( present ( delta )) then this % delta = delta else this % delta = 0.036_r8 end if if ( present ( nu )) then this % nu = nu else this % nu = 0.0_r8 end if if ( present ( mu )) then this % mu = mu else this % mu = 0.0_r8 end if if ( present ( r_val )) then this % r_val = r_val else this % r_val = 1.12_r8 end if if ( present ( phi )) then this % phi = phi else this % phi = 0.0_r8 end if this % time = 0.0_r8 ! Initialise preconditioner this % precond = pseudospec_block ( this % thickness ) ! Store information on boundary conditions call this % boundaries % thickness_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % thickness_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower thickness boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper thickness boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if #endif select case ( btype_l ) case ( free_boundary ) case ( dirichlet ) this % lower_bounds ( 1 ) = . true . case default error stop ( 'Only free, and Dirichlet boundary conditions ' // & 'supported for plume thickness.' ) end select select case ( btype_u ) case ( free_boundary ) case ( dirichlet ) this % upper_bounds ( 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for plume.' ) end select call this % boundaries % velocity_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % velocity_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower velocity boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper velocity boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 2 ) call this % boundaries % temperature_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % temperature_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower temperature boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper temperature boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 4 ) call this % boundaries % salinity_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % salinity_bound_info ( 1 , btype_u , bdepth_u ) #ifdef DEBUG if ( abs ( bdepth_l ) > 1 ) then error stop ( 'Lower salinity boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if if ( abs ( bdepth_u ) > 1 ) then error stop ( 'Upper salinity boundary has depth greater than 1, ' // & 'which is not supported by plume.' ) end if #endif call set_preconditioners ( btype_l , btype_u , 6 ) #ifdef DEBUG call logger % debug ( 'plume' , 'Initialised new ice shelf object.' ) #endif contains subroutine set_preconditioners ( ltype , utype , comp_id ) integer , intent ( in ) :: ltype , utype , comp_id select case ( ltype ) case ( free_boundary ) case ( dirichlet ) this % lower_bounds ( comp_id ) = . true . case ( neumann ) this % lower_bounds ( comp_id + 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for plume.' ) end select select case ( utype ) case ( free_boundary ) case ( dirichlet ) this % upper_bounds ( comp_id ) = . true . case ( neumann ) this % upper_bounds ( comp_id + 1 ) = . true . case default error stop ( 'Only free, Dirichlet, and Neumann boundary conditions ' // & 'supported for plume.' ) end select end subroutine set_preconditioners end subroutine plume_initialise"},{"title":"plume_update – ISOFT","tags":"","loc":"proc/plume_update.html","text":"private subroutine plume_update(this, state_vector, ice_thickness) Updates the state of the plume from its state vector. The state\n vector is a real array containing the value of each of the plume's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( plume ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n plume. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate. Contents Source Code plume_update Source Code subroutine plume_update ( this , state_vector , ice_thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the plume from its state vector. The state ! vector is a real array containing the value of each of the plume's ! properties at each of the locations on the grid used in discretization. ! class ( plume ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! plume. class ( scalar_field ), optional , intent ( in ) :: ice_thickness !! The ice thickness which, if present, will be used to update !! the calculation of the melt rate. integer :: i !TODO: Add some assertion-like checks that the state vector is the right size call this % thickness % set_from_raw ( state_vector ( 1 : this % thickness_size )) i = 1 + this % thickness_size call this % velocity % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % velocity_dx % set_from_raw ( state_vector ( i : i + this % velocity_size - 1 )) i = i + this % velocity_size call this % temperature % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % temperature_dx % set_from_raw ( state_vector ( i : i + this % temperature_size - 1 )) i = i + this % temperature_size call this % salinity % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) i = i + this % salinity_size call this % salinity_dx % set_from_raw ( state_vector ( i : i + this % salinity_size - 1 )) if ( present ( ice_thickness )) then call this % melt_formulation % solve_for_melt ( this % velocity , & - ice_thickness / this % r_val , & this % temperature , & this % salinity , & this % thickness , & this % time ) end if #ifdef DEBUG call logger % debug ( 'plume%update' , 'Updated state of plume.' ) #endif end subroutine plume_update"},{"title":"plume_read_data – ISOFT","tags":"","loc":"proc/plume_read_data.html","text":"private subroutine plume_read_data(this, file_id, group_name, error) Reads the state of the plume object from an HDF file in the\n specified group. This sets the thickness, velocity, temperature,\n salinity dataset, and parameter values. Arguments Type Intent Optional Attributes Name class( plume ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Calls proc~~plume_read_data~~CallsGraph proc~plume_read_data plume_read_data h5ltget_attribute_string_f h5ltget_attribute_string_f proc~plume_read_data->h5ltget_attribute_string_f h5gopen_f h5gopen_f proc~plume_read_data->h5gopen_f h5gclose_f h5gclose_f proc~plume_read_data->h5gclose_f str str proc~plume_read_data->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code plume_read_data Source Code subroutine plume_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the plume object from an HDF file in the ! specified group. This sets the thickness, velocity, temperature, ! salinity dataset, and parameter values. ! class ( plume ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err real ( r8 ), dimension ( 1 ) :: param character ( len = 50 ) :: base_type ret_err = 0 call h5gopen_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % error ( 'plume%read_data' , 'Could not open HDF group \"' // & group_name // '\", so no IO performed.' ) return end if call h5ltget_attribute_string_f ( file_id , group_name , hdf_type_attr , & base_type , error ) if ( trim ( base_type ) /= hdf_type_name ) then call logger % error ( 'plume%read_data' , 'Trying to read data from ' // & 'basal_surface of type other than plume.' ) error = - 1 return end if !call h5ltget_attribute_double_f(file_id, group_name, hdf_delta, & !                                param, error) !this%delta = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_nu, & !                                param, error) !this%nu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_mu, & !                                param, error) !this%mu = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_r, & !                                param, error) !this%r_val = param(1) !call h5ltget_attribute_double_f(file_id, group_name, hdf_phi, & !                                param, error) !this%phi = param(1) !if (error /= 0) then !  call logger%warning('plume%read_data','Error code '//     & !                      trim(str(error))//' returned when '//  & !                      'reading attributes from HDF group '// & !                      group_name) !  ret_err = error !end if call this % thickness % read_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume thickness field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % read_hdf ( group_id , hdf_velocity , error ) this % velocity_dx = this % velocity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume velocity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % read_hdf ( group_id , hdf_temperature , error ) this % temperature_dx = this % temperature % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume temperature field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % read_hdf ( group_id , hdf_salinity , error ) this % salinity_dx = this % salinity % d_dx ( 1 ) if ( error /= 0 ) then call logger % warning ( 'plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'reading plume salinity field ' // & 'from HDF file' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'plume%read_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err call logger % trivia ( 'plume%read_data' , 'Read plume data from HDF group ' // & group_name ) end subroutine plume_read_data"},{"title":"plume_write_data – ISOFT","tags":"","loc":"proc/plume_write_data.html","text":"private subroutine plume_write_data(this, file_id, group_name, error) Writes the state of the plume object to an HDF file in the\n specified group. This will consist of a thickness, a velocity, a\n temperature, and a salinity dataset. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Calls proc~~plume_write_data~~CallsGraph proc~plume_write_data plume_write_data str str proc~plume_write_data->str h5ltset_attribute_string_f h5ltset_attribute_string_f proc~plume_write_data->h5ltset_attribute_string_f h5gclose_f h5gclose_f proc~plume_write_data->h5gclose_f h5gcreate_f h5gcreate_f proc~plume_write_data->h5gcreate_f h5ltset_attribute_double_f h5ltset_attribute_double_f proc~plume_write_data->h5ltset_attribute_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code plume_write_data Source Code subroutine plume_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the plume object to an HDF file in the ! specified group. This will consist of a thickness, a velocity, a ! temperature, and a salinity dataset. ! class ( plume ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id integer :: ret_err ret_err = 0 call h5gcreate_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned ' // & 'when creating HDF group \"' // group_name // '\"' ) call logger % error ( 'plume%write_data' , 'Data IO not performed for plume' ) return end if call h5ltset_attribute_string_f ( file_id , group_name , hdf_type_attr , & hdf_type_name , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_delta , & [ this % delta ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_nu , & [ this % nu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_mu , & [ this % mu ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_r , & [ this % r_val ], 1_size_t , error ) call h5ltset_attribute_double_f ( file_id , group_name , hdf_phi , & [ this % phi ], 1_size_t , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing attribute to HDF group ' // & group_name ) ret_err = error end if call this % thickness % write_hdf ( group_id , hdf_thickness , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume thickness field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % velocity % write_hdf ( group_id , hdf_velocity , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume velocity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % temperature % write_hdf ( group_id , hdf_temperature , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume temperature field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call this % salinity % write_hdf ( group_id , hdf_salinity , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'writing plume salinity field to HDF' ) if ( ret_err == 0 ) ret_err = error end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then call logger % warning ( 'plume%write_data' , 'Error code ' // & trim ( str ( error )) // ' returned when ' // & 'closing HDF group ' // group_name ) if ( ret_err == 0 ) ret_err = error end if error = ret_err #ifdef DEBUG call logger % debug ( 'plume%write_data' , 'Wrote plume data to HDF group ' // & group_name ) #endif end subroutine plume_write_data"},{"title":"plume_solve – ISOFT","tags":"","loc":"proc/plume_solve.html","text":"private subroutine plume_solve(this, ice_thickness, ice_density, ice_temperature, time, success) Solves the state of the plume for the specified ice properties,\n at the specified time. This is done using the a\n quasilinearisation method and a GMRES iterative linear solver. Arguments Type Intent Optional Attributes Name class( plume ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise Calls proc~~plume_solve~~CallsGraph proc~plume_solve plume_solve str str proc~plume_solve->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code plume_solve Source Code subroutine plume_solve ( this , ice_thickness , ice_density , ice_temperature , & time , success ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Solves the state of the plume for the specified ice properties, ! at the specified time. This is done using the a ! quasilinearisation method and a GMRES iterative linear solver. ! class ( plume ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: ice_thickness !! Thickness of the ice above the basal surface real ( r8 ), intent ( in ) :: ice_density !! The density of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: ice_temperature !! The temperature of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: time !! The time to which the basal surface should be solved logical , intent ( out ) :: success !! True if the solver is successful, false otherwise real ( r8 ), dimension (:), allocatable :: solution real ( r8 ) :: residual integer , dimension ( 5 ) :: info integer :: flag class ( scalar_field ), pointer :: b call ice_thickness % guard_temp () b => - ice_thickness / this % r_val call b % guard_temp () select type ( bound => this % boundaries ) class is ( upstream_plume_boundary ) call bound % calculate ( time , non_diff_terms , b ) class default call bound % set_time ( time ) end select solution = this % state_vector () #ifdef DEBUG call logger % debug ( 'plume%solve' , 'Calling QLM ODE solver' ) #endif call quasilinear_solve ( L , f , jac_prod , solution , 1 , residual , flag , info , & 1.e-9_r8 * size ( solution ), precond = preconditioner , & iter_max = 100 , krylov_dim = 85 , gmres_iter_max = 5000 ) call this % update ( solution ) #ifdef DEBUG call logger % debug ( 'plume%solve' , 'QLM solver required ' // & trim ( str ( info ( 5 ))) // ' nonlinear iterations ' // & 'and ' // trim ( str ( info ( 1 ) + info ( 2 ))) // & ' function calls.' ) #endif select case ( flag ) case ( 0 ) call logger % trivia ( 'plume%solver' , 'Solved plume at time ' // trim ( str ( time ))) success = . true . this % time = time case ( 1 ) call logger % warning ( 'plume%solver' , 'Plume solver stagnated with ' // & 'residual of ' // trim ( str ( residual ))) success = . false . case ( 2 ) call logger % error ( 'plume%solver' , 'Reached maximum number of ' // & 'iterations solving plume' ) success = . false . case ( 3 ) call logger % error ( 'plume%solver' , 'Plume solution began to diverge.' ) success = . false . case default call logger % error ( 'plume%solve' , 'QLM solver failed for plume with ' // & 'error code ' // trim ( str ( flag ))) success = . false . end select call ice_thickness % clean_temp (); call b % clean_temp () contains function L ( v ) !! The linear differentiation operator real ( r8 ), dimension (:), intent ( in ) :: v !! The state vector for the system of differential equations real ( r8 ), dimension ( size ( v )) :: L integer :: st , en , btype_l , btype_u , bdepth_l , bdepth_u type ( cheb1d_scalar_field ) :: scalar_tmp type ( cheb1d_vector_field ) :: vector_tmp type ( cheb1d_vector_field ) :: coriolis call this % update ( v ) ! Thickness scalar_tmp = this % thickness % d_dx ( 1 ) call this % boundaries % thickness_bound_info ( - 1 , btype_l , bdepth_l ) call this % boundaries % thickness_bound_info ( 1 , btype_u , bdepth_u ) if ( this % lower_bounds ( 1 )) then call scalar_tmp % set_boundary ( - 1 , 1 , this % thickness % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % thickness % get_boundary ( 1 , 1 )) end if st = 1 en = st + this % thickness_size - 1 L ( st : en ) = scalar_tmp % raw () ! Velocity vector_tmp = this % velocity % d_dx ( 1 ) - this % velocity_dx if ( this % lower_bounds ( 2 )) then call vector_tmp % set_boundary ( - 1 , 1 , this % velocity % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % velocity_size - 1 L ( st : en ) = vector_tmp % raw () if ( this % phi /= 0._r8 ) then coriolis = [ 0._r8 , 0._r8 , this % phi / this % nu ] . cross . this % velocity vector_tmp = this % velocity_dx % d_dx ( 1 ) - coriolis else vector_tmp = this % velocity_dx % d_dx ( 1 ) end if if ( this % lower_bounds ( 3 )) then call vector_tmp % set_boundary ( - 1 , 1 , this % velocity_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , this % velocity_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % velocity_size - 1 L ( st : en ) = vector_tmp % raw () ! Temperature scalar_tmp = this % temperature % d_dx ( 1 ) - this % temperature_dx if ( this % lower_bounds ( 4 )) then call scalar_tmp % set_boundary ( - 1 , 1 , this % temperature % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % temperature_size - 1 L ( st : en ) = scalar_tmp % raw () scalar_tmp = this % temperature_dx % d_dx ( 1 ) if ( this % lower_bounds ( 5 )) then call scalar_tmp % set_boundary ( - 1 , 1 , this % temperature_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % temperature_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % temperature_size - 1 L ( st : en ) = scalar_tmp % raw () ! Salinity scalar_tmp = this % salinity % d_dx ( 1 ) - this % salinity_dx if ( this % lower_bounds ( 6 )) then call scalar_tmp % set_boundary ( - 1 , 1 , this % salinity % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % salinity_size - 1 L ( st : en ) = scalar_tmp % raw () scalar_tmp = this % salinity_dx % d_dx ( 1 ) if ( this % lower_bounds ( 7 )) then call scalar_tmp % set_boundary ( - 1 , 1 , this % salinity_dx % get_boundary ( - 1 , 1 )) end if if ( this % upper_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , this % salinity_dx % get_boundary ( 1 , 1 )) end if st = en + 1 en = st + this % salinity_size - 1 L ( st : en ) = scalar_tmp % raw () end function L subroutine non_diff_terms ( D , Uvec , T , S , b , DU_x , DUU_x , DUT_x , DUS_x ) !! Computes the values of (DU)_x, (DU\\vec{U})_x, !! (DUT)_x, (DUS)_x, when diffusion is not !! included. This should be able to handle uniform field types, !! for use in an ODE solver when integrating near the !! boundary. The momentum term is calculated quite differently !! depending on whether it is being done for the ODE solver !! orthe plume solver. For this reason, as well as the !! usefulness of avoiding taking any derivatives when !! calculating it, I have chosen not to bother calculating it !! here unless it is for the ODE solver. class ( scalar_field ), intent ( in ) :: D !! The plume thickness class ( vector_field ), intent ( in ) :: Uvec !! The plume velocity class ( scalar_field ), intent ( in ) :: T !! The plume temperature class ( scalar_field ), intent ( in ) :: S !! The plume salinity class ( scalar_field ), intent ( in ) :: b !! The debth of the base of the ice shelf class ( scalar_field ), intent ( out ) :: DU_x !! The derivative of the product DU class ( vector_field ), intent ( out ) :: DUU_x !! The derivative of the product DUU class ( scalar_field ), intent ( out ) :: DUT_x !! The derivative of the product DUT class ( scalar_field ), intent ( out ) :: DUS_x !! The derivative of the product DUS integer :: dims class ( scalar_field ), pointer :: m , rho , e , S_a , U , V , & T_a , rho_a , rho_x , Unorm class ( scalar_field ), allocatable , dimension (:) :: tmp type ( cheb1d_vector_field ) :: coriolis call D % guard_temp (); call Uvec % guard_temp (); call T % guard_temp () call S % guard_temp (); call b % guard_temp () S_a => this % ambient_conds % ambient_salinity ( b , time ) T_a => this % ambient_conds % ambient_temperature ( b , time ) call S_a % guard_temp (); call T_a % guard_temp () rho => this % eos % water_density ( T , S ) rho_a => this % eos % water_density ( T_a , S_a ) U => Uvec % component ( 1 ) V => Uvec % component ( 2 ) call rho % guard_temp (); call rho_a % guard_temp (); call U % guard_temp () call V % guard_temp () e => this % entrainment_formulation % entrainment_rate ( Uvec , D , b , rho_a - rho , time ) call e % guard_temp () call this % melt_formulation % solve_for_melt ( Uvec , b , T , S , D , time ) m => this % melt_formulation % melt_rate () call m % guard_temp () DU_x = e + m if ( this % melt_formulation % has_heat_terms ()) then DUT_x = e * T_a - this % melt_formulation % heat_equation_terms () else DUT_x = e * T_a end if if ( this % melt_formulation % has_salt_terms ()) then DUS_x = e * S_a - this % melt_formulation % salt_equation_terms () !        print*, DUS_x%raw() else DUS_x = e * S_a end if select type ( Uvec ) class is ( uniform_vector_field ) Unorm => Uvec % norm () rho_x => this % eos % water_density_derivative ( T , ( DUT_x - DU_x * T ) / ( D * U ), & S , ( DUS_x - DU_x * S ) / ( D * U ), 1 ) call Unorm % guard_temp (); call rho_x % guard_temp () dims = Uvec % raw_size () / Uvec % elements () allocate ( tmp ( dims ), mold = D ) tmp ( 1 ) = 1._r8 - this % delta * D * ( rho_a - rho ) / U ** 2 !print*,tmp(1)%raw() tmp ( 1 ) = ( D * ( rho_a - rho ) * ( b % d_dx ( 1 ) - 2 * this % delta * DU_x / U ) & + 0.5 * this % delta * D ** 2 * rho_x - this % mu * Unorm * U & + this % phi * D * V ) / ( 1._r8 - this % delta * D * ( rho_a - rho ) / U ** 2 ) if ( dims > 1 ) then tmp ( 2 ) = - this % mu * Unorm * V - this % phi * D * U end if DUU_x = tmp call Unorm % clean_temp (); call rho_x % clean_temp () class default !        if (this%phi /= 0._r8) then !          coriolis = [0._r8, 0._r8, this%phi] .cross. Uvec !          DUU_x = -this%mu*Uvec*Uvec%norm() + 0.5_r8*this%delta*D**2*(.grad. rho) & !                  + D*(rho_a - rho)*(.grad.(b - this%delta*D)) - D*coriolis !        else DUU_x = - this % mu * Uvec * Uvec % norm () + 0.5_r8 * this % delta * D ** 2 * (. grad . rho ) & + D * ( rho_a - rho ) * (. grad .( b - this % delta * D )) !        end if end select call e % clean_temp (); call S_a % clean_temp (); call T_a % clean_temp () call rho % clean_temp (); call m % clean_temp (); call rho_a % clean_temp () call U % clean_temp (); call V % clean_temp () call D % clean_temp (); call Uvec % clean_temp (); call T % clean_temp () call S % clean_temp (); call b % clean_temp () end subroutine non_diff_terms function f ( v ) !! The nonlinear operator real ( r8 ), dimension (:,:), intent ( in ) :: v !! The state vector for the system of differential equations, !! and its derivatives. Column i represents the i-1 !! derivative. real ( r8 ), dimension ( size ( v , 1 )) :: f call this % update ( v (:, 1 )) call nonlinear ( f , . false .) end function f function jac_prod ( v , dv ) !! The product of the Jacobian of the nonlienar operator at v, !! multiplying dv. real ( r8 ), dimension (:,:), intent ( in ) :: v !! The state vector for the system of differential equations, !! and its derivatives. Column i represents the i-1 !! derivative. real ( r8 ), dimension (:,:), intent ( in ) :: dv !! The state vector for the system of differential equations, !! and its derivatives, to be multiplied by the !! Jacobian. Column i represents the i-1 derivative. real ( r8 ), dimension ( size ( v , 1 )) :: jac_prod type ( cheb1d_scalar_field ) :: stmp type ( cheb1d_vector_field ) :: vtmp integer :: i call this % update ( v (:, 1 )) call stmp % assign_meta_data ( this % thickness ) call vtmp % assign_meta_data ( this % velocity ) call stmp % set_from_raw ( dv ( 1 : this % thickness_size , 1 )) call this % thickness % set_derivative ( stmp ) i = 1 + this % thickness_size call vtmp % set_from_raw ( dv ( i : i + this % velocity_size - 1 , 1 )) call this % velocity % set_derivative ( vtmp ) i = i + this % velocity_size call vtmp % set_from_raw ( dv ( i : i + this % velocity_size - 1 , 1 )) call this % velocity_dx % set_derivative ( vtmp ) i = i + this % velocity_size call stmp % set_from_raw ( dv ( i : i + this % temperature_size - 1 , 1 )) call this % temperature % set_derivative ( stmp ) i = i + this % temperature_size call stmp % set_from_raw ( dv ( i : i + this % temperature_size - 1 , 1 )) call this % temperature_dx % set_derivative ( stmp ) i = i + this % temperature_size call stmp % set_from_raw ( dv ( i : i + this % salinity_size - 1 , 1 )) call this % salinity % set_derivative ( stmp ) i = i + this % salinity_size call stmp % set_from_raw ( dv ( i : i + this % salinity_size - 1 , 1 )) call this % salinity_dx % set_derivative ( stmp ) call nonlinear ( jac_prod , . true .) call this % thickness % unset_derivative () call this % velocity % unset_derivative () call this % velocity_dx % unset_derivative () call this % temperature % unset_derivative () call this % temperature_dx % unset_derivative () call this % salinity % unset_derivative () call this % salinity_dx % unset_derivative () end function jac_prod subroutine nonlinear ( f , deriv ) real ( r8 ), dimension (:), intent ( out ) :: f logical , intent ( in ) :: deriv !! If true, return Jacobian product, otherwise return result !! of nonlienar operator. integer :: st , en type ( cheb1d_scalar_field ) :: scalar_tmp , D_x , D_nd , S_nd , T_nd type ( cheb1d_vector_field ) :: vector_tmp , U_nd class ( scalar_field ), pointer :: U , U_x ! Use same or similar notation for variables as used in equations associate ( D => this % thickness , Uvec => this % velocity , & Uvec_x => this % velocity_dx , S => this % salinity , & S_x => this % salinity_dx , T => this % temperature , & T_x => this % temperature_dx , mf => this % melt_formulation , & h => ice_thickness , delta => this % delta , nu => this % nu , & mu => this % mu , r => this % r_val , bounds => this % boundaries ) call non_diff_terms ( D , Uvec , T , S , b , D_nd , U_nd , T_nd , S_nd ) ! FIXME: Alter this so that can take advantage of ! parameterisations returning uniform fields. U => this % velocity % component ( 1 ) U_x => this % velocity_dx % component ( 1 ) call U % guard_temp (); call U_x % guard_temp () ! Thickness scalar_tmp = ( D_nd - D * U_x ) / U D_x = scalar_tmp if ( this % lower_bounds ( 1 )) then call scalar_tmp % set_boundary ( - 1 , 1 , bounds % thickness_bound ( - 1 )) end if if ( this % upper_bounds ( 1 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % thickness_bound ( 1 )) end if st = 1 en = st + this % thickness_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () ! Velocity vector_tmp = 0._r8 * Uvec if ( this % lower_bounds ( 2 )) then call vector_tmp % set_boundary ( - 1 , 1 , bounds % velocity_bound ( - 1 )) end if if ( this % upper_bounds ( 2 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( 1 )) end if st = en + 1 en = st + this % velocity_size - 1 if ( deriv ) then vector_tmp = vector_tmp % get_derivative () end if f ( st : en ) = vector_tmp % raw () vector_tmp = D * U * Uvec_x !Needed due to compiler bug vector_tmp = ( vector_tmp + D * U_x * Uvec + D_x * U * Uvec - U_nd - & nu * D_x * Uvec_x ) / ( nu * D ) if ( this % lower_bounds ( 3 )) then call vector_tmp % set_boundary ( - 1 , 1 , bounds % velocity_bound ( - 1 )) end if if ( this % upper_bounds ( 3 )) then call vector_tmp % set_boundary ( 1 , 1 , bounds % velocity_bound ( 1 )) end if st = en + 1 en = st + this % velocity_size - 1 if ( deriv ) then vector_tmp = vector_tmp % get_derivative () end if f ( st : en ) = vector_tmp % raw () ! Temperature scalar_tmp = uniform_scalar_field ( 0._r8 ) if ( this % lower_bounds ( 4 )) then call scalar_tmp % set_boundary ( - 1 , 1 , bounds % temperature_bound ( - 1 )) end if if ( this % upper_bounds ( 4 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( 1 )) end if st = en + 1 en = st + this % temperature_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () scalar_tmp = ( D * U * T_x + D * U_x * T + D_x * U * T - T_nd - nu * D_x * T_x ) / ( nu * D ) if ( this % lower_bounds ( 5 )) then call scalar_tmp % set_boundary ( - 1 , 1 , bounds % temperature_bound ( - 1 )) end if if ( this % upper_bounds ( 5 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % temperature_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () ! Salinity scalar_tmp = uniform_scalar_field ( 0._r8 ) if ( this % lower_bounds ( 6 )) then call scalar_tmp % set_boundary ( - 1 , 1 , bounds % salinity_bound ( - 1 )) end if if ( this % upper_bounds ( 6 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () scalar_tmp = ( D * U * S_x + D * U_x * S + D_x * U * S - S_nd - nu * D_x * S_x ) / ( nu * D ) if ( this % lower_bounds ( 7 )) then call scalar_tmp % set_boundary ( - 1 , 1 , bounds % salinity_bound ( - 1 )) end if if ( this % upper_bounds ( 7 )) then call scalar_tmp % set_boundary ( 1 , 1 , bounds % salinity_bound ( 1 )) end if st = en + 1 en = st + this % salinity_size - 1 if ( deriv ) then scalar_tmp = scalar_tmp % get_derivative () end if f ( st : en ) = scalar_tmp % raw () call U % clean_temp (); call U_x % clean_temp () end associate end subroutine nonlinear function preconditioner ( v , state , L_op , f_op , fcur , rhs ) !! The preconditioner, which approximates an inverse of `L`. real ( r8 ), dimension (:), intent ( in ) :: v !! The vector to be preconditioned. real ( r8 ), dimension (:,:), intent ( in ) :: state !! The current state vector for the system of differential !! equations, and its derivatives. Column i represents the !! i-1 derivative. procedure ( L ) :: L_op !! The linear, left-hand-side of the ODE being solved. procedure ( f ) :: f_op !! The nonlinear, right-hand-side of the ODE being solved. real ( r8 ), dimension (:), intent ( in ) :: fcur !! The result of `f(u)` real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being !! preconditioned. real ( r8 ), dimension ( size ( v )) :: preconditioner !! The result of applying the preconditioner. integer :: st , en , ust , uen , pst , pen integer :: bloc real ( r8 ) :: nu type ( plume ) :: v_plume type ( cheb1d_scalar_field ) :: scalar_tmp type ( cheb1d_vector_field ) :: vector_tmp class ( scalar_field ), pointer :: U , U_x v_plume % thickness_size = this % thickness_size call v_plume % thickness % assign_meta_data ( this % thickness ) v_plume % velocity_size = this % velocity_size call v_plume % velocity % assign_meta_data ( this % velocity ) call v_plume % velocity_dx % assign_meta_data ( this % velocity_dx ) v_plume % temperature_size = this % temperature_size call v_plume % temperature % assign_meta_data ( this % temperature ) call v_plume % temperature_dx % assign_meta_data ( this % temperature_dx ) v_plume % salinity_size = this % salinity_size call v_plume % salinity % assign_meta_data ( this % salinity ) call v_plume % salinity_dx % assign_meta_data ( this % salinity_dx ) call v_plume % update ( v ) nu = this % nu bloc = get_bound_loc ( 1 ) v_plume % thickness = this % precond % solve_for ( v_plume % thickness , bloc , & v_plume % thickness % get_boundary ( bloc , 1 )) st = 1 en = st + this % thickness_size - 1 preconditioner ( st : en ) = v_plume % thickness % raw () ! Precondition the U_x term after have preconditioned values for S and T st = en + 1 en = st + this % velocity_size - 1 ust = st uen = en bloc = get_bound_loc ( 3 ) v_plume % velocity_dx = this % precond % solve_for ( v_plume % velocity_dx , bloc , & v_plume % velocity_dx % get_boundary ( bloc , 1 )) st = en + 1 en = st + this % velocity_size - 1 preconditioner ( st : en ) = v_plume % velocity_dx % raw () bloc = get_bound_loc ( 2 ) vector_tmp = v_plume % velocity + v_plume % velocity_dx v_plume % velocity = this % precond % solve_for ( vector_tmp , bloc , & v_plume % velocity % get_boundary ( bloc , 1 )) preconditioner ( ust : uen ) = v_plume % velocity % raw () ! Precondition T_x terms before T st = en + 1 en = st + this % temperature_size - 1 pst = st pen = en bloc = get_bound_loc ( 5 ) v_plume % temperature_dx = this % precond % solve_for ( v_plume % temperature_dx , bloc , & v_plume % temperature_dx % get_boundary ( bloc , 1 )) st = en + 1 en = st + this % temperature_size - 1 preconditioner ( st : en ) = v_plume % temperature_dx % raw () bloc = get_bound_loc ( 4 ) v_plume % temperature = this % precond % solve_for ( v_plume % temperature + & v_plume % temperature_dx , bloc , v_plume % temperature % get_boundary ( bloc , 1 )) preconditioner ( pst : pen ) = v_plume % temperature % raw () ! Precondition S_x terms before S st = en + 1 en = st + this % salinity_size - 1 pst = st pen = en bloc = get_bound_loc ( 7 ) v_plume % salinity_dx = this % precond % solve_for ( v_plume % salinity_dx , bloc , & v_plume % salinity_dx % get_boundary ( bloc , 1 )) st = en + 1 en = st + this % temperature_size - 1 preconditioner ( st : en ) = v_plume % salinity_dx % raw () bloc = get_bound_loc ( 6 ) v_plume % salinity = this % precond % solve_for ( v_plume % salinity + v_plume % salinity_dx , bloc , & v_plume % salinity % get_boundary ( bloc , 1 )) preconditioner ( pst : pen ) = v_plume % salinity % raw () end function preconditioner integer function get_bound_loc ( component_id ) integer :: component_id if ( this % lower_bounds ( component_id )) then get_bound_loc = - 1 else if ( this % upper_bounds ( component_id )) then get_bound_loc = 1 else get_bound_loc = 0 end if end function get_bound_loc end subroutine plume_solve"},{"title":"dummy_jacv – ISOFT","tags":"","loc":"proc/dummy_jacv.html","text":"public subroutine dummy_jacv(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) A dummy subroutine which does not apply a preconditioner or\n calculate an analytic Jacobian. This can be passed to nitsol for the argument jacv . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=r8), intent(in), dimension(n) :: xcur real(kind=r8), intent(in), dimension(n) :: fcur integer, intent(in) :: ijob real(kind=r8), intent(in), dimension(n) :: v real(kind=r8), intent(out), dimension(n) :: z real(kind=r8), intent(inout), dimension(*) :: rpar integer, intent(inout), dimension(*) :: ipar integer, intent(out) :: itrmjv Contents Source Code dummy_jacv Source Code subroutine dummy_jacv ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !* Author: Chris MacMackin !  Date: November 2016 ! ! A dummy subroutine which does not apply a preconditioner or ! calculate an analytic Jacobian. This can be passed to [[nitsol]] ! for the argument `jacv`. ! integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of length `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flag indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce J\\vec{v}, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} end subroutine dummy_jacv"},{"title":"dummy_f – ISOFT","tags":"","loc":"proc/dummy_f.html","text":"public subroutine dummy_f(n, xcur, fcur, rpar, ipar, itrmf) A dummy subroutine which does not calculate the function. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(out), dimension(n) :: fcur Array of length n containing f(xcur) on output real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array integer, intent(inout), dimension(*) :: ipar Parameter/work array integer, intent(out) :: itrmf Termination flag. 0 means normal termination, 1 means\n failure to produce f(xcur) Contents Source Code dummy_f Source Code subroutine dummy_f ( n , xcur , fcur , rpar , ipar , itrmf ) !* Author: Chris MacMackin !  Date: March 2017 ! ! A dummy subroutine which does not calculate the function. ! integer , intent ( in ) :: n !! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur !! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( out ) :: fcur !! Array of length `n` containing f(xcur) on output real ( r8 ), dimension ( * ), intent ( inout ) :: rpar !! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar !! Parameter/work array integer , intent ( out ) :: itrmf !! Termination flag. 0 means normal termination, 1 means !! failure to produce f(xcur) end subroutine dummy_f"},{"title":"gmres_solve – ISOFT","tags":"","loc":"proc/gmres_solve.html","text":"public subroutine gmres_solve(solution, lhs, rhs, resid_norm, flag, nlhs, nrpre, nli, tol, precond, rpar, ipar, resid_update, iter_max, krylov_dim, inner_prod, norm) A wraper for the nitsol implementation of the generalised minimal residual method\n ( GMRES )\n for iteratively solving linear systems. This provides a more\n general interface not specifically intended for use with Newton\n iteration. It also uses Fortran 90 features to provide a more\n convenient call signature. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(inout), dimension(:) :: solution On input, an initial guess of the solution to the linear\n system. On output, the iteratively determined solution. procedure( mat_mult ) :: lhs The linear operator on the left hand side of the linear\n system. real(kind=r8), intent(in), dimension(:) :: rhs The right hand side of the linear system being solved real(kind=r8), intent(out) :: resid_norm GMRES residual norm on return integer, intent(out) :: flag Termination flag. Values have the following meanings: 0 normal termination: acceptable solution found 1 J\\vec{v} failure 2 P&#94;{-1}\\vec{v} failure 3 Acceptable solution not found in iter_max GMRES iterations 4 Insignificant residual norm reduction of a cycle of kdmax steps (stagnation) before an acceptable solution has been \n found. 5 Dangerous ill-conditioning detected before an acceptable \n solution has been found. integer, intent(out), optional :: nlhs Number of evaluations of the left hand side of the system integer, intent(out), optional :: nrpre Number of evaluations of the right-preconditioner integer, intent(out), optional :: nli Number of iterations real(kind=r8), intent(in), optional :: tol The tolerance for the solution. Default is size(solution) * 1e-8 . procedure( mat_mult ), optional :: precond A right-preconditioner which may be used to improve\n convergence of the solution. real(kind=r8), intent(inout), optional dimension(*) :: rpar Parameter/work array passed to the lhs and precond routines. integer, intent(inout), optional dimension(*) :: ipar Parameter/work array passed to the lhs and precond routines integer, intent(in), optional :: resid_update Residual update flag. On GMRES restarts, the residual can\n be updated using a linear combination ( iresup == 0 ) or by\n direct evaluation ( iresup == 1 ). The first is cheap (one\n n-vector saxpy) but may lose accuracy with extreme residual\n reduction; the second retains accuracy better but costs one J\\vec{v} product. Default is 0. integer, intent(in), optional :: iter_max Maximum allowable number of GMRES iterations. Default is\n 1000. integer, intent(in), optional :: krylov_dim Maximum Krylov subspace dimension; default 10. procedure( dinpr_intr ), optional :: inner_prod Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ), optional :: norm Norm routine, either user supplied or BLAS dnrm2. Calls proc~~gmres_solve~~CallsGraph proc~gmres_solve gmres_solve interface~nitgm2 nitgm2 proc~gmres_solve->interface~nitgm2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gmres_solve~~CalledByGraph proc~gmres_solve gmres_solve proc~quasilinear_solve quasilinear_solve proc~quasilinear_solve->proc~gmres_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gmres_solve Source Code subroutine gmres_solve ( solution , lhs , rhs , resid_norm , flag , nlhs , nrpre , & nli , tol , precond , rpar , ipar , resid_update , & iter_max , krylov_dim , inner_prod , norm ) !* Author: Chris MacMackin !  Date: March 2017 ! ! A wraper for the ! [nitsol](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! implementation of the generalised minimal residual method ! ([GMRES](https://en.wikipedia.org/wiki/Generalized_minimal_residual_method)) ! for iteratively solving linear systems. This provides a more ! general interface not specifically intended for use with Newton ! iteration. It also uses Fortran 90 features to provide a more ! convenient call signature. ! real ( r8 ), dimension (:), intent ( inout ) :: solution !! On input, an initial guess of the solution to the linear !! system. On output, the iteratively determined solution. procedure ( mat_mult ) :: lhs !! The linear operator on the left hand side of the linear !! system. real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being solved real ( r8 ), intent ( out ) :: resid_norm !! GMRES residual norm on return integer , intent ( out ) :: flag !! Termination flag. Values have the following meanings: !! !!0 !!:    normal termination: acceptable solution found !! !!1 !!:    J\\vec{v}  failure !! !!2 !!:    P&#94;{-1}\\vec{v} failure !! !!3 !!:    Acceptable solution not found in `iter_max` GMRES iterations !! !!4 !!:    Insignificant residual norm reduction of a cycle of `kdmax` !!     steps (stagnation) before an acceptable solution has been !!     found. !! !!5 !!:    Dangerous ill-conditioning detected before an acceptable !!     solution has been found. real ( r8 ), intent ( in ), optional :: tol !! The tolerance for the solution. Default is `size(solution) * 1e-8`. integer , intent ( out ), optional :: nlhs !! Number of evaluations of the left hand side of the system integer , intent ( out ), optional :: nrpre !! Number of evaluations of the right-preconditioner integer , intent ( out ), optional :: nli !! Number of iterations procedure ( mat_mult ), optional :: precond !! A right-preconditioner which may be used to improve !! convergence of the solution. real ( r8 ), dimension ( * ), intent ( inout ), optional :: rpar !! Parameter/work array passed to the `lhs` and `precond` routines. integer , dimension ( * ), intent ( inout ), optional :: ipar !! Parameter/work array passed to the `lhs` and `precond` routines integer , intent ( in ), optional :: resid_update !! Residual update flag. On GMRES restarts, the residual can !! be updated using a linear combination (`iresup == 0`) or by !! direct evaluation (`iresup == 1`). The first is cheap (one !! n-vector saxpy) but may lose accuracy with extreme residual !! reduction; the second retains accuracy better but costs one !! J\\vec{v} product. Default is 0. integer , intent ( in ), optional :: iter_max !! Maximum allowable number of GMRES iterations. Default is !! 1000. integer , intent ( in ), optional :: krylov_dim !! Maximum Krylov subspace dimension; default 10. procedure ( dinpr_intr ), optional :: inner_prod !! Inner-product routine, either user-supplied or BLAS `ddot`. procedure ( dnorm_intr ), optional :: norm !! Norm routine, either user supplied or BLAS dnrm2. integer :: npoints , preflag , resup , itmax , kdim , nfe , lnlhs , lnrpre , lnli real ( r8 ) :: eta procedure ( dinpr_intr ), pointer :: dinpr procedure ( dnorm_intr ), pointer :: dnorm real ( r8 ), dimension (:), allocatable , save :: xcur , svbig , svsml , w , rwork real ( r8 ), dimension (:,:), allocatable , save :: vv , rr lnlhs = 0 lnrpre = 0 lnli = 0 npoints = size ( solution ) if ( present ( precond )) then preflag = 1 else preflag = 0 end if if ( present ( tol )) then eta = tol else eta = 1.e-8_r8 * npoints end if if ( present ( resid_update )) then resup = resid_update else resup = 0 end if if ( present ( iter_max )) then itmax = iter_max else itmax = 1000 end if if ( present ( krylov_dim )) then kdim = krylov_dim else kdim = 10 end if if ( present ( inner_prod )) then dinpr => inner_prod else dinpr => ddot end if if ( present ( norm )) then dnorm => norm else dnorm => dnrm2 end if xcur = solution if ( allocated ( vv )) then if ( any ( shape ( vv ) /= [ npoints , kdim + 1 ])) then deallocate ( vv ) allocate ( vv ( npoints , kdim + 1 )) end if if ( size ( svbig ) /= kdim ) then deallocate ( rr ) deallocate ( svbig ) deallocate ( svsml ) deallocate ( w ) allocate ( rr ( kdim , kdim )) allocate ( svbig ( kdim )) allocate ( svsml ( kdim )) allocate ( w ( kdim )) end if if ( size ( rwork ) /= npoints ) then deallocate ( rwork ) allocate ( rwork ( npoints )) end if else allocate ( vv ( npoints , kdim + 1 )) allocate ( rr ( kdim , kdim )) allocate ( svbig ( kdim )) allocate ( svsml ( kdim )) allocate ( w ( kdim )) allocate ( rwork ( npoints )) end if call nitgm2 ( npoints , xcur , - rhs , solution , eta , dummy_f , jacv , & rpar , ipar , 1 , preflag , itmax , resup , 1 , nfe , & lnlhs , lnrpre , lnli , kdim , kdim + 1 , vv , rr , svbig , & svsml , w , rwork , resid_norm , dinpr , dnorm , flag ) if ( present ( nlhs )) nlhs = lnlhs if ( present ( nrpre )) nrpre = lnrpre if ( present ( nli )) nli = lnli contains subroutine jacv ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! A wrapper on the user-provided routines for the linear !! operator and preconditioner, to put them in the form NITSOL !! expects. !! integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of length `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flag indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce J\\vec{v}, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} logical :: success itrmjv = 0 if ( ijob == 0 ) then z = lhs ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 1 else if ( ijob == 1 ) then z = precond ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 2 else error stop ( '`ijob` not equal to 0 or 1.' ) end if end subroutine jacv end subroutine gmres_solve"},{"title":"tfqmr_solve – ISOFT","tags":"","loc":"proc/tfqmr_solve.html","text":"public subroutine tfqmr_solve(solution, lhs, rhs, resid_norm, flag, nlhs, nrpre, nli, tol, precond, rpar, ipar, resid_update, iter_max, krylov_dim, inner_prod, norm) A wraper for the nitsol implementation of the transpose-free quasi-minimal residual method\n ( TFQMR )\n for iteratively solving linear systems. This provides a more\n general interface not specifically intended for use with Newton\n iteration. It also uses Fortran 90 features to provide a more\n convenient call signature. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(inout), dimension(:) :: solution On input, an initial guess of the solution to the linear\n system. On output, the iteratively determined solution. procedure( mat_mult ) :: lhs The linear operator on the left hand side of the linear\n system. real(kind=r8), intent(in), dimension(:) :: rhs The right hand side of the linear system being solved real(kind=r8), intent(out) :: resid_norm TFQMR residual norm on return integer, intent(out) :: flag Termination flag. Values have the following meanings: 0 normal termination: acceptable step found 1 J\\vec{v} failure in nitjv 2 P&#94;{-1}\\vec{v} failure in nitjv 3 Acceptable step not found in iksmax TFQMR iterations 4 TFQMR breakdown 5 Floating point error (the underlying CGS iteration\n has probably blown up) integer, intent(out), optional :: nlhs Number of evaluations of the left hand side of the system integer, intent(out), optional :: nrpre Number of evaluations of the right-preconditioner integer, intent(out), optional :: nli Number of iterations real(kind=r8), intent(in), optional :: tol The tolerance for the solution. Default is size(solution) * 1e-8 . procedure( mat_mult ), optional :: precond A right-preconditioner which may be used to improve\n convergence of the solution. real(kind=r8), intent(inout), optional dimension(*) :: rpar Parameter/work array passed to the lhs and precond routines. integer, intent(inout), optional dimension(*) :: ipar Parameter/work array passed to the lhs and precond routines integer, intent(in), optional :: resid_update Residual update flag. On GMRES restarts, the residual can\n be updated using a linear combination ( iresup == 0 ) or by\n direct evaluation ( iresup == 1 ). The first is cheap (one\n n-vector saxpy) but may lose accuracy with extreme residual\n reduction; the second retains accuracy better but costs one J\\vec{v} product. Meaningless in this routine, but kept\n for consistent interface. integer, intent(in), optional :: iter_max Maximum allowable number of TFQMR iterations. Default is\n 1000. integer, intent(in), optional :: krylov_dim Maximum Krylov subspace dimension; default 10. procedure( dinpr_intr ), optional :: inner_prod Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ), optional :: norm Norm routine, either user supplied or BLAS dnrm2. Contents Source Code tfqmr_solve Source Code subroutine tfqmr_solve ( solution , lhs , rhs , resid_norm , flag , nlhs , nrpre , & nli , tol , precond , rpar , ipar , resid_update , & iter_max , krylov_dim , inner_prod , norm ) !* Author: Chris MacMackin !  Date: March 2017 ! ! A wraper for the ! [nitsol](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! implementation of the transpose-free quasi-minimal residual method ! ([TFQMR](https://epubs.siam.org/doi/pdf/10.1137/0914029)) ! for iteratively solving linear systems. This provides a more ! general interface not specifically intended for use with Newton ! iteration. It also uses Fortran 90 features to provide a more ! convenient call signature. ! real ( r8 ), dimension (:), intent ( inout ) :: solution !! On input, an initial guess of the solution to the linear !! system. On output, the iteratively determined solution. procedure ( mat_mult ) :: lhs !! The linear operator on the left hand side of the linear !! system. real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being solved real ( r8 ), intent ( out ) :: resid_norm !! TFQMR residual norm on return integer , intent ( out ) :: flag !! Termination flag. Values have the following meanings: !! !!0 !!:    normal termination: acceptable step found !! !!1 !!:    J\\vec{v}  failure in `nitjv` !! !!2 !!:    P&#94;{-1}\\vec{v} failure in `nitjv` !! !!3 !!:    Acceptable step not found in `iksmax` TFQMR iterations !! !!4 !!:    TFQMR breakdown !! !!5 !!:    Floating point error (the underlying CGS iteration !!     has probably blown up) real ( r8 ), intent ( in ), optional :: tol !! The tolerance for the solution. Default is `size(solution) * 1e-8`. integer , intent ( out ), optional :: nlhs !! Number of evaluations of the left hand side of the system integer , intent ( out ), optional :: nrpre !! Number of evaluations of the right-preconditioner integer , intent ( out ), optional :: nli !! Number of iterations procedure ( mat_mult ), optional :: precond !! A right-preconditioner which may be used to improve !! convergence of the solution. real ( r8 ), dimension ( * ), intent ( inout ), optional :: rpar !! Parameter/work array passed to the `lhs` and `precond` routines. integer , dimension ( * ), intent ( inout ), optional :: ipar !! Parameter/work array passed to the `lhs` and `precond` routines integer , intent ( in ), optional :: resid_update !! Residual update flag. On GMRES restarts, the residual can !! be updated using a linear combination (`iresup == 0`) or by !! direct evaluation (`iresup == 1`). The first is cheap (one !! n-vector saxpy) but may lose accuracy with extreme residual !! reduction; the second retains accuracy better but costs one !! J\\vec{v} product. Meaningless in this routine, but kept !! for consistent interface. integer , intent ( in ), optional :: iter_max !! Maximum allowable number of TFQMR iterations. Default is !! 1000. integer , intent ( in ), optional :: krylov_dim !! Maximum Krylov subspace dimension; default 10. procedure ( dinpr_intr ), optional :: inner_prod !! Inner-product routine, either user-supplied or BLAS `ddot`. procedure ( dnorm_intr ), optional :: norm !! Norm routine, either user supplied or BLAS dnrm2. integer :: npoints , preflag , resup , itmax , kdim , nfe , lnlhs , lnrpre , lnli real ( r8 ) :: eta procedure ( dinpr_intr ), pointer :: dinpr procedure ( dnorm_intr ), pointer :: dnorm real ( r8 ), dimension (:), allocatable , save :: xcur real ( r8 ), dimension (:,:), allocatable , save :: workers lnlhs = 0 lnrpre = 0 lnli = 0 npoints = size ( solution ) if ( present ( precond )) then preflag = 1 else preflag = 0 end if if ( present ( tol )) then eta = tol else eta = 1.e-8_r8 * npoints end if if ( present ( resid_update )) then resup = resid_update else resup = 0 end if if ( present ( iter_max )) then itmax = iter_max else itmax = 1000 end if if ( present ( krylov_dim )) then kdim = krylov_dim else kdim = 10 end if if ( present ( inner_prod )) then dinpr => inner_prod else dinpr => ddot end if if ( present ( norm )) then dnorm => norm else dnorm => dnrm2 end if xcur = solution if ( allocated ( workers )) then if ( size ( workers , 1 ) /= npoints ) then deallocate ( workers ) allocate ( workers ( npoints , 11 )) end if else allocate ( workers ( npoints , 11 )) end if call nittfq2 ( npoints , xcur , - rhs , solution , eta , dummy_f , jacv , & rpar , ipar , 1 , preflag , itmax , 1 , nfe , lnlhs , lnrpre , & lnli , workers (:, 1 ), workers (:, 2 ), workers (:, 3 ), & workers (:, 4 ), workers (:, 5 ), workers (:, 6 ), & workers (:, 6 ), workers (:, 8 ), workers (:, 9 ), & workers (:, 10 ), workers (:, 11 ), resid_norm , dinpr , & dnorm , flag ) if ( present ( nlhs )) nlhs = lnlhs if ( present ( nrpre )) nrpre = lnrpre if ( present ( nli )) nli = lnli contains subroutine jacv ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! A wrapper on the user-provided routines for the linear !! operator and preconditioner, to put them in the form NITSOL !! expects. !! integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of length `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flag indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce J\\vec{v}, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} logical :: success itrmjv = 0 if ( ijob == 0 ) then z = lhs ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 1 else if ( ijob == 1 ) then z = precond ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 2 else error stop ( '`ijob` not equal to 0 or 1.' ) end if end subroutine jacv end subroutine tfqmr_solve"},{"title":"bicgstab_solve – ISOFT","tags":"","loc":"proc/bicgstab_solve.html","text":"public subroutine bicgstab_solve(solution, lhs, rhs, resid_norm, flag, nlhs, nrpre, nli, tol, precond, rpar, ipar, resid_update, iter_max, krylov_dim, inner_prod, norm) A wraper for the nitsol implementation of the biconjugate gradient stabilized method\n ( BiCGSTAB )\n for iteratively solving linear systems. This provides a more\n general interface not specifically intended for use with Newton\n iteration. It also uses Fortran 90 features to provide a more\n convenient call signature. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(inout), dimension(:) :: solution On input, an initial guess of the solution to the linear\n system. On output, the iteratively determined solution. procedure( mat_mult ) :: lhs The linear operator on the left hand side of the linear\n system. real(kind=r8), intent(in), dimension(:) :: rhs The right hand side of the linear system being solved real(kind=r8), intent(out) :: resid_norm BiCGSTAB residual norm on return integer, intent(out) :: flag Termination flag. Values have the following meanings: 0 normal termination: acceptable step found 1 J\\vec{v} failure in nitjv 2 P&#94;{-1}\\vec{v} failure in nitjv 3 Acceptable step not found in iksmax BiCGSTAB iterations 4 BiCGSTAB breakdown integer, intent(out), optional :: nlhs Number of evaluations of the left hand side of the system integer, intent(out), optional :: nrpre Number of evaluations of the right-preconditioner integer, intent(out), optional :: nli Number of iterations real(kind=r8), intent(in), optional :: tol The tolerance for the solution. Default is size(solution) * 1e-8 . procedure( mat_mult ), optional :: precond A right-preconditioner which may be used to improve\n convergence of the solution. real(kind=r8), intent(inout), optional dimension(*) :: rpar Parameter/work array passed to the lhs and precond routines. integer, intent(inout), optional dimension(*) :: ipar Parameter/work array passed to the lhs and precond routines integer, intent(in), optional :: resid_update Residual update flag. On GMRES restarts, the residual can be\n updated using a linear combination ( iresup == 0 ) or by\n direct evaluation ( iresup == 1 ). The first is cheap (one\n n-vector saxpy) but may lose accuracy with extreme residual\n reduction; the second retains accuracy better but costs one J\\vec{v} product. Meaningless in this routine, but kept\n for consistent interface. integer, intent(in), optional :: iter_max Maximum allowable number of TFQMR iterations. Default is\n 1000. integer, intent(in), optional :: krylov_dim Maximum Krylov subspace dimension; default 10. procedure( dinpr_intr ), optional :: inner_prod Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ), optional :: norm Norm routine, either user supplied or BLAS dnrm2. Contents Source Code bicgstab_solve Source Code subroutine bicgstab_solve ( solution , lhs , rhs , resid_norm , flag , nlhs , nrpre , & nli , tol , precond , rpar , ipar , resid_update , & iter_max , krylov_dim , inner_prod , norm ) !* Author: Chris MacMackin !  Date: March 2017 ! ! A wraper for the ! [nitsol](http://users.wpi.edu/~walker/Papers/nitsol,SISC_19,1998,302-318.pdf) ! implementation of the biconjugate gradient stabilized method ! ([BiCGSTAB](https://en.wikipedia.org/wiki/Biconjugate_gradient_stabilized_method)) ! for iteratively solving linear systems. This provides a more ! general interface not specifically intended for use with Newton ! iteration. It also uses Fortran 90 features to provide a more ! convenient call signature. ! real ( r8 ), dimension (:), intent ( inout ) :: solution !! On input, an initial guess of the solution to the linear !! system. On output, the iteratively determined solution. procedure ( mat_mult ) :: lhs !! The linear operator on the left hand side of the linear !! system. real ( r8 ), dimension (:), intent ( in ) :: rhs !! The right hand side of the linear system being solved real ( r8 ), intent ( out ) :: resid_norm !! BiCGSTAB residual norm on return integer , intent ( out ) :: flag !! Termination flag. Values have the following meanings: !! !!0 !!:    normal termination: acceptable step found !! !!1 !!:    J\\vec{v}  failure in `nitjv` !! !!2 !!:    P&#94;{-1}\\vec{v} failure in `nitjv` !! !!3 !!:    Acceptable step not found in `iksmax` BiCGSTAB iterations !! !!4 !!:    BiCGSTAB breakdown real ( r8 ), intent ( in ), optional :: tol !! The tolerance for the solution. Default is `size(solution) * 1e-8`. integer , intent ( out ), optional :: nlhs !! Number of evaluations of the left hand side of the system integer , intent ( out ), optional :: nrpre !! Number of evaluations of the right-preconditioner integer , intent ( out ), optional :: nli !! Number of iterations procedure ( mat_mult ), optional :: precond !! A right-preconditioner which may be used to improve !! convergence of the solution. real ( r8 ), dimension ( * ), intent ( inout ), optional :: rpar !! Parameter/work array passed to the `lhs` and `precond` routines. integer , dimension ( * ), intent ( inout ), optional :: ipar !! Parameter/work array passed to the `lhs` and `precond` routines integer , intent ( in ), optional :: resid_update !! Residual update flag. On GMRES restarts, the residual can be !! updated using a linear combination (`iresup == 0`) or by !! direct evaluation (`iresup == 1`). The first is cheap (one !! n-vector saxpy) but may lose accuracy with extreme residual !! reduction; the second retains accuracy better but costs one !! J\\vec{v} product. Meaningless in this routine, but kept !! for consistent interface. integer , intent ( in ), optional :: iter_max !! Maximum allowable number of TFQMR iterations. Default is !! 1000. integer , intent ( in ), optional :: krylov_dim !! Maximum Krylov subspace dimension; default 10. procedure ( dinpr_intr ), optional :: inner_prod !! Inner-product routine, either user-supplied or BLAS `ddot`. procedure ( dnorm_intr ), optional :: norm !! Norm routine, either user supplied or BLAS dnrm2. integer :: npoints , preflag , resup , itmax , kdim , nfe , lnlhs , lnrpre , lnli real ( r8 ) :: eta procedure ( dinpr_intr ), pointer :: dinpr procedure ( dnorm_intr ), pointer :: dnorm real ( r8 ), dimension (:), allocatable , save :: xcur real ( r8 ), dimension (:,:), allocatable , save :: workers lnlhs = 0 lnrpre = 0 lnli = 0 npoints = size ( solution ) if ( present ( precond )) then preflag = 1 else preflag = 0 end if if ( present ( tol )) then eta = tol else eta = 1.e-8_r8 * npoints end if if ( present ( resid_update )) then resup = resid_update else resup = 0 end if if ( present ( iter_max )) then itmax = iter_max else itmax = 1000 end if if ( present ( krylov_dim )) then kdim = krylov_dim else kdim = 10 end if if ( present ( inner_prod )) then dinpr => inner_prod else dinpr => ddot end if if ( present ( norm )) then dnorm => norm else dnorm => dnrm2 end if xcur = solution if ( allocated ( workers )) then if ( size ( workers , 1 ) /= npoints ) then deallocate ( workers ) allocate ( workers ( npoints , 8 )) end if else allocate ( workers ( npoints , 8 )) end if call nitstb2 ( npoints , xcur , - rhs , solution , eta , dummy_f , jacv , & rpar , ipar , 1 , preflag , itmax , 1 , nfe , lnlhs , lnrpre , & lnli , workers (:, 1 ), workers (:, 2 ), workers (:, 3 ), & workers (:, 4 ), workers (:, 5 ), workers (:, 6 ), & workers (:, 6 ), workers (:, 8 ), resid_norm , dinpr , & dnorm , flag ) if ( present ( nlhs )) nlhs = lnlhs if ( present ( nrpre )) nrpre = lnrpre if ( present ( nli )) nli = lnli contains subroutine jacv ( n , xcur , fcur , ijob , v , z , rpar , ipar , itrmjv ) !! A wrapper on the user-provided routines for the linear !! operator and preconditioner, to put them in the form NITSOL !! expects. !! integer , intent ( in ) :: n ! Dimension of the problem real ( r8 ), dimension ( n ), intent ( in ) :: xcur ! Array of length `n` containing the current x value real ( r8 ), dimension ( n ), intent ( in ) :: fcur ! Array of length `n` containing the current f(x) value integer , intent ( in ) :: ijob ! Integer flag indicating which product is desired. 0 ! indicates z = J\\vec{v}. 1 indicates z = P&#94;{-1}\\vec{v}. real ( r8 ), dimension ( n ), intent ( in ) :: v ! An array of length `n` to be multiplied real ( r8 ), dimension ( n ), intent ( out ) :: z ! An array of length n containing the desired product on ! output. real ( r8 ), dimension ( * ), intent ( inout ) :: rpar ! Parameter/work array integer , dimension ( * ), intent ( inout ) :: ipar ! Parameter/work array integer , intent ( out ) :: itrmjv ! Termination flag. 0 indcates normal termination, 1 ! indicatesfailure to prodce J\\vec{v}, and 2 indicates ! failure to produce P&#94;{-1}\\vec{v} logical :: success itrmjv = 0 if ( ijob == 0 ) then z = lhs ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 1 else if ( ijob == 1 ) then z = precond ( v , xcur , fcur , rpar , ipar , success ) if (. not . success ) itrmjv = 2 else error stop ( '`ijob` not equal to 0 or 1.' ) end if end subroutine jacv end subroutine bicgstab_solve"},{"title":"nitsol – ISOFT","tags":"","loc":"interface/nitsol.html","text":"interface Called by interface~~nitsol~~CalledByGraph interface~nitsol nitsol proc~glacier_integrate glacier_integrate proc~glacier_integrate->interface~nitsol proc~shelf_solve_velocity shelf_solve_velocity proc~shelf_solve_velocity->interface~nitsol Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine nitsol(n, x, f, jacv, ftol, stptol, input, info, rwork, rpar, ipar, iterm, dinpr, dnorm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(inout), dimension(n) :: x Vector of length n, initial guess on input and final\n approximate solution on output procedure( f_intr ) :: f User-supplied subroutine for evaluating the function\n the zero of which is sought. procedure( jacv_intr ) :: jacv User-supplied subroutine for optionally evaluating J\\vec{v} or P&#94;{-1}\\vec{v} , where J is the Jacobian\n of f and P is a right preconditioning operator. If\n neither analytic J\\vec{v} evaluations nor right\n preconditioning is used, this can be a dummy subroutine;\n if right preconditioning is used but not analytic J\\vec{v} evaluations, this need only evaluate P&#94;{-1}\\vec{v} . real(kind=r8), intent(in) :: ftol Stopping tolerance of the f-norm real(kind=r8), intent(in) :: stptol Stopping tolerance of the step-length integer, intent(in), dimension(10) :: input Array containing various user-specified inputs; see above integer, intent(out), dimension(6) :: info Array containing various outputs; see above real(kind=r8), intent(inout), dimension(*) :: rwork Work array with length depending on the solver used as follows: GMRES n\\times(\\text{kdmax}+5)+\\text{kdmax}\\times(\\text{kdmax}+3) ,\n where kdmax is the maximum Krylove subspace dimension, either\n the default value of 20 or another value specified by the user BiCGSTAB 11n TFQMR 14n real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array passed to the f and jacv routines integer, intent(inout), dimension(*) :: ipar Parameter/work array passed to the f and jacv routines integer, intent(out) :: iterm Termination flag. Values have the following meanings: -k illegal value in input(k) 0 normal termination: ||F|| < \\text{ftol} or ||\\text{step}||\n < \\text{stptol} 1 nnimax nonlinar iterations reached without success 2 failure to evaluate F 3 in nitjv , J\\vec{v} failure 4 in nitjv , P&#94;{-1}\\vec{v} failure 5 in nitdrv , insufficient initial model norm reduction for\n adequate progress. Note: This can occur for several\n reasons; examine itrmks on return from the Krylov solver\n for further information. (This will be printed out if \\text{iplvl}\\ge 3 ; see the discussion of optional common\n blocks below.) 6 in nitbt , failure to reach an acceptable step through\n backtracking procedure( dinpr_intr ) :: dinpr User-supplied function for calculating vector inner products.\n This has the same interace as the BLAS routine ddot .\n If the Euclidean inner product is desired then user can link\n to a local BLAS library and provide the name ddot to nitsol . dinpr must be declared as an external function that returns\n a double precision in the calling program. procedure( dnorm_intr ) :: dnorm User-supplied function for calculating vector norms. This\n has the same interface as the BLAS routine dnrm2; if the\n Euclidean norm is desired the user can link to a local\n BLAS library and provide the name dnrm2 to nitsol.  dnorm\n must be declared as an external function that returns a\n double precision value in the calling program. Description An explicit interface to the nitsol Newton iterative nonlinear solver. Input parameters The input array argument allows the user to specify various\n options. It should be declared an integer vector of length 11\n [sic.] in the calling program. To specify an option, set the\n appropriate input component to the desired value according to\n the specifications below. Usage Note: Setting a particular input component to zero gives the \n default option for that component in all cases. The first five input components are things that every user might wish \n to modify; the remainder will usually be of interest only to more \n experienced users. Optional every-user input: input(1) = nnimax = maximum number of nonlinear iterations (default 200).\n\ninput(2) = ijacv = flag for determining the method of J*v evaluation:\n             0 =&gt; finite-difference evaluation (default) \n             1 =&gt; analytic evaluation\n\ninput(3) = ikrysl = flag for determining the Krylov solver: \n             0 =&gt; GMRES (default)\n             1 =&gt; BiCGSTAB\n             2 =&gt; TFQMR\n\n           For brief descriptions of the solvers plus references, \n           see the subroutines nitgm, nitstb, and nittfq.\n\ninput(4) = kdmax = maximum Krylov subspace dimension when GMRES is used \n           (default 20).\n\ninput(5) = irpre = flag for right preconditioning: \n             0 =&gt; no right preconditioning\n             1 =&gt; right preconditioning Optional experienced user input: input(6) = iksmax = maximum allowable number of iterations per call \n           to the Krylov solver routine (default 1000).\n\ninput(7) = iresup = residual update flag when GMRES is used; on \n           restarts, the residual is updated as follows: \n             0 =&gt; linear combination (default) \n             1 =&gt; direct evaluation\n           The first is cheap (one n-vector saxpy) but may lose \n           accuracy with extreme residual reduction; the second \n           retains accuracy better but costs one J*v product per \n           restart.\n\ninput(8) = ifdord = order of the finite-difference formula (sometimes) \n           used when input(2) = ijacv = 0. When input(2) = ijacv = 0, \n           this must be 0, 1, 2, or 4 on input; otherwise, it is \n           irrelevant. With input(2) = ijacv = 0, the precise \n           meaning is as follows:\n\n           If GMRES is used, then ifdord matters only if input(7) = \n           iresup = 1, in which case it determines the order of \n           the finite-difference formula used in evaluating the \n           initial residual at each GMRES restart (default 2); if \n           ifdord = 0 on input, then it is set to 2 below. NOTE: This \n           only affects initial residuals at restarts; first-order \n           differences are always used within each GMRES cycle. Using \n           higher-order differences at restarts only should give \n           the same accuracy as if higher-order differences were \n           used throughout; see K. Turner and H. F. Walker, \"Efficient \n           high accuracy solutions with GMRES(m),\" SIAM J. Sci. \n           Stat. Comput., 13 (1992), pp. 815--825.\n\n           If BiCGSTAB or TFQMR is used, then ifdord determines the \n           order of the finite-difference formula used at each \n           iteration (default 1); if ifdord = 0 on input, then it \n           is set to 1 below.\n\ninput(9) = ibtmax = maximum allowable number of backtracks (step \n           reductions) per call to nitbt (default 10).\n\n           USAGE NOTE: Backtracking can be turned off by setting \n              ibtmax = -1. Other negative values of ibtmax are not \n           valid.\n\ninput(10) = ieta = flag determining the forcing term eta as follows: \n             0 =&gt; abs( ||fcur|| - ||fprev+Jprev*sprev|| )/||fprev||\n                  (default) \n             1 =&gt; (||fcur||/||fprev||)**2 \n             2 =&gt; gamma*(||fcur||/||fprev||)**alpha \n                  for user-supplied gamma in (0,1] and alpha in (1,2] \n             3 =&gt; fixed (constant) eta in (0,1), either 0.1 (default) \n                     or specified by the user (see USAGE NOTE below) \n           Here, fcur = current f, fprev = previous f, etc. The Krylov \n           iterations are terminated when an iterate s satisfies \n           an inexact Newton condition ||F + J*s|| .le. eta*||F||.\n\n           USAGE NOTE: If input(10) = ieta = 2, then alpha and gamma \n           must be set in common block nitparam.h as described below. \n              If input(10) = ieta = 3, then the desired constant eta may \n              be similarly set in nitparam.h if a value other than the \n              default of 0.1 is desired.\n\n           The first three expressions above are from S. C. Eisenstat \n           and H. F. Walker, \"Choosing the forcing terms in an inexact \n           Newton method\", SIAM J. Scientific Computing, 17 (1996), \n           pp. 16--32. (They may be modified according to certain \n           safeguards in subroutine nitdrv.) The first gives convergence \n           that is q-superlinear and of r-order (1+sqrt(5))/2. The \n           second gives convergence that is r-quadratic and of q-order \n           p for every p in [1,2). The third gives convergence that is \n           of q-order alpha when gamma &lt; 1 and, when gamma = 1, of \n           r-order alpha and q-order p for every p in [1,alpha). The \n           fourth gives q-linear convergence with asymptotic rate \n           constant eta in a certain norm; see R. S. Dembo, S. C. \n              Eisenstat, and T. Steihaug, \"Inexact Newton methods\", \n           SIAM J. Numer. Anal., 18 (1982), pp. 400-408.\n\n           Of these four choices, the 1st is usually satisfactory, \n           the 2nd or 3rd is sometimes preferred, and the 4th may be \n           useful in some situations, e.g., it may be desirable to \n           choose a fairly large fixed eta in (0,1), such as eta = .1, \n           when numerical inaccuracy prevents the Krylov solver \n           from obtaining much residual reduction. Output parameters On output, the components of the info argument are as follows: info(1)   = nfe (number of function evaluations)\n info(2)   = njve (number of J*v evaluations)\n info(3)   = nrpre (number of P(inverse)*v evaluations)\n info(4)   = nli (number of linear iterations)\n info(5)   = nni (number of nonlinear iterations)\n info(6)   = nbt (number of backtracks)"},{"title":"nitgm2 – ISOFT","tags":"","loc":"interface/nitgm2.html","text":"interface Called by interface~~nitgm2~~CalledByGraph interface~nitgm2 nitgm2 proc~gmres_solve gmres_solve proc~gmres_solve->interface~nitgm2 proc~quasilinear_solve quasilinear_solve proc~quasilinear_solve->proc~gmres_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine nitgm2(n, xcur, fcur, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, iresup, ifdord, nfe, njve, nrpre, nli, kdmax, kdmaxp1, vv, rr, svbig, svsml, w, rwork, rsnrm, dinpr, dnorm, itrmks) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(in), dimension(n) :: fcur Array of length n containing current approximate solution real(kind=r8), intent(inout), dimension(n) :: step Vector of of length n containing trial step real(kind=r8), intent(in) :: eta Relative residual reduction factor procedure( f_intr ) :: f User-supplied subroutine for evaluating the function\n the zero of which is sought. procedure( jacv_intr ) :: jacv User-supplied subroutine for optionally evaluating J\\vec{v} or P&#94;{-1}\\vec{v} , where J is the Jacobian\n of f and P is a right preconditioning operator. If\n neither analytic J\\vec{v} evaluations nor right\n preconditioning is used, this can be a dummy subroutine;\n if right preconditioning is used but not analytic J\\vec{v} evaluations, this need only evaluate P&#94;{-1}\\vec{v} . real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array passed to the f and jacv routines integer, intent(inout), dimension(*) :: ipar Parameter/work array passed to the f and jacv routines integer, intent(in) :: ijacv Flag for determining method of J\\vec{v} evaluation. 0\n (default) indicates finite-difference evaluation, while 1\n indicates analytic evaluation. integer, intent(in) :: irpre Flag for right preconditioning. 0 indicates no\n preconditioning, while 1 inidcates right preconditioning. integer, intent(in) :: iksmax Maximum allowable number of GMRES iterations integer, intent(in) :: iresup Residual update flag. On GMRES restarts, the residual can\n be updated using a linear combination ( iresup == 0 ) or by\n direct evaluation ( iresup == 1 ). The first is cheap (one\n n-vector saxpy) but may lose accuracy with extreme residual\n reduction; the second retains accuracy better but costs one J\\vec{v} product. integer, intent(in) :: ifdord Order of the finite-difference formula (sometimes) used on\n GMRES restarts when J\\vec{v} products are evaluated\n using finite- differences. When ijacv = 0 on input to\n nitsol, ifdord is set to 1, 2, or 4 in nitsol; otherwise,\n it is irrelevant. When ijacv = 0 on input to this\n subroutine, the precise meaning is as follows: With GMRES, ifdord matters only if iresup = 1, in which case it determines the order of the finite-difference formula used \n in evaluating the initial residual at each GMRES restart (default 2). If iresup = 1 and ijacv = 0 on input to this subroutine, then ijacv is temporarily reset to -1 at each restart below to force a finite-difference evaluation of order\n ifdord. NOTE: This only affects initial residuals at restarts;\n first-order differences are always used within each GMRES cycle. Using higher-order differences at restarts only should \n give the same accuracy as if higher-order differences were used throughout; see K. Turner and H. F. Walker, \"Efficient high accuracy solutions with GMRES(m),\" SIAM J. Sci. Stat. Comput., 13 (1992), pp. 815--825. integer, intent(inout) :: nfe Number of function evaluations integer, intent(inout) :: njve Number of J\\vec{v} evaluations integer, intent(inout) :: nrpre Number of P&#94;{-1}\\vec{v} evaluations integer, intent(inout) :: nli Number of linear iterations integer, intent(in) :: kdmax Maximum Krylov subspace dimension; default 10. integer, intent(in) :: kdmaxp1 kdmax + 1 real(kind=r8), intent(out), dimension(n, kdmaxp1) :: vv Matrix for storage of Krylov basis in GMRES; on return, the\n residual vector is contained in the first column. real(kind=r8), intent(out), dimension(kdmax, kdmax) :: rr Matrix for storage of triangular matrix in GMRES. real(kind=r8), intent(out), dimension(kdmax) :: svbig Vector for storage of estimate of singular vector of rr with largest singular value. real(kind=r8), intent(out), dimension(kdmax) :: svsml Vector for storage of estimate of singular vector of rr with smallest singular value. real(kind=r8), intent(out), dimension(kdmax) :: w Vector containing right-hand side of triangular system and\n least-squares residual norm in GMRES. real(kind=r8), intent(out), dimension(n) :: rwork Work array real(kind=r8), intent(out) :: rsnrm GMRES residual norm on return procedure( dinpr_intr ) :: dinpr Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ) :: dnorm Norm routine, either user supplied or BLAS dnrm2. integer, intent(out) :: itrmks Termination flag. Values have the following meanings: 0 normal termination: acceptable step found 1 J\\vec{v} failure in nitjv 2 P&#94;{-1}\\vec{v} failure in nitjv 3 Acceptable step not found in iksmax GMRES iterations 4 Insignificant residual norm reduction of a cycle of kdmax steps (stagnation) before an acceptable step has been found. 5 Dangerous ill-conditioning detected before an acceptable \n step has been found. Description An interface to my modified versino of the nitsol implementation of the generalised minimal residual method\n ( GMRES )\n for iteratively solving linear systems. It has been modified\n so that the user provides a non-zero initial guess of the\n solution."},{"title":"nittfq2 – ISOFT","tags":"","loc":"interface/nittfq2.html","text":"interface public subroutine nittfq2(n, xcur, fcur, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, ifdord, nfe, njve, nrpre, nli, r, rcgs, rtil, d, p, q, u, v, y, rwork1, rwork2, rsnrm, dinpr, dnorm, itrmks) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(in), dimension(n) :: fcur Array of length n containing current approximate solution real(kind=r8), intent(inout), dimension(n) :: step Vector of of length n containing trial step real(kind=r8), intent(in) :: eta Relative residual reduction factor procedure( f_intr ) :: f User-supplied subroutine for evaluating the function\n the zero of which is sought. procedure( jacv_intr ) :: jacv User-supplied subroutine for optionally evaluating J\\vec{v} or P&#94;{-1}\\vec{v} , where J is the Jacobian\n of f and P is a right preconditioning operator. If\n neither analytic J\\vec{v} evaluations nor right\n preconditioning is used, this can be a dummy subroutine;\n if right preconditioning is used but not analytic J\\vec{v} evaluations, this need only evaluate P&#94;{-1}\\vec{v} . real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array passed to the f and jacv routines integer, intent(inout), dimension(*) :: ipar Parameter/work array passed to the f and jacv routines integer, intent(in) :: ijacv Flag for determining method of J\\vec{v} evaluation. 0\n (default) indicates finite-difference evaluation, while 1\n indicates analytic evaluation. integer, intent(in) :: irpre Flag for right preconditioning. 0 indicates no\n preconditioning, while 1 inidcates right preconditioning. integer, intent(in) :: iksmax Maximum allowable number of TFQMR iterations integer, intent(in) :: ifdord Order of the finite-difference formula used in TFQMR\n when J*v products are evaluated using finite-differences. \n When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or \n 4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on \n input to this subroutine, ifdord determines the order of the \n finite-difference formula used at each TFQMR iteration \n (default 1). In this case, ijacv is set to -1 below to \n signal to nitjv that the order of the finite-difference \n formula is to be determined by ifdord. The original value \n ijacv = 0 is restored on return. integer, intent(inout) :: nfe Number of function evaluations integer, intent(inout) :: njve Number of J\\vec{v} evaluations integer, intent(inout) :: nrpre Number of P&#94;{-1}\\vec{v} evaluations integer, intent(inout) :: nli Number of linear iterations real(kind=r8), intent(out), dimension(n) :: r Residual vector (for the QMR process) real(kind=r8), intent(out), dimension(n) :: rcgs Residual vector (of the underlying CGS process) real(kind=r8), intent(out), dimension(n) :: rtil 'Shadow' residual vector used in bi-orthogonalization real(kind=r8), intent(out), dimension(n) :: d Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: p Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: q Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: u Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: v Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: y Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: rwork1 Work vector, passed on to nitjv real(kind=r8), intent(out), dimension(n) :: rwork2 Work vector, passed on to nitjv real(kind=r8), intent(out) :: rsnrm TFQMR residual norm on return procedure( dinpr_intr ) :: dinpr Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ) :: dnorm Norm routine, either user supplied or BLAS dnrm2. integer, intent(out) :: itrmks Termination flag. Values have the following meanings: 0 normal termination: acceptable step found 1 J\\vec{v} failure in nitjv 2 P&#94;{-1}\\vec{v} failure in nitjv 3 Acceptable step not found in iksmax TFQMR iterations 4 TFQMR breakdown 5 Floating point error (the underlying CGS iteration\n has probably blown up) Description An interface to my modified versino of the nitsol implementation of the transpose-free quasi-minimal residual\n method\n ( TFQMR ) for\n iteratively solving linear systems. It has been modified so\n that the user provides a non-zero initial guess of the\n solution."},{"title":"nitstb2 – ISOFT","tags":"","loc":"interface/nitstb2.html","text":"interface public subroutine nitstb2(n, xcur, fcur, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, ifdord, nfe, njve, nrpre, nli, r, rtil, p, phat, v, t, rwork1, rwork2, rsnrm, dinpr, dnorm, itrmks) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(in), dimension(n) :: fcur Array of length n containing current approximate solution real(kind=r8), intent(inout), dimension(n) :: step Vector of of length n containing trial step real(kind=r8), intent(in) :: eta Relative residual reduction factor procedure( f_intr ) :: f User-supplied subroutine for evaluating the function\n the zero of which is sought. procedure( jacv_intr ) :: jacv User-supplied subroutine for optionally evaluating J\\vec{v} or P&#94;{-1}\\vec{v} , where J is the Jacobian\n of f and P is a right preconditioning operator. If\n neither analytic J\\vec{v} evaluations nor right\n preconditioning is used, this can be a dummy subroutine;\n if right preconditioning is used but not analytic J\\vec{v} evaluations, this need only evaluate P&#94;{-1}\\vec{v} . real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array passed to the f and jacv routines integer, intent(inout), dimension(*) :: ipar Parameter/work array passed to the f and jacv routines integer, intent(in) :: ijacv Flag for determining method of J\\vec{v} evaluation. 0\n (default) indicates finite-difference evaluation, while 1\n indicates analytic evaluation. integer, intent(in) :: irpre Flag for right preconditioning. 0 indicates no\n preconditioning, while 1 inidcates right preconditioning. integer, intent(in) :: iksmax Maximum allowable number of BiCGSTAB iterations integer, intent(in) :: ifdord Order of the finite-difference formula used in BiCGSTAB \n when J*v products are evaluated using finite-differences. \n When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or \n 4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on \n input to this subroutine, ifdord determines the order of the \n finite-difference formula used at each BiCGSTAB iteration \n (default 1). In this case, ijacv is set to -1 below to \n signal to nitjv that the order of the finite-difference \n formula is to be determined by ifdord. The original value \n ijacv = 0 is restored on return. integer, intent(inout) :: nfe Number of function evaluations integer, intent(inout) :: njve Number of J\\vec{v} evaluations integer, intent(inout) :: nrpre Number of P&#94;{-1}\\vec{v} evaluations integer, intent(inout) :: nli Number of linear iterations real(kind=r8), intent(out), dimension(n) :: r Residual vector real(kind=r8), intent(out), dimension(n) :: rtil \\tilde{r} vector used in BiCGSTAB real(kind=r8), intent(out), dimension(n) :: p Vector used in BiCGSTAB real(kind=r8), intent(out), dimension(n) :: phat Vector used in BiCGSTAB real(kind=r8), intent(out), dimension(n) :: v Vector used in BiCGSTAB real(kind=r8), intent(out), dimension(n) :: t Vector used in BiCGSTAB real(kind=r8), intent(out), dimension(n) :: rwork1 Work vector, passed on to nitjv real(kind=r8), intent(out), dimension(n) :: rwork2 Work vector, passed on to nitjv real(kind=r8), intent(out) :: rsnrm BiCGSTAB residual norm on return procedure( dinpr_intr ) :: dinpr Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ) :: dnorm Norm routine, either user supplied or BLAS dnrm2. integer, intent(out) :: itrmks Termination flag. Values have the following meanings: 0 normal termination: acceptable step found 1 J\\vec{v} failure in nitjv 2 P&#94;{-1}\\vec{v} failure in nitjv 3 Acceptable step not found in iksmax BiCGSTAB iterations 4 BiCGSTAB breakdown Description An interface to my modified versino of the nitsol implementation of the biconjugate gradient stabilized method\n ( BiCGSTAB )\n for iteratively solving linear systems. It has been modified\n so that the user provides a non-zero initial guess of the\n solution."},{"title":"ddot – ISOFT","tags":"","loc":"interface/ddot.html","text":"interface public function ddot(n, x, sx, y, sy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=r8), intent(in), dimension(*) :: x integer, intent(in) :: sx real(kind=r8), intent(in), dimension(*) :: y integer, intent(in) :: sy Return Value real(kind=r8) Description An interface to the BLAS routine for calculating Euclidean\n inner product. This can be passed to nitsol for the\n argument dinpr ."},{"title":"dnrm2 – ISOFT","tags":"","loc":"interface/dnrm2.html","text":"interface Called by interface~~dnrm2~~CalledByGraph interface~dnrm2 dnrm2 proc~quasilinear_solve quasilinear_solve proc~quasilinear_solve->interface~dnrm2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function dnrm2(n, x, sx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=r8), intent(in), dimension(*) :: x integer, intent(in) :: sx Return Value real(kind=r8) Description An interface to the BLAS routine for calculating Euclidean\n norm. This can be passed to nitsol for the argument dnorm ."},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~8.html","text":"private function constructor(const, beta_s, thickness) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: const The constant to which SD is equal. real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S , relating\n salinity and density. class(scalar_field), intent(in) :: thickness The thickness of the plume, from which the salinity is calculated. Return Value type( prescribed_eos ) Called by proc~~constructor~8~~CalledByGraph proc~constructor~8 constructor interface~prescribed_eos prescribed_eos interface~prescribed_eos->proc~constructor~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code function constructor ( const , beta_s , thickness ) result ( this ) real ( r8 ), intent ( in ) :: const !! The constant to which SD is equal. real ( r8 ), intent ( in ) :: beta_s !! The haline contraction coefficient, \\beta_S, relating !! salinity and density. class ( scalar_field ), intent ( in ) :: thickness !! The thickness of the plume, from which the salinity is calculated. type ( prescribed_eos ) :: this call thickness % guard_temp () allocate ( this % density , mold = thickness ) this % density = const * beta_s / thickness this % beta_s = beta_s call thickness % clean_temp () end function constructor"},{"title":"prescribed_water_density – ISOFT","tags":"","loc":"proc/prescribed_water_density.html","text":"private function prescribed_water_density(this, temperature, salinity) result(density) Returns the density corresponding to the prescribed salinity, as\n calculated in the constructor. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water Calls proc~~prescribed_water_density~~CallsGraph proc~prescribed_water_density prescribed_water_density uniform_scalar_field uniform_scalar_field proc~prescribed_water_density->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code prescribed_water_density Source Code function prescribed_water_density ( this , temperature , salinity ) result ( density ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns the density corresponding to the prescribed salinity, as ! calculated in the constructor. ! class ( prescribed_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), pointer :: density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () if ( temperature == uniform_scalar_field ( 0._r8 ) . and . & salinity == uniform_scalar_field ( 0._r8 )) then ! Kludge to ensure correct ambient density is returned call temperature % allocate_scalar_field ( density ) density = uniform_scalar_field ( 0._r8 ) else call this % density % allocate_scalar_field ( density ) density = this % density end if call temperature % clean_temp (); call salinity % clean_temp () call density % set_temp () end function prescribed_water_density"},{"title":"prescribed_water_deriv – ISOFT","tags":"","loc":"proc/prescribed_water_deriv.html","text":"private function prescribed_water_deriv(this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Calculates the derivative of the water density. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the density of the water Calls proc~~prescribed_water_deriv~~CallsGraph proc~prescribed_water_deriv prescribed_water_deriv uniform_scalar_field uniform_scalar_field proc~prescribed_water_deriv->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code prescribed_water_deriv Source Code function prescribed_water_deriv ( this , temperature , d_temperature , salinity , & d_salinity , dir ) result ( d_density ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Calculates the derivative of the water density. class ( prescribed_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature !! A field containing the temperature of the water class ( scalar_field ), intent ( in ) :: d_temperature !! A field containing the derivative of the temperature of the !! water, in teh same direction as `dir` class ( scalar_field ), intent ( in ) :: salinity !! A field containing the salinity of the water class ( scalar_field ), intent ( in ) :: d_salinity !! A field containing the derivative of the salinity of the !! water, in the same direction as `dir` integer , intent ( in ) :: dir !! The direction in which to take the derivative class ( scalar_field ), pointer :: d_density !! A field containing the density of the water call temperature % guard_temp (); call salinity % guard_temp () call d_temperature % guard_temp (); call d_salinity % guard_temp () if ( temperature == uniform_scalar_field ( 0._r8 ) . and . & salinity == uniform_scalar_field ( 0._r8 )) then ! Kludge to ensure correct ambient density is returned call temperature % allocate_scalar_field ( d_density ) d_density = uniform_scalar_field ( 0._r8 ) else call this % density % allocate_scalar_field ( d_density ) d_density = this % density % d_dx ( 1 ) end if call temperature % clean_temp (); call salinity % clean_temp () call d_temperature % clean_temp (); call d_salinity % clean_temp () call d_density % set_temp () end function prescribed_water_deriv"},{"title":"prescribed_haline_contraction – ISOFT","tags":"","loc":"proc/prescribed_haline_contraction.html","text":"private function prescribed_haline_contraction(this, temperature, salinity) result(coef) Returns the haline contraction coefficient. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Calls proc~~prescribed_haline_contraction~~CallsGraph proc~prescribed_haline_contraction prescribed_haline_contraction uniform_scalar_field uniform_scalar_field proc~prescribed_haline_contraction->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code prescribed_haline_contraction Source Code function prescribed_haline_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: June 2017 ! ! Returns the haline contraction coefficient. ! class ( prescribed_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( this % beta_s ) end function prescribed_haline_contraction"},{"title":"prescribed_thermal_contraction – ISOFT","tags":"","loc":"proc/prescribed_thermal_contraction.html","text":"private function prescribed_thermal_contraction(this, temperature, salinity) result(coef) Returns the thermal contraction coefficient. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Calls proc~~prescribed_thermal_contraction~~CallsGraph proc~prescribed_thermal_contraction prescribed_thermal_contraction uniform_scalar_field uniform_scalar_field proc~prescribed_thermal_contraction->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code prescribed_thermal_contraction Source Code function prescribed_thermal_contraction ( this , temperature , salinity ) result ( coef ) !* Author: Chris MacMackin !  Date: June 2017 ! ! Returns the thermal contraction coefficient. ! class ( prescribed_eos ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: temperature class ( scalar_field ), intent ( in ) :: salinity class ( scalar_field ), allocatable :: coef allocate ( uniform_scalar_field :: coef ) coef = uniform_scalar_field ( 0.0_r8 ) end function prescribed_thermal_contraction"},{"title":"prescribed_assign – ISOFT","tags":"","loc":"proc/prescribed_assign.html","text":"private subroutine prescribed_assign(lhs, rhs) Assigns this object to another equation of state object,\n allowing the definided assignment for the precalculated density\n field to work correctly. Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(out) :: lhs class( prescribed_eos ), intent(in) :: rhs Contents Source Code prescribed_assign Source Code subroutine prescribed_assign ( lhs , rhs ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Assigns this object to another equation of state object, ! allowing the definided assignment for the precalculated density ! field to work correctly. ! class ( equation_of_state ), intent ( out ) :: lhs class ( prescribed_eos ), intent ( in ) :: rhs select type ( lhs ) class is ( prescribed_eos ) if ( allocated ( lhs % density )) then if (. not . same_type_as ( lhs % density , rhs % density )) then deallocate ( lhs % density ) allocate ( lhs % density , mold = rhs % density ) end if else allocate ( lhs % density , mold = rhs % density ) end if lhs % density = rhs % density class default error stop ( \"Can't assign to `equation_of_state` object of class other \" // & \"than `prescribed_eos`.\" ) end select end subroutine prescribed_assign"},{"title":"prescribed_eos – ISOFT","tags":"","loc":"interface/prescribed_eos.html","text":"public interface prescribed_eos Calls interface~~prescribed_eos~~CallsGraph interface~prescribed_eos prescribed_eos proc~constructor~8 constructor interface~prescribed_eos->proc~constructor~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private function constructor (const, beta_s, thickness) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: const The constant to which SD is equal. real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S , relating\n salinity and density. class(scalar_field), intent(in) :: thickness The thickness of the plume, from which the salinity is calculated. Return Value type( prescribed_eos )"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~9.html","text":"private function constructor() result(this) Instantiates a ground object. Arguments None Return Value type( ground ) Called by proc~~constructor~9~~CalledByGraph proc~constructor~9 constructor interface~ground ground interface~ground->proc~constructor~9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code function constructor () result ( this ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Instantiates a [[ground]] object. ! type ( ground ) :: this end function constructor"},{"title":"ground_melt – ISOFT","tags":"","loc":"proc/ground_melt.html","text":"private function ground_melt(this) result(melt) Computes and returns the melt rate at the bottom of the ice\n sheet due to interaction with the ground. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. Contents Source Code ground_melt Source Code function ground_melt ( this ) result ( melt ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the melt rate at the bottom of the ice ! sheet due to interaction with the ground. ! class ( ground ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate at the base of the ice sheet. end function ground_melt"},{"title":"ground_drag_parameter – ISOFT","tags":"","loc":"proc/ground_drag_parameter.html","text":"private function ground_drag_parameter(this) result(drag) Computes and returns a quantity which may be necessary to determine\n the frictional drag the ground exerts on the bottom of the ice\n sheet. An example would be the coefficient of friction. The \n description of this method is left deliberately vague so that as not\n to constrain how the drag is parameterized. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of a paramter describing the drag of the ground on the\n ice sheet. Contents Source Code ground_drag_parameter Source Code function ground_drag_parameter ( this ) result ( drag ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns a quantity which may be necessary to determine ! the frictional drag the ground exerts on the bottom of the ice ! sheet. An example would be the coefficient of friction. The ! description of this method is left deliberately vague so that as not ! to constrain how the drag is parameterized. ! class ( ground ), intent ( in ) :: this class ( scalar_field ), pointer :: drag !! The value of a paramter describing the drag of the ground on the !! ice sheet. end function ground_drag_parameter"},{"title":"ground_water_density – ISOFT","tags":"","loc":"proc/ground_water_density.html","text":"private function ground_water_density(this) result(density) Computes and returns the density of the water beneath the ice sheet.\n This water would be subglacial discharge and would tend to lubricate\n the motion of the ice sheet. The density probably won't be important\n in the case of an ice sheet, but is included so that the ground data\n type can have the same interface as the plume data type. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value real(kind=r8) The density of any water at the base of the ice sheet. Contents Source Code ground_water_density Source Code function ground_water_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Computes and returns the density of the water beneath the ice sheet. ! This water would be subglacial discharge and would tend to lubricate ! the motion of the ice sheet. The density probably won't be important ! in the case of an ice sheet, but is included so that the ground data ! type can have the same interface as the [[plume]] data type. ! class ( ground ), intent ( in ) :: this real ( r8 ) :: density !! The density of any water at the base of the ice sheet. end function ground_water_density"},{"title":"ground_data_size – ISOFT","tags":"","loc":"proc/ground_data_size.html","text":"private pure function ground_data_size(this) Returns the number of elements in the ground's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value integer The number of elements in the ground's state vector. Contents Source Code ground_data_size Source Code pure function ground_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the ground's state vector. ! This is the size of the vector returned by ! [[ground(type):state_vector]] and taken as an argument by ! [[ground(type):update]]. ! class ( ground ), intent ( in ) :: this integer :: ground_data_size !! The number of elements in the ground's state vector. end function ground_data_size"},{"title":"ground_state_vector – ISOFT","tags":"","loc":"proc/ground_state_vector.html","text":"private pure function ground_state_vector(this) result(state_vector) Returns the state vector for the current state of the ground. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:),allocatable The state vector describing the ground. Contents Source Code ground_state_vector Source Code pure function ground_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the ground. ! This takes the form of a 1D array. ! class ( ground ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the ground. end function ground_state_vector"},{"title":"ground_update – ISOFT","tags":"","loc":"proc/ground_update.html","text":"private subroutine ground_update(this, state_vector, ice_thickness) Updates the state of the ground from its state vector. The state\n vector is a real array containing the value of each of the ground's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( ground ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n ground. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate and/or drag parameter. Contents Source Code ground_update Source Code subroutine ground_update ( this , state_vector , ice_thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the ground from its state vector. The state ! vector is a real array containing the value of each of the ground's ! properties at each of the locations on the grid used in discretization. ! class ( ground ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! ground. class ( scalar_field ), optional , intent ( in ) :: ice_thickness !! The ice thickness which, if present, will be used to update !! the calculation of the melt rate and/or drag parameter. end subroutine ground_update"},{"title":"ground_read_data – ISOFT","tags":"","loc":"proc/ground_read_data.html","text":"private subroutine ground_read_data(this, file_id, group_name, error) Reads the state of the ground object from the specified group in\n an HDF file. Arguments Type Intent Optional Attributes Name class( ground ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group from which this data is\n meant to be read. character(len=*), intent(in) :: group_name The name of the group in the HDF5 file storing the\n ground's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Contents Source Code ground_read_data Source Code subroutine ground_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the ground object from the specified group in ! an HDF file. ! class ( ground ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group from which this data is !! meant to be read. character ( len =* ), intent ( in ) :: group_name !! The name of the group in the HDF5 file storing the !! ground's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id error = 0 end subroutine ground_read_data"},{"title":"ground_write_data – ISOFT","tags":"","loc":"proc/ground_write_data.html","text":"private subroutine ground_write_data(this, file_id, group_name, error) Writes the state of the ground object to an HDF file in the\n specified group. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ground's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Calls proc~~ground_write_data~~CallsGraph proc~ground_write_data ground_write_data h5gclose_f h5gclose_f proc~ground_write_data->h5gclose_f h5gcreate_f h5gcreate_f proc~ground_write_data->h5gcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ground_write_data Source Code subroutine ground_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the ground object to an HDF file in the ! specified group. ! class ( ground ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ground's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. integer ( hid_t ) :: group_id call h5gcreate_f ( file_id , group_name , group_id , error ) if ( error /= 0 ) then write ( * , * ) 'WARNING: Error code' , error , ' returned when creating HDF ' // & 'group' , group_name write ( * , * ) '         Data IO not performed for ice shelf' return end if call h5gclose_f ( group_id , error ) if ( error /= 0 ) then write ( * , * ) 'WARNING: Error code' , error , ' returned when closing HDF ' // & 'group' , group_name write ( * , * ) '         Possible bad IO' end if end subroutine ground_write_data"},{"title":"ground_solve – ISOFT","tags":"","loc":"proc/ground_solve.html","text":"private subroutine ground_solve(this, ice_thickness, ice_density, ice_temperature, time, success) Solves the state of the ground for the specified ice properties,\n at the specified time. Arguments Type Intent Optional Attributes Name class( ground ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise Contents Source Code ground_solve Source Code subroutine ground_solve ( this , ice_thickness , ice_density , & ice_temperature , time , success ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Solves the state of the ground for the specified ice properties, ! at the specified time. ! class ( ground ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: ice_thickness !! Thickness of the ice above the basal surface real ( r8 ), intent ( in ) :: ice_density !! The density of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: ice_temperature !! The temperature of the ice above the basal surface, assumed uniform real ( r8 ), intent ( in ) :: time !! The time to which the basal surface should be solved logical , intent ( out ) :: success !! True if the solver is successful, false otherwise end subroutine ground_solve"},{"title":"ground – ISOFT","tags":"","loc":"interface/ground.html","text":"public interface ground Calls interface~~ground~~CallsGraph interface~ground ground proc~constructor~9 constructor interface~ground->proc~constructor~9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private function constructor () result(this) Author Christopher MacMackin Date April 2016 Instantiates a ground object. Arguments None Return Value type( ground )"},{"title":"scalar_bound – ISOFT","tags":"","loc":"proc/scalar_bound.html","text":"private function scalar_bound(this, location) Returns a field containing the boundary values for the specified\n boundary location. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Calls proc~~scalar_bound~~CallsGraph proc~scalar_bound scalar_bound uniform_scalar_field uniform_scalar_field proc~scalar_bound->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code scalar_bound Source Code function scalar_bound ( this , location ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the boundary values for the specified ! boundary location. ! class ( plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: scalar_bound type ( uniform_scalar_field ) :: dummy call dummy % allocate_scalar_field ( scalar_bound ) scalar_bound = uniform_scalar_field ( 0.0_r8 ) end function scalar_bound"},{"title":"vector_bound – ISOFT","tags":"","loc":"proc/vector_bound.html","text":"private function vector_bound(this, location) Returns a field containing the boundary values for the specified\n boundary location. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer Calls proc~~vector_bound~~CallsGraph proc~vector_bound vector_bound uniform_vector_field uniform_vector_field proc~vector_bound->uniform_vector_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code vector_bound Source Code function vector_bound ( this , location ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the boundary values for the specified ! boundary location. ! class ( plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( vector_field ), pointer :: vector_bound type ( uniform_scalar_field ) :: dummy call dummy % allocate_vector_field ( vector_bound ) vector_bound = uniform_vector_field ([ 0.0_r8 , 0.0_r8 ]) end function vector_bound"},{"title":"bound_info – ISOFT","tags":"","loc":"proc/bound_info.html","text":"private subroutine bound_info(this, location, bound_type, bound_depth) Provides information about the type of boundary, and the number\n of layers of data-points needed to describe it. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. Contents Source Code bound_info Source Code subroutine bound_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Provides information about the type of boundary, and the number ! of layers of data-points needed to describe it. ! class ( plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. bound_type = free_boundary bound_depth = 0 end subroutine bound_info"},{"title":"set_time – ISOFT","tags":"","loc":"proc/set_time.html","text":"private subroutine set_time(this, time) Sets the time at which boundary conditions are to be calculated. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: time Contents Source Code set_time Source Code subroutine set_time ( this , time ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Sets the time at which boundary conditions are to be calculated. ! class ( plume_boundary ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time end subroutine set_time"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~10.html","text":"private function constructor(domain, resolution, thickness, velocity, viscosity_law, lambda, chi) result(this) Creates a new ice_sheet object with initial conditions provided\n by the arguments. At present only a 1D model is supported. If\n information is provided for higher dimensions then it will be ignored. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the ice sheet. The first index represents the dimension for which\n the boundaries apply. If the second index is 1 then it corresponds\n to the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( thickness_func ) :: thickness A function which calculates the initial value of the thickness of \n the ice sheet at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the ice at a given location in an ice sheet. class( abstract_viscosity ), intent(in), optional :: viscosity_law An object which calculates the viscosity of the ice. real(kind=r8), intent(in), optional :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real(kind=r8), intent(in), optional :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Return Value type( ice_sheet ) An ice sheet object with its domain and initial conditions set\n according to the arguments of the constructor function. Called by proc~~constructor~10~~CalledByGraph proc~constructor~10 constructor interface~ice_sheet ice_sheet interface~ice_sheet->proc~constructor~10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code function constructor ( domain , resolution , thickness , velocity , & viscosity_law , lambda , chi ) result ( this ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Creates a new [[ice_sheet]] object with initial conditions provided ! by the arguments. At present only a 1D model is supported. If ! information is provided for higher dimensions then it will be ignored. ! real ( r8 ), dimension (:,:), intent ( in ) :: domain !! An array containing the upper and lower limits of the domain for !! the ice sheet. The first index represents the dimension for which !! the boundaries apply. If the second index is 1 then it corresponds !! to the lower bound. If the second index is 2 then it corresponds to !! the upper bound. integer , dimension (:), intent ( in ) :: resolution !! The number of data points in each dimension procedure ( thickness_func ) :: thickness !! A function which calculates the initial value of the thickness of !! the ice sheet at a given location. procedure ( velocity_func ) :: velocity !! A function which calculates the initial value of the velocity !! (vector) of the ice at a given location in an ice sheet. class ( abstract_viscosity ), intent ( in ), optional :: viscosity_law !! An object which calculates the viscosity of the ice. real ( r8 ), intent ( in ), optional :: lambda !! The dimensionless ratio !! $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real ( r8 ), intent ( in ), optional :: chi !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ type ( ice_sheet ) :: this !! An ice sheet object with its domain and initial conditions set !! according to the arguments of the constructor function. end function constructor"},{"title":"sheet_thickness – ISOFT","tags":"","loc":"proc/sheet_thickness.html","text":"private pure function sheet_thickness(this) result(thickness) Returns the thickness of the ice sheet across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value class(scalar_field),\n  pointer The ice thickness. Contents Source Code sheet_thickness Source Code pure function sheet_thickness ( this ) result ( thickness ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the thickness of the ice sheet across its domain. ! class ( ice_sheet ), intent ( in ) :: this class ( scalar_field ), pointer :: thickness !! The ice thickness. end function sheet_thickness"},{"title":"sheet_velocity – ISOFT","tags":"","loc":"proc/sheet_velocity.html","text":"private function sheet_velocity(this) result(velocity) Returns the velocity of the ice sheet across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value class(vector_field),\n  allocatable The ice velocity. Contents Source Code sheet_velocity Source Code function sheet_velocity ( this ) result ( velocity ) !* Author: Christopher MacMackin !  Date: July 2016 ! ! Returns the velocity of the ice sheet across its domain. ! class ( ice_sheet ), intent ( in ) :: this class ( vector_field ), allocatable :: velocity !! The ice velocity. allocate ( velocity , source = this % velocity ) end function sheet_velocity"},{"title":"sheet_density – ISOFT","tags":"","loc":"proc/sheet_density.html","text":"private pure function sheet_density(this) result(density) Returns the density of the ice in the sheet, which is assumed to be\n uniform across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8) The ice density. Contents Source Code sheet_density Source Code pure function sheet_density ( this ) result ( density ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the density of the ice in the sheet, which is assumed to be ! uniform across its domain. ! class ( ice_sheet ), intent ( in ) :: this real ( r8 ) :: density !! The ice density. end function sheet_density"},{"title":"sheet_temperature – ISOFT","tags":"","loc":"proc/sheet_temperature.html","text":"private pure function sheet_temperature(this) result(temperature) Returns the density of the ice in the sheet, which is assumed to be\n uniform across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8) The ice density. Contents Source Code sheet_temperature Source Code pure function sheet_temperature ( this ) result ( temperature ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the density of the ice in the sheet, which is assumed to be ! uniform across its domain. ! class ( ice_sheet ), intent ( in ) :: this real ( r8 ) :: temperature !! The ice density. end function sheet_temperature"},{"title":"sheet_residual – ISOFT","tags":"","loc":"proc/sheet_residual.html","text":"private function sheet_residual(this, previous_states, melt_rate, basal_drag_parameter, water_density) result(residual) Returns the residual when the current state of the glacier is run\n through the system of equations describing it. The residual takes the\n form of a 1D array, with each element respresenting the residual for\n one of the equations in the system. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most recent\n state, but the fact that this is an array allows overriding\n methods to use older states for higher-order integration\n methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier. class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate the\n drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. Return Value real(kind=r8),\n  dimension(:),allocatable The residual of the system of equations describing the glacier. Contents Source Code sheet_residual Source Code function sheet_residual ( this , previous_states , melt_rate , basal_drag_parameter , & water_density ) result ( residual ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the residual when the current state of the glacier is run ! through the system of equations describing it. The residual takes the ! form of a 1D array, with each element respresenting the residual for ! one of the equations in the system. ! class ( ice_sheet ), intent ( in ) :: this class ( glacier ), dimension (:), intent ( in ) :: previous_states !! The states of the glacier in the previous time steps. The !! first element of the array should be the most recent. The !! default implementation will only make use of the most recent !! state, but the fact that this is an array allows overriding !! methods to use older states for higher-order integration !! methods. class ( scalar_field ), intent ( in ) :: melt_rate !! Thickness of the ice above the glacier. class ( scalar_field ), intent ( in ) :: basal_drag_parameter !! A paramter, e.g. coefficient of friction, needed to calculate the !! drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier. real ( r8 ), dimension (:), allocatable :: residual !! The residual of the system of equations describing the glacier. end function sheet_residual"},{"title":"sheet_precondition – ISOFT","tags":"","loc":"proc/sheet_precondition.html","text":"private function sheet_precondition(this, previous_states, melt_rate, basal_drag_parameter, water_density, delta_state) result(preconditioned) Provides a preconditioner for the nonlinear solver trying to\n bring the residual to zero. The Jacobian is approximated as a\n block matrix, where each block is a tridiagonal matrix using a\n finite difference method for differentiation. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier real(kind=r8), intent(in), dimension(:) :: delta_state The change to the state vector which is being preconditioned. Return Value real(kind=r8),\n  dimension(:),allocatable The result of applying the preconditioner to delta_state . Contents Source Code sheet_precondition Source Code function sheet_precondition ( this , previous_states , melt_rate , & basal_drag_parameter , water_density , & delta_state ) result ( preconditioned ) !* Author: Chris MacMackin !  Date: January 2016 ! ! Provides a preconditioner for the nonlinear solver trying to ! bring the residual to zero. The Jacobian is approximated as a ! block matrix, where each block is a tridiagonal matrix using a ! finite difference method for differentiation. ! class ( ice_sheet ), intent ( inout ) :: this class ( glacier ), dimension (:), intent ( in ) :: previous_states !! The states of the glacier in the previous time steps. The !! first element of the array should be the most recent. The !! default implementation will only make use of the most !! recent state, but the fact that this is an array allows !! overriding methods to use older states for higher-order !! integration methods. class ( scalar_field ), intent ( in ) :: melt_rate !! Thickness of the ice above the glacier class ( scalar_field ), intent ( in ) :: basal_drag_parameter !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. real ( r8 ), intent ( in ) :: water_density !! The density of the water below the glacier real ( r8 ), dimension (:), intent ( in ) :: delta_state !! The change to the state vector which is being preconditioned. real ( r8 ), dimension (:), allocatable :: preconditioned !! The result of applying the preconditioner to `delta_state`. end function sheet_precondition"},{"title":"sheet_data_size – ISOFT","tags":"","loc":"proc/sheet_data_size.html","text":"private pure function sheet_data_size(this) Returns the number of elements in the ice sheet's state vector.\n This is the size of the vector returned by residual and state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value integer The number of elements in the ice sheet's state vector. Contents Source Code sheet_data_size Source Code pure function sheet_data_size ( this ) !* Author: Christopher MacMackin !  Date: August 2016 ! ! Returns the number of elements in the ice sheet's state vector. ! This is the size of the vector returned by [[ice_sheet(type):residual]] ! and [[ice_sheet(type):state_vector]] and taken as an argument by ! [[ice_sheet(type):update]]. ! class ( ice_sheet ), intent ( in ) :: this integer :: sheet_data_size !! The number of elements in the ice sheet's state vector. end function sheet_data_size"},{"title":"sheet_state_vector – ISOFT","tags":"","loc":"proc/sheet_state_vector.html","text":"private pure function sheet_state_vector(this) result(state_vector) Returns the state vector for the current state of the ice sheet. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:),allocatable The state vector describing the ice sheet. Contents Source Code sheet_state_vector Source Code pure function sheet_state_vector ( this ) result ( state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Returns the state vector for the current state of the ice sheet. ! This takes the form of a 1D array. ! class ( ice_sheet ), intent ( in ) :: this real ( r8 ), dimension (:), allocatable :: state_vector !! The state vector describing the ice sheet. end function sheet_state_vector"},{"title":"sheet_time_step – ISOFT","tags":"","loc":"proc/sheet_time_step.html","text":"private function sheet_time_step(this) result(dt) Calculates the time step for integrating the ice sheet, using\n the CFL condition. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8) The time-step to use Contents Source Code sheet_time_step Source Code function sheet_time_step ( this ) result ( dt ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Calculates the time step for integrating the ice sheet, using ! the CFL condition. ! class ( ice_sheet ), intent ( in ) :: this real ( r8 ) :: dt !! The time-step to use end function sheet_time_step"},{"title":"sheet_update – ISOFT","tags":"","loc":"proc/sheet_update.html","text":"private subroutine sheet_update(this, state_vector) Updates the state of the ice sheet from its state vector. The state\n vector is a real array containing the value of each of the ice sheet's\n properties at each of the locations on the grid used in descretization. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n glacier. Contents Source Code sheet_update Source Code subroutine sheet_update ( this , state_vector ) !* Author: Christopher MacMackin !  Date: April 2016 ! ! Updates the state of the ice sheet from its state vector. The state ! vector is a real array containing the value of each of the ice sheet's ! properties at each of the locations on the grid used in descretization. ! class ( ice_sheet ), intent ( inout ) :: this real ( r8 ), dimension (:), intent ( in ) :: state_vector !! A real array containing the data describing the state of the !! glacier. end subroutine sheet_update"},{"title":"sheet_set_time – ISOFT","tags":"","loc":"proc/sheet_set_time.html","text":"private subroutine sheet_set_time(this, time) Sets the time information held by the ice sheet object. This is\n the time at which the ice sheet is in its current state. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the glacier is in the present state. Contents Source Code sheet_set_time Source Code subroutine sheet_set_time ( this , time ) !* Author: Christopher MacMackin !  Date: November 2016 ! ! Sets the time information held by the ice sheet object. This is ! the time at which the ice sheet is in its current state. ! class ( ice_sheet ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time !! The time at which the glacier is in the present state. this % time = time end subroutine sheet_set_time"},{"title":"sheet_solve_velocity – ISOFT","tags":"","loc":"proc/sheet_solve_velocity.html","text":"private subroutine sheet_solve_velocity(this, basal_drag, success) Computes the ice sheet velocity at the current time with the\n current ice thickness. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. logical, intent(out) :: success True if the integration is successful, false otherwise Contents Source Code sheet_solve_velocity Source Code subroutine sheet_solve_velocity ( this , basal_drag , success ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Computes the ice sheet velocity at the current time with the ! current ice thickness. ! class ( ice_sheet ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: basal_drag !! A paramter, e.g. coefficient of friction, needed to calculate !! the drag on basal surface of the glacier. logical , intent ( out ) :: success !! True if the integration is successful, false otherwise end subroutine sheet_solve_velocity"},{"title":"sheet_read_data – ISOFT","tags":"","loc":"proc/sheet_read_data.html","text":"private subroutine sheet_read_data(this, file_id, group_name, error) Reads the state of the ice shelf object from the specified group\n in an HDF5 file. This sets the thickness, the velocity, and\n parameter values. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Contents Source Code sheet_read_data Source Code subroutine sheet_read_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: April 2017 ! ! Reads the state of the ice shelf object from the specified group ! in an HDF5 file. This sets the thickness, the velocity, and ! parameter values. ! class ( ice_sheet ), intent ( inout ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice shelf's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. end subroutine sheet_read_data"},{"title":"sheet_write_data – ISOFT","tags":"","loc":"proc/sheet_write_data.html","text":"private subroutine sheet_write_data(this, file_id, group_name, error) Writes the state of the ice sheet object to an HDF file in the\n specified group. This will consist of a thickness and a velocity\n dataset. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice sheet's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. Contents Source Code sheet_write_data Source Code subroutine sheet_write_data ( this , file_id , group_name , error ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Writes the state of the ice sheet object to an HDF file in the ! specified group. This will consist of a thickness and a velocity ! dataset. ! class ( ice_sheet ), intent ( in ) :: this integer ( hid_t ), intent ( in ) :: file_id !! The identifier for the HDF5 file/group in which this data is !! meant to be written. character ( len =* ), intent ( in ) :: group_name !! The name to give the group in the HDF5 file storing the !! ice sheet's data. integer , intent ( out ) :: error !! Flag indicating whether routine ran without error. If no !! error occurs then has value 0. end subroutine sheet_write_data"},{"title":"sheet_assign – ISOFT","tags":"","loc":"proc/sheet_assign.html","text":"private subroutine sheet_assign(this, rhs) Copies the data from one ice sheet into another. This is only\n needed due to a bug in gfortran which means that the intrinsic\n assignment for glacier types is not using the appropriate\n defined assignment for the field components. It does not assign the Jacobian object as it would take up quite\n a bit of extra space and it is unlikely that it would ever be\n needed without first having to be recalculated. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(out) :: this class( glacier ), intent(in) :: rhs The ice sheet to be assigned to this one. Contents Source Code sheet_assign Source Code subroutine sheet_assign ( this , rhs ) !* Author: Chris MacMackin !  Date: February 2017 ! ! Copies the data from one ice sheet into another. This is only ! needed due to a bug in gfortran which means that the intrinsic ! assignment for glacier types is not using the appropriate ! defined assignment for the field components. ! ! It does not assign the Jacobian object as it would take up quite ! a bit of extra space and it is unlikely that it would ever be ! needed without first having to be recalculated. ! class ( ice_sheet ), intent ( out ) :: this class ( glacier ), intent ( in ) :: rhs !! The ice sheet to be assigned to this one. select type ( rhs ) class is ( ice_sheet ) this % thickness = rhs % thickness this % velocity = rhs % velocity this % lambda = rhs % lambda this % chi = rhs % chi allocate ( this % viscosity_law , source = rhs % viscosity_law ) this % time = rhs % time class default call logger % fatal ( 'ice_sheet%assign' , 'Type other than `ice_sheet` ' // & 'requested to be assigned.' ) error stop end select #ifdef DEBUG call logger % debug ( 'ice_sheet%assign' , 'Copied ice sheet data.' ) #endif end subroutine sheet_assign"},{"title":"ice_sheet – ISOFT","tags":"","loc":"interface/ice_sheet.html","text":"public interface ice_sheet Calls interface~~ice_sheet~~CallsGraph interface~ice_sheet ice_sheet proc~constructor~10 constructor interface~ice_sheet->proc~constructor~10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private function constructor (domain, resolution, thickness, velocity, viscosity_law, lambda, chi) result(this) Author Christopher MacMackin Date April 2016 Creates a new ice_sheet object with initial conditions provided\n by the arguments. At present only a 1D model is supported. If\n information is provided for higher dimensions then it will be ignored. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the ice sheet. The first index represents the dimension for which\n the boundaries apply. If the second index is 1 then it corresponds\n to the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( thickness_func ) :: thickness A function which calculates the initial value of the thickness of \n the ice sheet at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the ice at a given location in an ice sheet. class( abstract_viscosity ), intent(in), optional :: viscosity_law An object which calculates the viscosity of the ice. real(kind=r8), intent(in), optional :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real(kind=r8), intent(in), optional :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Return Value type( ice_sheet ) An ice sheet object with its domain and initial conditions set\n according to the arguments of the constructor function."},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~11.html","text":"private function constructor(template, boundary_locs, boundary_types) result(this) Build a tridiagonal matrix block for finite differences. See the\n end of the documentation of the fin_diff_block type\n for a description of how boundary conditions are treated. Arguments Type Intent Optional Attributes Name class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. integer, intent(in), optional dimension(:) :: boundary_locs The locations in the raw representation of rhs for which\n boundary conditions are specified. Defaults to there being\n none. integer, intent(in), optional dimension(:) :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. Defaults to Dirichlet. The\n order in which they are stored must match that of boundary_locs . Return Value type( fin_diff_block ) A new finite difference operator Called by proc~~constructor~11~~CalledByGraph proc~constructor~11 constructor interface~fin_diff_block fin_diff_block interface~fin_diff_block->proc~constructor~11 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code function constructor ( template , boundary_locs , boundary_types ) result ( this ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Build a tridiagonal matrix block for finite differences. See the ! end of the documentation of the [[fin_diff_block(type)]] type ! for a description of how boundary conditions are treated. ! class ( abstract_field ), intent ( in ) :: template !! A scalar field with the same grid as any fields passed as !! arguments to the [[fin_diff_block(type):solve_for]] method. integer , dimension (:), optional , intent ( in ) :: boundary_locs !! The locations in the raw representation of `rhs` for which !! boundary conditions are specified. Defaults to there being !! none. integer , dimension (:), optional , intent ( in ) :: boundary_types !! Integers specifying the type of boundary condition. The type !! of boundary condition corresponding to a given integer is !! specified in [[boundary_types_mod]]. Only Dirichlet and !! Neumann conditions are supported. Defaults to Dirichlet. The !! order in which they are stored must match that of !! `boundary_locs`. type ( fin_diff_block ) :: this !! A new finite difference operator integer :: i , n , pos logical :: use_cached real ( r8 ), dimension (:), allocatable , save :: cached_dx_c real ( r8 ), save :: cached_upper_bound , & cached_lower_bound class ( vector_field ), pointer :: grid class ( abstract_field ), allocatable , save :: cached_field_type real ( r8 ), dimension (:,:), allocatable :: domain if ( present ( boundary_locs )) then this % boundary_locs = boundary_locs else allocate ( this % boundary_locs ( 0 )) end if if ( present ( boundary_types )) then this % boundary_types = boundary_types else allocate ( this % boundary_types ( size ( this % boundary_locs ))) this % boundary_types = dirichlet end if n = template % raw_size () domain = template % domain () ! Try to use cached copy of inverse grid spacing, if available and suitable if ( allocated ( cached_field_type )) then use_cached = same_type_as ( template , cached_field_type ) . and . & abs ( domain ( 1 , 1 ) - cached_lower_bound ) < 1 e - 10 . and . & abs ( domain ( 1 , 2 ) - cached_upper_bound ) < 1 e - 10 . and . & n == size ( cached_dx_c ) else use_cached = . false . end if ! Construct an array containing the distance between grid ! points, if necessary if (. not . use_cached ) then if ( allocated ( cached_field_type )) then deallocate ( cached_field_type ) deallocate ( cached_dx_c ) end if #ifdef DEBUG call logger % debug ( 'fin_diff_block' , 'Calculating and caching ' // & 'grid spacings.' ) #endif cached_lower_bound = domain ( 1 , 1 ) cached_upper_bound = domain ( 1 , 2 ) allocate ( cached_field_type , mold = template ) allocate ( cached_dx_c ( n )) call template % allocate_vector_field ( grid ) grid = template % grid_spacing () ! Use this array to temporarily hold the grid spacings cached_dx_c = grid % raw () cached_dx_c ( 2 : n - 1 ) = 0.5_r8 / cached_dx_c ( 2 : n - 1 ) cached_dx_c ( 1 ) = 1._r8 / cached_dx_c ( 1 ) cached_dx_c ( n ) = 1._r8 / cached_dx_c ( n ) end if ! Create tridiagonal matrix allocate ( this % diagonal ( n )) this % diagonal = 0._r8 this % diagonal ( 1 ) = - cached_dx_c ( 1 ) this % diagonal ( n ) = cached_dx_c ( n ) this % super_diagonal = cached_dx_c ( 1 : n - 1 ) this % sub_diagonal = - cached_dx_c ( 2 : n ) ! Apply boundary conditions this % diagonal ( 1 ) = this % diagonal ( 1 ) + 1 e - 7 do i = 1 , size ( this % boundary_locs ) pos = this % boundary_locs ( i ) select case ( this % boundary_types ( i )) case ( dirichlet ) this % diagonal ( pos ) = 1._r8 if ( pos < n ) this % super_diagonal ( pos ) = 0._r8 if ( pos > 1 ) this % sub_diagonal ( pos - 1 ) = 1.e-7_r8 case ( neumann ) if ( pos == n ) then this % diagonal ( n ) = cached_dx_c ( n ) this % sub_diagonal ( n - 1 ) = - cached_dx_c ( n ) else if ( pos == 1 ) then this % diagonal ( 1 ) = - cached_dx_c ( 1 ) this % super_diagonal ( 1 ) = cached_dx_c ( 1 ) else this % super_diagonal ( pos ) = cached_dx_c ( pos ) this % sub_diagonal ( pos - 1 ) = cached_dx_c ( pos ) this % diagonal ( pos ) = 0._r8 end if case ( free_boundary ) continue case default call logger % fatal ( 'fin_diff_block' , 'Boundary condition of ' // & 'type other than Dirichlet or Neumann encountered.' ) error stop end select end do do i = 1 , size ( this % boundary_locs ) pos = this % boundary_locs ( i ) select case ( this % boundary_types ( i )) case ( dirichlet ) this % diagonal ( pos ) = 1._r8 if ( pos < n ) this % super_diagonal ( pos ) = 0._r8 if ( pos > 1 ) this % sub_diagonal ( pos - 1 ) = 1.e-7_r8 case ( neumann ) if ( pos == n ) then this % diagonal ( n ) = cached_dx_c ( n ) this % sub_diagonal ( n - 1 ) = - cached_dx_c ( n ) else if ( pos == 1 ) then this % diagonal ( 1 ) = - cached_dx_c ( 1 ) this % super_diagonal ( 1 ) = cached_dx_c ( 1 ) else this % super_diagonal ( pos ) = cached_dx_c ( pos ) this % sub_diagonal ( pos - 1 ) = cached_dx_c ( pos ) this % diagonal ( pos ) = 0._r8 end if case ( free_boundary ) continue case default call logger % fatal ( 'fin_diff_block' , 'Boundary condition of ' // & 'type other than Dirichlet or Neumann encountered.' ) error stop end select end do !this%magnitude = dnrm2(n-1, this%super_diagonal, 1) #ifdef DEBUG call logger % debug ( 'fin_diff_block' , 'Instantiated a finite difference ' // & 'block object.' ) #endif end function constructor"},{"title":"fin_diff_block_solve_scalar – ISOFT","tags":"","loc":"proc/fin_diff_block_solve_scalar.html","text":"private function fin_diff_block_solve_scalar(this, rhs, offset) result(solution) Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a scalar field). Optionally, the differential\n operator can be augmented by adding an offset, i.e. a scalar\n field which is added to the operator. Warning Currently this is only implemented for a 1-D field. Arguments Type Intent Optional Attributes Name class( fin_diff_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. class(scalar_field), intent(in), optional :: offset An offset to add to the differential operator Return Value class(scalar_field),\n  pointer Calls proc~~fin_diff_block_solve_scalar~~CallsGraph proc~fin_diff_block_solve_scalar fin_diff_block_solve_scalar la_gtsvx la_gtsvx proc~fin_diff_block_solve_scalar->la_gtsvx str str proc~fin_diff_block_solve_scalar->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fin_diff_block_solve_scalar Source Code function fin_diff_block_solve_scalar ( this , rhs , offset ) result ( solution ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Solves the linear(ised) system represented by this finite ! difference block, for a given right hand side state vector ! (represented by a scalar field). Optionally, the differential ! operator can be augmented by adding an offset, i.e. a scalar ! field which is added to the operator. ! ! @Warning Currently this is only implemented for a 1-D field. ! class ( fin_diff_block ), intent ( inout ) :: this class ( scalar_field ), intent ( in ) :: rhs !! The right hand side of the linear(ised) system. class ( scalar_field ), optional , intent ( in ) :: offset !! An offset to add to the differential operator class ( scalar_field ), pointer :: solution real ( r8 ), dimension (:), allocatable :: sol_vector , diag_vector integer :: flag , n , i , j real ( r8 ) :: forward_err , & backward_err , & condition_num character ( len = 1 ) :: factor character ( len = :), allocatable :: msg call rhs % guard_temp () if ( present ( offset )) call offset % guard_temp () allocate ( sol_vector ( rhs % raw_size ())) ! Allocate the arrays used to hold the factorisation of the ! tridiagonal matrix n = size ( this % diagonal ) if (. not . allocated ( this % pivots )) then allocate ( this % l_multipliers ( n - 1 )) allocate ( this % u_diagonal ( n )) allocate ( this % u_superdiagonal1 ( n - 1 )) allocate ( this % u_superdiagonal2 ( n - 2 )) allocate ( this % pivots ( n )) factor = 'N' else if (. not . present ( offset ) . and . . not . this % had_offset ) then factor = 'F' else factor = 'N' end if end if if ( present ( offset )) then #ifdef DEBUG if ( offset % elements () /= n ) then call logger % fatal ( 'fin_diff_block%solve_for' , 'Offset field has ' // & 'different resolution than finite difference block.' ) end if #endif allocate ( diag_vector ( n )) where ( this % diagonal == 0._r8 ) diag_vector = this % diagonal + offset % raw () elsewhere diag_vector = this % diagonal end where if (. not . any ( 1 == this % boundary_locs )) then diag_vector ( 1 ) = diag_vector ( 1 ) + offset % get_element ( 1 ) end if if (. not . any ( n == this % boundary_locs )) then diag_vector ( n ) = diag_vector ( n ) + offset % get_element ( n ) end if do i = 1 , size ( this % boundary_locs ) j = this % boundary_locs ( i ) if (( j == 1 . or . j == n ) . and . this % boundary_types ( i ) == free_boundary ) then diag_vector ( j ) = diag_vector ( j ) + offset % get_element ( j ) end if end do call la_gtsvx ( this % sub_diagonal , diag_vector , this % super_diagonal , & rhs % raw (), sol_vector , this % l_multipliers , & this % u_diagonal , this % u_superdiagonal1 , & this % u_superdiagonal2 , this % pivots , factor , 'N' , & forward_err , backward_err , condition_num , flag ) else call la_gtsvx ( this % sub_diagonal , this % diagonal , this % super_diagonal , & rhs % raw (), sol_vector , this % l_multipliers , this % u_diagonal , & this % u_superdiagonal1 , this % u_superdiagonal2 , this % pivots , & factor , 'N' , forward_err , backward_err , condition_num , & flag ) end if if ( flag /= 0 ) then msg = 'Tridiagonal matrix solver returned with flag ' // str ( flag ) call logger % error ( 'fin_diff_block%solve_for' , msg ) else this % had_offset = present ( offset ) #ifdef DEBUG msg = 'Tridiagonal matrix solver retunred with estimated condition ' // & 'number ' // str ( condition_num ) call logger % debug ( 'fin_diff_block%solve_for' , msg ) #endif end if call rhs % allocate_scalar_field ( solution ) call solution % unset_temp () call solution % assign_meta_data ( rhs ) call solution % set_from_raw ( sol_vector ) if ( present ( offset )) call offset % clean_temp () call rhs % clean_temp (); call solution % set_temp () end function fin_diff_block_solve_scalar"},{"title":"fin_diff_block_solve_vector – ISOFT","tags":"","loc":"proc/fin_diff_block_solve_vector.html","text":"private function fin_diff_block_solve_vector(this, rhs, offset) result(solution) Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a vector field). Optionally, the differential\n operator can be augmented by adding an offset, i.e. a vector\n field which is added to the operator. Warning Currently this is only implemented for a 1-D field. Bug For some reason, calls to the vector_dimensions() method\n produce a segfault when rhs is class(vector_field) . Everything works fine if it is class(cheb1d_vector_field) , so this is used as a workaround. Arguments Type Intent Optional Attributes Name class( fin_diff_block ), intent(inout) :: this class(cheb1d_vector_field), intent(in) :: rhs The right hand side of the linear(ised) system. class(cheb1d_vector_field), intent(in), optional :: offset An offset to add to the differential operator Return Value class(vector_field),\n  pointer Calls proc~~fin_diff_block_solve_vector~~CallsGraph proc~fin_diff_block_solve_vector fin_diff_block_solve_vector str str proc~fin_diff_block_solve_vector->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fin_diff_block_solve_vector Source Code function fin_diff_block_solve_vector ( this , rhs , offset ) result ( solution ) !* Author: Chris MacMackin !  Date: December 2016 ! ! Solves the linear(ised) system represented by this finite ! difference block, for a given right hand side state vector ! (represented by a vector field). Optionally, the differential ! operator can be augmented by adding an offset, i.e. a vector ! field which is added to the operator. ! ! @Warning Currently this is only implemented for a 1-D field. ! ! @Bug For some reason, calls to the `vector_dimensions()` method ! produce a segfault when `rhs` is ! `class(vector_field)`. Everything works fine if it is ! `class(cheb1d_vector_field)`, so this is used as a workaround. ! class ( fin_diff_block ), intent ( inout ) :: this class ( cheb1d_vector_field ), intent ( in ) :: rhs !! The right hand side of the linear(ised) system. class ( cheb1d_vector_field ), optional , intent ( in ) :: offset !! An offset to add to the differential operator class ( vector_field ), pointer :: solution real ( r8 ), dimension (:), allocatable :: sol_vector , diag_vector integer :: flag , n , i , j , k class ( scalar_field ), pointer :: component , ocomponent integer :: m real ( r8 ) :: forward_err , & backward_err , & condition_num character ( len = 1 ) :: factor character ( len = :), allocatable :: msg call rhs % guard_temp () if ( present ( offset )) call offset % guard_temp () allocate ( sol_vector ( rhs % raw_size ())) n = size ( this % diagonal ) ! Allocate the arrays used to hold the factorisation of the ! tridiagonal matrix if (. not . allocated ( this % pivots )) then allocate ( this % l_multipliers ( n - 1 )) allocate ( this % u_diagonal ( n )) allocate ( this % u_superdiagonal1 ( n - 1 )) allocate ( this % u_superdiagonal2 ( n - 2 )) allocate ( this % pivots ( n )) factor = 'N' else if (. not . present ( offset ) . and . . not . this % had_offset ) then factor = 'F' else factor = 'N' end if end if call rhs % allocate_scalar_field ( component ) call component % guard_temp () if ( present ( offset )) then #ifdef DEBUG if ( offset % elements () /= n ) then call logger % fatal ( 'fin_diff_block%solve_for' , 'Offset field has ' // & 'different resolution than finite difference block.' ) error stop else if ( offset % vector_dimensions () < rhs % vector_dimensions ()) then call logger % fatal ( 'fin_diff_block%solve_for' , 'Offset field has ' // & 'different number of vector components than ' // & 'field being solved for.' ) error stop end if #endif call offset % allocate_scalar_field ( ocomponent ) call ocomponent % guard_temp () end if do i = 1 , rhs % vector_dimensions () if ( i > 1 . and . . not . present ( offset )) factor = 'F' component = rhs % component ( i ) if ( present ( offset )) then ocomponent = offset % component ( i ) if ( i == 1 ) allocate ( diag_vector ( n )) where ( this % diagonal == 0._r8 ) diag_vector = this % diagonal + ocomponent % raw () elsewhere diag_vector = this % diagonal end where if (. not . any ( 1 == this % boundary_locs )) then diag_vector ( 1 ) = diag_vector ( 1 ) + ocomponent % get_element ( 1 ) end if if (. not . any ( n == this % boundary_locs )) then diag_vector ( n ) = diag_vector ( n ) + ocomponent % get_element ( n ) end if do j = 1 , size ( this % boundary_locs ) k = this % boundary_locs ( j ) if (( k == 1 . or . k == n ) . and . this % boundary_types ( j ) == free_boundary ) then diag_vector ( k ) = diag_vector ( k ) + ocomponent % get_element ( k ) end if end do call la_gtsvx ( this % sub_diagonal , diag_vector , this % super_diagonal , & component % raw (), sol_vector (( i - 1 ) * n + 1 : i * n ), & this % l_multipliers , this % u_diagonal , & this % u_superdiagonal1 , this % u_superdiagonal2 , & this % pivots , factor , 'N' , forward_err , backward_err , & condition_num , flag ) else call la_gtsvx ( this % sub_diagonal , this % diagonal , this % super_diagonal , & component % raw (), sol_vector (( i - 1 ) * n + 1 : i * n ), & this % l_multipliers , this % u_diagonal , & this % u_superdiagonal1 , this % u_superdiagonal2 , & this % pivots , factor , 'N' , forward_err , backward_err , & condition_num , flag ) end if end do call component % clean_temp () if ( present ( offset )) call ocomponent % clean_temp () if ( flag /= 0 ) then msg = 'Tridiagonal matrix solver returned with flag ' // str ( flag ) call logger % error ( 'fin_diff_block%solve_for' , msg ) else this % had_offset = present ( offset ) #ifdef DEBUG msg = 'Tridiagonal matrix solver returned with estimated condition ' // & 'number ' // str ( condition_num ) call logger % debug ( 'fin_diff_block%solve_for' , msg ) #endif end if call rhs % allocate_vector_field ( solution ) call solution % unset_temp () call solution % assign_meta_data ( rhs ) call solution % set_from_raw ( sol_vector ) if ( present ( offset )) call offset % clean_temp () call rhs % clean_temp (); call solution % set_temp () end function fin_diff_block_solve_vector"},{"title":"fin_diff_block – ISOFT","tags":"","loc":"interface/fin_diff_block.html","text":"public interface fin_diff_block Calls interface~~fin_diff_block~~CallsGraph interface~fin_diff_block fin_diff_block proc~constructor~11 constructor interface~fin_diff_block->proc~constructor~11 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private function constructor (template, boundary_locs, boundary_types) result(this) Author Chris MacMackin Date December 2016 Build a tridiagonal matrix block for finite differences. See the\n end of the documentation of the fin_diff_block type\n for a description of how boundary conditions are treated. Arguments Type Intent Optional Attributes Name class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. integer, intent(in), optional dimension(:) :: boundary_locs The locations in the raw representation of rhs for which\n boundary conditions are specified. Defaults to there being\n none. integer, intent(in), optional dimension(:) :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. Defaults to Dirichlet. The\n order in which they are stored must match that of boundary_locs . Return Value type( fin_diff_block ) A new finite difference operator"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~12.html","text":"private function constructor(temperature, salinity) result(this) Produces an ambient object which will return the specified\n salinity and temeprature values. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: temperature The temperature of the ambient ocean. Default is 0. real(kind=r8), intent(in), optional :: salinity The salinity of the ambient ocean. Default is 0. Return Value type( uniform_ambient_conditions ) Calls proc~~constructor~12~~CallsGraph proc~constructor~12 constructor uniform_scalar_field uniform_scalar_field proc~constructor~12->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~constructor~12~~CalledByGraph proc~constructor~12 constructor interface~uniform_ambient_conditions uniform_ambient_conditions interface~uniform_ambient_conditions->proc~constructor~12 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code function constructor ( temperature , salinity ) result ( this ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Produces an ambient object which will return the specified ! salinity and temeprature values. ! real ( r8 ), intent ( in ), optional :: temperature !! The temperature of the ambient ocean. Default is 0. real ( r8 ), intent ( in ), optional :: salinity !! The salinity of the ambient ocean. Default is 0. type ( uniform_ambient_conditions ) :: this if ( present ( temperature )) then this % temperature = uniform_scalar_field ( temperature ) else this % temperature = uniform_scalar_field ( 0.0_r8 ) end if if ( present ( salinity )) then this % salinity = uniform_scalar_field ( salinity ) else this % salinity = uniform_scalar_field ( 0.0_r8 ) end if end function constructor"},{"title":"uniform_temperature – ISOFT","tags":"","loc":"proc/uniform_temperature.html","text":"private function uniform_temperature(this, depth, t) result(property) Returns the ambient ocean temperature. Arguments Type Intent Optional Attributes Name class( uniform_ambient_conditions ), intent(in) :: this class(scalar_field), intent(in) :: depth A field containing the depths at which the ambient temperature\n is to be calculated. real(kind=r8), intent(in) :: t The time at which the ambient conditions are to be calculated. Return Value class(scalar_field),\n  pointer A field containing the ambient temperature at the depth specified\n for each location. Contents Source Code uniform_temperature Source Code function uniform_temperature ( this , depth , t ) result ( property ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Returns the ambient ocean temperature. ! class ( uniform_ambient_conditions ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: depth !! A field containing the depths at which the ambient temperature !! is to be calculated. real ( r8 ), intent ( in ) :: t !! The time at which the ambient conditions are to be calculated. class ( scalar_field ), pointer :: property !! A field containing the ambient temperature at the depth specified !! for each location. call this % temperature % allocate_scalar_field ( property ) property = this % temperature call property % set_temp () ! Shouldn't need to call this, but for ! some rason being set as non-temporary ! when assignment subroutine returns. end function uniform_temperature"},{"title":"uniform_salinity – ISOFT","tags":"","loc":"proc/uniform_salinity.html","text":"private function uniform_salinity(this, depth, t) result(property) Returns the ambient ocean salinity. Arguments Type Intent Optional Attributes Name class( uniform_ambient_conditions ), intent(in) :: this class(scalar_field), intent(in) :: depth A field containing the depths at which the ambient salinity\n is to be calculated. real(kind=r8), intent(in) :: t The time at which the ambient conditions are to be calculated. Return Value class(scalar_field),\n  pointer A field containing the ambient salinity at the depth specified\n for each location. Contents Source Code uniform_salinity Source Code function uniform_salinity ( this , depth , t ) result ( property ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Returns the ambient ocean salinity. ! class ( uniform_ambient_conditions ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: depth !! A field containing the depths at which the ambient salinity !! is to be calculated. real ( r8 ), intent ( in ) :: t !! The time at which the ambient conditions are to be calculated. class ( scalar_field ), pointer :: property !! A field containing the ambient salinity at the depth specified !! for each location. call this % salinity % allocate_scalar_field ( property ) property = this % salinity call property % set_temp () ! Shouldn't need to call this, but for ! some rason being set as non-temporary ! when assignment subroutine returns. end function uniform_salinity"},{"title":"uniform_ambient_conditions – ISOFT","tags":"","loc":"interface/uniform_ambient_conditions.html","text":"public interface uniform_ambient_conditions Calls interface~~uniform_ambient_conditions~~CallsGraph interface~uniform_ambient_conditions uniform_ambient_conditions proc~constructor~12 constructor interface~uniform_ambient_conditions->proc~constructor~12 uniform_scalar_field uniform_scalar_field proc~constructor~12->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private function constructor (temperature, salinity) result(this) Author Chris MacMackin Date November 2016 Produces an ambient object which will return the specified\n salinity and temeprature values. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: temperature The temperature of the ambient ocean. Default is 0. real(kind=r8), intent(in), optional :: salinity The salinity of the ambient ocean. Default is 0. Return Value type( uniform_ambient_conditions )"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~13.html","text":"private pure function constructor(thickness, velocity, temperature, salinity) result(this) Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: thickness The water thickness at the inflowing plume boundary real(kind=r8), intent(in), dimension(2) :: velocity The longitudinal water velocity at the inflowing plume boundary real(kind=r8), intent(in) :: temperature The water temperature at the inflowing plume boundary real(kind=r8), intent(in) :: salinity The water salinity at the inflowing plume boundary Return Value type( simple_plume_boundary ) Called by proc~~constructor~13~~CalledByGraph proc~constructor~13 constructor interface~simple_plume_boundary simple_plume_boundary interface~simple_plume_boundary->proc~constructor~13 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( thickness , velocity , temperature , salinity ) & result ( this ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Constructs a boundary condition object for an ice shelf based on ! the conditions used in Dallaston et al. (2015). ! real ( r8 ), intent ( in ) :: thickness !! The water thickness at the inflowing plume boundary real ( r8 ), dimension ( 2 ), intent ( in ) :: velocity !! The longitudinal water velocity at the inflowing plume boundary real ( r8 ), intent ( in ) :: temperature !! The water temperature at the inflowing plume boundary real ( r8 ), intent ( in ) :: salinity !! The water salinity at the inflowing plume boundary type ( simple_plume_boundary ) :: this this % thickness = thickness this % velocity = velocity this % temperature = temperature this % salinity = salinity end function constructor"},{"title":"simple_thickness_bound – ISOFT","tags":"","loc":"proc/simple_thickness_bound.html","text":"private function simple_thickness_bound(this, location) result(bound) Returns a field containing the thickness boundary values for the\n specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Calls proc~~simple_thickness_bound~~CallsGraph proc~simple_thickness_bound simple_thickness_bound uniform_scalar_field uniform_scalar_field proc~simple_thickness_bound->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code simple_thickness_bound Source Code function simple_thickness_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the thickness boundary values for the ! specified boundary location. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % thickness ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function simple_thickness_bound"},{"title":"simple_velocity_bound – ISOFT","tags":"","loc":"proc/simple_velocity_bound.html","text":"private function simple_velocity_bound(this, location) result(bound) Returns a field containing the velocity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer Calls proc~~simple_velocity_bound~~CallsGraph proc~simple_velocity_bound simple_velocity_bound uniform_vector_field uniform_vector_field proc~simple_velocity_bound->uniform_vector_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code simple_velocity_bound Source Code function simple_velocity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the velocity boundary values for ! the specified boundary location. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( vector_field ), pointer :: bound call dummy % allocate_vector_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_vector_field ( this % velocity ) case ( 1 ) bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) case default bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function simple_velocity_bound"},{"title":"simple_temperature_bound – ISOFT","tags":"","loc":"proc/simple_temperature_bound.html","text":"private function simple_temperature_bound(this, location) result(bound) Returns a field containing the temperature boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Calls proc~~simple_temperature_bound~~CallsGraph proc~simple_temperature_bound simple_temperature_bound uniform_scalar_field uniform_scalar_field proc~simple_temperature_bound->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code simple_temperature_bound Source Code function simple_temperature_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the temperature boundary values for ! the specified boundary location. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % temperature ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function simple_temperature_bound"},{"title":"simple_salinity_bound – ISOFT","tags":"","loc":"proc/simple_salinity_bound.html","text":"private function simple_salinity_bound(this, location) result(bound) Returns a field containing the salinity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Calls proc~~simple_salinity_bound~~CallsGraph proc~simple_salinity_bound simple_salinity_bound uniform_scalar_field uniform_scalar_field proc~simple_salinity_bound->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code simple_salinity_bound Source Code function simple_salinity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the salinity boundary values for ! the specified boundary location. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % salinity ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function simple_salinity_bound"},{"title":"simple_thickness_info – ISOFT","tags":"","loc":"proc/simple_thickness_info.html","text":"private subroutine simple_thickness_info(this, location, bound_type, bound_depth) Indicates that the lower boundary is Dirichlet and the upper\n boundary is free. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. Contents Source Code simple_thickness_info Source Code subroutine simple_thickness_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is free. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine simple_thickness_info"},{"title":"simple_info – ISOFT","tags":"","loc":"proc/simple_info.html","text":"private subroutine simple_info(this, location, bound_type, bound_depth) Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. Contents Source Code simple_info Source Code subroutine simple_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is Neumann. ! class ( simple_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case ( 1 ) bound_type = neumann bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine simple_info"},{"title":"simple_plume_boundary – ISOFT","tags":"","loc":"interface/simple_plume_boundary.html","text":"public interface simple_plume_boundary Calls interface~~simple_plume_boundary~~CallsGraph interface~simple_plume_boundary simple_plume_boundary proc~constructor~13 constructor interface~simple_plume_boundary->proc~constructor~13 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (thickness, velocity, temperature, salinity) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: thickness The water thickness at the inflowing plume boundary real(kind=r8), intent(in), dimension(2) :: velocity The longitudinal water velocity at the inflowing plume boundary real(kind=r8), intent(in) :: temperature The water temperature at the inflowing plume boundary real(kind=r8), intent(in) :: salinity The water salinity at the inflowing plume boundary Return Value type( simple_plume_boundary )"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~14.html","text":"private pure function constructor(thickness, frequency, amplitude, mean, temperature) result(this) Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with\n seasonal variations in subglacial discharge. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: thickness The plume thickness at the inflowing plume boundary, defaults\n to 0.1 real(kind=r8), intent(in), optional :: frequency The angular frequency of the oscillations in discharge,\n defaults to 1.0 real(kind=r8), intent(in), optional :: amplitude The amplitude of the oscillations in discharge, defaults to\n 1.0 real(kind=r8), intent(in), optional :: mean The time-average of the discharge, about which it oscillates,\n defaulting to 1.0 real(kind=r8), intent(in), optional :: temperature The water temperature at the inflowing plume boundary,\n defaults to 0.0 Return Value type( dallaston2015_seasonal_boundary ) Called by proc~~constructor~14~~CalledByGraph proc~constructor~14 constructor interface~dallaston2015_seasonal_boundary dallaston2015_seasonal_boundary interface~dallaston2015_seasonal_boundary->proc~constructor~14 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( thickness , frequency , amplitude , mean , & temperature ) result ( this ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Constructs a boundary condition object for an ice shelf based on ! the conditions used in Dallaston et al. (2015), but with ! seasonal variations in subglacial discharge. ! real ( r8 ), intent ( in ), optional :: thickness !! The plume thickness at the inflowing plume boundary, defaults !! to 0.1 real ( r8 ), intent ( in ), optional :: frequency !! The angular frequency of the oscillations in discharge, !! defaults to 1.0 real ( r8 ), intent ( in ), optional :: amplitude !! The amplitude of the oscillations in discharge, defaults to !! 1.0 real ( r8 ), intent ( in ), optional :: mean !! The time-average of the discharge, about which it oscillates, !! defaulting to 1.0 real ( r8 ), intent ( in ), optional :: temperature !! The water temperature at the inflowing plume boundary, !! defaults to 0.0 type ( dallaston2015_seasonal_boundary ) :: this if ( present ( thickness )) this % thickness = thickness if ( present ( frequency )) this % frequency = frequency if ( present ( amplitude )) this % amplitude = amplitude if ( present ( mean )) this % mean = mean if ( present ( temperature )) this % temperature = temperature end function constructor"},{"title":"seasonal_thickness_bound – ISOFT","tags":"","loc":"proc/seasonal_thickness_bound.html","text":"private function seasonal_thickness_bound(this, location) result(bound) Returns a field containing the thickness boundary values for the\n specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Calls proc~~seasonal_thickness_bound~~CallsGraph proc~seasonal_thickness_bound seasonal_thickness_bound uniform_scalar_field uniform_scalar_field proc~seasonal_thickness_bound->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code seasonal_thickness_bound Source Code function seasonal_thickness_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the thickness boundary values for the ! specified boundary location. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % thickness ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function seasonal_thickness_bound"},{"title":"seasonal_velocity_bound – ISOFT","tags":"","loc":"proc/seasonal_velocity_bound.html","text":"private function seasonal_velocity_bound(this, location) result(bound) Returns a field containing the velocity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer Calls proc~~seasonal_velocity_bound~~CallsGraph proc~seasonal_velocity_bound seasonal_velocity_bound uniform_vector_field uniform_vector_field proc~seasonal_velocity_bound->uniform_vector_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code seasonal_velocity_bound Source Code function seasonal_velocity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the velocity boundary values for ! the specified boundary location. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( vector_field ), pointer :: bound call dummy % allocate_vector_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_vector_field ([ this % discharge ** ( 1._r8 / 3._r8 ), 0._r8 ]) case ( 1 ) bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) case default bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function seasonal_velocity_bound"},{"title":"seasonal_temperature_bound – ISOFT","tags":"","loc":"proc/seasonal_temperature_bound.html","text":"private function seasonal_temperature_bound(this, location) result(bound) Returns a field containing the temperature boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Calls proc~~seasonal_temperature_bound~~CallsGraph proc~seasonal_temperature_bound seasonal_temperature_bound uniform_scalar_field uniform_scalar_field proc~seasonal_temperature_bound->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code seasonal_temperature_bound Source Code function seasonal_temperature_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the temperature boundary values for ! the specified boundary location. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % temperature ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function seasonal_temperature_bound"},{"title":"seasonal_salinity_bound – ISOFT","tags":"","loc":"proc/seasonal_salinity_bound.html","text":"private function seasonal_salinity_bound(this, location) result(bound) Returns a field containing the salinity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Calls proc~~seasonal_salinity_bound~~CallsGraph proc~seasonal_salinity_bound seasonal_salinity_bound uniform_scalar_field uniform_scalar_field proc~seasonal_salinity_bound->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code seasonal_salinity_bound Source Code function seasonal_salinity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Returns a field containing the salinity boundary values for ! the specified boundary location. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % discharge ** ( 2._r8 / 3._r8 ) / this % thickness ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function seasonal_salinity_bound"},{"title":"seasonal_thickness_info – ISOFT","tags":"","loc":"proc/seasonal_thickness_info.html","text":"private subroutine seasonal_thickness_info(this, location, bound_type, bound_depth) Indicates that the lower boundary is Dirichlet and the upper\n boundary is free. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. Contents Source Code seasonal_thickness_info Source Code subroutine seasonal_thickness_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is free. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine seasonal_thickness_info"},{"title":"seasonal_info – ISOFT","tags":"","loc":"proc/seasonal_info.html","text":"private subroutine seasonal_info(this, location, bound_type, bound_depth) Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. Contents Source Code seasonal_info Source Code subroutine seasonal_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: March 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is Neumann. ! class ( dallaston2015_seasonal_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case ( 1 ) bound_type = neumann bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine seasonal_info"},{"title":"seasonal_set_time – ISOFT","tags":"","loc":"proc/seasonal_set_time.html","text":"private subroutine seasonal_set_time(this, time) Sets the time at which boundary conditions are to be calculated. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: time Contents Source Code seasonal_set_time Source Code subroutine seasonal_set_time ( this , time ) !* Author: Chris MacMackin !  Date: May 2017 ! ! Sets the time at which boundary conditions are to be calculated. ! class ( dallaston2015_seasonal_boundary ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: time this % discharge = this % mean + this % amplitude * sin ( this % frequency * time ) end subroutine seasonal_set_time"},{"title":"dallaston2015_seasonal_boundary – ISOFT","tags":"","loc":"interface/dallaston2015_seasonal_boundary.html","text":"public interface dallaston2015_seasonal_boundary Calls interface~~dallaston2015_seasonal_boundary~~CallsGraph interface~dallaston2015_seasonal_boundary dallaston2015_seasonal_boundary proc~constructor~14 constructor interface~dallaston2015_seasonal_boundary->proc~constructor~14 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (thickness, frequency, amplitude, mean, temperature) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with\n seasonal variations in subglacial discharge. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: thickness The plume thickness at the inflowing plume boundary, defaults\n to 0.1 real(kind=r8), intent(in), optional :: frequency The angular frequency of the oscillations in discharge,\n defaults to 1.0 real(kind=r8), intent(in), optional :: amplitude The amplitude of the oscillations in discharge, defaults to\n 1.0 real(kind=r8), intent(in), optional :: mean The time-average of the discharge, about which it oscillates,\n defaulting to 1.0 real(kind=r8), intent(in), optional :: temperature The water temperature at the inflowing plume boundary,\n defaults to 0.0 Return Value type( dallaston2015_seasonal_boundary )"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~15.html","text":"private pure function constructor(thickness, frequency, amplitude, mean, chi, square) result(this) Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with the ice\n flux at the grounding line varying in time. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: thickness The ice thickness at the inflowing ice shelf boundary,\n defaults to 1.0 real(kind=r8), intent(in), optional :: frequency The angular frequency of the oscillations in ice flux,\n defaults to 0.5 real(kind=r8), intent(in), optional :: amplitude The amplitude of the oscillations in ice flux, defaults to\n 1.0 real(kind=r8), intent(in), optional :: mean The time-average of the discharge, about which it oscillates,\n defaulting to 1.0 real(kind=r8), intent(in), optional :: chi The dimensionless ratio \\chi \\equiv\n \\frac{\\rho_igh_0x_x}{2\\eta_0u_0} , defaults to 1.0 logical, intent(in), optional :: square If present and true, produce a square wave. Otherwise produce\n a sinusoid. Return Value type( seasonal_glacier_boundary ) Called by proc~~constructor~15~~CalledByGraph proc~constructor~15 constructor interface~seasonal_glacier_boundary seasonal_glacier_boundary interface~seasonal_glacier_boundary->proc~constructor~15 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( thickness , frequency , amplitude , mean , chi , & square ) result ( this ) !* Author: Chris MacMackin !  Date: October 2017 ! ! Constructs a boundary condition object for an ice shelf based on ! the conditions used in Dallaston et al. (2015), but with the ice ! flux at the grounding line varying in time. ! real ( r8 ), intent ( in ), optional :: thickness !! The ice thickness at the inflowing ice shelf boundary, !! defaults to 1.0 real ( r8 ), intent ( in ), optional :: frequency !! The angular frequency of the oscillations in ice flux, !! defaults to 0.5 real ( r8 ), intent ( in ), optional :: amplitude !! The amplitude of the oscillations in ice flux, defaults to !! 1.0 real ( r8 ), intent ( in ), optional :: mean !! The time-average of the discharge, about which it oscillates, !! defaulting to 1.0 real ( r8 ), intent ( in ), optional :: chi !! The dimensionless ratio \\chi \\equiv !! \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}, defaults to 1.0 logical , intent ( in ), optional :: square !! If present and true, produce a square wave. Otherwise produce !! a sinusoid. type ( seasonal_glacier_boundary ) :: this if ( present ( thickness )) this % thickness = thickness if ( present ( frequency )) this % frequency = frequency if ( present ( amplitude )) this % amplitude = amplitude if ( present ( mean )) this % mean = mean if ( present ( chi )) this % chi = chi if ( present ( square )) this % square = square end function constructor"},{"title":"seasonal_lower_bound – ISOFT","tags":"","loc":"proc/seasonal_lower_bound.html","text":"private pure function seasonal_lower_bound(this) result(bound_array) Indicates that one layer of cells at the lower boundary in the\n first dimension should be omitted. This is appropriate for\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) Contents Source Code seasonal_lower_bound Source Code pure function seasonal_lower_bound ( this ) result ( bound_array ) !* Author: Chris MacMackin !  Date: October 2017 ! ! Indicates that one layer of cells at the lower boundary in the ! first dimension should be omitted. This is appropriate for ! Dirichlet boundary conditions. ! class ( seasonal_glacier_boundary ), intent ( in ) :: this integer , dimension ( 2 ) :: bound_array bound_array = [ 1 , 0 ] end function seasonal_lower_bound"},{"title":"seasonal_upper_bound – ISOFT","tags":"","loc":"proc/seasonal_upper_bound.html","text":"private pure function seasonal_upper_bound(this) result(bound_array) Indicates that one layer of cells at the upper boundary in the\n first dimension should be omitted for thickness. This is\n appropriate for Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) Contents Source Code seasonal_upper_bound Source Code pure function seasonal_upper_bound ( this ) result ( bound_array ) !* Author: Chris MacMackin !  Date: October 2017 ! ! Indicates that one layer of cells at the upper boundary in the ! first dimension should be omitted for thickness. This is ! appropriate for Dirichlet boundary conditions. ! class ( seasonal_glacier_boundary ), intent ( in ) :: this integer , dimension ( 2 ) :: bound_array bound_array = [ 1 , 0 ] end function seasonal_upper_bound"},{"title":"seasonal_lower_type – ISOFT","tags":"","loc":"proc/seasonal_lower_type.html","text":"private pure function seasonal_lower_type(this) result(bound_type) Specifies that the lower boundary in the first dimension has\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:),allocatable Contents Source Code seasonal_lower_type Source Code pure function seasonal_lower_type ( this ) result ( bound_type ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Specifies that the lower boundary in the first dimension has ! Dirichlet boundary conditions. ! class ( seasonal_glacier_boundary ), intent ( in ) :: this integer , dimension (:), allocatable :: bound_type bound_type = [ dirichlet , free_boundary ] end function seasonal_lower_type"},{"title":"seasonal_upper_type – ISOFT","tags":"","loc":"proc/seasonal_upper_type.html","text":"private pure function seasonal_upper_type(this) result(bound_type) Specifies that the upper boundary in the first dimension has\n Neumann boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:),allocatable Contents Source Code seasonal_upper_type Source Code pure function seasonal_upper_type ( this ) result ( bound_type ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Specifies that the upper boundary in the first dimension has ! Neumann boundary conditions. ! class ( seasonal_glacier_boundary ), intent ( in ) :: this integer , dimension (:), allocatable :: bound_type bound_type = [ neumann , free_boundary ] end function seasonal_upper_type"},{"title":"seasonal_residuals – ISOFT","tags":"","loc":"proc/seasonal_residuals.html","text":"private function seasonal_residuals(this, thickness, velocity, viscosity, t) result(residuals) Returns the difference between the glacier conditions of the\n plume and the Dirichlet conditions prescribed in the model of\n Dallaston et al. (2015) Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this class(scalar_field), intent(in) :: thickness A field containing the thickness of the glacier class(vector_field), intent(in) :: velocity A field containing the flow velocity of the glacier class(scalar_field), intent(in) :: viscosity A field containing the viscosity of the ice in the glacier. real(kind=r8), intent(in) :: t The time at which the boundary conditions are to be\n calculated. Return Value real(kind=r8),\n  allocatable,dimension(:) An array containing the difference between the required\n boundary values and those which are actually present. They\n are stored in the order: lower thickness boundary, upper\n thickness boundary, lower velocity boundary, and upper\n velocity boundary. Contents Source Code seasonal_residuals Source Code function seasonal_residuals ( this , thickness , velocity , viscosity , t ) & result ( residuals ) !* Author: Chris MacMackin !  Date: October 2017 ! ! Returns the difference between the glacier conditions of the ! plume and the Dirichlet conditions prescribed in the model of ! Dallaston et al. (2015) ! class ( seasonal_glacier_boundary ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: thickness !! A field containing the thickness of the glacier class ( vector_field ), intent ( in ) :: velocity !! A field containing the flow velocity of the glacier class ( scalar_field ), intent ( in ) :: viscosity !! A field containing the viscosity of the ice in the glacier. real ( r8 ), intent ( in ) :: t !! The time at which the boundary conditions are to be !! calculated. real ( r8 ), allocatable , dimension (:) :: residuals !! An array containing the difference between the required !! boundary values and those which are actually present. They !! are stored in the order: lower thickness boundary, upper !! thickness boundary, lower velocity boundary, and upper !! velocity boundary. real ( r8 ) :: vel , tm class ( scalar_field ), pointer :: thickness_bound , & velocity_bound_upper , & velocity_deriv class ( vector_field ), pointer :: velocity_bound_lower call thickness % guard_temp (); call velocity % guard_temp (); call viscosity % guard_temp () call thickness % allocate_scalar_field ( thickness_bound ) thickness_bound = thickness % get_boundary ( - 1 , 1 ) - this % thickness call velocity % allocate_vector_field ( velocity_bound_lower ) if ( this % square ) then vel = this % mean + sign ( this % amplitude , sin ( this % frequency * t )) else vel = this % mean + this % amplitude * sin ( this % frequency * t ) end if velocity_bound_lower = velocity % get_boundary ( - 1 , 1 ) - [ vel ] call velocity % allocate_scalar_field ( velocity_deriv ) velocity_deriv = velocity % component_d_dx ( 1 , 1 ) call velocity % allocate_scalar_field ( velocity_bound_upper ) velocity_bound_upper = velocity_deriv % get_boundary ( 1 , 1 ) & * thickness % get_boundary ( 1 , 1 ) & - ( 0.25_r8 * this % chi ) * thickness % get_boundary ( 1 , 1 ) ** 2 & / viscosity % get_boundary ( 1 , 1 ) residuals = [ thickness_bound % raw (), velocity_bound_lower % raw (), & velocity_bound_upper % raw ()] call thickness % clean_temp (); call velocity % clean_temp (); call viscosity % clean_temp () end function seasonal_residuals"},{"title":"seasonal_glacier_boundary – ISOFT","tags":"","loc":"interface/seasonal_glacier_boundary.html","text":"public interface seasonal_glacier_boundary Calls interface~~seasonal_glacier_boundary~~CallsGraph interface~seasonal_glacier_boundary seasonal_glacier_boundary proc~constructor~15 constructor interface~seasonal_glacier_boundary->proc~constructor~15 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (thickness, frequency, amplitude, mean, chi, square) result(this) Author Chris MacMackin Date October 2017 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with the ice\n flux at the grounding line varying in time. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: thickness The ice thickness at the inflowing ice shelf boundary,\n defaults to 1.0 real(kind=r8), intent(in), optional :: frequency The angular frequency of the oscillations in ice flux,\n defaults to 0.5 real(kind=r8), intent(in), optional :: amplitude The amplitude of the oscillations in ice flux, defaults to\n 1.0 real(kind=r8), intent(in), optional :: mean The time-average of the discharge, about which it oscillates,\n defaulting to 1.0 real(kind=r8), intent(in), optional :: chi The dimensionless ratio \\chi \\equiv\n \\frac{\\rho_igh_0x_x}{2\\eta_0u_0} , defaults to 1.0 logical, intent(in), optional :: square If present and true, produce a square wave. Otherwise produce\n a sinusoid. Return Value type( seasonal_glacier_boundary )"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~16.html","text":"private pure function constructor(bound_calculator, distance, thresholds) result(this) Constructs a boundary condition object which integrates an IVP\n from actual boundary values to calculate the staet of the plume\n a little upstream. This can be used to avoid boundary layers. Arguments Type Intent Optional Attributes Name procedure( bound_vals ) :: bound_calculator Calculates the \"actual\" inflow boundary conditions, used to\n initiate the integration to find the values to use in the\n simulation. real(kind=r8), intent(in) :: distance The distance upstream which the plume should be integrated. real(kind=r8), intent(in), optional dimension(:) :: thresholds The thresholds to use when evaluating the error of the\n integration. This is done according to the formula abs(e) / max(magnitude_y, THRESHOLDS) <= TOLERANCE . Return Value type( upstream_plume_boundary ) Called by proc~~constructor~16~~CalledByGraph proc~constructor~16 constructor interface~upstream_plume_boundary upstream_plume_boundary interface~upstream_plume_boundary->proc~constructor~16 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( bound_calculator , distance , thresholds ) & result ( this ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Constructs a boundary condition object which integrates an IVP ! from actual boundary values to calculate the staet of the plume ! a little upstream. This can be used to avoid boundary layers. ! procedure ( bound_vals ) :: bound_calculator !! Calculates the \"actual\" inflow boundary conditions, used to !! initiate the integration to find the values to use in the !! simulation. real ( r8 ), intent ( in ) :: distance !! The distance upstream which the plume should be integrated. real ( r8 ), dimension (:), optional , intent ( in ) :: thresholds !! The thresholds to use when evaluating the error of the !! integration. This is done according to the formula !! `abs(e) / max(magnitude_y, THRESHOLDS) <= TOLERANCE`. type ( upstream_plume_boundary ) :: this this % get_boundaries => bound_calculator this % distance = distance if ( present ( thresholds )) this % thresholds = thresholds end function constructor"},{"title":"upstream_thickness_bound – ISOFT","tags":"","loc":"proc/upstream_thickness_bound.html","text":"private function upstream_thickness_bound(this, location) result(bound) Returns a field containing the thickness boundary values for the\n specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Calls proc~~upstream_thickness_bound~~CallsGraph proc~upstream_thickness_bound upstream_thickness_bound uniform_scalar_field uniform_scalar_field proc~upstream_thickness_bound->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code upstream_thickness_bound Source Code function upstream_thickness_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Returns a field containing the thickness boundary values for the ! specified boundary location. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % thickness ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function upstream_thickness_bound"},{"title":"upstream_velocity_bound – ISOFT","tags":"","loc":"proc/upstream_velocity_bound.html","text":"private function upstream_velocity_bound(this, location) result(bound) Returns a field containing the velocity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer Calls proc~~upstream_velocity_bound~~CallsGraph proc~upstream_velocity_bound upstream_velocity_bound uniform_vector_field uniform_vector_field proc~upstream_velocity_bound->uniform_vector_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code upstream_velocity_bound Source Code function upstream_velocity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Returns a field containing the velocity boundary values for ! the specified boundary location. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( vector_field ), pointer :: bound call dummy % allocate_vector_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_vector_field ( this % velocity ) case ( 1 ) bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) case default bound = uniform_vector_field ([ 0._r8 , 0._r8 ]) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function upstream_velocity_bound"},{"title":"upstream_temperature_bound – ISOFT","tags":"","loc":"proc/upstream_temperature_bound.html","text":"private function upstream_temperature_bound(this, location) result(bound) Returns a field containing the temperature boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Calls proc~~upstream_temperature_bound~~CallsGraph proc~upstream_temperature_bound upstream_temperature_bound uniform_scalar_field uniform_scalar_field proc~upstream_temperature_bound->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code upstream_temperature_bound Source Code function upstream_temperature_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Returns a field containing the temperature boundary values for ! the specified boundary location. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % temperature ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function upstream_temperature_bound"},{"title":"upstream_salinity_bound – ISOFT","tags":"","loc":"proc/upstream_salinity_bound.html","text":"private function upstream_salinity_bound(this, location) result(bound) Returns a field containing the salinity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Calls proc~~upstream_salinity_bound~~CallsGraph proc~upstream_salinity_bound upstream_salinity_bound uniform_scalar_field uniform_scalar_field proc~upstream_salinity_bound->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code upstream_salinity_bound Source Code function upstream_salinity_bound ( this , location ) result ( bound ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Returns a field containing the salinity boundary values for ! the specified boundary location. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. class ( scalar_field ), pointer :: bound call dummy % allocate_scalar_field ( bound ) select case ( location ) case ( - 1 ) bound = uniform_scalar_field ( this % salinity ) case ( 1 ) bound = uniform_scalar_field ( 0._r8 ) case default bound = uniform_scalar_field ( 0._r8 ) end select call bound % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. end function upstream_salinity_bound"},{"title":"upstream_thickness_info – ISOFT","tags":"","loc":"proc/upstream_thickness_info.html","text":"private subroutine upstream_thickness_info(this, location, bound_type, bound_depth) Indicates that the lower boundary is Dirichlet and the upper\n boundary is free. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. Contents Source Code upstream_thickness_info Source Code subroutine upstream_thickness_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is free. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine upstream_thickness_info"},{"title":"upstream_info – ISOFT","tags":"","loc":"proc/upstream_info.html","text":"private subroutine upstream_info(this, location, bound_type, bound_depth) Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. Contents Source Code upstream_info Source Code subroutine upstream_info ( this , location , bound_type , bound_depth ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Indicates that the lower boundary is Dirichlet and the upper ! boundary is Neumann. ! class ( upstream_plume_boundary ), intent ( in ) :: this integer , intent ( in ) :: location !! Which boundary information is to be provided for.  The !! boundary will be the one normal to dimension of number !! `abs(boundary)`. If the argument is negative, then the lower !! boundary is returned. If positive, then the upper boundary is !! returned. integer , intent ( out ) :: bound_type !! An integer representing what sort of boundary condition is !! used. The integer value corresponding to each boundary type is !! specified in the [[boundary_types_mod]]. integer , intent ( out ) :: bound_depth !! The number of layers of data-points needed to specify the !! boundary condition. select case ( location ) case ( - 1 ) bound_type = dirichlet bound_depth = 1 case ( 1 ) bound_type = neumann bound_depth = 1 case default bound_type = free_boundary bound_depth = 0 end select end subroutine upstream_info"},{"title":"upstream_calculate – ISOFT","tags":"","loc":"proc/upstream_calculate.html","text":"private subroutine upstream_calculate(this, t, func, b) Calculates the boundary values to use at the current time with\n the current ice thickness. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: t The time at which to calculate the boundary values. procedure( non_diff ) :: func A function which returns the non-diffusive, non-inertial\n components of the ODEs describing the plume. class(scalar_field), intent(in) :: b The depth of the ice shelf base. Calls proc~~upstream_calculate~~CallsGraph proc~upstream_calculate upstream_calculate str str proc~upstream_calculate->str interface~range_integrate range_integrate proc~upstream_calculate->interface~range_integrate interface~setup setup proc~upstream_calculate->interface~setup interface~collect_garbage collect_garbage proc~upstream_calculate->interface~collect_garbage proc~range_integrate_r1 range_integrate_r1 interface~range_integrate->proc~range_integrate_r1 proc~setup_r1 setup_r1 interface~setup->proc~setup_r1 proc~collect_garbage_r1 collect_garbage_r1 interface~collect_garbage->proc~collect_garbage_r1 proc~method_const method_const proc~setup_r1->proc~method_const proc~rkmsg_r1 rkmsg_r1 proc~setup_r1->proc~rkmsg_r1 proc~machine_const machine_const proc~setup_r1->proc~machine_const interface~reset_t_end reset_t_end proc~range_integrate_r1->interface~reset_t_end interface~interpolate interpolate proc~range_integrate_r1->interface~interpolate interface~step_integrate step_integrate proc~range_integrate_r1->interface~step_integrate proc~set_saved_state_r1 set_saved_state_r1 proc~range_integrate_r1->proc~set_saved_state_r1 proc~get_saved_state_r1 get_saved_state_r1 proc~range_integrate_r1->proc~get_saved_state_r1 proc~range_integrate_r1->proc~rkmsg_r1 proc~get_saved_fatal_r1 get_saved_fatal_r1 proc~range_integrate_r1->proc~get_saved_fatal_r1 proc~reset_t_end_r1 reset_t_end_r1 interface~reset_t_end->proc~reset_t_end_r1 proc~interpolate_r1 interpolate_r1 interface~interpolate->proc~interpolate_r1 proc~step_integrate_r1 step_integrate_r1 interface~step_integrate->proc~step_integrate_r1 proc~rkmsg_r1->proc~set_saved_state_r1 proc~get_stop_on_fatal_r1 get_stop_on_fatal_r1 proc~rkmsg_r1->proc~get_stop_on_fatal_r1 proc~step_integrate_r1->proc~set_saved_state_r1 proc~step_integrate_r1->proc~get_saved_state_r1 proc~step_integrate_r1->proc~rkmsg_r1 proc~stiff_r1 stiff_r1 proc~step_integrate_r1->proc~stiff_r1 proc~step_r1 step_r1 proc~step_integrate_r1->proc~step_r1 proc~truerr_r1 truerr_r1 proc~step_integrate_r1->proc~truerr_r1 proc~interpolate_r1->proc~get_saved_state_r1 proc~interpolate_r1->proc~rkmsg_r1 proc~reset_t_end_r1->proc~get_saved_state_r1 proc~reset_t_end_r1->proc~rkmsg_r1 proc~truerr_r1->proc~step_r1 var panprocupstream_calculateCallsGraph = svgPanZoom('#procupstream_calculateCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code upstream_calculate Source Code subroutine upstream_calculate ( this , t , func , b ) !* Author: Chris MacMackin !  Date: July 2017 ! ! Calculates the boundary values to use at the current time with ! the current ice thickness. ! class ( upstream_plume_boundary ), intent ( inout ) :: this real ( r8 ), intent ( in ) :: t !! The time at which to calculate the boundary values. procedure ( non_diff ) :: func !! A function which returns the non-diffusive, non-inertial !! components of the ODEs describing the plume. class ( scalar_field ), intent ( in ) :: b !! The depth of the ice shelf base. integer :: n real ( r8 ) :: D_0 , U_0 , S_0 , T_0 , DU_0 , DUS_0 , DUT_0 real ( r8 ), dimension (:), allocatable :: Uvec_0 , DUvecU_0 class ( scalar_field ), pointer :: b_x real ( r8 ), dimension (:), allocatable :: y0 , ygot , yderiv_got real ( r8 ) :: xgot integer :: flag type ( rk_comm_real_1d ) :: comm call b % guard_temp () call this % get_boundaries ( t , D_0 , Uvec_0 , T_0 , S_0 ) U_0 = Uvec_0 ( 1 ) DU_0 = D_0 * U_0 DUvecU_0 = DU_0 * Uvec_0 DUT_0 = DU_0 * T_0 DUS_0 = DU_0 * S_0 y0 = [ DU_0 , DUvecU_0 , DUT_0 , DUS_0 ] n = size ( y0 ) allocate ( ygot ( n ), yderiv_got ( n )) if (. not . allocated ( this % thresholds )) then allocate ( this % thresholds ( n )) this % thresholds = 1._r8 end if b_x => b % d_dx ( 1 ) call b_x % guard_temp () call setup ( comm , 0._r8 , y0 , this % distance , 1 e - 6_r8 , this % thresholds , & method = 'h' , h_start = 2 e - 3_r8 * this % distance ) call range_integrate ( comm , integrand , this % distance , xgot , ygot , & yderiv_got , flag ) if ( flag /= 1 ) then call logger % error ( 'upstream_plume_boundary%calculate' , & 'Could only integrate plume to x = ' // str ( xgot )) end if !this%thresholds = abs(ygot) + 1e-10 this % thickness = ygot ( 1 ) ** 2 / ygot ( 2 ) this % velocity = ygot ( 2 : n - 2 ) / ygot ( 1 ) this % temperature = ygot ( n - 1 ) / ygot ( 1 ) this % salinity = ygot ( n ) / ygot ( 1 ) call logger % trivia ( 'upstream_plume_boundary%calculate' , & 'Calculated boundary values D=' // str ( this % thickness ) // ', U=' // & str ( this % velocity ) // ', T=' // str ( this % temperature ) // ', S=' // & str ( this % salinity )) if ( this % thickness < 0._r8 ) error stop ( 'Negative plume thickness found' ) call collect_garbage ( comm ) call b % clean_temp (); call b_x % clean_temp () contains function integrand ( x , y ) result ( f ) real ( r8 ), intent ( in ) :: x !! The independent variable real ( r8 ), dimension (:), intent ( in ) :: y !! The dependent variable real ( r8 ), dimension ( size ( y )) :: f !! The derivatives type ( uniform_scalar_field ) :: D , T , S , DU_x , DUT_x , DUS_x type ( uniform_vector_field ) :: Uvec , DUU_x type ( uniform_gradient_field ) :: b_loc D = uniform_scalar_field ( y ( 1 ) ** 2 / y ( 2 )) Uvec = uniform_vector_field ( y ( 2 : n - 2 ) / y ( 1 )) T = uniform_scalar_field ( y ( n - 1 ) / y ( 1 )) S = uniform_scalar_field ( y ( n ) / y ( 1 )) b_loc = uniform_gradient_field ( b % interpolate ([ x ]), [ b_x % interpolate ([ x ])]) call func ( D , Uvec , T , S , b_loc , DU_x , DUU_x , DUT_x , DUS_x ) f ( 1 ) = DU_x % get_value () f ( 2 : n - 2 ) = DUU_x % get_value () f ( n - 1 ) = DUT_x % get_value () f ( n ) = DUS_x % get_value () end function integrand end subroutine upstream_calculate"},{"title":"upstream_plume_boundary – ISOFT","tags":"","loc":"interface/upstream_plume_boundary.html","text":"public interface upstream_plume_boundary Calls interface~~upstream_plume_boundary~~CallsGraph interface~upstream_plume_boundary upstream_plume_boundary proc~constructor~16 constructor interface~upstream_plume_boundary->proc~constructor~16 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (bound_calculator, distance, thresholds) result(this) Author Chris MacMackin Date July 2017 Constructs a boundary condition object which integrates an IVP\n from actual boundary values to calculate the staet of the plume\n a little upstream. This can be used to avoid boundary layers. Arguments Type Intent Optional Attributes Name procedure( bound_vals ) :: bound_calculator Calculates the \"actual\" inflow boundary conditions, used to\n initiate the integration to find the values to use in the\n simulation. real(kind=r8), intent(in) :: distance The distance upstream which the plume should be integrated. real(kind=r8), intent(in), optional dimension(:) :: thresholds The thresholds to use when evaluating the error of the\n integration. This is done according to the formula abs(e) / max(magnitude_y, THRESHOLDS) <= TOLERANCE . Return Value type( upstream_plume_boundary )"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~17.html","text":"private pure function constructor(thickness, velocity, chi) result(this) Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: thickness The ice thickness at the inflowing ice shelf boundary real(kind=r8), intent(in) :: velocity The longitudinal ice velocity at the inflowing ice shelf boundary real(kind=r8), intent(in) :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Return Value type( dallaston2015_glacier_boundary ) Called by proc~~constructor~17~~CalledByGraph proc~constructor~17 constructor interface~dallaston2015_glacier_boundary dallaston2015_glacier_boundary interface~dallaston2015_glacier_boundary->proc~constructor~17 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( thickness , velocity , chi ) result ( this ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Constructs a boundary condition object for an ice shelf based on ! the conditions used in Dallaston et al. (2015). ! real ( r8 ), intent ( in ) :: thickness !! The ice thickness at the inflowing ice shelf boundary real ( r8 ), intent ( in ) :: velocity !! The longitudinal ice velocity at the inflowing ice shelf boundary real ( r8 ), intent ( in ) :: chi !! The dimensionless ratio !! $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ type ( dallaston2015_glacier_boundary ) :: this this % thickness = thickness this % velocity = velocity this % chi = chi end function constructor"},{"title":"dallaston2015_lower_bound – ISOFT","tags":"","loc":"proc/dallaston2015_lower_bound.html","text":"private pure function dallaston2015_lower_bound(this) result(bound_array) Indicates that one layer of cells at the lower boundary in the\n first dimension should be omitted. This is appropriate for\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) Contents Source Code dallaston2015_lower_bound Source Code pure function dallaston2015_lower_bound ( this ) result ( bound_array ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Indicates that one layer of cells at the lower boundary in the ! first dimension should be omitted. This is appropriate for ! Dirichlet boundary conditions. ! class ( dallaston2015_glacier_boundary ), intent ( in ) :: this integer , dimension ( 2 ) :: bound_array bound_array = [ 1 , 0 ] end function dallaston2015_lower_bound"},{"title":"dallaston2015_upper_bound – ISOFT","tags":"","loc":"proc/dallaston2015_upper_bound.html","text":"private pure function dallaston2015_upper_bound(this) result(bound_array) Indicates that one layer of cells at the upper boundary in the\n first dimension should be omitted for thickness. This is\n appropriate for Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) Contents Source Code dallaston2015_upper_bound Source Code pure function dallaston2015_upper_bound ( this ) result ( bound_array ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Indicates that one layer of cells at the upper boundary in the ! first dimension should be omitted for thickness. This is ! appropriate for Dirichlet boundary conditions. ! class ( dallaston2015_glacier_boundary ), intent ( in ) :: this integer , dimension ( 2 ) :: bound_array bound_array = [ 1 , 0 ] end function dallaston2015_upper_bound"},{"title":"dallaston2015_lower_type – ISOFT","tags":"","loc":"proc/dallaston2015_lower_type.html","text":"private pure function dallaston2015_lower_type(this) result(bound_type) Specifies that the lower boundary in the first dimension has\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:),allocatable Contents Source Code dallaston2015_lower_type Source Code pure function dallaston2015_lower_type ( this ) result ( bound_type ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Specifies that the lower boundary in the first dimension has ! Dirichlet boundary conditions. ! class ( dallaston2015_glacier_boundary ), intent ( in ) :: this integer , dimension (:), allocatable :: bound_type bound_type = [ dirichlet , free_boundary ] end function dallaston2015_lower_type"},{"title":"dallaston2015_upper_type – ISOFT","tags":"","loc":"proc/dallaston2015_upper_type.html","text":"private pure function dallaston2015_upper_type(this) result(bound_type) Specifies that the upper boundary in the first dimension has\n Neumann boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:),allocatable Contents Source Code dallaston2015_upper_type Source Code pure function dallaston2015_upper_type ( this ) result ( bound_type ) !* Author: Chris MacMackin !  Date: January 2017 ! ! Specifies that the upper boundary in the first dimension has ! Neumann boundary conditions. ! class ( dallaston2015_glacier_boundary ), intent ( in ) :: this integer , dimension (:), allocatable :: bound_type bound_type = [ neumann , free_boundary ] end function dallaston2015_upper_type"},{"title":"dallaston2015_residuals – ISOFT","tags":"","loc":"proc/dallaston2015_residuals.html","text":"private function dallaston2015_residuals(this, thickness, velocity, viscosity, t) result(residuals) Returns the difference between the glacier conditions of the\n plume and the Dirichlet conditions prescribed in the model of\n Dallaston et al. (2015) Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this class(scalar_field), intent(in) :: thickness A field containing the thickness of the glacier class(vector_field), intent(in) :: velocity A field containing the flow velocity of the glacier class(scalar_field), intent(in) :: viscosity A field containing the viscosity of the ice in the glacier. real(kind=r8), intent(in) :: t The time at which the boundary conditions are to be\n calculated. Return Value real(kind=r8),\n  allocatable,dimension(:) An array containing the difference between the required\n boundary values and those which are actually present. They\n are stored in the order: lower thickness boundary, upper\n thickness boundary, lower velocity boundary, and upper\n velocity boundary. Contents Source Code dallaston2015_residuals Source Code function dallaston2015_residuals ( this , thickness , velocity , viscosity , t ) & result ( residuals ) !* Author: Chris MacMackin !  Date: November 2016 ! ! Returns the difference between the glacier conditions of the ! plume and the Dirichlet conditions prescribed in the model of ! Dallaston et al. (2015) ! class ( dallaston2015_glacier_boundary ), intent ( in ) :: this class ( scalar_field ), intent ( in ) :: thickness !! A field containing the thickness of the glacier class ( vector_field ), intent ( in ) :: velocity !! A field containing the flow velocity of the glacier class ( scalar_field ), intent ( in ) :: viscosity !! A field containing the viscosity of the ice in the glacier. real ( r8 ), intent ( in ) :: t !! The time at which the boundary conditions are to be !! calculated. real ( r8 ), allocatable , dimension (:) :: residuals !! An array containing the difference between the required !! boundary values and those which are actually present. They !! are stored in the order: lower thickness boundary, upper !! thickness boundary, lower velocity boundary, and upper !! velocity boundary. class ( scalar_field ), pointer :: thickness_bound , & velocity_bound_upper , & velocity_deriv class ( vector_field ), pointer :: velocity_bound_lower call thickness % guard_temp (); call velocity % guard_temp (); call viscosity % guard_temp () call thickness % allocate_scalar_field ( thickness_bound ) thickness_bound = thickness % get_boundary ( - 1 , 1 ) - this % thickness call velocity % allocate_vector_field ( velocity_bound_lower ) velocity_bound_lower = velocity % get_boundary ( - 1 , 1 ) - [ this % velocity ] call velocity % allocate_scalar_field ( velocity_deriv ) velocity_deriv = velocity % component_d_dx ( 1 , 1 ) call velocity % allocate_scalar_field ( velocity_bound_upper ) velocity_bound_upper = velocity_deriv % get_boundary ( 1 , 1 ) & * thickness % get_boundary ( 1 , 1 ) & - ( 0.25_r8 * this % chi ) * thickness % get_boundary ( 1 , 1 ) ** 2 & / viscosity % get_boundary ( 1 , 1 ) residuals = [ thickness_bound % raw (), velocity_bound_lower % raw (), & velocity_bound_upper % raw ()] call thickness % clean_temp (); call velocity % clean_temp (); call viscosity % clean_temp () end function dallaston2015_residuals"},{"title":"dallaston2015_glacier_boundary – ISOFT","tags":"","loc":"interface/dallaston2015_glacier_boundary.html","text":"public interface dallaston2015_glacier_boundary Calls interface~~dallaston2015_glacier_boundary~~CallsGraph interface~dallaston2015_glacier_boundary dallaston2015_glacier_boundary proc~constructor~17 constructor interface~dallaston2015_glacier_boundary->proc~constructor~17 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (thickness, velocity, chi) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: thickness The ice thickness at the inflowing ice shelf boundary real(kind=r8), intent(in) :: velocity The longitudinal ice velocity at the inflowing ice shelf boundary real(kind=r8), intent(in) :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Return Value type( dallaston2015_glacier_boundary )"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~18.html","text":"private pure function constructor(coef1, coef2, fresh_sal, melt_temp, a_UabsT) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coef1 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), intent(in) :: coef2 The unitless multiplier applied to the theram forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), intent(in), optional :: fresh_sal The salinity of fresh water. Defaults to 0. real(kind=r8), intent(in), optional :: melt_temp The melting point of the ice. Defaults to 0. real(kind=r8), intent(in), optional :: a_UabsT The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy, where f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the\n variables |\\vec{U}| and T in the transverse\n direction. Defaults to 1. Return Value type( ave_one_equation_melt ) The newly created object representing the melt relationship. Called by proc~~constructor~18~~CalledByGraph proc~constructor~18 constructor interface~ave_one_equation_melt ave_one_equation_melt interface~ave_one_equation_melt->proc~constructor~18 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( coef1 , coef2 , fresh_sal , melt_temp , a_UabsT ) result ( this ) real ( r8 ), intent ( in ) :: coef1 !! The unitless multiplier on the thermal forcing term, !! \\Gamma_Tx_0/D_0. real ( r8 ), intent ( in ) :: coef2 !! The unitless multiplier applied to the theram forcing term to !! get the melt rate, c_oT_0/L. real ( r8 ), intent ( in ), optional :: fresh_sal !! The salinity of fresh water. Defaults to 0. real ( r8 ), intent ( in ), optional :: melt_temp !! The melting point of the ice. Defaults to 0. real ( r8 ), intent ( in ), optional :: a_UabsT !! The shape coefficient for a horizontally-integrated model. It !! is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1} !! \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy,  where !! f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the !! variables |\\vec{U}| and T in the transverse !! direction. Defaults to 1. type ( ave_one_equation_melt ) :: this !! The newly created object representing the melt relationship. this % coef1 = coef1 if ( present ( fresh_sal )) this % sal_forcing = - fresh_sal * coef2 if ( present ( melt_temp )) this % melt_temp = melt_temp if ( present ( a_UabsT )) this % a_UabsT = a_UabsT end function constructor"},{"title":"one_equation_heat – ISOFT","tags":"","loc":"proc/one_equation_heat.html","text":"private function one_equation_heat(this) result(heat) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the heat equation for a plume Contents Source Code one_equation_heat Source Code function one_equation_heat ( this ) result ( heat ) class ( ave_one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: heat !! The value of the contribution made by melting/thermal !! transfer to the heat equation for a [[plume]] if (. not . allocated ( this % forcing_values )) error stop ( 'Melt values not calculated' ) call this % forcing_values % allocate_scalar_field ( heat ) if ( this % melt_temp /= 0._r8 ) then heat = ( 1 - this % coef2 * this % melt_temp ) * this % forcing_values else heat = this % forcing_values end if call heat % set_temp () ! Shouldn't need to call this, but for some ! rason being set as non-temporary when ! assignment subroutine returns. end function one_equation_heat"},{"title":"one_equation_salt – ISOFT","tags":"","loc":"proc/one_equation_salt.html","text":"private function one_equation_salt(this) result(salt) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the salt equation for a plume Contents Source Code one_equation_salt Source Code function one_equation_salt ( this ) result ( salt ) class ( ave_one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: salt !! The value of the contribution made by melting/thermal !! transfer to the salt equation for a [[plume]] if (. not . allocated ( this % forcing_values ) . and . this % sal_forcing /= 0._r8 ) then error stop ( 'Melt values not calculated' ) end if salt => this % sal_forcing * this % forcing_values end function one_equation_salt"},{"title":"ave_one_equation_melt_rate – ISOFT","tags":"","loc":"proc/ave_one_equation_melt_rate.html","text":"private function ave_one_equation_melt_rate(this) result(melt) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate from the ice into the plume water. Contents Source Code ave_one_equation_melt_rate Source Code function ave_one_equation_melt_rate ( this ) result ( melt ) class ( ave_one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate from the ice into the plume water. if (. not . allocated ( this % forcing_values )) error stop ( 'Melt values not calculated' ) melt => this % coef2 * this % forcing_values end function ave_one_equation_melt_rate"},{"title":"one_equation_has_heat – ISOFT","tags":"","loc":"proc/one_equation_has_heat.html","text":"private pure function one_equation_has_heat(this) result(has_heat) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat equation of the plume. Contents Source Code one_equation_has_heat Source Code pure function one_equation_has_heat ( this ) result ( has_heat ) class ( ave_one_equation_melt ), intent ( in ) :: this logical :: has_heat !! Whether this formulation of melting contributes terms to !! the heat equation of the plume. has_heat = . true . end function one_equation_has_heat"},{"title":"one_equation_has_salt – ISOFT","tags":"","loc":"proc/one_equation_has_salt.html","text":"private pure function one_equation_has_salt(this) result(has_salt) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the salinity equation of the plume. Contents Source Code one_equation_has_salt Source Code pure function one_equation_has_salt ( this ) result ( has_salt ) class ( ave_one_equation_melt ), intent ( in ) :: this logical :: has_salt !! Whether this formulation of melting contributes terms to !! the salinity equation of the plume. has_salt = ( this % sal_forcing /= 0._r8 ) end function one_equation_has_salt"},{"title":"one_equation_solve – ISOFT","tags":"","loc":"proc/one_equation_solve.html","text":"private subroutine one_equation_solve(this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed. Contents Source Code one_equation_solve Source Code subroutine one_equation_solve ( this , velocity , pressure , temperature , & salinity , plume_thickness , time ) class ( ave_one_equation_melt ), intent ( inout ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: pressure !! The water pressure at the interface where the melting occurs. class ( scalar_field ), intent ( in ) :: temperature !! The temperature of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: salinity !! The salinity of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: plume_thickness !! The thickness of the plume into which fluid is melting. real ( r8 ), intent ( in ), optional :: time !! The time at which the melting is being solved for. If not !! present then assumed to be same as previous value passed. call velocity % guard_temp (); call pressure % guard_temp () call temperature % guard_temp (); call salinity % guard_temp () call plume_thickness % guard_temp () if (. not . allocated ( this % forcing_values )) then allocate ( this % forcing_values , mold = temperature ) else if (. not . same_type_as ( this % forcing_values , temperature )) then deallocate ( this % forcing_values ) allocate ( this % forcing_values , mold = temperature ) end if this % forcing_values = this % coef1 * ( this % a_UabsT * temperature - & this % melt_temp ) * velocity % norm () call velocity % clean_temp (); call pressure % clean_temp () call temperature % clean_temp (); call salinity % clean_temp () call plume_thickness % clean_temp () end subroutine one_equation_solve"},{"title":"ave_one_equation_melt – ISOFT","tags":"","loc":"interface/ave_one_equation_melt.html","text":"public interface ave_one_equation_melt Calls interface~~ave_one_equation_melt~~CallsGraph interface~ave_one_equation_melt ave_one_equation_melt proc~constructor~18 constructor interface~ave_one_equation_melt->proc~constructor~18 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (coef1, coef2, fresh_sal, melt_temp, a_UabsT) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coef1 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), intent(in) :: coef2 The unitless multiplier applied to the theram forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), intent(in), optional :: fresh_sal The salinity of fresh water. Defaults to 0. real(kind=r8), intent(in), optional :: melt_temp The melting point of the ice. Defaults to 0. real(kind=r8), intent(in), optional :: a_UabsT The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy, where f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the\n variables |\\vec{U}| and T in the transverse\n direction. Defaults to 1. Return Value type( ave_one_equation_melt ) The newly created object representing the melt relationship."},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~19.html","text":"private pure function constructor(viscosity_value) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: viscosity_value The numerical value of the viscosity which this type is meant \n to return. Return Value type( newtonian_viscosity ) The viscosity object being created. Called by proc~~constructor~19~~CalledByGraph proc~constructor~19 constructor interface~newtonian_viscosity newtonian_viscosity interface~newtonian_viscosity->proc~constructor~19 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( viscosity_value ) result ( this ) real ( r8 ), intent ( in ) :: viscosity_value !! The numerical value of the viscosity which this type is meant !! to return. type ( newtonian_viscosity ) :: this !! The viscosity object being created. this % viscosity_value = viscosity_value end function constructor"},{"title":"newtonian_ice_viscosity – ISOFT","tags":"","loc":"proc/newtonian_ice_viscosity.html","text":"private function newtonian_ice_viscosity(this, velocity, temperature, time) result(viscosity) Arguments Type Intent Optional Attributes Name class( newtonian_viscosity ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the ice for which the velocity is\n being calculated real(kind=r8), intent(in) :: temperature The temperature of the ice for which viscosity is being\n calculated. real(kind=r8), intent(in), optional :: time The time at which the viscosity is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the viscosity Calls proc~~newtonian_ice_viscosity~~CallsGraph proc~newtonian_ice_viscosity newtonian_ice_viscosity uniform_scalar_field uniform_scalar_field proc~newtonian_ice_viscosity->uniform_scalar_field Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code newtonian_ice_viscosity Source Code function newtonian_ice_viscosity ( this , velocity , temperature , time ) & result ( viscosity ) class ( newtonian_viscosity ), intent ( in ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the ice for which the velocity is !! being calculated real ( r8 ), intent ( in ) :: temperature !! The temperature of the ice for which viscosity is being !! calculated. real ( r8 ), intent ( in ), optional :: time !! The time at which the viscosity is being calculated. If not !! present then assumed to be same as previous value passed. class ( scalar_field ), pointer :: viscosity !! The value of the viscosity type ( uniform_scalar_field ) :: dummy call velocity % guard_temp () call dummy % allocate_scalar_field ( viscosity ) viscosity = uniform_scalar_field ( this % viscosity_value ) call viscosity % set_temp () ! Shouldn't need to call this, but for some ! reason being set as non-temporary when ! assignment subroutine returns. call velocity % clean_temp () end function newtonian_ice_viscosity"},{"title":"newtonian_viscosity – ISOFT","tags":"","loc":"interface/newtonian_viscosity.html","text":"public interface newtonian_viscosity Calls interface~~newtonian_viscosity~~CallsGraph interface~newtonian_viscosity newtonian_viscosity proc~constructor~19 constructor interface~newtonian_viscosity->proc~constructor~19 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (viscosity_value) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: viscosity_value The numerical value of the viscosity which this type is meant \n to return. Return Value type( newtonian_viscosity ) The viscosity object being created."},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~20.html","text":"private pure function constructor(b_val, index) result(this) Instantiates an instance of a viscosity object implementing\n Glen's flow law. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: b_val The coefficient, B , in Glen's flow law. real(kind=r8), intent(in) :: index The index, n , in the exponent of Glen's flow law. Return Value type( glens_law_viscosity ) The viscosity object being created. Called by proc~~constructor~20~~CalledByGraph proc~constructor~20 constructor interface~glens_law_viscosity glens_law_viscosity interface~glens_law_viscosity->proc~constructor~20 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( b_val , index ) result ( this ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Instantiates an instance of a viscosity object implementing ! Glen's flow law. ! real ( r8 ), intent ( in ) :: b_val !! The coefficient, B, in Glen's flow law. real ( r8 ), intent ( in ) :: index !! The index, n, in the exponent of Glen's flow law. type ( glens_law_viscosity ) :: this !! The viscosity object being created. this % b_val = b_val this % index = index end function constructor"},{"title":"glens_ice_viscosity – ISOFT","tags":"","loc":"proc/glens_ice_viscosity.html","text":"private function glens_ice_viscosity(this, velocity, temperature, time) result(viscosity) Calculates the viscosity of ice using Glen's flow law. See the\n documentation of the glens_law_viscosity object for a\n description of this parameterisation. Arguments Type Intent Optional Attributes Name class( glens_law_viscosity ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the ice for which the velocity is\n being calculated real(kind=r8), intent(in) :: temperature The temperature of the ice for which viscosity is being\n calculated. real(kind=r8), intent(in), optional :: time The time at which the viscosity is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the viscosity Contents Source Code glens_ice_viscosity Source Code function glens_ice_viscosity ( this , velocity , temperature , time ) & result ( viscosity ) !* Author: Christopher MacMackin !  Date: April 2017 ! ! Calculates the viscosity of ice using Glen's flow law. See the ! documentation of the [[glens_law_viscosity]] object for a ! description of this parameterisation. ! class ( glens_law_viscosity ), intent ( in ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the ice for which the velocity is !! being calculated real ( r8 ), intent ( in ) :: temperature !! The temperature of the ice for which viscosity is being !! calculated. real ( r8 ), intent ( in ), optional :: time !! The time at which the viscosity is being calculated. If not !! present then assumed to be same as previous value passed. class ( scalar_field ), pointer :: viscosity !! The value of the viscosity call velocity % guard_temp () if ( velocity % dimensions () > 1 ) then error stop ( 'Multidimensional case not implemented' ) ! This should all work, but there seems to be yet another ! compiler bug. At present I don't need the multi-dimensional ! case anyway. !      viscosity => velocity%component_d_dx(1, 1)**2 + & !                   velocity%component_d_dx(2, 2)**2 + & !                   0.25_r8*(velocity%component_d_dx(1, 2) + & !                            velocity%component_d_dx(2, 1)**2) !      viscosity => sqrt(viscosity) else viscosity => abs ( velocity % component_d_dx ( 1 , 1 , 1 )) end if viscosity => 0.5_r8 * this % b_val * viscosity ** ( 1._r8 / this % index - 1._r8 ) call velocity % clean_temp () call viscosity % set_temp () end function glens_ice_viscosity"},{"title":"glens_law_viscosity – ISOFT","tags":"","loc":"interface/glens_law_viscosity.html","text":"public interface glens_law_viscosity Calls interface~~glens_law_viscosity~~CallsGraph interface~glens_law_viscosity glens_law_viscosity proc~constructor~20 constructor interface~glens_law_viscosity->proc~constructor~20 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (b_val, index) result(this) Author Christopher MacMackin Date April 2017 Instantiates an instance of a viscosity object implementing\n Glen's flow law. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: b_val The coefficient, B , in Glen's flow law. real(kind=r8), intent(in) :: index The index, n , in the exponent of Glen's flow law. Return Value type( glens_law_viscosity ) The viscosity object being created."},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~21.html","text":"private pure function constructor(coefficient, delta) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coefficient The entrainment coefficient c_L&#94;2x_0/D_0 real(kind=r8), intent(in) :: delta The ratio D_0/h_0 Return Value type( kochergin1987_entrainment ) A new entrainment object Called by proc~~constructor~21~~CalledByGraph proc~constructor~21 constructor interface~kochergin1987_entrainment kochergin1987_entrainment interface~kochergin1987_entrainment->proc~constructor~21 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( coefficient , delta ) result ( this ) real ( r8 ), intent ( in ) :: coefficient !! The entrainment coefficient c_L&#94;2x_0/D_0 real ( r8 ), intent ( in ) :: delta !! The ratio D_0/h_0 type ( kochergin1987_entrainment ) :: this !! A new entrainment object this % coefficient = coefficient this % delta = delta end function constructor"},{"title":"kochergin1987_rate – ISOFT","tags":"","loc":"proc/kochergin1987_rate.html","text":"private function kochergin1987_rate(this, velocity, thickness, depth, density_diff, time) result(entrainment) e = \\frac{c_L&#94;2}{S_m}\\sqrt{|\\vec{U}|&#94;2+\\frac{g'D}{S_m}}. Here, c_L is an entrainment coefficient, \\vec{U} is the\n velocity of the plume, g' is the reduced gravity, and S_m is the turbulent Schmidt number. The Schmidt number is a\n function of the Richardson number Ri = g'D/|\\vec{U}|&#94;2 : S_m = \\frac{Ri}{0.0725(Ri + 0.186 -\n \\sqrt{Ri&#94;2 - 0.316Ri + 0.0346})}. Arguments Type Intent Optional Attributes Name class( kochergin1987_entrainment ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is being \n entrained. class(scalar_field), intent(in) :: thickness The thickness of the plume into which fluid is being\n entrained class(scalar_field), intent(in) :: depth The depth of the upper surface of the plume into which\n fluid is being entrained class(scalar_field), intent(in) :: density_diff The difference between the ambient density and the density of\n the plume into which the ambient fluid is being entrained. real(kind=r8), intent(in), optional :: time The time at which the entrainment is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the entrainment Contents Source Code kochergin1987_rate Source Code function kochergin1987_rate ( this , velocity , thickness , depth , density_diff , time ) & result ( entrainment ) !* Author: Christopher MacMackin !  Date: Feburary 2018 ! ! e = \\frac{c_L&#94;2}{S_m}\\sqrt{|\\vec{U}|&#94;2+\\frac{g'D}{S_m}}. ! Here, c_L is an entrainment coefficient, \\vec{U} is the ! velocity of the plume, g' is the reduced gravity, and ! S_m is the turbulent Schmidt number. The Schmidt number is a ! function of the Richardson number Ri = g'D/|\\vec{U}|&#94;2: !  S_m = \\frac{Ri}{0.0725(Ri + 0.186 - ! \\sqrt{Ri&#94;2 - 0.316Ri + 0.0346})}.  ! class ( kochergin1987_entrainment ), intent ( in ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is being !! entrained. class ( scalar_field ), intent ( in ) :: thickness !! The thickness of the plume into which fluid is being !! entrained class ( scalar_field ), intent ( in ) :: depth !! The depth of the upper surface of the plume into which !! fluid is being entrained class ( scalar_field ), intent ( in ) :: density_diff !! The difference between the ambient density and the density of !! the plume into which the ambient fluid is being entrained. real ( r8 ), intent ( in ), optional :: time !! The time at which the entrainment is being calculated. If not !! present then assumed to be same as previous value passed. class ( scalar_field ), pointer :: entrainment !! The value of the entrainment class ( scalar_field ), pointer :: Ri , Sm call velocity % guard_temp (); call thickness % guard_temp () call depth % guard_temp (); call density_diff % guard_temp () call depth % allocate_scalar_field ( entrainment ) call entrainment % unset_temp () call depth % allocate_scalar_field ( Ri ) call depth % allocate_scalar_field ( Sm ) call Ri % guard_temp (); call Sm % guard_temp () entrainment = velocity % norm () ! Have to awkwardly split this operation to prevent ICE Ri = this % delta * density_diff * thickness / ( entrainment ** 2 ) Sm = Ri / ( 0.0725_r8 * ( Ri + 0.186_r8 - sqrt ( Ri ** 2 - 0.316_r8 * Ri + 0.0346_r8 ))) entrainment = this % coefficient * entrainment / Sm * sqrt ( 1._r8 + Ri / Sm ) call velocity % clean_temp (); call thickness % clean_temp () call depth % clean_temp (); call density_diff % clean_temp () call Ri % clean_temp (); call Sm % clean_temp () call entrainment % set_temp () end function kochergin1987_rate"},{"title":"kochergin1987_entrainment – ISOFT","tags":"","loc":"interface/kochergin1987_entrainment.html","text":"public interface kochergin1987_entrainment Calls interface~~kochergin1987_entrainment~~CallsGraph interface~kochergin1987_entrainment kochergin1987_entrainment proc~constructor~21 constructor interface~kochergin1987_entrainment->proc~constructor~21 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (coefficient, delta) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coefficient The entrainment coefficient c_L&#94;2x_0/D_0 real(kind=r8), intent(in) :: delta The ratio D_0/h_0 Return Value type( kochergin1987_entrainment ) A new entrainment object"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~22.html","text":"private pure function constructor(coefficient) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coefficient The entrainment coefficient, $E_0$ to be used Return Value type( jenkins1991_entrainment ) A new entrainment object Called by proc~~constructor~22~~CalledByGraph proc~constructor~22 constructor interface~jenkins1991_entrainment jenkins1991_entrainment interface~jenkins1991_entrainment->proc~constructor~22 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( coefficient ) result ( this ) real ( r8 ), intent ( in ) :: coefficient !! The entrainment coefficient, $E_0$ to be used type ( jenkins1991_entrainment ) :: this !! A new entrainment object this % coefficient = coefficient end function constructor"},{"title":"jenkins1991_rate – ISOFT","tags":"","loc":"proc/jenkins1991_rate.html","text":"private function jenkins1991_rate(this, velocity, thickness, depth, density_diff, time) result(entrainment) e = E_0 |\\vec{U}\\sin(\\theta) \\simeq E_0|\\vec{U}||\\nabla b| Here, E_0 is a coefficient typically taken to be 0.036 (the\n default value), \\vec{U} is the velocity of the plume, \\theta is the angle of slope of the ice shelf base, and b is the\n basal depth of the ice shelf. Warning The calculation must be performed as fortran\n this%coefficient * depth%d_dx(1) * velocity%norm() with the variables in a different order than how the equation is\n usually formulated. If they are in the correct order then gfortran expects the result to be a vector_field . It\n is not clear whether this is due to a bug in gfortran or in factual . Arguments Type Intent Optional Attributes Name class( jenkins1991_entrainment ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is being \n entrained. class(scalar_field), intent(in) :: thickness The thickness of the plume into which fluid is being\n entrained class(scalar_field), intent(in) :: depth The depth of the upper surface of the plume into which\n fluid is being entrained class(scalar_field), intent(in) :: density_diff The difference between the ambient density and the density of\n the plume into which the ambient fluid is being entrained. real(kind=r8), intent(in), optional :: time The time at which the entrainment is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the entrainment Contents Source Code jenkins1991_rate Source Code function jenkins1991_rate ( this , velocity , thickness , depth , density_diff , time ) & result ( entrainment ) !* Author: Christopher MacMackin !  Date: October 2016 ! ! e = E_0 |\\vec{U}\\sin(\\theta) \\simeq E_0|\\vec{U}||\\nabla b| ! Here, E_0 is a coefficient typically taken to be 0.036 (the ! default value), \\vec{U} is the velocity of the plume, \\theta ! is the angle of slope of the ice shelf base, and b is the ! basal depth of the ice shelf. ! ! @Warning ! The calculation must be performed as ! ```fortran ! this%coefficient * depth%d_dx(1) * velocity%norm() ! ``` ! with the variables in a different order than how the equation is ! usually formulated. If they are in the correct order then ! `gfortran` expects the result to be a `vector_field`. It ! is not clear whether this is due to a bug in `gfortran` or in ! `factual`. ! class ( jenkins1991_entrainment ), intent ( in ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is being !! entrained. class ( scalar_field ), intent ( in ) :: thickness !! The thickness of the plume into which fluid is being !! entrained class ( scalar_field ), intent ( in ) :: depth !! The depth of the upper surface of the plume into which !! fluid is being entrained class ( scalar_field ), intent ( in ) :: density_diff !! The difference between the ambient density and the density of !! the plume into which the ambient fluid is being entrained. real ( r8 ), intent ( in ), optional :: time !! The time at which the entrainment is being calculated. If not !! present then assumed to be same as previous value passed. class ( scalar_field ), pointer :: entrainment !! The value of the entrainment class ( vector_field ), pointer :: tmp call velocity % guard_temp (); call thickness % guard_temp () call depth % guard_temp (); call density_diff % guard_temp () call depth % allocate_scalar_field ( entrainment ) call depth % allocate_vector_field ( tmp ) entrainment = velocity % norm () call entrainment % unset_temp () tmp = . grad . depth entrainment = tmp % norm () ! Needed due to ICE when try to put all on one line. TODO: Create minimal example and submit bug report. entrainment = this % coefficient * entrainment * velocity % norm () call velocity % clean_temp (); call thickness % clean_temp () call depth % clean_temp (); call density_diff % clean_temp () call entrainment % set_temp () end function jenkins1991_rate"},{"title":"jenkins1991_entrainment – ISOFT","tags":"","loc":"interface/jenkins1991_entrainment.html","text":"public interface jenkins1991_entrainment Calls interface~~jenkins1991_entrainment~~CallsGraph interface~jenkins1991_entrainment jenkins1991_entrainment proc~constructor~22 constructor interface~jenkins1991_entrainment->proc~constructor~22 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (coefficient) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coefficient The entrainment coefficient, $E_0$ to be used Return Value type( jenkins1991_entrainment ) A new entrainment object"},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~23.html","text":"private pure function constructor(beta, melt_conversion, salinity_denom) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: beta The inverse stefan number, \\frac{c(T_a - T_m)}{L} real(kind=r8), intent(in) :: melt_conversion The factor to convert between the scale for melt used by\n Dallaston et al. (2015) and that used in ISOFT, \\frac{m_0x_0}{D_0U_0}, where m_0 is the melt scale\n used by Dalalston et al. real(kind=r8), intent(in), optional :: salinity_denom The factor which, when used to divide the melt_conversion term, produces a conversion factor for the melt-terms in the\n salinity equation of Dallaston et al. (2015). It has the form \\frac{Q_{g0}}{D_0U_0}, where Q_{g0} is the\n subglacial discharge across the grounding line. Return Value type( dallaston2015_melt ) The newly created object representing the melt relationship. Called by proc~~constructor~23~~CalledByGraph proc~constructor~23 constructor interface~dallaston2015_melt dallaston2015_melt interface~dallaston2015_melt->proc~constructor~23 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( beta , melt_conversion , salinity_denom ) result ( this ) real ( r8 ), intent ( in ) :: beta !! The inverse stefan number,  \\frac{c(T_a - T_m)}{L}  real ( r8 ), intent ( in ) :: melt_conversion !! The factor to convert between the scale for melt used by !! Dallaston et al. (2015) and that used in ISOFT,  !! \\frac{m_0x_0}{D_0U_0},  where m_0 is the melt scale !! used by Dalalston et al. real ( r8 ), intent ( in ), optional :: salinity_denom !! The factor which, when used to divide the `melt_conversion` !! term, produces a conversion factor for the melt-terms in the !! salinity equation of Dallaston et al. (2015). It has the form !!  \\frac{Q_{g0}}{D_0U_0},  where Q_{g0} is the !! subglacial discharge across the grounding line. type ( dallaston2015_melt ) :: this !! The newly created object representing the melt relationship. this % coef = ( beta + 1.0_r8 ) this % melt_conversion = melt_conversion if ( present ( salinity_denom )) this % salinity_denom = salinity_denom end function constructor"},{"title":"dallaston2015_heat – ISOFT","tags":"","loc":"proc/dallaston2015_heat.html","text":"private function dallaston2015_heat(this) result(heat) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the heat equation for a plume Contents Source Code dallaston2015_heat Source Code function dallaston2015_heat ( this ) result ( heat ) class ( dallaston2015_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: heat !! The value of the contribution made by melting/thermal !! transfer to the heat equation for a [[plume]] if (. not . allocated ( this % melt_values )) error stop ( 'Melt values not allocated' ) call this % melt_values % allocate_scalar_field ( heat ) heat = this % coef * this % melt_values end function dallaston2015_heat"},{"title":"dallaston2015_salt – ISOFT","tags":"","loc":"proc/dallaston2015_salt.html","text":"private function dallaston2015_salt(this) result(salt) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the salt equation for a plume Contents Source Code dallaston2015_salt Source Code function dallaston2015_salt ( this ) result ( salt ) class ( dallaston2015_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: salt !! The value of the contribution made by melting/thermal !! transfer to the salt equation for a [[plume]] if (. not . allocated ( this % melt_values )) error stop ( 'Melt values not allocated' ) call this % melt_values % allocate_scalar_field ( salt ) salt = this % melt_conversion / this % salinity_denom * this % melt_values end function dallaston2015_salt"},{"title":"dallaston2015_melt_rate – ISOFT","tags":"","loc":"proc/dallaston2015_melt_rate.html","text":"private function dallaston2015_melt_rate(this) result(melt) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate from the ice into the plume water. Contents Source Code dallaston2015_melt_rate Source Code function dallaston2015_melt_rate ( this ) result ( melt ) class ( dallaston2015_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate from the ice into the plume water. if (. not . allocated ( this % melt_values )) error stop ( 'Melt values not allocated' ) call this % melt_values % allocate_scalar_field ( melt ) melt = this % melt_conversion * this % melt_values end function dallaston2015_melt_rate"},{"title":"dallaston2015_has_heat – ISOFT","tags":"","loc":"proc/dallaston2015_has_heat.html","text":"private pure function dallaston2015_has_heat(this) result(has_heat) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat equation of the plume. Contents Source Code dallaston2015_has_heat Source Code pure function dallaston2015_has_heat ( this ) result ( has_heat ) class ( dallaston2015_melt ), intent ( in ) :: this logical :: has_heat !! Whether this formulation of melting contributes terms to !! the heat equation of the plume. has_heat = . true . end function dallaston2015_has_heat"},{"title":"dallaston2015_has_salt – ISOFT","tags":"","loc":"proc/dallaston2015_has_salt.html","text":"private pure function dallaston2015_has_salt(this) result(has_salt) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the salinity equation of the plume. Contents Source Code dallaston2015_has_salt Source Code pure function dallaston2015_has_salt ( this ) result ( has_salt ) class ( dallaston2015_melt ), intent ( in ) :: this logical :: has_salt !! Whether this formulation of melting contributes terms to !! the salinity equation of the plume. has_salt = . true . end function dallaston2015_has_salt"},{"title":"dallaston2015_solve – ISOFT","tags":"","loc":"proc/dallaston2015_solve.html","text":"private subroutine dallaston2015_solve(this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed. Contents Source Code dallaston2015_solve Source Code subroutine dallaston2015_solve ( this , velocity , pressure , temperature , & salinity , plume_thickness , time ) class ( dallaston2015_melt ), intent ( inout ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: pressure !! The water pressure at the interface where the melting occurs. class ( scalar_field ), intent ( in ) :: temperature !! The temperature of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: salinity !! The salinity of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: plume_thickness !! The thickness of the plume into which fluid is melting. real ( r8 ), intent ( in ), optional :: time !! The time at which the melting is being solved for. If not !! present then assumed to be same as previous value passed. call velocity % guard_temp (); call pressure % guard_temp () call temperature % guard_temp (); call salinity % guard_temp () call plume_thickness % guard_temp () if (. not . allocated ( this % melt_values )) then allocate ( this % melt_values , mold = salinity ) end if this % melt_values = velocity % norm () call velocity % clean_temp (); call pressure % clean_temp () call temperature % clean_temp (); call salinity % clean_temp () call plume_thickness % clean_temp () end subroutine dallaston2015_solve"},{"title":"dallaston2015_melt – ISOFT","tags":"","loc":"interface/dallaston2015_melt.html","text":"public interface dallaston2015_melt Calls interface~~dallaston2015_melt~~CallsGraph interface~dallaston2015_melt dallaston2015_melt proc~constructor~23 constructor interface~dallaston2015_melt->proc~constructor~23 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (beta, melt_conversion, salinity_denom) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: beta The inverse stefan number, \\frac{c(T_a - T_m)}{L} real(kind=r8), intent(in) :: melt_conversion The factor to convert between the scale for melt used by\n Dallaston et al. (2015) and that used in ISOFT, \\frac{m_0x_0}{D_0U_0}, where m_0 is the melt scale\n used by Dalalston et al. real(kind=r8), intent(in), optional :: salinity_denom The factor which, when used to divide the melt_conversion term, produces a conversion factor for the melt-terms in the\n salinity equation of Dallaston et al. (2015). It has the form \\frac{Q_{g0}}{D_0U_0}, where Q_{g0} is the\n subglacial discharge across the grounding line. Return Value type( dallaston2015_melt ) The newly created object representing the melt relationship."},{"title":"constructor – ISOFT","tags":"","loc":"proc/constructor~24.html","text":"private pure function constructor(coef1, coef2, fresh_sal, melt_temp) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coef1 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), intent(in) :: coef2 The unitless multiplier applied to the theram forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), intent(in), optional :: fresh_sal The salinity of fresh water. Defaults to 0. real(kind=r8), intent(in), optional :: melt_temp The melting point of the ice. Defaults to 0. Return Value type( one_equation_melt ) The newly created object representing the melt relationship. Called by proc~~constructor~24~~CalledByGraph proc~constructor~24 constructor interface~one_equation_melt one_equation_melt interface~one_equation_melt->proc~constructor~24 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code constructor Source Code pure function constructor ( coef1 , coef2 , fresh_sal , melt_temp ) result ( this ) real ( r8 ), intent ( in ) :: coef1 !! The unitless multiplier on the thermal forcing term, !! \\Gamma_Tx_0/D_0. real ( r8 ), intent ( in ) :: coef2 !! The unitless multiplier applied to the theram forcing term to !! get the melt rate, c_oT_0/L. real ( r8 ), intent ( in ), optional :: fresh_sal !! The salinity of fresh water. Defaults to 0. real ( r8 ), intent ( in ), optional :: melt_temp !! The melting point of the ice. Defaults to 0. type ( one_equation_melt ) :: this !! The newly created object representing the melt relationship. this % coef1 = coef1 this % coef2 = coef2 if ( present ( fresh_sal )) this % sal_forcing = - fresh_sal * coef2 if ( present ( melt_temp )) this % melt_temp = melt_temp end function constructor"},{"title":"one_equation_heat – ISOFT","tags":"","loc":"proc/one_equation_heat~2.html","text":"private function one_equation_heat(this) result(heat) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the heat equation for a plume Contents Source Code one_equation_heat Source Code function one_equation_heat ( this ) result ( heat ) class ( one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: heat !! The value of the contribution made by melting/thermal !! transfer to the heat equation for a [[plume]] if (. not . allocated ( this % forcing_values )) error stop ( 'Melt values not calculated' ) call this % forcing_values % allocate_scalar_field ( heat ) if ( this % melt_temp /= 0._r8 ) then heat = ( 1 - this % coef2 * this % melt_temp ) * this % forcing_values else heat = this % forcing_values end if call heat % set_temp () ! Shouldn't need to call this, but for some ! rason being set as non-temporary when ! assignment subroutine returns. end function one_equation_heat"},{"title":"one_equation_salt – ISOFT","tags":"","loc":"proc/one_equation_salt~2.html","text":"private function one_equation_salt(this) result(salt) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the salt equation for a plume Contents Source Code one_equation_salt Source Code function one_equation_salt ( this ) result ( salt ) class ( one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: salt !! The value of the contribution made by melting/thermal !! transfer to the salt equation for a [[plume]] if (. not . allocated ( this % forcing_values ) . and . this % sal_forcing /= 0._r8 ) then error stop ( 'Melt values not calculated' ) end if salt => this % sal_forcing * this % forcing_values end function one_equation_salt"},{"title":"one_equation_melt_rate – ISOFT","tags":"","loc":"proc/one_equation_melt_rate.html","text":"private function one_equation_melt_rate(this) result(melt) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate from the ice into the plume water. Contents Source Code one_equation_melt_rate Source Code function one_equation_melt_rate ( this ) result ( melt ) class ( one_equation_melt ), intent ( in ) :: this class ( scalar_field ), pointer :: melt !! The melt rate from the ice into the plume water. if (. not . allocated ( this % forcing_values )) error stop ( 'Melt values not calculated' ) melt => this % coef2 * this % forcing_values end function one_equation_melt_rate"},{"title":"one_equation_has_heat – ISOFT","tags":"","loc":"proc/one_equation_has_heat~2.html","text":"private pure function one_equation_has_heat(this) result(has_heat) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat equation of the plume. Contents Source Code one_equation_has_heat Source Code pure function one_equation_has_heat ( this ) result ( has_heat ) class ( one_equation_melt ), intent ( in ) :: this logical :: has_heat !! Whether this formulation of melting contributes terms to !! the heat equation of the plume. has_heat = . true . end function one_equation_has_heat"},{"title":"one_equation_has_salt – ISOFT","tags":"","loc":"proc/one_equation_has_salt~2.html","text":"private pure function one_equation_has_salt(this) result(has_salt) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the salinity equation of the plume. Contents Source Code one_equation_has_salt Source Code pure function one_equation_has_salt ( this ) result ( has_salt ) class ( one_equation_melt ), intent ( in ) :: this logical :: has_salt !! Whether this formulation of melting contributes terms to !! the salinity equation of the plume. has_salt = ( this % sal_forcing /= 0._r8 ) end function one_equation_has_salt"},{"title":"one_equation_solve – ISOFT","tags":"","loc":"proc/one_equation_solve~2.html","text":"private subroutine one_equation_solve(this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed. Contents Source Code one_equation_solve Source Code subroutine one_equation_solve ( this , velocity , pressure , temperature , & salinity , plume_thickness , time ) class ( one_equation_melt ), intent ( inout ) :: this class ( vector_field ), intent ( in ) :: velocity !! The velocity field of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: pressure !! The water pressure at the interface where the melting occurs. class ( scalar_field ), intent ( in ) :: temperature !! The temperature of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: salinity !! The salinity of the plume into which fluid is melting. class ( scalar_field ), intent ( in ) :: plume_thickness !! The thickness of the plume into which fluid is melting. real ( r8 ), intent ( in ), optional :: time !! The time at which the melting is being solved for. If not !! present then assumed to be same as previous value passed. call velocity % guard_temp (); call pressure % guard_temp () call temperature % guard_temp (); call salinity % guard_temp () call plume_thickness % guard_temp () if (. not . allocated ( this % forcing_values )) then allocate ( this % forcing_values , mold = temperature ) else if (. not . same_type_as ( this % forcing_values , temperature )) then deallocate ( this % forcing_values ) allocate ( this % forcing_values , mold = temperature ) end if this % forcing_values = this % coef1 * ( temperature - this % melt_temp ) * velocity % norm () call velocity % clean_temp (); call pressure % clean_temp () call temperature % clean_temp (); call salinity % clean_temp () call plume_thickness % clean_temp () end subroutine one_equation_solve"},{"title":"one_equation_melt – ISOFT","tags":"","loc":"interface/one_equation_melt.html","text":"public interface one_equation_melt Calls interface~~one_equation_melt~~CallsGraph interface~one_equation_melt one_equation_melt proc~constructor~24 constructor interface~one_equation_melt->proc~constructor~24 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures constructor Module Procedures private pure function constructor (coef1, coef2, fresh_sal, melt_temp) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coef1 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), intent(in) :: coef2 The unitless multiplier applied to the theram forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), intent(in), optional :: fresh_sal The salinity of fresh water. Defaults to 0. real(kind=r8), intent(in), optional :: melt_temp The melting point of the ice. Defaults to 0. Return Value type( one_equation_melt ) The newly created object representing the melt relationship."},{"title":"version – ISOFT","tags":"","loc":"proc/version.html","text":"module function version() Interface → Arguments None Return Value real Called by proc~~version~~CalledByGraph proc~version version interface~version version interface~version->proc~version proc~read_ice read_ice proc~read_ice->interface~version proc~write_data write_data proc~write_data->interface~version proc~read_sub_ice read_sub_ice proc~read_sub_ice->interface~version proc~read_data read_data proc~read_data->interface~version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code version Source Code module function version () version = version_num end function version"},{"title":"compile_time – ISOFT","tags":"","loc":"proc/compile_time.html","text":"module function compile_time() Interface → Arguments None Return Value real Called by proc~~compile_time~~CalledByGraph proc~compile_time compile_time interface~compile_time compile_time interface~compile_time->proc~compile_time proc~write_data write_data proc~write_data->interface~compile_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code compile_time Source Code module function compile_time () compile_time = compile_time_val end function compile_time"},{"title":"compile_info – ISOFT","tags":"","loc":"proc/compile_info.html","text":"module function compile_info() Interface → Arguments None Return Value real Called by proc~~compile_info~~CalledByGraph proc~compile_info compile_info interface~compile_info compile_info interface~compile_info->proc~compile_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code compile_info Source Code module function compile_info () character ( len = 40 ), parameter :: result_format = & '(\"Compiled with \",a,\" using options \",a)' write ( compile_info , result_format ) compiler_version (), compiler_options () compile_info = 'Compiled with \"' // compiler_version () // & '\" using options \"' // compiler_options () // & '\"' end function compile_info"},{"title":"meta_mod – ISOFT","tags":"","loc":"module/meta_mod.html","text":"Provides functions specifying the version of ISOFT, time of compilation, etc. Uses iso_fortran_env module~~meta_mod~~UsesGraph module~meta_mod meta_mod iso_fortran_env iso_fortran_env module~meta_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: meta_implementation_mod module~~meta_mod~~UsedByGraph module~meta_mod meta_mod module~cryosphere_mod cryosphere_mod module~cryosphere_mod->module~meta_mod module~meta_implementation_mod meta_implementation_mod module~meta_implementation_mod->module~meta_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables months time_format Interfaces version compile_time compile_info Functions current_time Variables Type Visibility Attributes Name Initial character(len=3), public, parameter, dimension(12) :: months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] character(len=42), public, parameter :: time_format = '(a3,1x,i2,1x,i4,1x,i2.2,\":\",'//'i2.2,\":\",i2.2)' Interfaces interface public module function version() Implementation → Returns the version number for ISOFT. Arguments None Return Value character(len=5) interface public module function compile_time() Implementation → Returns the date and time at which ISOFT was compiled. Arguments None Return Value character(len=20) interface public module function compile_info() Implementation → Returns compiler version and and flags. Arguments None Return Value character(len=1000) Functions public function current_time () Author Chris MacMackin Date November 2016 Returns the current date and time in the same format as the compile_time function. Arguments None Return Value character(len=20)"},{"title":"rksuite_90_prec – ISOFT","tags":"","loc":"module/rksuite_90_prec.html","text":"Uses iso_fortran_env module~~rksuite_90_prec~~UsesGraph module~rksuite_90_prec rksuite_90_prec iso_fortran_env iso_fortran_env module~rksuite_90_prec->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~rksuite_90_prec~~UsedByGraph module~rksuite_90_prec rksuite_90_prec module~rksuite_90 rksuite_90 module~rksuite_90->module~rksuite_90_prec module~upstream_plume_mod upstream_plume_mod module~upstream_plume_mod->module~rksuite_90 module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~upstream_plume_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~upstream_plume_mod module~plume_mod plume_mod module~plume_mod->module~upstream_plume_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables wp Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64"},{"title":"rksuite_90 – ISOFT","tags":"","loc":"module/rksuite_90.html","text":"Uses rksuite_90_prec module~~rksuite_90~~UsesGraph module~rksuite_90 rksuite_90 module~rksuite_90_prec rksuite_90_prec module~rksuite_90->module~rksuite_90_prec iso_fortran_env iso_fortran_env module~rksuite_90_prec->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~rksuite_90~~UsedByGraph module~rksuite_90 rksuite_90 module~upstream_plume_mod upstream_plume_mod module~upstream_plume_mod->module~rksuite_90 module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~upstream_plume_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~upstream_plume_mod module~plume_mod plume_mod module~plume_mod->module~upstream_plume_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces setup range_integrate step_integrate statistics global_error reset_t_end interpolate set_stop_on_fatal get_saved_fatal collect_garbage Derived Types rk_comm_real_1d Functions get_saved_state_r1 get_saved_fatal_r1 get_stop_on_fatal_r1 Subroutines machine_const method_const setup_r1 collect_garbage_r1 range_integrate_r1 step_integrate_r1 truerr_r1 step_r1 stiff_r1 statistics_r1 global_error_r1 reset_t_end_r1 interpolate_r1 rkmsg_r1 set_saved_state_r1 set_stop_on_fatal_r1 Interfaces public interface setup private subroutine setup_r1 (comm, t_start, y_start, t_end, tolerance, thresholds, method, task, error_assess, h_start, message) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ) :: comm real(kind=wp), intent(in) :: t_start real(kind=wp), intent(in), dimension(:) :: y_start real(kind=wp), intent(in) :: t_end real(kind=wp), intent(in) :: tolerance real(kind=wp), intent(in), dimension(:) :: thresholds character(len=*), intent(in), optional :: method character(len=*), intent(in), optional :: task logical, intent(in), optional :: error_assess real(kind=wp), intent(in), optional :: h_start logical, intent(in), optional :: message public interface range_integrate private recursive subroutine range_integrate_r1 (comm, f, t_want, t_got, y_got, yderiv_got, flag) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(in) :: t_want real(kind=wp), intent(out) :: t_got real(kind=wp), intent(out), dimension(:) :: y_got real(kind=wp), intent(out), dimension(:) :: yderiv_got integer, intent(out), optional :: flag public interface step_integrate private recursive subroutine step_integrate_r1 (comm, f, t_now, y_now, yderiv_now, flag) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(out) :: t_now real(kind=wp), intent(out), dimension(:) :: y_now real(kind=wp), intent(out), dimension(:) :: yderiv_now integer, intent(out), optional :: flag public interface statistics private subroutine statistics_r1 (comm, total_f_calls, step_cost, waste, num_succ_steps, h_next, y_maxvals) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm integer, intent(out), optional :: total_f_calls integer, intent(out), optional :: step_cost real(kind=wp), intent(out), optional :: waste integer, intent(out), optional :: num_succ_steps real(kind=wp), intent(out), optional :: h_next real(kind=wp), intent(out), optional dimension(:) :: y_maxvals public interface global_error private subroutine global_error_r1 (comm, rms_error, max_error, t_max_error) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm real(kind=wp), intent(out), optional dimension(:) :: rms_error real(kind=wp), intent(out), optional :: max_error real(kind=wp), intent(out), optional :: t_max_error public interface reset_t_end private subroutine reset_t_end_r1 (comm, t_end_new) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm real(kind=wp), intent(in) :: t_end_new public interface interpolate private subroutine interpolate_r1 (comm, f, t_want, y_want, yderiv_want) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout), target :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(in) :: t_want real(kind=wp), intent(out), optional dimension(:) :: y_want real(kind=wp), intent(out), optional dimension(:) :: yderiv_want public interface set_stop_on_fatal private subroutine set_stop_on_fatal_r1 (comm, action) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm logical, intent(in) :: action public interface get_saved_fatal private function get_saved_fatal_r1 (comm) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(in) :: comm Return Value logical public interface collect_garbage private subroutine collect_garbage_r1 (comm) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ) :: comm Derived Types type, public :: rk_comm_real_1d Components Type Visibility Attributes Name Initial real(kind=wp), private :: t real(kind=wp), private :: t_old real(kind=wp), private :: t_start real(kind=wp), private :: t_end real(kind=wp), private :: dir real(kind=wp), private :: h real(kind=wp), private :: h_old real(kind=wp), private :: h_start real(kind=wp), private :: h_average real(kind=wp), private :: tol integer, private :: f_count integer, private :: full_f_count integer, private :: step_count integer, private :: bad_step_count logical, private :: at_t_start logical, private :: at_t_end real(kind=wp), private, dimension(:), pointer :: thresh real(kind=wp), private, dimension(:), pointer :: weights real(kind=wp), private, dimension(:), pointer :: ymax real(kind=wp), private, dimension(:), pointer :: scratch real(kind=wp), private, dimension(:), pointer :: y real(kind=wp), private, dimension(:), pointer :: yp real(kind=wp), private, dimension(:), pointer :: y_new real(kind=wp), private, dimension(:), pointer :: y_old real(kind=wp), private, dimension(:), pointer :: yp_old real(kind=wp), private, dimension(:), pointer :: v0 real(kind=wp), private, dimension(:), pointer :: v1 real(kind=wp), private, dimension(:), pointer :: err_estimates real(kind=wp), private, dimension(:), pointer :: v2 real(kind=wp), private, dimension(:), pointer :: v3 real(kind=wp), private, dimension(:), pointer :: vtemp real(kind=wp), private, dimension(:,:), pointer :: stages real(kind=wp), private :: a (13,13) real(kind=wp), private :: b (13) real(kind=wp), private :: c (13) real(kind=wp), private :: bhat (13) real(kind=wp), private :: r (11,6) real(kind=wp), private :: e (7) integer, private :: ptr (13) integer, private :: no_of_stages integer, private :: rk_method integer, private :: intrp_degree logical, private :: intrp_able logical, private :: intrp_needs_stages real(kind=wp), private :: toosml real(kind=wp), private :: cost real(kind=wp), private :: safety real(kind=wp), private :: expon real(kind=wp), private :: stability_radius real(kind=wp), private :: tan_angle real(kind=wp), private :: rs real(kind=wp), private :: rs1 real(kind=wp), private :: rs2 real(kind=wp), private :: rs3 real(kind=wp), private :: rs4 integer, private :: order integer, private :: last_stage integer, private :: max_stiff_iters integer, private :: no_of_ge_steps logical, private :: fsal real(kind=wp), private :: ge_max_contrib real(kind=wp), private :: t_ge_max_contrib integer, private :: ge_f_count real(kind=wp), private, dimension(:), pointer :: ge_assess real(kind=wp), private, dimension(:), pointer :: ge_y real(kind=wp), private, dimension(:), pointer :: ge_yp real(kind=wp), private, dimension(:), pointer :: ge_y_new real(kind=wp), private, dimension(:), pointer :: ge_err_estimates real(kind=wp), private, dimension(:,:), pointer :: ge_stages logical, private :: erason logical, private :: erasfl real(kind=wp), private :: mcheps real(kind=wp), private :: dwarf real(kind=wp), private :: round_off real(kind=wp), private :: sqrrmc real(kind=wp), private :: cubrmc real(kind=wp), private :: sqtiny integer, private :: outch logical, private :: print_message logical, private :: use_range character(len=80), private :: rec (10) real(kind=wp), private :: tlast real(kind=wp), private :: range_t_end real(kind=wp), private, dimension(:), pointer :: xstage real(kind=wp), private, dimension(:), pointer :: ytemp real(kind=wp), private, dimension(:,:), pointer :: p integer, private :: stiff_bad_step_count integer, private :: hit_t_end_count real(kind=wp), private :: errold logical, private :: chkeff logical, private :: phase2 integer, private, dimension(7) :: save_states logical, private :: stop_on_fatal logical, private :: saved_fatal_err Functions private function get_saved_state_r1 (srname, save_states) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: srname integer, intent(inout), dimension(7) :: save_states Return Value integer private function get_saved_fatal_r1 (comm) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(in) :: comm Return Value logical private function get_stop_on_fatal_r1 (comm) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(in) :: comm Return Value logical Subroutines private subroutine machine_const (round_off, sqrrmc, cubrmc, sqtiny, outch) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out) :: round_off real(kind=wp), intent(out) :: sqrrmc real(kind=wp), intent(out) :: cubrmc real(kind=wp), intent(out) :: sqtiny integer, intent(out) :: outch private subroutine method_const (rk_method, a, b, c, bhat, r, e, ptr, no_of_stages, intrp_degree, intrp_able, intrp_needs_stages, cost, safety, expon, stability_radius, tan_angle, rs, rs1, rs2, rs3, rs4, order, last_stage, max_stiff_iters, no_of_ge_steps, fsal, cdiff) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rk_method real(kind=wp), intent(out) :: a (13,13) real(kind=wp), intent(out) :: b (13) real(kind=wp), intent(out) :: c (13) real(kind=wp), intent(out) :: bhat (13) real(kind=wp), intent(out) :: r (11,6) real(kind=wp), intent(out) :: e (7) integer, intent(out) :: ptr (13) integer, intent(out) :: no_of_stages integer, intent(out) :: intrp_degree logical, intent(out) :: intrp_able logical, intent(out) :: intrp_needs_stages real(kind=wp), intent(out) :: cost real(kind=wp), intent(out) :: safety real(kind=wp), intent(out) :: expon real(kind=wp), intent(out) :: stability_radius real(kind=wp), intent(out) :: tan_angle real(kind=wp), intent(out) :: rs real(kind=wp), intent(out) :: rs1 real(kind=wp), intent(out) :: rs2 real(kind=wp), intent(out) :: rs3 real(kind=wp), intent(out) :: rs4 integer, intent(out) :: order integer, intent(out) :: last_stage integer, intent(out) :: max_stiff_iters integer, intent(out) :: no_of_ge_steps logical, intent(out) :: fsal real(kind=wp), intent(out) :: cdiff private subroutine setup_r1 (comm, t_start, y_start, t_end, tolerance, thresholds, method, task, error_assess, h_start, message) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ) :: comm real(kind=wp), intent(in) :: t_start real(kind=wp), intent(in), dimension(:) :: y_start real(kind=wp), intent(in) :: t_end real(kind=wp), intent(in) :: tolerance real(kind=wp), intent(in), dimension(:) :: thresholds character(len=*), intent(in), optional :: method character(len=*), intent(in), optional :: task logical, intent(in), optional :: error_assess real(kind=wp), intent(in), optional :: h_start logical, intent(in), optional :: message private subroutine collect_garbage_r1 (comm) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ) :: comm private recursive subroutine range_integrate_r1 (comm, f, t_want, t_got, y_got, yderiv_got, flag) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(in) :: t_want real(kind=wp), intent(out) :: t_got real(kind=wp), intent(out), dimension(:) :: y_got real(kind=wp), intent(out), dimension(:) :: yderiv_got integer, intent(out), optional :: flag private recursive subroutine step_integrate_r1 (comm, f, t_now, y_now, yderiv_now, flag) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(out) :: t_now real(kind=wp), intent(out), dimension(:) :: y_now real(kind=wp), intent(out), dimension(:) :: yderiv_now integer, intent(out), optional :: flag private subroutine truerr_r1 (comm, f, ier) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) integer, intent(inout) :: ier private subroutine step_r1 (comm, f, tnow, y, yp, stages, tol, htry, y_new, errest, err, hmin, phase_2) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout), target :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(in) :: tnow real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: yp real(kind=wp), intent(out), dimension(:,:) :: stages real(kind=wp), intent(in) :: tol real(kind=wp), intent(inout) :: htry real(kind=wp), intent(out), dimension(:) :: y_new real(kind=wp), intent(out), dimension(:) :: errest real(kind=wp), intent(out) :: err real(kind=wp), intent(in), optional :: hmin logical, intent(inout), optional :: phase_2 private subroutine stiff_r1 (comm, f, toomch, sure_stiff) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout), target :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) logical, intent(in) :: toomch logical, intent(out) :: sure_stiff private subroutine statistics_r1 (comm, total_f_calls, step_cost, waste, num_succ_steps, h_next, y_maxvals) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm integer, intent(out), optional :: total_f_calls integer, intent(out), optional :: step_cost real(kind=wp), intent(out), optional :: waste integer, intent(out), optional :: num_succ_steps real(kind=wp), intent(out), optional :: h_next real(kind=wp), intent(out), optional dimension(:) :: y_maxvals private subroutine global_error_r1 (comm, rms_error, max_error, t_max_error) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm real(kind=wp), intent(out), optional dimension(:) :: rms_error real(kind=wp), intent(out), optional :: max_error real(kind=wp), intent(out), optional :: t_max_error private subroutine reset_t_end_r1 (comm, t_end_new) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm real(kind=wp), intent(in) :: t_end_new private subroutine interpolate_r1 (comm, f, t_want, y_want, yderiv_want) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout), target :: comm public function f(t, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(:) :: y Return Value real(kind=wp),\n  dimension(size(y,1)) real(kind=wp), intent(in) :: t_want real(kind=wp), intent(out), optional dimension(:) :: y_want real(kind=wp), intent(out), optional dimension(:) :: yderiv_want private subroutine rkmsg_r1 (ier, srname, nrec, comm, flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ier character(len=*), intent(in) :: srname integer, intent(in) :: nrec type( rk_comm_real_1d ), intent(inout) :: comm integer, intent(out), optional :: flag private subroutine set_saved_state_r1 (srname, state, comm) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: srname integer, intent(in) :: state type( rk_comm_real_1d ), intent(inout) :: comm private subroutine set_stop_on_fatal_r1 (comm, action) Arguments Type Intent Optional Attributes Name type( rk_comm_real_1d ), intent(inout) :: comm logical, intent(in) :: action"},{"title":"glacier_mod – ISOFT","tags":"","loc":"module/glacier_mod.html","text":"Provides an abstract type to represent large masses of ice, such\n as ice sheets and ice shelves. Uses iso_fortran_env factual_mod nitsol_mod hdf5 penf logger_mod module~~glacier_mod~~UsesGraph module~glacier_mod glacier_mod logger_mod logger_mod module~glacier_mod->logger_mod factual_mod factual_mod module~glacier_mod->factual_mod hdf5 hdf5 module~glacier_mod->hdf5 iso_fortran_env iso_fortran_env module~glacier_mod->iso_fortran_env penf penf module~glacier_mod->penf module~nitsol_mod nitsol_mod module~glacier_mod->module~nitsol_mod module~nitsol_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~glacier_mod~~UsedByGraph module~glacier_mod glacier_mod module~ice_shelf_mod ice_shelf_mod module~ice_shelf_mod->module~glacier_mod module~cryosphere_mod cryosphere_mod module~cryosphere_mod->module~glacier_mod module~ice_sheet_mod ice_sheet_mod module~ice_sheet_mod->module~glacier_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables hdf_type_attr Abstract Interfaces get_scalar get_r8 get_residual precond get_r81d get_i t_step solve_vel setter time_setter read_dat write_dat assign_ice thickness_func velocity_func Derived Types glacier Subroutines glacier_integrate glacier_integrate_layers Variables Type Visibility Attributes Name Initial character(len=12), public, parameter :: hdf_type_attr = 'glacier_type' Abstract Interfaces abstract interface private function get_scalar(this) result(property) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property of the glacier is being returned. abstract interface private pure function get_r8(this) result(property) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value real(kind=r8) The value of whatever property of the glacier is being returned. abstract interface private function get_residual(this, previous_states, melt_rate, basal_drag_parameter, water_density) result(residual) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to\n calculate the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier Return Value real(kind=r8),\n  dimension(:), allocatable The residual of the system of equations describing the\n glacier abstract interface private function precond(this, previous_states, melt_rate, basal_drag_parameter, water_density, delta_state) result(preconditioned) Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to\n calculate the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier real(kind=r8), intent(in), dimension(:) :: delta_state The change to the state vector which is being\n preconditioned. Return Value real(kind=r8),\n  dimension(:), allocatable The result of applying the preconditioner to delta_state . abstract interface private function get_r81d(this) result(state_vector) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector of the glacier abstract interface private pure function get_i(this) result(property) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value integer The value of whatever property of the glacier is being returned. abstract interface private function t_step(this) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this Return Value real(kind=r8) A time step which will allow integration of the ice shelf\n without causing numerical instability. abstract interface private subroutine solve_vel(this, basal_drag, success) Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. logical, intent(out) :: success True if the integration is successful, false otherwise abstract interface private subroutine setter(this, state_vector) Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n glacier. abstract interface private subroutine time_setter(this, time) Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the glacier is in the present state. abstract interface private subroutine read_dat(this, file_id, group_name, error) Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group from which the data\n will be read. character(len=*), intent(in) :: group_name The name of the group in the HDF5 file from which to read\n glacier's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. abstract interface private subroutine write_dat(this, file_id, group_name, error) Arguments Type Intent Optional Attributes Name class( glacier ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n glacier's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. abstract interface private subroutine assign_ice(this, rhs) Arguments Type Intent Optional Attributes Name class( glacier ), intent(out) :: this class( glacier ), intent(in) :: rhs abstract interface public pure function thickness_func(location) result(thickness) Abstract interface for function providing the glacier thickness\n when a concrete object is being instantiated. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the thickness Return Value real(kind=r8) The thickness of the glacier at location abstract interface public pure function velocity_func(location) result(velocity) Abstract interface for function providing the glacier velocity\n when a concrete object is being instantiated. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the thickness Return Value real(kind=r8),\n  dimension(:), allocatable The velocity vector of the ice in the glacier at location Derived Types type, public, abstract :: glacier An abstract data type which represents large masses of ice, such\n as ice shelves and ice sheets. Type-Bound Procedures procedure(get_scalar), public :: ice_thickness Returns the thickness of the ice in the glacier across the domain. procedure(get_r8), public :: ice_density Returns the density of the ice, which is assumed to be uniform. procedure(get_r8), public :: ice_temperature Returns the temperature of the ice, which is assumed to be uniform. procedure(get_residual), public :: residual Computes the residual of the system of equations describing the\n glacier. procedure(precond), public :: precondition Applies a preconditioner to the passed state vector. procedure(solve_vel), public :: solve_velocity Solves for the velocity field using the current thickness. procedure(setter), public :: update Sets the state of the glacier. procedure(time_setter), public :: set_time Sets the time record for this glacier. procedure(get_i), public :: data_size Returns the number of elements in the glacier's state vector procedure(get_r81d), public :: state_vector Returns the glacier's state vector, a 1D array with all necessary \n data to describe its state. procedure(read_dat), public :: read_data Read the glacier data from an HDF5 file on the disc. procedure(write_dat), public :: write_data Writes the data describing the glacier to the disc as an HDF5 file. procedure(t_step), public :: time_step Calculates the appropriate time step for integration. procedure(assign_ice), private :: assign Copies the data from one glacier into another. This is only\n needed due to a bug in gfortran which means that the\n intrinsic assignment for glacier types is not using the\n appropriate defined assignment for the field components. generic, public :: assignment(=) => assign procedure, public :: integrate => glacier_integrate Performs a time-step of the integration, taking the state of\n the glacier to the specified time using the provided\n melt-rate data. procedure, public :: integrate_layers => glacier_integrate_layers Dummy routine which can be over-ridden to integrate internal\n layers of the glacier to the specified time. Subroutines private subroutine glacier_integrate (this, old_states, basal_melt, basal_drag, water_density, time, success) Author Chris MacMackin Date November 2016 Integrates the glacier's state to time . This is done using the\n NITSOL package of iterative Krylov solvers. If a different\n algorithm for the integration is desired, then this method may\n be overridden in the concrete implementations of the glacier\n type. Read more… Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. class(scalar_field), intent(in) :: basal_melt The melt rate that the bottom of the glacier experiences\n during this time step. class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise private subroutine glacier_integrate_layers (this, old_states, time, success) Author Chris MacMackin Date September 2018 Dummy routine which does nothing. Arguments Type Intent Optional Attributes Name class( glacier ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise"},{"title":"transverse_coefficients_mod – ISOFT","tags":"","loc":"module/transverse_coefficients_mod.html","text":"Provides functions to calculate the coefficients for the\n horizontally-integrated [asymmetric_plume] from the basal slope of\n the ice shelf. This module just provides the interface. The\n implmentation is automatically generated by the Python script\n XXXXXXXX based on various parameter choices, approximating the\n coefficients using interpolation. Uses iso_fortran_env factual_mod module~~transverse_coefficients_mod~~UsesGraph module~transverse_coefficients_mod transverse_coefficients_mod factual_mod factual_mod module~transverse_coefficients_mod->factual_mod iso_fortran_env iso_fortran_env module~transverse_coefficients_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces alpha_du alpha_du2 alpha_d2 alpha_dv alpha_duv alpha_uvecu alpha_uvecv alpha_dus alpha_dut alpha_uvect alpha_ds alpha_dt alpha_ds_t alpha_dt_t f_d f_u f_v f_s f_t f_u_p f_v_p f_s_p f_t_p splev Interfaces interface public function alpha_du(b_x) Interpolates the value of \\alpha_{DU} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)dy for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_du2(b_x) Interpolates the value of \\alpha_{DU&#94;2} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)&#94;2dy for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_d2(b_x) Interpolates the value of \\alpha_{D&#94;2} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)&#94;2dy for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_dv(b_x) Interpolates the value of \\alpha_{DV} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_V(y)dy for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_duv(b_x) Interpolates the value of \\alpha_{DUV} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)f_V(y)dy for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_uvecu(b_x) Interpolates the value of \\alpha_{|\\vec{U}|U} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_{|\\vec{U}|}(y)f_U(y)dy for the given\n shelf slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_uvecv(b_x) Interpolates the value of \\alpha_{|\\vec{U}|V} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_{|\\vec{U}|}(y)f_V(y)dy for the given\n shelf slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_dus(b_x) Interpolates the value of \\alpha_{DUS} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)f_S(y)dy for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_dut(b_x) Interpolates the value of \\alpha_{DUT} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_U(y)f_T(y)dy for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_uvect(b_x) Interpolates the value of \\alpha_{|\\vec{U}|T} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_{|\\vec{U}|}(y)f_{T}(y)dy for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_ds(b_x) Interpolates the value of \\alpha_{DS} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_S(y)dy for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_dt(b_x) Interpolates the value of \\alpha_{DT} = \\frac{1}{\\Delta\n y}\\int&#94;{y_2}_{y_1}f_D(y)f_T(y)dy for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function alpha_ds_t(b_x) Interpolates the value of \\tilde{\\alpha}_{DS} = \\frac{1}{\\Delta\n y\\alpha_{D&#94;2}}\\int&#94;{y_2}_{y_1}f_D(y)&#94;2f_S(y)dy for the\n given shelf slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value real interface public function alpha_dt_t(b_x) Interpolates the value of \\tilde{\\alpha}_{DT} = \\frac{1}{\\Delta\n y\\alpha_{D&#94;2}}\\int&#94;{y_2}_{y_1}f_D(y)&#94;2f_T(y)dy for the\n given shelf slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function f_d(b_x) Interpolates the value of $f_D(y_2)$ for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function f_u(b_x) Interpolates the value of $f_U(y_2)$ for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function f_v(b_x) Interpolates the value of $f_V(y_2)$ for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function f_s(b_x) Interpolates the value of $f_S(y_2)$ for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function f_t(b_x) Interpolates the value of $f_T(y_2)$ for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function f_u_p(b_x) Interpolates the value of $f'_U(y_2)$ for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function f_v_p(b_x) Interpolates the value of $f'_V(y_2)$ for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function f_s_p(b_x) Interpolates the value of $f'_S(y_2)$ for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface public function f_t_p(b_x) Interpolates the value of $f'_T(y_2)$ for the given shelf\n slope. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: b_x Return Value class(scalar_field),\n  pointer interface private subroutine splev(t, n, c, k, x, y, m, e, ier) Subroutine splev evaluates in a number of points x(i),i=1,2,...,m\n  a spline s(x) of degree k, given in its b-spline representation. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(*) :: t Array, length n, which contains the position of the knots. integer, intent(in) :: n Integer, giving the total number of knots of s(x). real(kind=r8), intent(in), dimension(*) :: c Array, length n, which contains the b-spline coefficients. integer, intent(in) :: k Integer, giving the degree of s(x). real(kind=r8), intent(in), dimension(*) :: x Array, length m, which contains the points where s(x) must\n be evaluated. real(kind=r8), intent(out), dimension(*) :: y Array, length m, giving the value of s(x) at the different\n points. integer, intent(in) :: m Integer, giving the number of points where s(x) must be\n evaluated. integer, intent(in) :: e integer, if 0 the spline is extrapolated from the end\n spans for points not in the support, if 1 the spline\n evaluates to zero for those points, if 2 ier is set to\n 1 and the subroutine returns, and if 3 the spline evaluates\n to the value of the nearest boundary point. integer, intent(out) :: ier Error flag: ier = 0: normal return ier = 1: argument out of bounds and e == 2 ier =10: invalid input data (see restrictions)"},{"title":"asymmetric_plume_mod – ISOFT","tags":"","loc":"module/asymmetric_plume_mod.html","text":"Provides a concrete implementation of the basal_surface data type,\n representing a buoyant plume beneath an ice shelf. Uses iso_fortran_env basal_surface_mod factual_mod ode_solvers_mod entrainment_mod melt_relationship_mod plume_boundary_mod upstream_plume_mod boundary_types_mod ambient_mod equation_of_state_mod jenkins1991_entrainment_mod dallaston2015_melt_mod uniform_ambient_mod simple_plume_boundary_mod pseudospectral_block_mod coriolis_block_mod linear_eos_mod ave_linear_eos_mod hdf5 h5lt logger_mod penf module~~asymmetric_plume_mod~~UsesGraph module~asymmetric_plume_mod asymmetric_plume_mod module~ave_linear_eos_mod ave_linear_eos_mod module~asymmetric_plume_mod->module~ave_linear_eos_mod h5lt h5lt module~asymmetric_plume_mod->h5lt module~ode_solvers_mod ode_solvers_mod module~asymmetric_plume_mod->module~ode_solvers_mod module~simple_plume_boundary_mod simple_plume_boundary_mod module~asymmetric_plume_mod->module~simple_plume_boundary_mod module~plume_boundary_mod plume_boundary_mod module~asymmetric_plume_mod->module~plume_boundary_mod penf penf module~asymmetric_plume_mod->penf module~boundary_types_mod boundary_types_mod module~asymmetric_plume_mod->module~boundary_types_mod module~melt_relationship_mod melt_relationship_mod module~asymmetric_plume_mod->module~melt_relationship_mod factual_mod factual_mod module~asymmetric_plume_mod->factual_mod hdf5 hdf5 module~asymmetric_plume_mod->hdf5 module~coriolis_block_mod coriolis_block_mod module~asymmetric_plume_mod->module~coriolis_block_mod module~uniform_ambient_mod uniform_ambient_mod module~asymmetric_plume_mod->module~uniform_ambient_mod module~entrainment_mod entrainment_mod module~asymmetric_plume_mod->module~entrainment_mod module~upstream_plume_mod upstream_plume_mod module~asymmetric_plume_mod->module~upstream_plume_mod module~basal_surface_mod basal_surface_mod module~asymmetric_plume_mod->module~basal_surface_mod iso_fortran_env iso_fortran_env module~asymmetric_plume_mod->iso_fortran_env module~ambient_mod ambient_mod module~asymmetric_plume_mod->module~ambient_mod module~dallaston2015_melt_mod dallaston2015_melt_mod module~asymmetric_plume_mod->module~dallaston2015_melt_mod logger_mod logger_mod module~asymmetric_plume_mod->logger_mod module~equation_of_state_mod equation_of_state_mod module~asymmetric_plume_mod->module~equation_of_state_mod module~jenkins1991_entrainment_mod jenkins1991_entrainment_mod module~asymmetric_plume_mod->module~jenkins1991_entrainment_mod module~pseudospectral_block_mod pseudospectral_block_mod module~asymmetric_plume_mod->module~pseudospectral_block_mod module~linear_eos_mod linear_eos_mod module~asymmetric_plume_mod->module~linear_eos_mod module~ave_linear_eos_mod->factual_mod module~ave_linear_eos_mod->iso_fortran_env module~ave_linear_eos_mod->module~equation_of_state_mod module~ode_solvers_mod->penf module~ode_solvers_mod->iso_fortran_env module~ode_solvers_mod->logger_mod module~nitsol_mod nitsol_mod module~ode_solvers_mod->module~nitsol_mod module~simple_plume_boundary_mod->module~plume_boundary_mod module~simple_plume_boundary_mod->module~boundary_types_mod module~simple_plume_boundary_mod->factual_mod module~simple_plume_boundary_mod->iso_fortran_env module~plume_boundary_mod->module~boundary_types_mod module~plume_boundary_mod->factual_mod module~plume_boundary_mod->iso_fortran_env module~melt_relationship_mod->factual_mod module~melt_relationship_mod->iso_fortran_env module~coriolis_block_mod->penf module~coriolis_block_mod->factual_mod module~coriolis_block_mod->iso_fortran_env module~coriolis_block_mod->logger_mod module~coriolis_block_mod->module~pseudospectral_block_mod f95_lapack f95_lapack module~coriolis_block_mod->f95_lapack module~uniform_ambient_mod->factual_mod module~uniform_ambient_mod->iso_fortran_env module~uniform_ambient_mod->module~ambient_mod module~entrainment_mod->factual_mod module~entrainment_mod->iso_fortran_env module~upstream_plume_mod->module~plume_boundary_mod module~upstream_plume_mod->penf module~upstream_plume_mod->module~boundary_types_mod module~upstream_plume_mod->factual_mod module~upstream_plume_mod->iso_fortran_env module~upstream_plume_mod->logger_mod module~rksuite_90 rksuite_90 module~upstream_plume_mod->module~rksuite_90 module~uniform_gradient_field_mod uniform_gradient_field_mod module~upstream_plume_mod->module~uniform_gradient_field_mod module~basal_surface_mod->factual_mod module~basal_surface_mod->hdf5 module~basal_surface_mod->iso_fortran_env module~basal_surface_mod->module~nitsol_mod module~ambient_mod->factual_mod module~ambient_mod->iso_fortran_env module~dallaston2015_melt_mod->module~melt_relationship_mod module~dallaston2015_melt_mod->factual_mod module~dallaston2015_melt_mod->iso_fortran_env module~equation_of_state_mod->factual_mod module~equation_of_state_mod->iso_fortran_env module~jenkins1991_entrainment_mod->factual_mod module~jenkins1991_entrainment_mod->module~entrainment_mod module~jenkins1991_entrainment_mod->iso_fortran_env module~pseudospectral_block_mod->penf module~pseudospectral_block_mod->factual_mod module~pseudospectral_block_mod->iso_fortran_env module~pseudospectral_block_mod->logger_mod chebyshev_mod chebyshev_mod module~pseudospectral_block_mod->chebyshev_mod module~linear_eos_mod->factual_mod module~linear_eos_mod->iso_fortran_env module~linear_eos_mod->module~equation_of_state_mod module~nitsol_mod->iso_fortran_env module~rksuite_90_prec rksuite_90_prec module~rksuite_90->module~rksuite_90_prec module~uniform_gradient_field_mod->factual_mod module~uniform_gradient_field_mod->iso_fortran_env utils_mod utils_mod module~uniform_gradient_field_mod->utils_mod module~rksuite_90_prec->iso_fortran_env var panmoduleasymmetric_plume_modUsesGraph = svgPanZoom('#moduleasymmetric_plume_modUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables hdf_type_name hdf_thickness hdf_velocity hdf_temperature hdf_salinity hdf_delta hdf_nu hdf_mu hdf_r hdf_phi Abstract Interfaces scalar_func velocity_func Derived Types plume_shape asym_plume Functions asym_plume_melt asym_plume_drag_parameter asym_plume_water_density asym_plume_data_size asym_plume_state_vector Subroutines asym_plume_initialise asym_plume_update asym_plume_read_data asym_plume_write_data asym_plume_solve Variables Type Visibility Attributes Name Initial character(len=10), public, parameter :: hdf_type_name = 'asym_plume' character(len=9), public, parameter :: hdf_thickness = 'thickness' character(len=8), public, parameter :: hdf_velocity = 'velocity' character(len=11), public, parameter :: hdf_temperature = 'temperature' character(len=8), public, parameter :: hdf_salinity = 'salinity' character(len=5), public, parameter :: hdf_delta = 'delta' character(len=2), public, parameter :: hdf_nu = 'nu' character(len=2), public, parameter :: hdf_mu = 'mu' character(len=5), public, parameter :: hdf_r = 'r_val' character(len=3), public, parameter :: hdf_phi = 'phi' Abstract Interfaces abstract interface private pure function scalar_func(location) result(scalar) Abstract interface for function providing the initial values\n for the scalar properties of an asym_plume object\n when it is being instantiated. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the property Return Value real(kind=r8) The value of the scalar quantity at location abstract interface private pure function velocity_func(location) result(vector) Abstract interface for function providing the asym_plume velocity when an object is being\n instantiated. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the thickness Return Value real(kind=r8),\n  dimension(:), allocatable The velocity vector of the water in the plume at location Derived Types type, public :: plume_shape A type containing the data necessary to specify the transverse\n shape of the plume. All variables in the plume are assumed to be\n seperable with the form D(x,y) = f_D2(y)\\hat{D}(x) , U(x,y)\n = f_U2(y)\\hat{U}(x) , etc. The magnitude of the velocity does\n not necessary take the form |\\vec{U}| = \\sqrt{U&#94;2 + V&#94;2} and\n is treated as an independent seperable variable |\\vec{U}| =\n f_{|\\vec{U}|}(y)\\widehat{|\\vec{U}|}(x) . The transverse\n functions f_{D}(y) , f_U2(y) , etc. have all been\n normalised over the integration width y_1 to y_2 . Read more… Components Type Visibility Attributes Name Initial real(kind=r8), public :: f_D1 = 1.0_r8 f_D2(y_1) real(kind=r8), public :: f_D2 = 1.0_r8 f_D2(y_2) real(kind=r8), public :: f_U1 = 1.0_r8 f_U2(y_1) real(kind=r8), public :: f_U2 = 1.0_r8 f_U2(y_2) real(kind=r8), public :: f_V1 = 1.0_r8 f_V2(y_1) real(kind=r8), public :: f_V2 = 1.0_r8 f_V2(y_2) real(kind=r8), public :: f_S1 = 1.0_r8 f_S2(y_1) real(kind=r8), public :: f_S2 = 1.0_r8 f_S2(y_2) real(kind=r8), public :: f_T1 = 1.0_r8 f_T2(y_1) real(kind=r8), public :: f_T2 = 1.0_r8 f_T2(y_2) real(kind=r8), public :: f_Up = 0.0_r8 df_U2(y_2)/dy real(kind=r8), public :: f_Vp = 0.0_r8 df_V2(y_2)/dy real(kind=r8), public :: f_Sp = 0.0_r8 df_S2(y_2)/dy real(kind=r8), public :: f_Tp = 0.0_r8 df_T2(y_2)/dy real(kind=r8), public :: a_DU = 1.0_r8 \\alpha_{DU} = \\overline{f_D2 f_U2} real(kind=r8), public :: a_DV = 1.0_r8 \\alpha_{DV} = \\overline{f_D2 f_V2} real(kind=r8), public :: a_DU2 = 1.0_r8 \\alpha_{DU&#94;2} = \\overline{f_D2 f_U2&#94;2} real(kind=r8), public :: a_DUV = 1.0_r8 \\alpha_{DUV} = \\overline{f_D2 f_U2 f_V2} real(kind=r8), public :: a_D2 = 1.0_r8 \\alpha_{D&#94;2} = \\overline{f_D2&#94;2} real(kind=r8), public :: a_UabsU = 1.0_r8 \\alpha_{|\\vec{U}|U} = \\overline{f_{|\\vec{U}|} f_U2 real(kind=r8), public :: a_UabsV = 1.0_r8 \\alpha_{|\\vec{U}|V} = \\overline{f_{|\\vec{U}|} f_V2 real(kind=r8), public :: a_DUS = 1.0_r8 \\alpha_{DUS} = \\overline{f_D2 f_U2 f_S2} real(kind=r8), public :: a_DUT = 1.0_r8 \\alpha_{DUT} = \\overline{f_D2 f_U2 f_T2} real(kind=r8), public :: a_UabsT = 1.0_r8 \\alpha_{|\\vec{U}|T} = \\overline{f_{|\\vec{U}|} f_T2 real(kind=r8), public :: a_DS = 1.0_r8 \\alpha_{DS} = \\overline{f_D2 f_S2} real(kind=r8), public :: a_DT = 1.0_r8 \\alpha_{DT} = \\overline{f_D2 f_T2} real(kind=r8), public :: a_DS_t = 1.0_r8 \\tilde{\\alpha}_{DS} = \\overline{f_D2 f_S2}/\\alpha_{D&#94;2} real(kind=r8), public :: a_DT_t = 1.0_r8 \\tilde{\\alpha}_{DT} = \\overline{f_D2 f_T2}/\\alpha_{D&#94;2} type, public, extends( basal_surface ) :: asym_plume A concrete implementation of the basal_surface abstract data type, representing the buoyant plume beneath an\n ice shelf, which has been horizontally integrated over width \\Delta y = y_2 - y_1 in the y-direction. Transverse\n variation is assumed to be seperable, with variables having the\n form D(x,y) = f_D2(y)\\hat{D}(x) , U(x,y) =\n f_U2(y)\\hat{U}(x) . The shape of the transverse functions are\n described using the plume_shape type. Components Type Visibility Attributes Name Initial type(cheb1d_scalar_field), private :: thickness The thickness of the plume type(cheb1d_vector_field), private :: velocity The velocity of the plume type(cheb1d_vector_field), private :: velocity_dx The derivative of the velocity field type(cheb1d_scalar_field), private :: temperature The temperature of the plume type(cheb1d_scalar_field), private :: temperature_dx The derivative of the temperature of the plume type(cheb1d_scalar_field), private :: salinity The salinity of the plume type(cheb1d_scalar_field), private :: salinity_dx The derivative of the salinity of the plume class( abstract_entrainment ), private, allocatable :: entrainment_formulation An object which provides the parameterisation for entrainment\n of water into the plume. class( abstract_melt_relationship ), private, allocatable :: melt_formulation An object which provides the parameterisation for melting,\n salt, and heat fluxes from the plume to the ice. class( ambient_conditions ), private, allocatable :: ambient_conds An object specifying the temperature and salinity of the\n ambient ocean at its interface with the plume. class( equation_of_state ), public, allocatable :: eos An object specifying the equation of state relating the plume\n water's density to its temperature and salinity. class( plume_boundary ), private, allocatable :: boundaries An object specifying the boundary conditions for the plume. real(kind=r8), private :: delta The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real(kind=r8), public :: nu The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real(kind=r8), private :: mu The dimensionless ratio \\mu \\equiv \\frac{\\C_dx_0}{D_0} real(kind=r8), private :: r_val The dimensionless ratio of the ocean water density to the\n density of the overlying ice shelf. real(kind=r8), public :: phi The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} type( plume_shape ), public :: shape The coefficients describing the transverse shape of the\n plume. real(kind=r8), private :: dy The width \\Delta y = y_2-y_1 over which the plume has\n been horizontally averaged. real(kind=r8), private :: time The time at which the ice shelf is in this state integer, private :: thickness_size The number of data values in the thickness field integer, private :: velocity_size The number of data values in the velocity field integer, private :: temperature_size The number of data values in the temperature field integer, private :: salinity_size the number of data values in the salinity field integer, private :: vel_dims The number of vector dimensions for the velocity logical, private, dimension(7) :: lower_bounds = .false. Which variables have boundary conditions at the grounding\n line. logical, private, dimension(7) :: upper_bounds = .false. Which variables have boundary conditions at the calving\n front. type( pseudospec_block ), private :: precond A pseudospectral differentiation block which can be used for\n preconditioning. type( coriolis_block ), private :: vel_precond A representation of the operation on the plume velocity terms\n which can be used for preconditioning. Type-Bound Procedures procedure, public :: initialise => asym_plume_initialise procedure, public :: basal_melt => asym_plume_melt procedure, public :: basal_drag_parameter => asym_plume_drag_parameter procedure, public :: water_density => asym_plume_water_density procedure, public :: update => asym_plume_update procedure, public :: data_size => asym_plume_data_size procedure, public :: state_vector => asym_plume_state_vector procedure, public :: read_data => asym_plume_read_data procedure, public :: write_data => asym_plume_write_data procedure, public :: solve => asym_plume_solve Functions private function asym_plume_melt (this) result(melt) Author Christopher MacMackin Date April 2016 Computes and returns the melt rate at the bottom of the ice\n shelf due to interaction with the plume. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice shelf. private function asym_plume_drag_parameter (this) result(drag) Author Christopher MacMackin Date April 2016 Computes and returns a quantity which may be necessary to determine\n the frictional drag the plume exerts on the bottom of the ice\n shelf. The plume would actually tend to exert no drag on the bottom\n of the ice shelf, but this method is present so that there is a\n consistent interface with the ground data type. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. private function asym_plume_water_density (this) result(density) Author Christopher MacMackin Date April 2016 Computes and returns the density of the plume water beneath the ice\n shelf. The density of this water would vary depending on how much \n saline ambient water has been entrained into the plume versus how\n much fresh water has been released due to melting. However, the\n Boussinesq approximation is used here and only a single reference \n density is returned. Read more… Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value real(kind=r8) The density of the water at the base of the ice sheet. private function asym_plume_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the plume's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value integer The number of elements in the plume's state vector. private function asym_plume_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the plume. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the plume. Subroutines private subroutine asym_plume_initialise (this, domain, resolution, thickness, velocity, temperature, salinity, shape, entrainment_formulation, melt_formulation, ambient_conds, eos, boundaries, delta, nu, mu, r_val, phi, dy) Author Christopher MacMackin Date April 2016 Instantiates an asym_plume object with initial\n coniditions provided by the arguments.At present only a 1D model\n is supported. If information is provided for higher dimensions\n then it will be ignored. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(out) :: this A plume object with its domain and initial conditions set according\n to the arguments of the constructor function. real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the plume. The first index represents the dimension for which the\n boundaries apply. If the second index is 1 then it corresponds to\n the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( scalar_func ) :: thickness A function which calculates the initial value of the thickness of \n the plume at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the water at a given location in a plume. procedure( scalar_func ) :: temperature A function which calculates the initial value of the temperature of \n the plume at a given location. procedure( scalar_func ) :: salinity A function which calculates the initial value of the salinity of \n the plume at a given location. type( plume_shape ), intent(in), optional :: shape An object with components describing the transverse profile\n of the plume. Default is a plume that is uniform in the\n transverse direction. class( abstract_entrainment ), intent(inout), optional allocatable :: entrainment_formulation An object which calculates entrainment into the plume. Will\n be unallocated on exit. Defaults to that used by Jenkins\n (1991) with the coefficient $E_0 = 1$. class( abstract_melt_relationship ), intent(inout), optional allocatable :: melt_formulation An object which calculates melting and the resulting thermal\n transfer into/out of the plume. Will be unallocated on\n exit. Defaults to that used by Dallaston et al. (2015),\n scaled to be consistent with the nondimensionalisation used\n here. class( ambient_conditions ), intent(inout), optional allocatable :: ambient_conds An object specifying the salinity and temperature of the\n ambient ocean. Will be unallocated on exit. Defaults to\n uniform ambient salinity and temperature, both of which are\n set to 0 (as temperature and salinity are measured relative\n to some reference value). class( equation_of_state ), intent(inout), optional allocatable :: eos An object specifying the equation of state for the water in\n the plume. Will be unallocated on exit. Defaults to\n linearised equation of state with no temperature dependence\n and a haline contraction coefficient of 1. The reference\n density is set to be 1 in the dimensionless units when\n salinity and temeprature are 0. class( plume_boundary ), intent(inout), optional allocatable :: boundaries An object providing the boundary conditions for the\n plume. Will be unallocated on exit. Defaults to those used by\n Dallaston et al. (2015). real(kind=r8), intent(in), optional :: delta The dimensionless ratio \\delta \\equiv\n \\frac{D_0}{h_0} . Defaults to 0.036. real(kind=r8), intent(in), optional :: nu The dimensionless ratio \\nu \\equiv\n \\frac{\\kappa_0}{x_0U_o} . Defaults to 0. real(kind=r8), intent(in), optional :: mu The dimensionless ratio \\mu \\equiv\n \\frac{C_dx_0}{D_0} . Defaults to 0. real(kind=r8), intent(in), optional :: r_val The dimensionless ratio of the water density to the ice shelf\n density, r = \\rho_0/\\rho_i. Defaults to 1.12. real(kind=r8), intent(in), optional :: phi The inverse Rossby number, \\Phi \\equiv\n \\frac{fx_0}{U_0} . Defaults to 0. real(kind=r8), intent(in), optional :: dy The width over which the plume has been averaged. Defualts to 1. private subroutine asym_plume_update (this, state_vector, ice_thickness) Author Christopher MacMackin Date April 2016 Updates the state of the plume from its state vector. The state\n vector is a real array containing the value of each of the plume's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n plume. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate. private subroutine asym_plume_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the plume object from an HDF file in the\n specified group. This sets the thickness, velocity, temperature,\n salinity dataset, and parameter values. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine asym_plume_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the plume object to an HDF file in the\n specified group. This will consist of a thickness, a velocity, a\n temperature, and a salinity dataset. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine asym_plume_solve (this, ice_thickness, ice_density, ice_temperature, time, success) Author Chris MacMackin Date March 2017 Solves the state of the plume for the specified ice properties,\n at the specified time. This is done using the a\n quasilinearisation method and a GMRES iterative linear solver. Arguments Type Intent Optional Attributes Name class( asym_plume ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise"},{"title":"ambient_mod – ISOFT","tags":"","loc":"module/ambient_mod.html","text":"Provides an abstract derived type which can be subtyped in order to\n specify the temperature and salinity of the ambient ocean. Uses iso_fortran_env factual_mod module~~ambient_mod~~UsesGraph module~ambient_mod ambient_mod factual_mod factual_mod module~ambient_mod->factual_mod iso_fortran_env iso_fortran_env module~ambient_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~ambient_mod~~UsedByGraph module~ambient_mod ambient_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~ambient_mod module~uniform_ambient_mod uniform_ambient_mod module~asymmetric_plume_mod->module~uniform_ambient_mod module~uniform_ambient_mod->module~ambient_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~ambient_mod module~static_plume_mod->module~uniform_ambient_mod module~plume_mod plume_mod module~plume_mod->module~ambient_mod module~plume_mod->module~uniform_ambient_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces get_property Derived Types ambient_conditions Abstract Interfaces abstract interface private function get_property(this, depth, t) result(property) Arguments Type Intent Optional Attributes Name class( ambient_conditions ), intent(in) :: this class(scalar_field), intent(in) :: depth A field containing the depths at which the ambient conditions\n are to be calculated. real(kind=r8), intent(in) :: t The time at which the ambient conditions are to be calculated. Return Value class(scalar_field),\n  pointer A field containing the ambient conditions at the depth specified\n for each location. Derived Types type, public, abstract :: ambient_conditions An abstract type to which procedures for getting the ambient ocean\n conditions are to be specified. The descendent types can contain\n whatever data is needed to compute the result. Type-Bound Procedures procedure(get_property), public :: ambient_temperature Returns the ambient ocean temperature procedure(get_property), public :: ambient_salinity Returns the ambient ocean temperature"},{"title":"linear_eos_mod – ISOFT","tags":"","loc":"module/linear_eos_mod.html","text":"Provides an abstract derived type which can be subtyped in order to\n implement an equation of state. Uses iso_fortran_env factual_mod equation_of_state_mod module~~linear_eos_mod~~UsesGraph module~linear_eos_mod linear_eos_mod factual_mod factual_mod module~linear_eos_mod->factual_mod iso_fortran_env iso_fortran_env module~linear_eos_mod->iso_fortran_env module~equation_of_state_mod equation_of_state_mod module~linear_eos_mod->module~equation_of_state_mod module~equation_of_state_mod->factual_mod module~equation_of_state_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~linear_eos_mod~~UsedByGraph module~linear_eos_mod linear_eos_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~linear_eos_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~linear_eos_mod module~plume_mod plume_mod module~plume_mod->module~linear_eos_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables absolute_zero Interfaces linear_eos Derived Types linear_eos Functions constructor linear_water_density linear_water_deriv linear_haline_contraction linear_thermal_contraction Variables Type Visibility Attributes Name Initial real(kind=r8), private, parameter :: absolute_zero = -273.15_r8 Interfaces public interface linear_eos private pure function constructor (ref_rho, ref_t, ref_s, beta_t, beta_s) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: ref_rho The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), intent(in) :: ref_t The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), intent(in) :: ref_s The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), intent(in) :: beta_t The thermal contraction coefficient, \\beta_T . real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S . Return Value type( linear_eos ) Derived Types type, public, extends( equation_of_state ) :: linear_eos A linearised implementation of the equation of state, of the\n form \\rho = \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)]. Components Type Visibility Attributes Name Initial real(kind=r8), private :: ref_rho = 1.0_r8 The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), private :: ref_t = 0.0_r8 The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), private :: ref_s = 0.0_r8 The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), private :: beta_t = 0.0_r8 The thermal contraction coefficient, \\beta_T . real(kind=r8), private :: beta_s = 1.0_r8 The haline contraction coefficient, \\beta_S . Constructor private pure function constructor (ref_rho, ref_t, ref_s, beta_t, beta_s) Type-Bound Procedures procedure, public :: water_density => linear_water_density procedure, public :: water_density_derivative => linear_water_deriv procedure, public :: haline_contraction => linear_haline_contraction procedure, public :: thermal_contraction => linear_thermal_contraction Functions private pure function constructor (ref_rho, ref_t, ref_s, beta_t, beta_s) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: ref_rho The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), intent(in) :: ref_t The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), intent(in) :: ref_s The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), intent(in) :: beta_t The thermal contraction coefficient, \\beta_T . real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S . Return Value type( linear_eos ) private function linear_water_density (this, temperature, salinity) result(density) Author Chris MacMackin Date November 2016 Calculates the density of the water from the temperature and\n salinity, using a linear equatino of state, \\rho =\n \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)]. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water private function linear_water_deriv (this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Author Chris MacMackin Date November 2016 Calculates the derivative of the water density from the\n temperature and salinity, using a linear equatino of state, \\rho = \\rho_0[1-\\beta_T(T-T_0) + \\beta_S(S-S_0)]. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the density of the water private function linear_haline_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date June 2017 Returns the haline contraction coefficient. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable private function linear_thermal_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date June 2017 Returns the thermal contraction coefficient. Arguments Type Intent Optional Attributes Name class( linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable"},{"title":"rootfind – ISOFT","tags":"","loc":"module/rootfind.html","text":"Provides subroutines implementing various root-finding algorithms, \n as well as a global bracket finder. Contents Subroutines bis_secant global_bis_sec global_brackets Subroutines public subroutine bis_secant (error, fnctn, maxerr, maxsteps, steps, xcur, xleft, xright) A root finder using the hybrid bisection-secant algorithm.\n Returns a computed value of the root within xleft and xright\n once error < maxerr or has run maximum number of iterations. Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: error A real variable in which an estimate of the error in the\n computed root will be stored and returned. public pure function fnctn(x) The Fortran function for which the root will be\n found. Must take only one real argument, return a\n real argument. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x Return Value real(kind=8) real(kind=8), intent(in) :: maxerr A real value which specifies the the maximum allowable\n error in the computed root. The subroutine terminates\n once the error passes below this level. integer, intent(in) :: maxsteps An integer value for the maximum number of iterations\n applied to the algorithm before terminating. integer, intent(out) :: steps Returns the number of iterations needed before error\n falls below maxerr (or returns maxsteps if that many\n iterations occur first). real(kind=8), intent(out) :: xcur A real variable in which the computed value of the root\n will be returned. real(kind=8), intent(inout) :: xleft A real value specifying lower bound within which to\n search for root. real(kind=8), intent(inout) :: xright A real value specifying upper bound within which to\n search for root. public subroutine global_bis_sec (dx, error, fnctn, maxerr, maxsteps, numroots, roots, steps, verbose, xmax, xmin) A subroutine which finds the values of all roots of a\n function (or as many as will fit into the provided arrays)\n within a given range of values. This subroutine uses the\n hybrid bisection-secant root-finding algorithm. Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: dx The initial size of increment to use when examining\n function.  Minimum interval will be 0.01 of this. real(kind=8), intent(out), dimension(:) :: error A real array in which an estimate of the error in each\n computed root will be stored and returned. public pure function fnctn(x) The Fortran function for which the root will be\n found. Must take only one real argument, return a\n real argument. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x Return Value real(kind=8) real(kind=8), intent(in) :: maxerr A real value which specifies the the maximum allowable\n error in the computed root. The subroutine terminates\n once the error passes below this level. integer, intent(in) :: maxsteps An integer value for the maximum number of iterations\n applied to the algorithm before terminating. integer, intent(out) :: numroots An integer value which will return the number of roots\n for which brackets were found. A negative number\n indicates that an error occurred. real(kind=8), intent(out), dimension(:) :: roots A real array in which the computed values of each root\n will be returned. integer, intent(out), dimension(:) :: steps An integer array in which the number of iterations needed\n before error falls below maxerr for each root is stored\n and returned. logical, intent(in) :: verbose A logical variable which specifies whether to print\n progress to stdout as brackets found and at each\n iteration as root found. Also says whether to print a\n warning if 'dx' set to 'dxmin' during 'globrack' routine\n and if maximum number of iterations reached while finding\n root. real(kind=8), intent(in) :: xmax The upper limit of the range on which the subroutine will\n search for roots and brackets. real(kind=8), intent(in) :: xmin The lower limit of the range on which the subroutine will\n search for roots and brackets. public subroutine global_brackets (brackets, dx, fnctn, numroots, verbose, xmax, xmin) A global bracket finder. For a given function it finds values\n on each side of each of the function's roots within a given\n range. Arguments Type Intent Optional Attributes Name real(kind=8), intent(out), dimension(:,:) :: brackets A 2 by n real array in which the left and right brackets\n will be stored and returned. Will find up to n sets of\n brackets. real(kind=8), intent(inout) :: dx The initial size of increment to use when examining\n function.  Minimum interval will be 0.01 of this. public pure function fnctn(x) The Fortran function for which the brackets will be\n found. Must take only one real argument, return a\n real argument. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x Return Value real(kind=8) integer, intent(out) :: numroots An integer value which will return the number of roots\n for which brackets were found. A negative number\n indicates that an error occurred. logical, intent(in) :: verbose A logical variable which specifies whether to print to\n stdout any bracket values which are found and warning\n messages when 'dx' set to 'dxmin'. real(kind=8), intent(in) :: xmax The upper limit of the range on which the subroutine will\n search for roots and brackets. real(kind=8), intent(in) :: xmin The lower limit of the range on which the subroutine will\n search for roots and brackets."},{"title":"static_plume_mod – ISOFT","tags":"","loc":"module/static_plume_mod.html","text":"Provides a concrete implementation of the basal_surface data type, representing a buoyant plume beneath an ice shelf. This\n implementation does not evolve the plume. Uses iso_fortran_env basal_surface_mod factual_mod ode_solvers_mod entrainment_mod melt_relationship_mod plume_boundary_mod upstream_plume_mod boundary_types_mod ambient_mod equation_of_state_mod jenkins1991_entrainment_mod dallaston2015_melt_mod uniform_ambient_mod simple_plume_boundary_mod pseudospectral_block_mod linear_eos_mod hdf5 h5lt logger_mod penf module~~static_plume_mod~~UsesGraph module~static_plume_mod static_plume_mod logger_mod logger_mod module~static_plume_mod->logger_mod h5lt h5lt module~static_plume_mod->h5lt module~melt_relationship_mod melt_relationship_mod module~static_plume_mod->module~melt_relationship_mod module~equation_of_state_mod equation_of_state_mod module~static_plume_mod->module~equation_of_state_mod module~ode_solvers_mod ode_solvers_mod module~static_plume_mod->module~ode_solvers_mod factual_mod factual_mod module~static_plume_mod->factual_mod module~upstream_plume_mod upstream_plume_mod module~static_plume_mod->module~upstream_plume_mod module~jenkins1991_entrainment_mod jenkins1991_entrainment_mod module~static_plume_mod->module~jenkins1991_entrainment_mod hdf5 hdf5 module~static_plume_mod->hdf5 module~basal_surface_mod basal_surface_mod module~static_plume_mod->module~basal_surface_mod module~simple_plume_boundary_mod simple_plume_boundary_mod module~static_plume_mod->module~simple_plume_boundary_mod module~plume_boundary_mod plume_boundary_mod module~static_plume_mod->module~plume_boundary_mod iso_fortran_env iso_fortran_env module~static_plume_mod->iso_fortran_env module~pseudospectral_block_mod pseudospectral_block_mod module~static_plume_mod->module~pseudospectral_block_mod module~ambient_mod ambient_mod module~static_plume_mod->module~ambient_mod module~linear_eos_mod linear_eos_mod module~static_plume_mod->module~linear_eos_mod penf penf module~static_plume_mod->penf module~uniform_ambient_mod uniform_ambient_mod module~static_plume_mod->module~uniform_ambient_mod module~entrainment_mod entrainment_mod module~static_plume_mod->module~entrainment_mod module~boundary_types_mod boundary_types_mod module~static_plume_mod->module~boundary_types_mod module~dallaston2015_melt_mod dallaston2015_melt_mod module~static_plume_mod->module~dallaston2015_melt_mod module~melt_relationship_mod->factual_mod module~melt_relationship_mod->iso_fortran_env module~equation_of_state_mod->factual_mod module~equation_of_state_mod->iso_fortran_env module~ode_solvers_mod->logger_mod module~ode_solvers_mod->iso_fortran_env module~ode_solvers_mod->penf module~nitsol_mod nitsol_mod module~ode_solvers_mod->module~nitsol_mod module~upstream_plume_mod->logger_mod module~upstream_plume_mod->factual_mod module~upstream_plume_mod->module~plume_boundary_mod module~upstream_plume_mod->iso_fortran_env module~upstream_plume_mod->penf module~upstream_plume_mod->module~boundary_types_mod module~rksuite_90 rksuite_90 module~upstream_plume_mod->module~rksuite_90 module~uniform_gradient_field_mod uniform_gradient_field_mod module~upstream_plume_mod->module~uniform_gradient_field_mod module~jenkins1991_entrainment_mod->factual_mod module~jenkins1991_entrainment_mod->iso_fortran_env module~jenkins1991_entrainment_mod->module~entrainment_mod module~basal_surface_mod->factual_mod module~basal_surface_mod->hdf5 module~basal_surface_mod->iso_fortran_env module~basal_surface_mod->module~nitsol_mod module~simple_plume_boundary_mod->factual_mod module~simple_plume_boundary_mod->module~plume_boundary_mod module~simple_plume_boundary_mod->iso_fortran_env module~simple_plume_boundary_mod->module~boundary_types_mod module~plume_boundary_mod->factual_mod module~plume_boundary_mod->iso_fortran_env module~plume_boundary_mod->module~boundary_types_mod module~pseudospectral_block_mod->logger_mod module~pseudospectral_block_mod->factual_mod module~pseudospectral_block_mod->iso_fortran_env module~pseudospectral_block_mod->penf chebyshev_mod chebyshev_mod module~pseudospectral_block_mod->chebyshev_mod module~ambient_mod->factual_mod module~ambient_mod->iso_fortran_env module~linear_eos_mod->module~equation_of_state_mod module~linear_eos_mod->factual_mod module~linear_eos_mod->iso_fortran_env module~uniform_ambient_mod->factual_mod module~uniform_ambient_mod->iso_fortran_env module~uniform_ambient_mod->module~ambient_mod module~entrainment_mod->factual_mod module~entrainment_mod->iso_fortran_env module~dallaston2015_melt_mod->module~melt_relationship_mod module~dallaston2015_melt_mod->factual_mod module~dallaston2015_melt_mod->iso_fortran_env module~nitsol_mod->iso_fortran_env module~rksuite_90_prec rksuite_90_prec module~rksuite_90->module~rksuite_90_prec module~uniform_gradient_field_mod->factual_mod module~uniform_gradient_field_mod->iso_fortran_env utils_mod utils_mod module~uniform_gradient_field_mod->utils_mod module~rksuite_90_prec->iso_fortran_env var panmodulestatic_plume_modUsesGraph = svgPanZoom('#modulestatic_plume_modUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables hdf_type_name hdf_thickness hdf_velocity hdf_temperature hdf_salinity hdf_delta hdf_nu hdf_mu hdf_r hdf_phi Abstract Interfaces scalar_func velocity_func Derived Types static_plume Functions static_plume_melt static_plume_drag_parameter static_plume_water_density static_plume_data_size static_plume_state_vector Subroutines static_plume_initialise static_plume_update static_plume_read_data static_plume_write_data static_plume_solve Variables Type Visibility Attributes Name Initial character(len=9), public, parameter :: hdf_type_name = 'plume' character(len=9), public, parameter :: hdf_thickness = 'thickness' character(len=8), public, parameter :: hdf_velocity = 'velocity' character(len=11), public, parameter :: hdf_temperature = 'temperature' character(len=8), public, parameter :: hdf_salinity = 'salinity' character(len=5), public, parameter :: hdf_delta = 'delta' character(len=2), public, parameter :: hdf_nu = 'nu' character(len=2), public, parameter :: hdf_mu = 'mu' character(len=5), public, parameter :: hdf_r = 'r_val' character(len=3), public, parameter :: hdf_phi = 'phi' Abstract Interfaces abstract interface private pure function scalar_func(location) result(scalar) Abstract interface for function providing the initial values\n for the scalar properties of a static_plume object when it\n is being instantiated. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the property Return Value real(kind=r8) The value of the scalar quantity at location abstract interface private pure function velocity_func(location) result(vector) Abstract interface for function providing the plume velocity\n when an object is being instantiated. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the thickness Return Value real(kind=r8),\n  dimension(:), allocatable The velocity vector of the water in the plume at location Derived Types type, public, extends( basal_surface ) :: static_plume A concrete implementation of the basal_surface abstract data type, representing the buoyant plume beneath an\n ice shelf, but unchanging in time. It keeps the values assigned\n at creation or with the write_data method. It\n is useful if you want to uncouple the ice shelf from the plume. Components Type Visibility Attributes Name Initial type(cheb1d_scalar_field), private :: thickness The thickness of the plume type(cheb1d_vector_field), private :: velocity The velocity of the plume type(cheb1d_vector_field), private :: velocity_dx The derivative of the velocity field type(cheb1d_scalar_field), private :: temperature The temperature of the plume type(cheb1d_scalar_field), private :: temperature_dx The derivative of the temperature of the plume type(cheb1d_scalar_field), private :: salinity The salinity of the plume type(cheb1d_scalar_field), private :: salinity_dx The derivative of the salinity of the plume class( abstract_entrainment ), private, allocatable :: entrainment_formulation An object which provides the parameterisation for entrainment\n of water into the plume. class( abstract_melt_relationship ), private, allocatable :: melt_formulation An object which provides the parameterisation for melting,\n salt, and heat fluxes from the plume to the ice. class( ambient_conditions ), private, allocatable :: ambient_conds An object specifying the temperature and salinity of the\n ambient ocean at its interface with the plume. class( equation_of_state ), public, allocatable :: eos An object specifying the equation of state relating the plume\n water's density to its temperature and salinity. class( plume_boundary ), private, allocatable :: boundaries An object specifying the boundary conditions for the plume. real(kind=r8), private :: delta The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real(kind=r8), public :: nu The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real(kind=r8), private :: mu The dimensionless ratio \\mu \\equiv \\frac{C_dx_0}{D_0} real(kind=r8), private :: r_val The dimensionless ratio of the ocean water density to the\n density of the overlying ice shelf. real(kind=r8), public :: phi The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} real(kind=r8), private :: time The time at which the ice shelf is in this state integer, private :: thickness_size The number of data values in the thickness field integer, private :: velocity_size The number of data values in the velocity field integer, private :: temperature_size The number of data values in the temperature field integer, private :: salinity_size the number of data values in the salinity field logical, private, dimension(7) :: lower_bounds = .false. Which variables have boundary conditions at the grounding\n line. logical, private, dimension(7) :: upper_bounds = .false. Which variables have boundary conditions at the calving\n front. type( pseudospec_block ), private :: precond A pseudospectral differentiation block which can be used for\n preconditioning. Type-Bound Procedures procedure, public :: initialise => static_plume_initialise procedure, public :: basal_melt => static_plume_melt procedure, public :: basal_drag_parameter => static_plume_drag_parameter procedure, public :: water_density => static_plume_water_density procedure, public :: update => static_plume_update procedure, public :: data_size => static_plume_data_size procedure, public :: state_vector => static_plume_state_vector procedure, public :: read_data => static_plume_read_data procedure, public :: write_data => static_plume_write_data procedure, public :: solve => static_plume_solve Functions private function static_plume_melt (this) result(melt) Author Christopher MacMackin Date April 2016 Computes and returns the melt rate at the bottom of the ice\n shelf due to interaction with the plume. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice shelf. private function static_plume_drag_parameter (this) result(drag) Author Christopher MacMackin Date April 2016 Computes and returns a quantity which may be necessary to determine\n the frictional drag the plume exerts on the bottom of the ice\n shelf. The plume would actually tend to exert no drag on the bottom\n of the ice shelf, but this method is present so that there is a\n consistent interface with the ground data type. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. private function static_plume_water_density (this) result(density) Author Christopher MacMackin Date April 2016 Computes and returns the density of the plume water beneath the ice\n shelf. The density of this water would vary depending on how much \n saline ambient water has been entrained into the plume versus how\n much fresh water has been released due to melting. However, the\n Boussinesq approximation is used here and only a single reference \n density is returned. Read more… Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value real(kind=r8) The density of the water at the base of the ice sheet. private function static_plume_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the plume's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value integer The number of elements in the plume's state vector. private function static_plume_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the plume. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the plume. Subroutines private subroutine static_plume_initialise (this, domain, resolution, thickness, velocity, temperature, salinity, entrainment_formulation, melt_formulation, ambient_conds, eos, boundaries, delta, nu, mu, r_val, phi) Author Christopher MacMackin Date April 2016 Instantiates a plume object with initial coniditions\n provided by the arguments.At present only a 1D model is\n supported. If information is provided for higher dimensions then\n it will be ignored. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(out) :: this A plume object with its domain and initial conditions set according\n to the arguments of the constructor function. real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the plume. The first index represents the dimension for which the\n boundaries apply. If the second index is 1 then it corresponds to\n the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( scalar_func ) :: thickness A function which calculates the initial value of the thickness of \n the plume at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the water at a given location in a plume. procedure( scalar_func ) :: temperature A function which calculates the initial value of the temperature of \n the plume at a given location. procedure( scalar_func ) :: salinity A function which calculates the initial value of the salinity of \n the plume at a given location. class( abstract_entrainment ), intent(inout), optional allocatable :: entrainment_formulation An object which calculates entrainment into the plume. Will\n be unallocated on exit. Defaults to that used by Jenkins\n (1991) with the coefficient $E_0 = 1$. class( abstract_melt_relationship ), intent(inout), optional allocatable :: melt_formulation An object which calculates melting and the resulting thermal\n transfer into/out of the plume. Will be unallocated on\n exit. Defaults to that used by Dallaston et al. (2015),\n scaled to be consistent with the nondimensionalisation used\n here. class( ambient_conditions ), intent(inout), optional allocatable :: ambient_conds An object specifying the salinity and temperature of the\n ambient ocean. Will be unallocated on exit. Defaults to\n uniform ambient salinity and temperature, both of which are\n set to 0 (as temperature and salinity are measured relative\n to some reference value). class( equation_of_state ), intent(inout), optional allocatable :: eos An object specifying the equation of state for the water in\n the plume. Will be unallocated on exit. Defaults to\n linearised equation of state with no temperature dependence\n and a haline contraction coefficient of 1. The reference\n density is set to be 1 in the dimensionless units when\n salinity and temeprature are 0. class( plume_boundary ), intent(inout), optional allocatable :: boundaries An object providing the boundary conditions for the\n plume. Will be unallocated on exit. Defaults to those used by\n Dallaston et al. (2015). real(kind=r8), intent(in), optional :: delta The dimensionless ratio \\delta \\equiv\n \\frac{D_0}{h_0} . Defaults to 0.036. real(kind=r8), intent(in), optional :: nu The dimensionless ratio \\nu \\equiv\n \\frac{\\kappa_0}{x_0U_o} . Defaults to 0. real(kind=r8), intent(in), optional :: mu The dimensionless ratio \\mu \\equiv\n \\frac{\\C_dx_0}{D_0} . Defaults to 0. real(kind=r8), intent(in), optional :: r_val The dimensionless ratio of the water density to the ice shelf\n density, r = \\rho_0/\\rho_i. Defaults to 1.12. real(kind=r8), intent(in), optional :: phi The inverse Rossby number, \\Phi \\equif\n \\frac{fx_0}{U_0} . Defaults to 0. private subroutine static_plume_update (this, state_vector, ice_thickness) Author Christopher MacMackin Date April 2016 Updates the state of the plume from its state vector. The state\n vector is a real array containing the value of each of the plume's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n plume. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate. private subroutine static_plume_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the plume object from an HDF file in the\n specified group. This sets the thickness, velocity, temperature,\n salinity dataset, and parameter values. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine static_plume_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the plume object to an HDF file in the\n specified group. This will consist of a thickness, a velocity, a\n temperature, and a salinity dataset. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine static_plume_solve (this, ice_thickness, ice_density, ice_temperature, time, success) Author Chris MacMackin Date March 2017 Would normally solve, but for this static implementation of the\n plume it does nothing. Arguments Type Intent Optional Attributes Name class( static_plume ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise"},{"title":"cryosphere_mod – ISOFT","tags":"","loc":"module/cryosphere_mod.html","text":"Provides a data structure representing a system of ice sheets and/or ice\n shelves, as well as the ground and/or ocean which they interact with. This\n is the fundamental data type of the ISOFT software suite. Uses iso_fortran_env basal_surface_mod glacier_mod meta_mod hdf5 h5lt logger_mod penf nitsol_mod module~~cryosphere_mod~~UsesGraph module~cryosphere_mod cryosphere_mod logger_mod logger_mod module~cryosphere_mod->logger_mod h5lt h5lt module~cryosphere_mod->h5lt hdf5 hdf5 module~cryosphere_mod->hdf5 module~glacier_mod glacier_mod module~cryosphere_mod->module~glacier_mod module~basal_surface_mod basal_surface_mod module~cryosphere_mod->module~basal_surface_mod module~meta_mod meta_mod module~cryosphere_mod->module~meta_mod iso_fortran_env iso_fortran_env module~cryosphere_mod->iso_fortran_env penf penf module~cryosphere_mod->penf module~nitsol_mod nitsol_mod module~cryosphere_mod->module~nitsol_mod module~glacier_mod->logger_mod module~glacier_mod->hdf5 module~glacier_mod->iso_fortran_env module~glacier_mod->penf module~glacier_mod->module~nitsol_mod factual_mod factual_mod module~glacier_mod->factual_mod module~basal_surface_mod->hdf5 module~basal_surface_mod->iso_fortran_env module~basal_surface_mod->module~nitsol_mod module~basal_surface_mod->factual_mod module~meta_mod->iso_fortran_env module~nitsol_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables hdf_glacier hdf_basal hdf_version hdf_comp_time hdf_write_time hdf_simulation_time hdf_crash_file Derived Types cryosphere Functions time_step state_vector get_time Subroutines initialise reduce_time_step increase_time_step integrate read_data read_ice read_sub_ice write_data Variables Type Visibility Attributes Name Initial character(len=12), public, parameter :: hdf_glacier = 'glacier' character(len=18), public, parameter :: hdf_basal = 'basal_surface' character(len=13), public, parameter :: hdf_version = 'isoft_version' character(len=23), public, parameter :: hdf_comp_time = 'binary_compilation_time' character(len=16), public, parameter :: hdf_write_time = 'data_output_time' character(len=15), public, parameter :: hdf_simulation_time = 'simulation_time' character(len=25), public, parameter :: hdf_crash_file = 'isoft_termination_dump.h5' Derived Types type, public :: cryosphere A data structure representing glaciers, either as ice shelves or\n (eventually) ice sheets. It will allow coupled systems of\n glaciers as well as different basal couplings with the ocean or\n ground. This type is a subclass of the FOODIE integrand ,\n allowing it to take advantage of that set of integration\n libraries for evolution in time. Components Type Visibility Attributes Name Initial class( glacier ), private, allocatable :: ice A model for the ice shelf or ice sheet class( basal_surface ), private, allocatable :: sub_ice A model for the ground or ocean underneath the ice real(kind=r8), private :: time The time in the simulation logical, private :: first_integration Indicates whether the cryosphere has been integrated before\n or not. real(kind=r8), private :: dt_factor = 1.0_r8 A factor by which to reduce the time step real(kind=r8), private :: min_dt_factor = 1e-3_r8 The smallest time step reduction to allow logical, private :: performing_time_step True if in the process of trying to get a time-step to\n successfully integrate. Type-Bound Procedures procedure, public :: initialise procedure, public :: time_step procedure, public :: reduce_time_step procedure, public :: increase_time_step procedure, public :: state_vector procedure, public :: integrate procedure, public :: read_data procedure, public :: read_ice procedure, public :: read_sub_ice procedure, public :: write_data procedure, public :: get_time Functions private function time_step (this) Author Chris MacMackin Date December 2016 Calculates an appropriate time step with which to integrate the\n cryosphere so as not to cause numerical instability. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this Return Value real(kind=r8) private function state_vector (this) Author Chris MacMackin Date April 2017 Returns the state vector for the current state of the\n cryosphere. This takes the form of a 1D array. This routine is\n mainly useful for unit-testing. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable private pure function get_time (this) Author Chris MacMackin Date April 2017 Returns the current time of the cryosphere system. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(in) :: this Return Value real(kind=r8) Subroutines private subroutine initialise (this, ice, sub_ice) Author Christopher MacMackin Date November 2016 Initialise a cryosphere object from the provided\n components. This object will model the evolution of a\n glacier/ice shelf/ice sheet and its surroundings. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(out) :: this class( glacier ), intent(inout), allocatable :: ice An object modelling the ice sheet or shelf component of this\n system. Will be deallocated on return. class( basal_surface ), intent(inout), allocatable :: sub_ice An object modelling the component of this system beneath the\n ice. Will be deallocated on return. private subroutine reduce_time_step (this) Author Christopher MacMackin Date April 2017 Reuces the time step by a factor of 2, unless doing so would\n take it below the minimum value. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this private subroutine increase_time_step (this) Author Christopher MacMackin Date April 2017 Increases the time step by a factor of 2, unless doing so would\n take it above the maximum. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this private subroutine integrate (this, time) Author Christopher MacMackin Date April 2016 Integrates the cryosphere forward until the specified time is\n reached. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this real(kind=r8), intent(in) :: time The time to which to integrate the cryosphere private subroutine read_data (this, infile, set_time) Author Christopher MacMackin Date April 2017 Reads the data describing the cryosphere from an HDF5 file on\n the disc. h5open_f must have been called once prior to using\n this method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this character(len=*), intent(in) :: infile The file from which to read the data describing the state of the \n cryosphere logical, intent(in), optional :: set_time If present and .true. then set the simulation time of the\n cryosphere to be the same as that in the HDF file. Otherwise,\n leave it unchanged. private subroutine read_ice (this, infile, set_time) Author Christopher MacMackin Date December 2017 Reads the data describing the ice component of the cryosphere\n from an HDF5 file on the disc. Data on anything below the ice is\n ignored. h5open_f must have been called once prior to using\n this method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this character(len=*), intent(in) :: infile The file from which to read the data describing the state of the \n cryosphere logical, intent(in), optional :: set_time If present and .true. then set the simulation time of the\n cryosphere to be the same as that in the HDF file. Otherwise,\n leave it unchanged. private subroutine read_sub_ice (this, infile, set_time) Author Christopher MacMackin Date April 2017 Reads the data describing the part of the cryosphere beneath the\n ice from an HDF5 file on the disc. Data on the ice itself is\n ignored. h5open_f must have been called once prior to using\n this method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(inout) :: this character(len=*), intent(in) :: infile The file from which to read the data describing the state of the \n cryosphere logical, intent(in), optional :: set_time If present and .true. then set the simulation time of the\n cryosphere to be the same as that in the HDF file. Otherwise,\n leave it unchanged. private subroutine write_data (this, outfile) Author Christopher MacMackin Date April 2016 Writes the data describing the cryosphere to the disc as an HDF5\n file. h5open_f must have been called once prior to using this\n method. After the method has been used, h5close_f must be\n called once before the end of the program. Arguments Type Intent Optional Attributes Name class( cryosphere ), intent(in) :: this character(len=*), intent(in) :: outfile The file to which to write the data describing the state of the \n cryosphere"},{"title":"melt_relationship_mod – ISOFT","tags":"","loc":"module/melt_relationship_mod.html","text":"Provides an abstract data type to model melting of an ice shelf into a \n vertically integrated plume. Uses iso_fortran_env factual_mod module~~melt_relationship_mod~~UsesGraph module~melt_relationship_mod melt_relationship_mod factual_mod factual_mod module~melt_relationship_mod->factual_mod iso_fortran_env iso_fortran_env module~melt_relationship_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~melt_relationship_mod~~UsedByGraph module~melt_relationship_mod melt_relationship_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~melt_relationship_mod module~dallaston2015_melt_mod dallaston2015_melt_mod module~asymmetric_plume_mod->module~dallaston2015_melt_mod module~one_equation_melt_mod one_equation_melt_mod module~one_equation_melt_mod->module~melt_relationship_mod module~ave_one_equation_melt_mod ave_one_equation_melt_mod module~ave_one_equation_melt_mod->module~melt_relationship_mod module~dallaston2015_melt_mod->module~melt_relationship_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~melt_relationship_mod module~static_plume_mod->module~dallaston2015_melt_mod module~plume_mod plume_mod module~plume_mod->module~melt_relationship_mod module~plume_mod->module~dallaston2015_melt_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces get_scalar has_terms solve Derived Types abstract_melt_relationship Abstract Interfaces abstract interface private function get_scalar(this) result(property) Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property is being returned. abstract interface private pure function has_terms(this) Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat or salinity equations. abstract interface private subroutine solve(this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( abstract_melt_relationship ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed. Derived Types type, public, abstract :: abstract_melt_relationship An abstract data type for calculating melting of an ice shelf into\n a vertically integrated plume . The melt rate, as well as\n effect on termperature and salinity, are calculated by calling solve_for_melt and then accessed\n using melt_rate , heat_equation_terms , salt_equation_terms . Type-Bound Procedures procedure(solve), public :: solve_for_melt procedure(get_scalar), public :: salt_equation_terms Returns the terms this melt formulation contributes to the\n salt equation, after they have been solved for using solve_for_melt . procedure(get_scalar), public :: heat_equation_terms Returns the terms this melt formulation contributes to the\n heat equation, after they have been solved for using solve_for_melt . procedure(get_scalar), public :: melt_rate Returns the melt rate calculated using this formulation,\n after it has been solved for using solve_for_melt . procedure(has_terms), public :: has_heat_terms Whether this formulation of melting contributes any terms to\n a plume's heat equation. procedure(has_terms), public :: has_salt_terms Whether this formulation of melting contributes any terms to\n a plume's salinity equation."},{"title":"glacier_boundary_mod – ISOFT","tags":"","loc":"module/glacier_boundary_mod.html","text":"Provides an abstract derived type which can be subtyped in order to\n specify the boundary conditions for glacier types. Uses iso_fortran_env factual_mod boundary_types_mod module~~glacier_boundary_mod~~UsesGraph module~glacier_boundary_mod glacier_boundary_mod factual_mod factual_mod module~glacier_boundary_mod->factual_mod iso_fortran_env iso_fortran_env module~glacier_boundary_mod->iso_fortran_env module~boundary_types_mod boundary_types_mod module~glacier_boundary_mod->module~boundary_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~glacier_boundary_mod~~UsedByGraph module~glacier_boundary_mod glacier_boundary_mod module~ice_shelf_mod ice_shelf_mod module~ice_shelf_mod->module~glacier_boundary_mod module~dallaston2015_glacier_boundary_mod dallaston2015_glacier_boundary_mod module~ice_shelf_mod->module~dallaston2015_glacier_boundary_mod module~dallaston2015_glacier_boundary_mod->module~glacier_boundary_mod module~seasonal_glacier_boundary_mod seasonal_glacier_boundary_mod module~seasonal_glacier_boundary_mod->module~glacier_boundary_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types glacier_boundary Functions bound_array boundary_residuals bound_type Derived Types type, public :: glacier_boundary A type in which procedures for getting the boundary conditions\n of glaciers are to be specified. The descendent types can\n contain whatever data is needed to compute the result. It\n provides the routine boundary_residuals to return an\n array with the residuals representing deviation from satisfying\n the conditions. This can then be appended to a glacier 's residual array. Read more… Type-Bound Procedures procedure, public :: thickness_lower_bound => bound_array Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the thickness\n field. procedure, public :: thickness_upper_bound => bound_array Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the thickness\n field. procedure, public :: velocity_lower_bound => bound_array Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the velocity\n field. procedure, public :: velocity_upper_bound => bound_array Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the velocity\n field. procedure, public :: thickness_lower_type => bound_type Returns an array indicating what type of boundary conditions\n apply for thickness at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: thickness_upper_type => bound_type Returns an array indicating what type of boundary conditions\n apply for thickness at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: velocity_lower_type => bound_type Returns an array indicating what type of boundary conditions\n apply for velocity at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: velocity_upper_type => bound_type Returns an array indicating what type of boundary conditions\n apply for velocity at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: boundary_residuals Returns an array consisting of the difference between the\n required boundary values and those which actually exist. The\n order in which these are listed is as follows: lower\n thickness boundary, upper thickness boundary, lower velocity\n boundary, and upper velocity boundary. Functions private pure function bound_array (this) Author Chris MacMackin Date September 2016 Default implementation of the method getting lower and upper\n boundary information, which is then passed to the methods for\n getting and setting raw representations of fields. It returns a\n 1D array of length 2, indicating free boundaries (the raw data\n should represent all cells contained in the field, not excluding\n any near the boundaries). Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) private function boundary_residuals (this, thickness, velocity, viscosity, t) result(residuals) Author Chris MacMackin Date September 2016 Default implementation of the boundary_residuals method. It returns a zero-length array, effectively indicating free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this class(scalar_field), intent(in) :: thickness A field containing the thickness of the glacier class(vector_field), intent(in) :: velocity A field containing the flow velocity of the glacier class(scalar_field), intent(in) :: viscosity A field containing the viscosity of the ice in the glacier. real(kind=r8), intent(in) :: t The time at which the boundary conditions are to be\n calculated. Return Value real(kind=r8),\n  allocatable, dimension(:) An array containing the difference between the required\n boundary values and those which are actually present. They\n are stored in the order: lower thickness boundary, upper\n thickness boundary, lower velocity boundary, and upper\n velocity boundary. private pure function bound_type (this) Author Chris MacMackin Date January 2017 Default implementation of the methods getting the boundary types\n for a glacier.  It returns an array which indicates free\n boundaries. Arguments Type Intent Optional Attributes Name class( glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable"},{"title":"boundary_types_mod – ISOFT","tags":"","loc":"module/boundary_types_mod.html","text":"Provides parameters which can be used to represent different types\n of boundary conditions. Used by module~~boundary_types_mod~~UsedByGraph module~boundary_types_mod boundary_types_mod module~ice_shelf_mod ice_shelf_mod module~ice_shelf_mod->module~boundary_types_mod module~jacobian_block_mod jacobian_block_mod module~ice_shelf_mod->module~jacobian_block_mod module~glacier_boundary_mod glacier_boundary_mod module~ice_shelf_mod->module~glacier_boundary_mod module~dallaston2015_glacier_boundary_mod dallaston2015_glacier_boundary_mod module~ice_shelf_mod->module~dallaston2015_glacier_boundary_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~boundary_types_mod module~upstream_plume_mod upstream_plume_mod module~asymmetric_plume_mod->module~upstream_plume_mod module~simple_plume_boundary_mod simple_plume_boundary_mod module~asymmetric_plume_mod->module~simple_plume_boundary_mod module~plume_boundary_mod plume_boundary_mod module~asymmetric_plume_mod->module~plume_boundary_mod module~jacobian_block_mod->module~boundary_types_mod module~upstream_plume_mod->module~boundary_types_mod module~upstream_plume_mod->module~plume_boundary_mod module~glacier_boundary_mod->module~boundary_types_mod module~dallaston2015_glacier_boundary_mod->module~boundary_types_mod module~dallaston2015_glacier_boundary_mod->module~glacier_boundary_mod module~simple_plume_boundary_mod->module~boundary_types_mod module~simple_plume_boundary_mod->module~plume_boundary_mod module~finite_difference_block_mod finite_difference_block_mod module~finite_difference_block_mod->module~boundary_types_mod module~plume_boundary_mod->module~boundary_types_mod module~dallaston2015_seasonal_mod dallaston2015_seasonal_mod module~dallaston2015_seasonal_mod->module~boundary_types_mod module~dallaston2015_seasonal_mod->module~plume_boundary_mod module~seasonal_glacier_boundary_mod seasonal_glacier_boundary_mod module~seasonal_glacier_boundary_mod->module~boundary_types_mod module~seasonal_glacier_boundary_mod->module~glacier_boundary_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~boundary_types_mod module~static_plume_mod->module~upstream_plume_mod module~static_plume_mod->module~simple_plume_boundary_mod module~static_plume_mod->module~plume_boundary_mod module~plume_mod plume_mod module~plume_mod->module~boundary_types_mod module~plume_mod->module~upstream_plume_mod module~plume_mod->module~simple_plume_boundary_mod module~plume_mod->module~plume_boundary_mod module~preconditioner_mod preconditioner_mod module~preconditioner_mod->module~jacobian_block_mod module~ice_sheet_mod ice_sheet_mod module~ice_sheet_mod->module~jacobian_block_mod var panmoduleboundary_types_modUsedByGraph = svgPanZoom('#moduleboundary_types_modUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables free_boundary dirichlet neumann cauchy robin Variables Type Visibility Attributes Name Initial integer, public, parameter :: free_boundary = -1 Indicates that the solution may take any value at the boundary. integer, public, parameter :: dirichlet = 0 Indicates that the value of the solution at this boundary is\n prescribed. integer, public, parameter :: neumann = 1 Indicates that the first derivative of the solution at this\n boundary is prescribed. integer, public, parameter :: cauchy = 5 Indicates that the value of the solution and its first\n derivative are both prescribed at this boundary. integer, public, parameter :: robin = 6 Indicates that the linear combination of the solution's value\n and first derivative is prescribed at this boundary."},{"title":"ave_linear_eos_mod – ISOFT","tags":"","loc":"module/ave_linear_eos_mod.html","text":"Provides an abstract derived type which can be subtyped in order to\n implement an equation of state. Uses iso_fortran_env factual_mod equation_of_state_mod module~~ave_linear_eos_mod~~UsesGraph module~ave_linear_eos_mod ave_linear_eos_mod factual_mod factual_mod module~ave_linear_eos_mod->factual_mod iso_fortran_env iso_fortran_env module~ave_linear_eos_mod->iso_fortran_env module~equation_of_state_mod equation_of_state_mod module~ave_linear_eos_mod->module~equation_of_state_mod module~equation_of_state_mod->factual_mod module~equation_of_state_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~ave_linear_eos_mod~~UsedByGraph module~ave_linear_eos_mod ave_linear_eos_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~ave_linear_eos_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables absolute_zero Interfaces ave_linear_eos Derived Types ave_linear_eos Functions constructor linear_water_density linear_water_density_ave1 linear_water_density_ave2 linear_water_deriv linear_haline_contraction linear_thermal_contraction Variables Type Visibility Attributes Name Initial real(kind=r8), private, parameter :: absolute_zero = -273.15_r8 Interfaces public interface ave_linear_eos private pure function constructor (ref_rho, ref_t, ref_s, beta_t, beta_s, a_DS, a_DT, a_DS_t, a_DT_t) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: ref_rho The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), intent(in) :: ref_t The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), intent(in) :: ref_s The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), intent(in) :: beta_t The thermal contraction coefficient, \\beta_T . real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S . real(kind=r8), intent(in), optional :: a_DS The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_S dy, where f_{D}(y) and f_S(y) are the shapes of the variables D and S in\n the transverse direction. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DT The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_T dy, where f_{D}(y) and f_T(y) are the shapes of the variables D and T in\n the transverse direction. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DS_t The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DS} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S\n dy, where f_{D}(y) and f_S(y) are the shapes of\n the variables D and S in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DT_t The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DT} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T\n dy, where f_{D}(y) and f_T(y) are the shapes of\n the variables D and T in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. Return Value type( ave_linear_eos ) Derived Types type, public, extends( equation_of_state ) :: ave_linear_eos A linearised implementation of the equation of state which has\n been horizontally-integrated. The basic equation of stateis \\rho(x,y) = \\rho_0[1-\\beta_T(T(x,y)-T_0) +\n \\beta_S(S(x,y)-S_0)]. Components Type Visibility Attributes Name Initial real(kind=r8), private :: ref_rho = 1.0_r8 The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), private :: ref_t = 0.0_r8 The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), private :: ref_s = 0.0_r8 The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), private :: beta_t = 0.0_r8 The thermal contraction coefficient, \\beta_T . real(kind=r8), private :: beta_s = 1.0_r8 The haline contraction coefficient, \\beta_S . real(kind=r8), private :: a_DS = 1.0_r8 The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_S dy, where f_{D}(y) and f_S(y) are the shapes of the variables D and S in\n the transverse direction. real(kind=r8), private :: a_DT = 1.0_r8 The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_T dy, where f_{D}(y) and f_T(y) are the shapes of the variables D and T in\n the transverse direction. real(kind=r8), private :: a_DS_t = 1.0_r8 The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DS} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S\n dy, where f_{D}(y) and f_S(y) are the shapes of\n the variables D and S in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. real(kind=r8), private :: a_DT_t = 1.0_r8 The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DT} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T\n dy, where f_{D}(y) and f_T(y) are the shapes of\n the variables D and T in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Constructor private pure function constructor (ref_rho, ref_t, ref_s, beta_t, beta_s, a_DS, a_DT, a_DS_t, a_DT_t) Type-Bound Procedures procedure, public :: water_density => linear_water_density procedure, public :: water_density_ave1 => linear_water_density_ave1 procedure, public :: water_density_ave2 => linear_water_density_ave2 procedure, public :: water_density_derivative => linear_water_deriv procedure, public :: haline_contraction => linear_haline_contraction procedure, public :: thermal_contraction => linear_thermal_contraction Functions private pure function constructor (ref_rho, ref_t, ref_s, beta_t, beta_s, a_DS, a_DT, a_DS_t, a_DT_t) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: ref_rho The density for the temperature and salinity about which the\n equation of state was linearised, \\rho_0 . real(kind=r8), intent(in) :: ref_t The temperature about which the equation of state was\n linearised, T_0 . real(kind=r8), intent(in) :: ref_s The salinity about which the equation of state was\n linearised, S_0 . real(kind=r8), intent(in) :: beta_t The thermal contraction coefficient, \\beta_T . real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S . real(kind=r8), intent(in), optional :: a_DS The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DS} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_S dy, where f_{D}(y) and f_S(y) are the shapes of the variables D and S in\n the transverse direction. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DT The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{DT} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{D}f_T dy, where f_{D}(y) and f_T(y) are the shapes of the variables D and T in\n the transverse direction. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DS_t The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DS} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_S\n dy, where f_{D}(y) and f_S(y) are the shapes of\n the variables D and S in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. real(kind=r8), intent(in), optional :: a_DT_t The shape coefficient for a horizontally-integrated model. It\n is defined as \\tilde{\\alpha}_{DT} =\n \\frac{1}{\\alpha_{D&#94;2}(y_2 - y_1)} \\int&#94;{y_2}_{y_1} f&#94;2_{D}f_T\n dy, where f_{D}(y) and f_T(y) are the shapes of\n the variables D and T in the transverse direction and \\alpha_{D&#94;2} = \\frac{1}{y_2 -\n y_1}\\int&#94;{y_2}_{y_1}f_D&#94;2dy. Defualt value is 1. Return Value type( ave_linear_eos ) private function linear_water_density (this, temperature, salinity) result(density) Author Chris MacMackin Date August 2018 Calculates the density of the water from the temperature and\n salinity, using a linear equation of state, \\rho(x,y) =\n \\rho_0[1-\\beta_T(T(x,y)-T_0) + \\beta_S(S(x,y)-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water private function linear_water_density_ave1 (this, temperature, salinity) result(density) Author Chris MacMackin Date August 2018 Calculates one form of the horizontally-averaged density of the\n water from the temperature and salinity, using a linear equation\n of state, \\bar{rho}(x) =\n \\rho_0[1-\\beta_T(\\alpha_{DT}T(x)-T_0) +\n \\beta_S(\\alpha_{DS}S(x)-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water private function linear_water_density_ave2 (this, temperature, salinity) result(density) Author Chris MacMackin Date August 2018 Calculates another form of the horizontally-averaged density of\n the water from the temperature and salinity, using a linear\n equation of state, \\tilde{\\rho}(x) =\n \\rho_0[1-\\beta_T(\\tilde{\\alpha}_{DT}T(x)-T_0) +\n \\beta_S(\\tilde{\\alpha}_{DS}S(x)-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water private function linear_water_deriv (this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Author Chris MacMackin Date August 2018 Calculates the derivative of the average water density from the\n temperature and salinity, using a linear equation of state with\n the second type of averaging, \\tilde{\\rho} =\n \\rho_0[1-\\beta_T(\\tilde{\\alpha}_{DT}T-T_0) +\n \\beta_S(\\tilde{\\alpha}_{DS}S-S_0)]. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the density of the water private function linear_haline_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date August 2018 Returns the haline contraction coefficient. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable private function linear_thermal_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date August 2018 Returns the thermal contraction coefficient. Arguments Type Intent Optional Attributes Name class( ave_linear_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable"},{"title":"ice_shelf_mod – ISOFT","tags":"","loc":"module/ice_shelf_mod.html","text":"Provides a concrete implementation of the glacier type, using\n a vertically integrated model of an ice shelf. Uses iso_fortran_env glacier_mod factual_mod viscosity_mod newtonian_viscosity_mod glacier_boundary_mod dallaston2015_glacier_boundary_mod jacobian_block_mod boundary_types_mod nitsol_mod hdf5 h5lt logger_mod penf module~~ice_shelf_mod~~UsesGraph module~ice_shelf_mod ice_shelf_mod logger_mod logger_mod module~ice_shelf_mod->logger_mod h5lt h5lt module~ice_shelf_mod->h5lt hdf5 hdf5 module~ice_shelf_mod->hdf5 module~glacier_mod glacier_mod module~ice_shelf_mod->module~glacier_mod factual_mod factual_mod module~ice_shelf_mod->factual_mod module~jacobian_block_mod jacobian_block_mod module~ice_shelf_mod->module~jacobian_block_mod module~glacier_boundary_mod glacier_boundary_mod module~ice_shelf_mod->module~glacier_boundary_mod module~dallaston2015_glacier_boundary_mod dallaston2015_glacier_boundary_mod module~ice_shelf_mod->module~dallaston2015_glacier_boundary_mod module~newtonian_viscosity_mod newtonian_viscosity_mod module~ice_shelf_mod->module~newtonian_viscosity_mod iso_fortran_env iso_fortran_env module~ice_shelf_mod->iso_fortran_env penf penf module~ice_shelf_mod->penf module~nitsol_mod nitsol_mod module~ice_shelf_mod->module~nitsol_mod module~viscosity_mod viscosity_mod module~ice_shelf_mod->module~viscosity_mod module~boundary_types_mod boundary_types_mod module~ice_shelf_mod->module~boundary_types_mod module~glacier_mod->logger_mod module~glacier_mod->hdf5 module~glacier_mod->factual_mod module~glacier_mod->iso_fortran_env module~glacier_mod->penf module~glacier_mod->module~nitsol_mod module~jacobian_block_mod->logger_mod module~jacobian_block_mod->factual_mod module~jacobian_block_mod->iso_fortran_env module~jacobian_block_mod->penf module~jacobian_block_mod->module~boundary_types_mod f95_lapack f95_lapack module~jacobian_block_mod->f95_lapack module~glacier_boundary_mod->factual_mod module~glacier_boundary_mod->iso_fortran_env module~glacier_boundary_mod->module~boundary_types_mod module~dallaston2015_glacier_boundary_mod->factual_mod module~dallaston2015_glacier_boundary_mod->module~glacier_boundary_mod module~dallaston2015_glacier_boundary_mod->iso_fortran_env module~dallaston2015_glacier_boundary_mod->module~boundary_types_mod module~newtonian_viscosity_mod->factual_mod module~newtonian_viscosity_mod->iso_fortran_env module~newtonian_viscosity_mod->module~viscosity_mod module~nitsol_mod->iso_fortran_env module~viscosity_mod->factual_mod module~viscosity_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables hdf_type_name hdf_thickness hdf_velocity hdf_lambda hdf_zeta hdf_chi hdf_n_kappa hdf_kappa Abstract Interfaces kappa_init_func Derived Types ice_shelf Functions shelf_thickness shelf_velocity shelf_density shelf_temperature shelf_residual shelf_precondition shelf_data_size shelf_state_vector shelf_kappa_vector shelf_time_step Subroutines shelf_initialise shelf_update shelf_set_time shelf_read_data shelf_write_data shelf_solve_velocity shelf_integrate shelf_assign ice_shelf_integrate_layers Variables Type Visibility Attributes Name Initial character(len=9), public, parameter :: hdf_type_name = 'ice_shelf' character(len=9), public, parameter :: hdf_thickness = 'thickness' character(len=8), public, parameter :: hdf_velocity = 'velocity' character(len=6), public, parameter :: hdf_lambda = 'lambda' character(len=4), public, parameter :: hdf_zeta = 'zeta' character(len=3), public, parameter :: hdf_chi = 'chi' character(len=10), public, parameter :: hdf_n_kappa = 'num_kappas' character(len=15), public, parameter :: hdf_kappa = '(\"kappa_\",i0.4)' Abstract Interfaces abstract interface private pure function kappa_init_func(n, location) result(kappa) Abstract interface for function providing the Taylor\n coefficients describing the distribution of internal\n reflectors within an ice shelf. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The index of the Taylor coefficient being calculated real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the coefficient Return Value real(kind=r8) The value of coefficient n at location Derived Types type, public, extends( glacier ) :: ice_shelf A concrete implementation of the glacier type, using a vertically\n integrated model of an ice shelf. This model is 1-dimensional only. Components Type Visibility Attributes Name Initial type(cheb1d_scalar_field), private :: thickness Thickness of ice shelf, h type(cheb1d_vector_field), private :: velocity Flow velocity of ice shelf, \\vec{u} type(cheb1d_scalar_field), private :: eta Viscosity of the ice, \\eta type(cheb1d_scalar_field), private, dimension(:), allocatable :: kappa Taylor coefficients for the vertical structure of a\n Lagrangian tracer representing englacial layers/internal\n reflectors. real(kind=r8), private :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real(kind=r8), private :: chi The dimensionless ratio \\chi \\equiv\n \\frac{\\rho_igh_0x_0}{2\\eta_0u_0} \\left(1 -\n \\frac{\\rho_i}{\\rho_o}\\right) real(kind=r8), private :: zeta The dimensionless ratio \\zeta \\equiv\n \\frac{\\rho_iu_0x_0}{\\eta_0} , corresponding to the Reynolds\n number. Currently unused. real(kind=r8), private :: courant The Courant number to use when calculating the time step. class( abstract_viscosity ), private, allocatable :: viscosity_law An object representing the model used for ice viscosity. class( glacier_boundary ), private, allocatable :: boundaries An object specifying the boundary conditions for the ice\n shelf. real(kind=r8), private :: max_dt The maximu  allowable time step real(kind=r8), private :: time The time at which the ice shelf is in this state. integer, private :: thickness_size The number of data values in the thickness field. integer, private :: velocity_size The number of data values in the velocity field. integer, private :: boundary_start The number of data values needed to represent the boundary\n conditions. integer, private :: thickness_lower_bound_size The number of data values needed to represent the lower\n boundary conditions for thickness. integer, private :: thickness_upper_bound_size The number of data values needed to represent the upper\n boundary conditions for thickness. integer, private :: velocity_lower_bound_size The number of data values needed to represent the lower\n boundary conditions for velocity. integer, private :: velocity_upper_bound_size The number of data values needed to represent the upper\n boundary conditions for thickness. type( jacobian_block ), private :: thickness_jacobian A representation of the Jacobian for the ice shelf thickness. type( jacobian_block ), private :: velocity_jacobian A representation of the Jacobian for the ice shelf velocity. logical, private :: stale_eta Indicates whether the viscosity needs updating. logical, private :: stale_jacobian Indicates if the Jacobians are stale and in need of updating. Type-Bound Procedures generic, public :: assignment(=) => assign procedure, public :: integrate => glacier_integrate Performs a time-step of the integration, taking the state of\n the glacier to the specified time using the provided\n melt-rate data. procedure, public :: initialise => shelf_initialise procedure, public :: ice_thickness => shelf_thickness procedure, public :: ice_density => shelf_density procedure, public :: ice_temperature => shelf_temperature procedure, public :: residual => shelf_residual procedure, public :: update => shelf_update procedure, public :: precondition => shelf_precondition procedure, public :: set_time => shelf_set_time procedure, public :: data_size => shelf_data_size procedure, public :: state_vector => shelf_state_vector procedure, public :: kappa_vector => shelf_kappa_vector procedure, public :: read_data => shelf_read_data procedure, public :: write_data => shelf_write_data procedure, public :: time_step => shelf_time_step procedure, public :: solve_velocity => shelf_solve_velocity procedure, private :: assign => shelf_assign procedure, public :: integrate_layers => ice_shelf_integrate_layers Functions private function shelf_thickness (this) result(thickness) Author Christopher MacMackin Date April 2016 Returns the thickness of the ice shelf across its domain. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value class(scalar_field),\n  pointer The ice thickness. private function shelf_velocity (this) result(velocity) Author Christopher MacMackin Date July 2016 Returns the velocity of the ice shelf across its domain. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value class(vector_field),\n  pointer The ice velocity. private pure function shelf_density (this) result(density) Author Christopher MacMackin Date April 2016 Returns the density of the ice in the shelf, which is assumed to be\n uniform across its domain. Read more… Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8) The ice density. private pure function shelf_temperature (this) result(temperature) Author Christopher MacMackin Date April 2016 Returns the density of the ice in the shelf, which is assumed to be\n uniform across its domain. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8) The ice density. private function shelf_residual (this, previous_states, melt_rate, basal_drag_parameter, water_density) result(residual) Author Christopher MacMackin Date April 2016 Returns the residual when the current state of the glacier is run\n through the system of equations describing it. The residual takes the\n form of a 1D array, with each element respresenting the residual for\n one of the equations in the system. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most recent\n state, but the fact that this is an array allows potential\n other implementations to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier. class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate the\n drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. Return Value real(kind=r8),\n  dimension(:), allocatable The residual of the system of equations describing the glacier. private function shelf_precondition (this, previous_states, melt_rate, basal_drag_parameter, water_density, delta_state) result(preconditioned) Author Chris MacMackin Date January 2016 Provides a preconditioner for the nonlinear solver trying to\n bring the residual to zero. The Jacobian is approximated as a\n block matrix, where each block is a tridiagonal matrix using a\n finite difference method for differentiation. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier real(kind=r8), intent(in), dimension(:) :: delta_state The change to the state vector which is being preconditioned. Return Value real(kind=r8),\n  dimension(:), allocatable The result of applying the preconditioner to delta_state . private pure function shelf_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the ice shelf's state vector.\n This is the size of the vector returned by residual and state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value integer The number of elements in the ice shelf's state vector. private function shelf_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the ice shelf. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the ice shelf. private function shelf_kappa_vector (this) result(kappa_vector) Author Christopher MacMackin Date April 2016 Returns the a vector representing the current state of the\n internal reflectors in the ice shelf.  This takes the form of a\n 1D array. The routien is only used for debugging purposes. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the ice shelf. private function shelf_time_step (this) result(dt) Author Chris MacMackin Date December 2016 Calculates the time step for integrating the ice shelf, using\n the CFL condition. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this Return Value real(kind=r8) The time-step to use Subroutines private subroutine shelf_initialise (this, domain, resolution, thickness, velocity, temperature, viscosity_law, boundaries, lambda, chi, zeta, courant, max_dt, kappa, n_kappa) Author Christopher MacMackin Date April 2016 Initialises an ice_shelf object with initial conditions provided\n by the arguments. At present only a 1D model is supported. If\n information is provided for higher dimensions then it will be ignored. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(out) :: this real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the ice shelf. The first index represents the dimension for which\n the boundaries apply. If the second index is 1 then it corresponds\n to the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension. procedure( thickness_func ) :: thickness A function which calculates the initial value of the thickness of \n the ice shelf at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the ice at a given location in an ice shelf. real(kind=r8), intent(in), optional :: temperature The temperature of the ice in the ice shelf. class( abstract_viscosity ), intent(inout), optional allocatable :: viscosity_law An object which calculates the viscosity of the ice. If not\n specified, then Glen's law will be used with $n=3$. Will be\n unallocated on return. class( glacier_boundary ), intent(inout), optional allocatable :: boundaries An object specifying the boundary conditions for the ice\n shelf. Will be unallocated on return. real(kind=r8), intent(in), optional :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_ih_0u_0}$. real(kind=r8), intent(in), optional :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}\\left(1 -\n \\frac{\\rho_i}{\\rho_0}\\right)$. real(kind=r8), intent(in), optional :: zeta The dimensionless ratio $\\zeta \\equiv\n \\frac{\\rho_iu_0x_0}{\\eta_0}$, corresponding to the Reynolds\n number. Currently this is unused and always treated as 0. real(kind=r8), intent(in), optional :: courant The Courant number to use when calculating the time\n step. Defaults to 100. Too large a value will pose\n difficulties for the nonlinear solver, while too small a\n value can be numerically unstable. Typically, smaller values\n are needed for lower resolution. real(kind=r8), intent(in), optional :: max_dt The maximum allowable time step. This defaults to 1\\times\n 10&#94;{99} (effectively no maximum). procedure( kappa_init_func ), optional :: kappa A function which specifies the initial values of the Taylor\n coefficients describing the vertical distribution of internal\n reflectors within the ice. The initial conditions at the\n grounding line will provide the boundary conditions there\n throughout the simulation. If this parameter is not provided\n then these layers will not be included in the\n integration. Both this parameter and n_kappa must be\n specified for the calculation to take place. integer, intent(in), optional :: n_kappa The number of Taylor coefficients used to describe internal\n reflectors. If not provided then these reflectors will not be\n included in the integration. Both this parameter and kappa must be specified for the calculation to take place. private subroutine shelf_update (this, state_vector) Author Christopher MacMackin Date April 2016 Updates the state of the ice shelf from its state vector. The state\n vector is a real array containing the value of each of the ice shelf's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n glacier. private subroutine shelf_set_time (this, time) Author Christopher MacMackin Date November 2016 Sets the time information held by the ice shelf object. This is\n the time at which the ice sheet is in its current state. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the glacier is in the present state. private subroutine shelf_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the ice shelf object from the specified group\n in an HDF5 file. This sets the thickness, the velocity, and\n parameter values. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine shelf_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the ice shelf object to an HDF file in the\n specified group. This will consist of a thickness and a velocity\n dataset. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine shelf_solve_velocity (this, basal_drag, success) Author Chris MacMackin Date May 2017 Computes the ice shelf velocity at the current time with the\n current ice thickness. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. logical, intent(out) :: success True if the integration is successful, false otherwise private subroutine shelf_integrate (this, old_states, basal_melt, basal_drag, water_density, time, success) Author Chris MacMackin Date May 2017 Integrates the glacier's state forward to time . This is done\n using an explicit method for the thickness and a Newton's solver\n for velocity. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the glacier, with the most recent one\n first. class(scalar_field), intent(in) :: basal_melt The melt rate that the bottom of the glacier experiences\n during this time step. class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. real(kind=r8), intent(in) :: time The time to which the glacier should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise private subroutine shelf_assign (this, rhs) Author Chris MacMackin Date February 2017 Copies the data from one ice shelf into another. This is only\n needed due to a bug in gfortran which means that the intrinsic\n assignment for glacier types is not using the appropriate\n defined assignment for the field components. Read more… Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(out) :: this class( glacier ), intent(in) :: rhs The ice shelf to be assigned to this one. private subroutine ice_shelf_integrate_layers (this, old_states, time, success) Author Chris MacMackin Date September 2018 Integrate the Taylor coefficients representing the vertical\n structure of internal reflectors forward to the specified\n time. This is done using an implicit method, with the resulting\n linear system solved using GMRES. Arguments Type Intent Optional Attributes Name class( ice_shelf ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: old_states Previous states of the ice_shelf, with the most recent one\n first. real(kind=r8), intent(in) :: time The time to which the ice_shelf should be integrated logical, intent(out) :: success True if the integration is successful, false otherwise"},{"title":"specfun_mod – ISOFT","tags":"","loc":"module/specfun_mod.html","text":"SPECFUN is a FORTRAN90 library which evaluates certain special\n functions, by William Cody and Laura Stoltz. In particular, SPECFUN can evaluate the I, J, K and Y Bessel\n functions, of orders 0, 1, or arbitrary positive integer order N,\n or for any positive non-integer order (an unusual feature). Routines are also available for the Gamma function, the logarithm\n of the Gamma function, the exponential integrals, the error\n function, the Psi function, and Dawson's integral. The original, true, correct (FORTRAN77) version of SPECFUN is\n available through NETLIB:\n http://www.netlib.org/specfun/index.html\". Note The routines used to calculate the real exponential integral\n have been slightly modified so that they have the elemental attribute. To do this, I needed to enclose them in a module. I was\n having some issues compiling the module (the compiler didn't seem\n to see the r8_gamma function and thus didn't correctly apply\n name-mangling). To avoid these, I just deleted everything that I\n didn't need. Contents Functions ei Subroutines calcei Functions public elemental function ei (x) * * * * * * * * * * * *80 Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x Return Value real(kind=8) Subroutines public elemental subroutine calcei (arg, result, jint) * * * * * * * * * * * *80 Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: arg real(kind=8), intent(out) :: result integer(kind=4), intent(in) :: jint"},{"title":"uniform_gradient_field_mod – ISOFT","tags":"","loc":"module/uniform_gradient_field_mod.html","text":"Provides an extension of the uniform field type which also appears\n to have a uniform gradient. This was written to allow some of the\n same code used when solving the plume in a Runge-Kutta solver,\n where I pass in uniform fields rather than ones using a Chebyshev\n grid. Uses iso_fortran_env utils_mod factual_mod module~~uniform_gradient_field_mod~~UsesGraph module~uniform_gradient_field_mod uniform_gradient_field_mod utils_mod utils_mod module~uniform_gradient_field_mod->utils_mod factual_mod factual_mod module~uniform_gradient_field_mod->factual_mod iso_fortran_env iso_fortran_env module~uniform_gradient_field_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~uniform_gradient_field_mod~~UsedByGraph module~uniform_gradient_field_mod uniform_gradient_field_mod module~upstream_plume_mod upstream_plume_mod module~upstream_plume_mod->module~uniform_gradient_field_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~upstream_plume_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~upstream_plume_mod module~plume_mod plume_mod module~plume_mod->module~upstream_plume_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces uniform_gradient_field Derived Types uniform_gradient_field Functions constructor uniform_gradient_d_dx uniform_gradient_gradient uniform_gradient_is_equal Subroutines uniform_gradient_assign Interfaces public interface uniform_gradient_field private function constructor (val, grad) result(this) Author Chris MacMackin Date July 2017 Creates a new scalar field with a uniform value across all of\n space but a non-zero gradient. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: val The value of the field real(kind=r8), intent(in), dimension(:) :: grad An array in which the i th element contains the gradient in\n the _i_th direction. Directions corresponding to values of i greater than the size of the array are taken to have a\n gradient of zero. Return Value type( uniform_gradient_field ) A scalar field initated based on teh arguments of this\n function. Derived Types type, public, extends(uniform_scalar_field) :: uniform_gradient_field A type of uniform field which also has a uniform gradient. Of\n course, this is impossible in practice, but it can be useful for\n tricking certain routines into working properly. Ideally a whole\n new derived type would be created which just holds the value and\n gradient at a single point, but the emphasis is on getting\n something quickly. Note that the gradient is not propagated\n across operations--the result of all overloaded operators is\n just a normal uniform field with no gradient. Components Type Visibility Attributes Name Initial real(kind=r8), public, dimension(:), allocatable :: grad The values of the gradient in each direction. Constructor private  function constructor (val, grad) Creates a new scalar field with a uniform value across all of\n space but a non-zero gradient. Type-Bound Procedures procedure, public :: d_dx => uniform_gradient_d_dx \\frac{\\partial&#94;n}{\\partial x_i&#94;n}({\\rm field}) procedure, private :: gradient => uniform_gradient_gradient \\nabla {\\rm field} procedure, private :: is_equal => uniform_gradient_is_equal Checks fields are equal within a tolerance procedure, private :: assign_field => uniform_gradient_assign {\\rm field} = {\\rm field} Functions private function constructor (val, grad) result(this) Author Chris MacMackin Date July 2017 Creates a new scalar field with a uniform value across all of\n space but a non-zero gradient. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: val The value of the field real(kind=r8), intent(in), dimension(:) :: grad An array in which the i th element contains the gradient in\n the _i_th direction. Directions corresponding to values of i greater than the size of the array are taken to have a\n gradient of zero. Return Value type( uniform_gradient_field ) A scalar field initated based on teh arguments of this\n function. private function uniform_gradient_d_dx (this, dir, order) result(res) Author Chris MacMackin Date July 2017 \\frac{\\partial&#94;{\\rm order}}{\\partial x_{\\rm dir}&#94;{\\rm order}}{\\rm field} Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(in) :: this integer, intent(in) :: dir Direction in which to differentiate integer, intent(in), optional :: order Order of the derivative, default = 1 Return Value class(scalar_field),\n  pointer private function uniform_gradient_gradient (this) result(res) Author Chris MacMackin Date July 2017 \\nabla{\\rm field} Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(in) :: this Return Value class(vector_field),\n  pointer The result of this operation private function uniform_gradient_is_equal (this, rhs) result(iseq) Author Chris MacMackin Date July 2017 Evaluates whether two scalar fields are equal within a tolerance,\n specified by set_tol . Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(in) :: this class(scalar_field), intent(in) :: rhs Return Value logical Subroutines private impure elemental subroutine uniform_gradient_assign (this, rhs) Author Chris MacMackin Date July 2017 {\\rm field} = {\\rm field} Arguments Type Intent Optional Attributes Name class( uniform_gradient_field ), intent(inout) :: this class(scalar_field), intent(in) :: rhs"},{"title":"viscosity_mod – ISOFT","tags":"","loc":"module/viscosity_mod.html","text":"Provides an abstract data type to model viscosity into a\n vertically integrated plume. Uses iso_fortran_env factual_mod module~~viscosity_mod~~UsesGraph module~viscosity_mod viscosity_mod factual_mod factual_mod module~viscosity_mod->factual_mod iso_fortran_env iso_fortran_env module~viscosity_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~viscosity_mod~~UsedByGraph module~viscosity_mod viscosity_mod module~ice_shelf_mod ice_shelf_mod module~ice_shelf_mod->module~viscosity_mod module~newtonian_viscosity_mod newtonian_viscosity_mod module~ice_shelf_mod->module~newtonian_viscosity_mod module~glens_law_mod glens_law_mod module~glens_law_mod->module~viscosity_mod module~newtonian_viscosity_mod->module~viscosity_mod module~ice_sheet_mod ice_sheet_mod module~ice_sheet_mod->module~viscosity_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces get_viscosity Derived Types abstract_viscosity Abstract Interfaces abstract interface private function get_viscosity(this, velocity, temperature, time) result(property) Arguments Type Intent Optional Attributes Name class( abstract_viscosity ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the ice for which the velocity is\n being calculated real(kind=r8), intent(in) :: temperature The temperature of the ice for which viscosity is being\n calculated. real(kind=r8), intent(in), optional :: time The time at which the viscosity is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the viscosity Derived Types type, public, abstract :: abstract_viscosity An abstract data type for calculating viscosity of a vertically\n integrated glacier . Type-Bound Procedures procedure(get_viscosity), public :: ice_viscosity Returns the viscosity for the ice."},{"title":"basal_surface_mod – ISOFT","tags":"","loc":"module/basal_surface_mod.html","text":"Provides an abstract data type to model the ground or ocean below\n the glacier. Uses iso_fortran_env factual_mod nitsol_mod hdf5 module~~basal_surface_mod~~UsesGraph module~basal_surface_mod basal_surface_mod module~nitsol_mod nitsol_mod module~basal_surface_mod->module~nitsol_mod factual_mod factual_mod module~basal_surface_mod->factual_mod iso_fortran_env iso_fortran_env module~basal_surface_mod->iso_fortran_env hdf5 hdf5 module~basal_surface_mod->hdf5 module~nitsol_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~basal_surface_mod~~UsedByGraph module~basal_surface_mod basal_surface_mod module~plume_mod plume_mod module~plume_mod->module~basal_surface_mod module~cryosphere_mod cryosphere_mod module~cryosphere_mod->module~basal_surface_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~basal_surface_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~basal_surface_mod module~ground_mod ground_mod module~ground_mod->module~basal_surface_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables hdf_type_attr Abstract Interfaces get_scalar get_real get_r81d get_i setter time_setter read_dat write_dat surface_solve Derived Types basal_surface Variables Type Visibility Attributes Name Initial character(len=10), public, parameter :: hdf_type_attr = 'basal_type' Abstract Interfaces abstract interface private function get_scalar(this) result(property) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of whatever property of the basal surface is being\n returned. abstract interface private function get_real(this) result(property) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value real(kind=r8) The value of whatever property of the basal surface is being \n returned. abstract interface private function get_r81d(this) result(state_vector) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector of the basal surface abstract interface private function get_i(this) result(property) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this Return Value integer The value of whatever property of the basal surface is being\n returned. abstract interface private subroutine setter(this, state_vector, ice_thickness) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n basal surface. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate and/or drag parameter. abstract interface private subroutine time_setter(this, time) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the basal surface is in the present state. abstract interface private subroutine read_dat(this, file_id, group_name, error) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group from which the data\n will be read. character(len=*), intent(in) :: group_name The name of the group in the HDF5 file from which to read\n basal surface's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. abstract interface private subroutine write_dat(this, file_id, group_name, error) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n basal surface's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. abstract interface private subroutine surface_solve(this, ice_thickness, ice_density, ice_temperature, time, success) Arguments Type Intent Optional Attributes Name class( basal_surface ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise Derived Types type, public, abstract :: basal_surface An abstract data type which represents whatever lies below a glacier .\n This could be the ground, a plume, or a fully dynamic ocean model.\n Methods are available to provide the coupling information between the glacier and the basal surface. Type-Bound Procedures procedure(get_scalar), public :: basal_melt Returns the basal melt rate. procedure(get_scalar), public :: basal_drag_parameter Returns a value which may be needed to calculate basal drag,\n such as the coefficient of friction. procedure(get_real), public :: water_density Density of the water at the basal surface. procedure(setter), public :: update Sets the state of the basal surface procedure(get_i), public :: data_size Returns the number of elements in the basal surface's state\n vector procedure(get_r81d), public :: state_vector Returns the basal surface's state vector, a 1D array with all\n necessary data to describe its state. procedure(read_dat), public :: read_data Read the basal surface data from an HDF5 file on the disc. procedure(write_dat), public :: write_data Writes the data describing the basal surface to the disc as\n an HDF5 file. procedure(surface_solve), public :: solve Solves for the state of the basal surface given a particular\n ice shelf geometry."},{"title":"preconditioner_mod – ISOFT","tags":"","loc":"module/preconditioner_mod.html","text":"Provides a type for preconditioning fields in an iterative\n solver using Picard iteration. Uses iso_fortran_env factual_mod logger_mod penf jacobian_block_mod module~~preconditioner_mod~~UsesGraph module~preconditioner_mod preconditioner_mod penf penf module~preconditioner_mod->penf logger_mod logger_mod module~preconditioner_mod->logger_mod factual_mod factual_mod module~preconditioner_mod->factual_mod iso_fortran_env iso_fortran_env module~preconditioner_mod->iso_fortran_env module~jacobian_block_mod jacobian_block_mod module~preconditioner_mod->module~jacobian_block_mod module~jacobian_block_mod->penf module~jacobian_block_mod->logger_mod module~jacobian_block_mod->factual_mod module~jacobian_block_mod->iso_fortran_env f95_lapack f95_lapack module~jacobian_block_mod->f95_lapack module~boundary_types_mod boundary_types_mod module~jacobian_block_mod->module~boundary_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces preconditioner Derived Types preconditioner Functions constructor Subroutines preconditioner_apply Interfaces public interface preconditioner private function constructor (tolerance, max_iterations) result(this) Author Chris MacMackin Date December 2016 Create a preconditioner object with the desired tolerance and\n maximum number of iterations. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: tolerance The tolerance within which to apply the inverse Jacobian.\n Defaults to 0.001. integer, intent(in), optional :: max_iterations The maximum number of iterations to use when applying the\n preconditioner. Defaults to 20. Return Value type( preconditioner ) Derived Types type, public :: preconditioner Uses Picard iterations to apply the inverse Jacobian of a system\n to a vector, to low accuracy. Rather than directly computing the\n inverse Jacobian, it is more efficient to approximate it. If d is the vector being preconditioned, and z is the\n result of applying the preconditioner, then z = J&#94;{-1}d\n \\Rightarrow Jz = d. Thus, the preconditioner can be applied by\n approximately solving this system for z . Linearising J ,\n this system can be solved efficiently using Picard iteration. Read more… Components Type Visibility Attributes Name Initial real(kind=r8), private :: tolerance = 1.e-3_r8 integer, private :: max_iterations = 20 Constructor private  function constructor (tolerance, max_iterations) Create a preconditioner object with the desired tolerance and\n maximum number of iterations. Type-Bound Procedures procedure, public :: apply => preconditioner_apply Functions private function constructor (tolerance, max_iterations) result(this) Author Chris MacMackin Date December 2016 Create a preconditioner object with the desired tolerance and\n maximum number of iterations. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: tolerance The tolerance within which to apply the inverse Jacobian.\n Defaults to 0.001. integer, intent(in), optional :: max_iterations The maximum number of iterations to use when applying the\n preconditioner. Defaults to 20. Return Value type( preconditioner ) Subroutines private subroutine preconditioner_apply (this, jacobian, vector, estimate) Author Chris MacMackin Date December 2016 Use Picard iteration to approximately multiply the state vector\n by the inverse Jacobian. The details for this procedure are in\n the documentation of the preconditioner type. Arguments Type Intent Optional Attributes Name class( preconditioner ), intent(in) :: this class( jacobian_block ), intent(inout), dimension(:,:) :: jacobian An n\\times n matrix approximating the Jacobian for which\n the preconditioner is used. class(scalar_field), intent(in), dimension(:) :: vector A vector of size n which is to be preconditioned. class(scalar_field), intent(inout), dimension(:) :: estimate On entry, an initial guess for the preconditioned vector. On\n exit, the iteratively determined value of the preconditioned\n vector."},{"title":"pseudospectral_block_mod – ISOFT","tags":"","loc":"module/pseudospectral_block_mod.html","text":"Provides a derived type which representes a finite difference\n matrix/operator. This can be useful for preconditioning problems\n which use a spectral discretisation. Uses iso_fortran_env factual_mod chebyshev_mod penf logger_mod module~~pseudospectral_block_mod~~UsesGraph module~pseudospectral_block_mod pseudospectral_block_mod penf penf module~pseudospectral_block_mod->penf logger_mod logger_mod module~pseudospectral_block_mod->logger_mod factual_mod factual_mod module~pseudospectral_block_mod->factual_mod iso_fortran_env iso_fortran_env module~pseudospectral_block_mod->iso_fortran_env chebyshev_mod chebyshev_mod module~pseudospectral_block_mod->chebyshev_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pseudospectral_block_mod~~UsedByGraph module~pseudospectral_block_mod pseudospectral_block_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~pseudospectral_block_mod module~coriolis_block_mod coriolis_block_mod module~asymmetric_plume_mod->module~coriolis_block_mod module~coriolis_block_mod->module~pseudospectral_block_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~pseudospectral_block_mod module~plume_mod plume_mod module~plume_mod->module~pseudospectral_block_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables no_extra_derivative Interfaces pseudospec_block Derived Types pseudospec_block Functions constructor pseudospec_block_solve_scalar pseudospec_block_solve_vector Variables Type Visibility Attributes Name Initial integer, private, parameter :: no_extra_derivative = -1 Interfaces public interface pseudospec_block private function constructor (template) result(this) Author Chris MacMackin Date September 2017 Builds a Chebyshsev pseudospectral differentiation matrix block\n which can be used to solve the inverse problem. The result can\n only be used with fields having the same grid as the template. Arguments Type Intent Optional Attributes Name class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. Return Value type( pseudospec_block ) Derived Types type, public :: pseudospec_block A data type representing a matrix pseudospectral differentiation\n operator. It can be useful when preconditioning systems which\n use a spectral discretisation, if higher accuracy than finite\n difference is needed. It is inherently 1-D in its\n implementation. Note that multiplication of a field will simply\n call that field's differentiation operator, which may or may not\n use a pseudospectral method. Components Type Visibility Attributes Name Initial real(kind=r8), private, dimension(:), pointer :: xvals Coordinates of collocation points. Constructor private  function constructor (template) Builds a Chebyshsev pseudospectral differentiation matrix block\n which can be used to solve the inverse problem. The result can\n only be used with fields having the same grid as the template. Type-Bound Procedures procedure, private :: pseudospec_block_solve_scalar procedure, private :: pseudospec_block_solve_vector generic, public :: solve_for => pseudospec_block_solve_scalar, pseudospec_block_solve_vector Functions private function constructor (template) result(this) Author Chris MacMackin Date September 2017 Builds a Chebyshsev pseudospectral differentiation matrix block\n which can be used to solve the inverse problem. The result can\n only be used with fields having the same grid as the template. Arguments Type Intent Optional Attributes Name class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. Return Value type( pseudospec_block ) private function pseudospec_block_solve_scalar (this, rhs, bound_loc, bound_val, good_bound) result(solution) Author Chris MacMackin Date September 2017 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a scalar field). Read more… Arguments Type Intent Optional Attributes Name class( pseudospec_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. integer, intent(in) :: bound_loc Which boundary is being set. The boundary will be the one\n normal to dimension of number abs(boundary) . If the\n argument is negative, then the lower boundary is returned. If\n positive, then the upper boundary is returned. class(scalar_field), intent(in) :: bound_val The value of the result at the specified boundary. integer, intent(in), optional :: good_bound If provided, indicates which boundary contains trusted\n information from which to calculate the power of the highest\n frequency mode. Defaults to the opposite of bound_loc . Return Value class(scalar_field),\n  pointer private function pseudospec_block_solve_vector (this, rhs, bound_loc, bound_val, good_bound) result(solution) Author Chris MacMackin Date September 2017 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a vector field). Read more… Arguments Type Intent Optional Attributes Name class( pseudospec_block ), intent(inout) :: this class(cheb1d_vector_field), intent(in) :: rhs The right hand side of the linear(ised) system. integer, intent(in) :: bound_loc Which boundary is being set. The boundary will be the one\n normal to dimension of number abs(boundary) . If the\n argument is negative, then the lower boundary is returned. If\n positive, then the upper boundary is returned. class(vector_field), intent(in) :: bound_val The value of the result at the specified boundary. integer, intent(in), optional :: good_bound If provided, indicates which boundary contains trusted\n information from which to calculate the power of the highest\n frequency mode. Defaults to the opposite of bound_loc . Return Value class(vector_field),\n  pointer"},{"title":"jacobian_block_mod – ISOFT","tags":"","loc":"module/jacobian_block_mod.html","text":"Provides a derived type which is useful for representing blocks in\n a Jacobian matrix. This follows the abstract calculus pattern,\n providing operators for matrix multiplication and for solving the\n linear(ised) system. See the documentation for the jacobian_block type for more details. Uses iso_fortran_env factual_mod boundary_types_mod f95_lapack penf logger_mod module~~jacobian_block_mod~~UsesGraph module~jacobian_block_mod jacobian_block_mod logger_mod logger_mod module~jacobian_block_mod->logger_mod factual_mod factual_mod module~jacobian_block_mod->factual_mod f95_lapack f95_lapack module~jacobian_block_mod->f95_lapack iso_fortran_env iso_fortran_env module~jacobian_block_mod->iso_fortran_env penf penf module~jacobian_block_mod->penf module~boundary_types_mod boundary_types_mod module~jacobian_block_mod->module~boundary_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~jacobian_block_mod~~UsedByGraph module~jacobian_block_mod jacobian_block_mod module~ice_shelf_mod ice_shelf_mod module~ice_shelf_mod->module~jacobian_block_mod module~preconditioner_mod preconditioner_mod module~preconditioner_mod->module~jacobian_block_mod module~ice_sheet_mod ice_sheet_mod module~ice_sheet_mod->module~jacobian_block_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables no_extra_derivative Interfaces jacobian_block Derived Types jacobian_block Functions constructor jacobian_block_multiply jacobian_block_add_real jacobian_block_add_field jacobian_block_add_block jacobian_block_solve Subroutines jacobian_block_assign jacobian_block_get_tridiag jacobian_block_bounds Variables Type Visibility Attributes Name Initial integer, private, parameter :: no_extra_derivative = -1 Interfaces public interface jacobian_block private function constructor (source_field, direction, extra_derivative, boundary_locs, boundary_types, boundary_operations, coef) result(this) Author Chris MacMackin Date December 2016 Build a block in a Jacobian matrix, with the form \\frac{\\partial F}{\\partial x_i} + F\\Delta_i, where F is\n a scalar field and \\Delta_i is the differentiation operator\n in the i -direction. Additionally, a further differentiation\n operator may be added to the right hand side of this matrix\n block.  Optional arguments allow for handling of boundary\n conditions. See the end of the documentation of the jacobian_block type for a description of how boundary\n conditions are treated. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: source_field A scalar field ( F ) making up this block of the Jacobian integer, intent(in) :: direction The direction in which field derivatives are taken. integer, intent(in), optional :: extra_derivative If present, specifies the direction of a differentiation\n operator to be added to the right hand side of this matrix\n block. integer, intent(in), optional dimension(:) :: boundary_locs The locations in the raw representation of rhs for which\n boundary conditions are specified. Defaults to there being\n none. integer, intent(in), optional dimension(:) :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. Defaults to Dirichlet. The\n order in which they are stored must match that of boundary_locs . procedure( jacobian_block_bounds ), optional :: boundary_operations A function specifying the values to place at the boundaries\n of the result when using the Jacobian block for\n multiplication. By default, all boundaries are set to 0. The\n order in which the resulting values are stored should match\n that of boundary_locs . real(kind=r8), intent(in), optional :: coef An optional coefficient by which the the \\partial\n F/\\partial x term in the operator will be\n multipled. Default value is 1. Return Value type( jacobian_block ) A new Jacobian block Derived Types type, public :: jacobian_block A data type representing a submatrix of a\n Jacobian. Specifically, it represents the commonly occurring\n operation \\frac{\\partial F}{\\partial x_i} + F\\Delta_i, where \\Delta_i is the differentiation operator in the i -direction. Optionally, there can be an additional\n differentiation operator on the right-hand-side of this. Read more… Components Type Visibility Attributes Name Initial integer, private :: direction The direction in which any derivatives are taken. integer, private :: extra_derivative = no_extra_derivative The direction in which to apply a differentiation on the\n right-hand-side of the Jacobian block operator. Defaults\n none. class(scalar_field), private, allocatable :: contents The value, A , to which the Jacobian block operation is\n beiing applied. real(kind=r8), private :: coef = 1._r8 Optional coefficient by which the the \\partial F/\\partial x term in the operator will be multiplied. procedure( jacobian_block_bounds ), private, pointer, nopass :: get_boundaries A subroutine which determines the expected boundary conditions\n (and their location in the raw array) for the solution of the\n Jacobian block. class(scalar_field), private, allocatable :: derivative The cached derivative of contents real(kind=r8), private, dimension(:), allocatable :: diagonal The diagonal of the tridiagonal matrix representation of this\n block. real(kind=r8), private, dimension(:), allocatable :: super_diagonal The super-diagonal of the tridiagonal matrix representation\n of this block. real(kind=r8), private, dimension(:), allocatable :: sub_diagonal The sub-diagonal of the tridiagonal matrix representation of\n this block. real(kind=r8), private, dimension(:), allocatable :: l_multipliers Multipliers defining the L matrix in the LU factorisation of\n the tridiagonal matrix representation of this block. real(kind=r8), private, dimension(:), allocatable :: u_diagonal The diagonal of the U matrix in the LU factorisation of\n the tridiagonal matrix representation of this block. real(kind=r8), private, dimension(:), allocatable :: u_superdiagonal1 The first superdiagonal of the U matrix in the LU\n factorisation of the tridiagonal matrix representation of\n this block. real(kind=r8), private, dimension(:), allocatable :: u_superdiagonal2 The second superdiagonal of the U matrix in the LU\n factorisation of the tridiagonal matrix representation of\n this block. integer, private, dimension(:), allocatable :: pivots Pivot indicies from the LU factorisation of the tridiagonal\n matrix representation of this block. real(kind=r8), private, dimension(:), allocatable :: boundary_vals Expected boundary values for the solution to the Jacobian\n block. integer, private, dimension(:), allocatable :: boundary_locs Locations in the raw arrays which are used to specify\n boundary conditions. integer, private, dimension(:), allocatable :: boundary_types The types of boundary conditions, specified using the\n parameters found in boundary_types_mod . real(kind=r8), private :: real_increment A scalar value which is to be added to this Jacobian block\n (i.e. to the diagonal). class(scalar_field), private, allocatable :: field_increment A scalar field which is to be added to this Jacobian block\n (i.e. to the diagonal). type( jacobian_block ), private, pointer :: block_increment => null() Another Jacobian block which is to be added to this one integer, private :: has_increment = 0 Indicates whether or not there has been an increment added to\n this block. If not, then 0. If a scalar real value has been\n added, then 1. If a scalar value has been added, then 2. Constructor private  function constructor (source_field, direction, extra_derivative, boundary_locs, boundary_types, boundary_operations, coef) Build a block in a Jacobian matrix, with the form \\frac{\\partial F}{\\partial x_i} + F\\Delta_i, where F is\n a scalar field and \\Delta_i is the differentiation operator\n in the i -direction. Additionally, a further differentiation\n operator may be added to the right hand side of this matrix\n block.  Optional arguments allow for handling of boundary\n conditions. See the end of the documentation of the jacobian_block type for a description of how boundary\n conditions are treated. Type-Bound Procedures procedure, private :: jacobian_block_multiply procedure, private :: jacobian_block_add_real procedure, private :: jacobian_block_add_field procedure, private :: jacobian_block_add_block procedure, private :: jacobian_block_assign procedure, private :: get_tridiag => jacobian_block_get_tridiag generic, public :: operator(*) => jacobian_block_multiply generic, public :: operator(+) => jacobian_block_add_real, jacobian_block_add_field, jacobian_block_add_block generic, public :: assignment(=) => jacobian_block_assign procedure, public :: solve_for => jacobian_block_solve Functions private function constructor (source_field, direction, extra_derivative, boundary_locs, boundary_types, boundary_operations, coef) result(this) Author Chris MacMackin Date December 2016 Build a block in a Jacobian matrix, with the form \\frac{\\partial F}{\\partial x_i} + F\\Delta_i, where F is\n a scalar field and \\Delta_i is the differentiation operator\n in the i -direction. Additionally, a further differentiation\n operator may be added to the right hand side of this matrix\n block.  Optional arguments allow for handling of boundary\n conditions. See the end of the documentation of the jacobian_block type for a description of how boundary\n conditions are treated. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: source_field A scalar field ( F ) making up this block of the Jacobian integer, intent(in) :: direction The direction in which field derivatives are taken. integer, intent(in), optional :: extra_derivative If present, specifies the direction of a differentiation\n operator to be added to the right hand side of this matrix\n block. integer, intent(in), optional dimension(:) :: boundary_locs The locations in the raw representation of rhs for which\n boundary conditions are specified. Defaults to there being\n none. integer, intent(in), optional dimension(:) :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. Defaults to Dirichlet. The\n order in which they are stored must match that of boundary_locs . procedure( jacobian_block_bounds ), optional :: boundary_operations A function specifying the values to place at the boundaries\n of the result when using the Jacobian block for\n multiplication. By default, all boundaries are set to 0. The\n order in which the resulting values are stored should match\n that of boundary_locs . real(kind=r8), intent(in), optional :: coef An optional coefficient by which the the \\partial\n F/\\partial x term in the operator will be\n multipled. Default value is 1. Return Value type( jacobian_block ) A new Jacobian block private recursive function jacobian_block_multiply (this, rhs) result(product) Author Chris MacMackin Date December 2016 Provides a matrix multiplication operator between a Jacobian\n block and a scalar field (which corresponds to a state vector). Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class(scalar_field), intent(in) :: rhs A field corresponding to a state vector being multiplied by\n the Jacobian block. Return Value class(scalar_field),\n  pointer private function jacobian_block_add_real (this, rhs) result(sum) Author Chris MacMackin Date December 2016 Produces a Jacobian block which has been offset by some constant\n increment. Read more… Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this real(kind=r8), intent(in) :: rhs A scalar which should be added to this block Return Value type( jacobian_block ) private function jacobian_block_add_field (this, rhs) result(sum) Author Chris MacMackin Date May 2017 Produces a Jacobian block which has been offset by a scalar\n field. Read more… Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class(scalar_field), intent(in) :: rhs A scalar which should be added to this block Return Value type( jacobian_block ) private function jacobian_block_add_block (this, rhs) result(sum) Author Chris MacMackin Date May 2017 Produces a Jacobian block which is the sum of two existing\n blocks. Boundary conditions are set by the first operand\n ( this ). Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this class( jacobian_block ), intent(in), target :: rhs A second block which should be added to this block Return Value type( jacobian_block ) private function jacobian_block_solve (this, rhs) result(solution) Author Chris MacMackin Date December 2016 Solves the linear(ised) system represented by this Jacobian\n block, for a given right hand side state vector (represented by\n a scalar field). Read more… Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. Return Value class(scalar_field),\n  pointer Subroutines private subroutine jacobian_block_assign (this, rhs) Author Chris MacMackin Date December 2016 Copies the contents of the rhs Jacobian block into this\n one. It will safely deallocate any data necessary. Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(out) :: this type( jacobian_block ), intent(in) :: rhs private recursive subroutine jacobian_block_get_tridiag (this, diagonal, subdiagonal, superdiagonal) Author Chris MacMackin Date May 2017 Computes the tridiagonal matrix used to solve for this Jacobian block. Arguments Type Intent Optional Attributes Name class( jacobian_block ), intent(in) :: this real(kind=r8), intent(out), dimension(:), allocatable :: diagonal real(kind=r8), intent(out), dimension(:), allocatable :: subdiagonal real(kind=r8), intent(out), dimension(:), allocatable :: superdiagonal private subroutine jacobian_block_bounds (contents, derivative, rhs, boundary_locs, boundary_types, boundary_values) Author Chris MacMackin Date January 2016 A default implementation of the get_boundaries procedure\n pointer for the jacobian_block type. It corresponds to setting\n all boundaries to 0 when multiplying a field by the Jacobian\n block. Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: contents The field used to construct the Jacobian block class(scalar_field), intent(in) :: derivative The first spatial derivative of the field used to construct\n the Jacobian block, in the direction specified class(scalar_field), intent(in) :: rhs The scalar field representing the vector being multiplied\n by Jacobian integer, intent(in), dimension(:), allocatable :: boundary_locs The locations in the raw representation of rhs containing\n the boundaries. integer, intent(in), dimension(:), allocatable :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. The storage order must\n correspond to that of boundary_locs . real(kind=r8), intent(out), dimension(:), allocatable :: boundary_values The values to go at the boundaries when multiplying a field\n by the Jacobian block. The storage order must be the same as\n for boundary_locs ."},{"title":"coriolis_block_mod – ISOFT","tags":"","loc":"module/coriolis_block_mod.html","text":"Provides a derived type which representes the operator acting on\n velocity and its derivative with the Coriolis force. This can be\n used for preconditioning in the plume solver. Uses iso_fortran_env factual_mod f95_lapack pseudospectral_block_mod penf logger_mod module~~coriolis_block_mod~~UsesGraph module~coriolis_block_mod coriolis_block_mod logger_mod logger_mod module~coriolis_block_mod->logger_mod factual_mod factual_mod module~coriolis_block_mod->factual_mod f95_lapack f95_lapack module~coriolis_block_mod->f95_lapack iso_fortran_env iso_fortran_env module~coriolis_block_mod->iso_fortran_env module~pseudospectral_block_mod pseudospectral_block_mod module~coriolis_block_mod->module~pseudospectral_block_mod penf penf module~coriolis_block_mod->penf module~pseudospectral_block_mod->logger_mod module~pseudospectral_block_mod->factual_mod module~pseudospectral_block_mod->iso_fortran_env module~pseudospectral_block_mod->penf chebyshev_mod chebyshev_mod module~pseudospectral_block_mod->chebyshev_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~coriolis_block_mod~~UsedByGraph module~coriolis_block_mod coriolis_block_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~coriolis_block_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables trans zero Interfaces coriolis_block Derived Types coriolis_block Functions constructor Subroutines solve_for assign Variables Type Visibility Attributes Name Initial character(len=1), private, parameter :: trans = 'N' The LAPACK parameter indicating not to operate on the transpose\n of the matrix when solving for boundary conditions. type(uniform_scalar_field), private :: zero Interfaces public interface coriolis_block private function constructor (phi, nu, velbound, dvelbound, integrate_bound, template) result(this) Author Chris MacMackin Date January 2018 Builds a Coriolis block which can be used to solve the inverse\n problem for the linear components of the plume momentum\n equations. The result can only be used with fields having the\n same grid as the template. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: phi The dimensionless coriolis parameter real(kind=r8), intent(in) :: nu The dimensionless eddy diffusivity integer, intent(in) :: velbound Location code for the velocity's boundary condition. 1\n indicates upper boundary, -1 indicates lower boundary. integer, intent(in) :: dvelbound Location code for the velocity's boundary condition. 1\n indicates upper boundary, -1 indicates lower boundary. integer, intent(in) :: integrate_bound Location code for the boundary to perform integrations\n from. This should be the opposite boundary from where\n boundary data is stored. class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. Return Value type( coriolis_block ) Derived Types type, public :: coriolis_block A data type representing a matrix operator for the momentum\n components of the linear parts plume equations, with the\n Coriolis force. It can be useful when preconditioning a the\n plume solver. It is inherently 1-D in its implementation, but\n has a transverse velocity component. Read more… Components Type Visibility Attributes Name Initial real(kind=r8), private, dimension(4) :: D_r Real component of the diagonal matrix, \\bm{D} , with only\n diagonal values stored real(kind=r8), private, dimension(4) :: D_i Imaginary component of the diagonal matrix, \\bm{D} , with\n only diagonal values stored type(cheb1d_scalar_field), private, dimension(4,4) :: emDxVinv_r Real component of e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1} type(cheb1d_scalar_field), private, dimension(4,4) :: emDxVinv_i Imaginary component of e&#94;{-\\bm{D}x}\\bm{V}&#94;{-1} type(cheb1d_scalar_field), private, dimension(4) :: eDx_r Real component of e&#94;{\\bm{D}x} , with only diagonal values\n stored type(cheb1d_scalar_field), private, dimension(4) :: eDx_i Imaginary component of e&#94;{\\bm{D}x} , with only diagonal\n values stored real(kind=r8), private, dimension(4,4) :: V_r Real component of the change of basis matrix, \\bm{V} real(kind=r8), private, dimension(4,4) :: V_i Imaginary component of the change of basis matrix, \\bm{V} type( pseudospec_block ), private :: integrator A pseudospectral differentiation block which can be used to\n perform integration integer, private :: vel_bound_loc Location code for the velocity's boundary condition integer, private :: dvel_bound_loc Location code for the velocity derivative's boundary\n condition integer, private :: integrate_bound Location from which to perform the integration real(kind=r8), private, dimension(4) :: xbounds Boundary location for each component of the solution vector complex(kind=r8), private, dimension(4,4) :: bound_matrix Matrix for the system to solve in order to satisfy the\n boundary conditions complex(kind=r8), private, dimension(4,4) :: bound_matrix_scaled Matrix for the system to solve in order to satisfy the\n boundary conditions, which has been scaled by LAPACK95 \n to improve conditioning. complex(kind=r8), private, dimension(4,4) :: factored_matrix Factored matrix for the system to solve in order to satisfy\n the boundary conditions integer, private, dimension(4) :: pivots The pivots used in the factorisation of the matrix used to\n satisfy boundary conditions real(kind=r8), private, dimension(4) :: r_scales Row scale factors from equilibrating the bound_matrix real(kind=r8), private, dimension(4) :: c_scales Column scale factors from equilibrating the bound_matrix character(len=1), private :: equed The method used to equilibrate bound_matrix integer, private :: int Constructor private  function constructor (phi, nu, velbound, dvelbound, integrate_bound, template) Builds a Coriolis block which can be used to solve the inverse\n problem for the linear components of the plume momentum\n equations. The result can only be used with fields having the\n same grid as the template. Type-Bound Procedures procedure, public :: solve_for procedure, private :: assign generic, public :: assignment(=) => assign Functions private function constructor (phi, nu, velbound, dvelbound, integrate_bound, template) result(this) Author Chris MacMackin Date January 2018 Builds a Coriolis block which can be used to solve the inverse\n problem for the linear components of the plume momentum\n equations. The result can only be used with fields having the\n same grid as the template. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: phi The dimensionless coriolis parameter real(kind=r8), intent(in) :: nu The dimensionless eddy diffusivity integer, intent(in) :: velbound Location code for the velocity's boundary condition. 1\n indicates upper boundary, -1 indicates lower boundary. integer, intent(in) :: dvelbound Location code for the velocity's boundary condition. 1\n indicates upper boundary, -1 indicates lower boundary. integer, intent(in) :: integrate_bound Location code for the boundary to perform integrations\n from. This should be the opposite boundary from where\n boundary data is stored. class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. Return Value type( coriolis_block ) Subroutines private subroutine solve_for (this, velocity, velocity_dx) Author Chris MacMackin Date January 2018 Inverts the linear portions of the plume momentum equation with\n the provided data. This is done by solving the linear ODE\n described in the documentation for the coriolis_block type. The block object must first have been initialised using\n the constructor. Read more… Arguments Type Intent Optional Attributes Name class( coriolis_block ), intent(inout) :: this class(vector_field), intent(inout) :: velocity On input, the velocity value being preconditioned. On output,\n the preconditioned velocity. class(vector_field), intent(inout) :: velocity_dx On input, the velocity derivative being preconditioned. On\n output, the preconditioned velocity derivative. private subroutine assign (this, rhs) Author Chris MacMackin Date January 2017 Safely assigns the value of one coriolis block to another. Arguments Type Intent Optional Attributes Name class( coriolis_block ), intent(inout) :: this class( coriolis_block ), intent(in) :: rhs The value being assigned"},{"title":"ode_solvers_mod – ISOFT","tags":"","loc":"module/ode_solvers_mod.html","text":"Provides routines to solve systems of ODEs. Uses iso_fortran_env nitsol_mod logger_mod penf module~~ode_solvers_mod~~UsesGraph module~ode_solvers_mod ode_solvers_mod penf penf module~ode_solvers_mod->penf module~nitsol_mod nitsol_mod module~ode_solvers_mod->module~nitsol_mod logger_mod logger_mod module~ode_solvers_mod->logger_mod iso_fortran_env iso_fortran_env module~ode_solvers_mod->iso_fortran_env module~nitsol_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~ode_solvers_mod~~UsedByGraph module~ode_solvers_mod ode_solvers_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~ode_solvers_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~ode_solvers_mod module~plume_mod plume_mod module~plume_mod->module~ode_solvers_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces L_intr f_intr jac_intr diff_intr pre_intr Subroutines quasilinear_solve Abstract Interfaces abstract interface public function L_intr(u) An interface for the (linear) left-hand-side of an ODE\n being solved by quasilinearisation. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: u The state vector for the system of differential equations Return Value real(kind=r8),\n  dimension(size(u)) abstract interface public function f_intr(u) An interface for the (nonlinear) right-hand-side of an ODE\n being solved by quasilinearisation. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:,:) :: u The state vector for the system of differential equations,\n and its derivatives. Column i represents the i-1 derivative. Return Value real(kind=r8),\n  dimension(size(u,1)) abstract interface public function jac_intr(u, du) An interface for the product of the Jacobian of the\n (nonlinear) right-hand-side of an ODE and another vector. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:,:) :: u The state vector for the system of differential equations,\n and its derivatives, for which the Jacobian should be\n evaluated. Column i represents the i-1 derivative. real(kind=r8), intent(in), dimension(:,:) :: du The state vector for the system of differential equations,\n and its derivatives, which the Jacobian operates on. Column i represents the i-1 derivative. Return Value real(kind=r8),\n  dimension(size(u,1)) abstract interface public function diff_intr(u, n) An interface for a function evaluating the derivative of the\n state vector. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: u The state vector for the system of differential equations integer, intent(in) :: n The order of the derivative to take Return Value real(kind=r8),\n  dimension(size(u)) abstract interface public function pre_intr(v, u, L, f, fcur, rhs) An interface for a preconditioner to be used with the\n quasilinearisation ODE solver. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: v The vector to be preconditioned. real(kind=r8), intent(in), dimension(:,:) :: u The current state vector for the system of differential\n equations, and its derivatives. Column i represents the i-1 derivative. procedure( L_intr ) :: L The linear, left-hand-side of the ODE being solved. procedure( f_intr ) :: f The nonlinear, right-hand-side of the ODE being solved. real(kind=r8), intent(in), dimension(:) :: fcur The result of f(u) real(kind=r8), intent(in), dimension(:) :: rhs The right hand side of the linear system being\n preconditioned. Return Value real(kind=r8),\n  dimension(size(v)) The result of applying the preconditioner. Subroutines public subroutine quasilinear_solve (L, f, jac_prod, solution, order, resid_norm, flag, info, tol, precond, differentiate, iter_max, gmres_iter_max, krylov_dim) Author Chris MacMackin Date March 2017 This is an iterative method to solve nonlinear systems of\n ODEs. Consider L&#94;{(n)}\\vec{u}(x) = \\vec{f}(\\vec{u}(x),\n \\vec{u}&#94;{(1)}(x), \\ldots, \\vec{u}&#94;{n-1}(x), x), \\qquad \\vec{u}\n \\in \\mathbb{R}&#94;{m}. For a domain from (0,b) , boundary\n conditions are specified by g_k(\\vec{u}(0) = 0,\n \\vec{u}&#94;{(1)}(0), \\ldots, \\vec{u}&#94;{n-1}(0)), \\qquad k = 1,\n \\ldots, l g_k(\\vec{u}(b), \\vec{u}&#94;{(1)}(b), \\ldots,\n \\vec{u}&#94;{n-1}(b)) = 0, \\qquad k = l+1, \\ldots, mn. Here, L&#94;{(n)} is an n th order ordinary differential operator,\n and \\vec{f}, g_1, g_2, \\ldots, g_{nm} are nonlinear\n functions of \\vec{u}(x) and its first n-1 derivatives. Read more… Arguments Type Intent Optional Attributes Name procedure( L_intr ) :: L A function providing the linear, left-hand-side of the ODE\n being solved. procedure( f_intr ) :: f A function providing the nonlinear, right-hand-side of the\n ODE being solved. procedure( jac_intr ) :: jac_prod A function providing the product of the Jacobian of the\n nonlinear, right-hand-side of the ODE being solved and\n another vector. real(kind=r8), intent(inout), dimension(:) :: solution On input, an estimate of the solution to the ODE. On output,\n the actual solution. integer, intent(in) :: order The order of the derivative taken by L real(kind=r8), intent(out) :: resid_norm Norm of the residual of the final solution. integer, intent(out) :: flag Status flag indicating whether the iterations ended succesfully. Read more… integer, intent(out), optional dimension(5) :: info Array containing various outputs; see above real(kind=r8), intent(in), optional :: tol The required reduction in the solution residual. Default is size(solution) * 1e-8 . procedure( pre_intr ), optional :: precond A right-preconditioner which may be used to improve\n convergence of the solution. procedure( diff_intr ), optional :: differentiate A procedure which will evaluate the n th derivative of the\n state vector, when n is less than order . integer, intent(in), optional :: iter_max Maximum allowable number of quasilinearised\n iterations. Default is 15. integer, intent(in), optional :: gmres_iter_max Maximum allowable number of GMRES iterations. Default is\n 1000. integer, intent(in), optional :: krylov_dim Maximum Krylov subspace dimension; default 10. Larger values\n will allow for faster convergence (and in some cases be the\n difference between whether or not convergence is possible),\n but require more memory."},{"title":"plume_mod – ISOFT","tags":"","loc":"module/plume_mod.html","text":"Provides a concrete implementation of the basal_surface data type,\n representing a buoyant plume beneath an ice shelf. Uses iso_fortran_env basal_surface_mod factual_mod ode_solvers_mod entrainment_mod melt_relationship_mod plume_boundary_mod upstream_plume_mod boundary_types_mod ambient_mod equation_of_state_mod jenkins1991_entrainment_mod dallaston2015_melt_mod uniform_ambient_mod simple_plume_boundary_mod pseudospectral_block_mod linear_eos_mod hdf5 h5lt logger_mod penf module~~plume_mod~~UsesGraph module~plume_mod plume_mod logger_mod logger_mod module~plume_mod->logger_mod h5lt h5lt module~plume_mod->h5lt module~melt_relationship_mod melt_relationship_mod module~plume_mod->module~melt_relationship_mod module~equation_of_state_mod equation_of_state_mod module~plume_mod->module~equation_of_state_mod module~ode_solvers_mod ode_solvers_mod module~plume_mod->module~ode_solvers_mod factual_mod factual_mod module~plume_mod->factual_mod module~upstream_plume_mod upstream_plume_mod module~plume_mod->module~upstream_plume_mod module~jenkins1991_entrainment_mod jenkins1991_entrainment_mod module~plume_mod->module~jenkins1991_entrainment_mod hdf5 hdf5 module~plume_mod->hdf5 module~basal_surface_mod basal_surface_mod module~plume_mod->module~basal_surface_mod module~simple_plume_boundary_mod simple_plume_boundary_mod module~plume_mod->module~simple_plume_boundary_mod module~plume_boundary_mod plume_boundary_mod module~plume_mod->module~plume_boundary_mod iso_fortran_env iso_fortran_env module~plume_mod->iso_fortran_env module~pseudospectral_block_mod pseudospectral_block_mod module~plume_mod->module~pseudospectral_block_mod module~ambient_mod ambient_mod module~plume_mod->module~ambient_mod module~linear_eos_mod linear_eos_mod module~plume_mod->module~linear_eos_mod penf penf module~plume_mod->penf module~uniform_ambient_mod uniform_ambient_mod module~plume_mod->module~uniform_ambient_mod module~entrainment_mod entrainment_mod module~plume_mod->module~entrainment_mod module~boundary_types_mod boundary_types_mod module~plume_mod->module~boundary_types_mod module~dallaston2015_melt_mod dallaston2015_melt_mod module~plume_mod->module~dallaston2015_melt_mod module~melt_relationship_mod->factual_mod module~melt_relationship_mod->iso_fortran_env module~equation_of_state_mod->factual_mod module~equation_of_state_mod->iso_fortran_env module~ode_solvers_mod->logger_mod module~ode_solvers_mod->iso_fortran_env module~ode_solvers_mod->penf module~nitsol_mod nitsol_mod module~ode_solvers_mod->module~nitsol_mod module~upstream_plume_mod->logger_mod module~upstream_plume_mod->factual_mod module~upstream_plume_mod->module~plume_boundary_mod module~upstream_plume_mod->iso_fortran_env module~upstream_plume_mod->penf module~upstream_plume_mod->module~boundary_types_mod module~rksuite_90 rksuite_90 module~upstream_plume_mod->module~rksuite_90 module~uniform_gradient_field_mod uniform_gradient_field_mod module~upstream_plume_mod->module~uniform_gradient_field_mod module~jenkins1991_entrainment_mod->factual_mod module~jenkins1991_entrainment_mod->iso_fortran_env module~jenkins1991_entrainment_mod->module~entrainment_mod module~basal_surface_mod->factual_mod module~basal_surface_mod->hdf5 module~basal_surface_mod->iso_fortran_env module~basal_surface_mod->module~nitsol_mod module~simple_plume_boundary_mod->factual_mod module~simple_plume_boundary_mod->module~plume_boundary_mod module~simple_plume_boundary_mod->iso_fortran_env module~simple_plume_boundary_mod->module~boundary_types_mod module~plume_boundary_mod->factual_mod module~plume_boundary_mod->iso_fortran_env module~plume_boundary_mod->module~boundary_types_mod module~pseudospectral_block_mod->logger_mod module~pseudospectral_block_mod->factual_mod module~pseudospectral_block_mod->iso_fortran_env module~pseudospectral_block_mod->penf chebyshev_mod chebyshev_mod module~pseudospectral_block_mod->chebyshev_mod module~ambient_mod->factual_mod module~ambient_mod->iso_fortran_env module~linear_eos_mod->module~equation_of_state_mod module~linear_eos_mod->factual_mod module~linear_eos_mod->iso_fortran_env module~uniform_ambient_mod->factual_mod module~uniform_ambient_mod->iso_fortran_env module~uniform_ambient_mod->module~ambient_mod module~entrainment_mod->factual_mod module~entrainment_mod->iso_fortran_env module~dallaston2015_melt_mod->module~melt_relationship_mod module~dallaston2015_melt_mod->factual_mod module~dallaston2015_melt_mod->iso_fortran_env module~nitsol_mod->iso_fortran_env module~rksuite_90_prec rksuite_90_prec module~rksuite_90->module~rksuite_90_prec module~uniform_gradient_field_mod->factual_mod module~uniform_gradient_field_mod->iso_fortran_env utils_mod utils_mod module~uniform_gradient_field_mod->utils_mod module~rksuite_90_prec->iso_fortran_env var panmoduleplume_modUsesGraph = svgPanZoom('#moduleplume_modUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables hdf_type_name hdf_thickness hdf_velocity hdf_temperature hdf_salinity hdf_delta hdf_nu hdf_mu hdf_r hdf_phi Abstract Interfaces scalar_func velocity_func Derived Types plume Functions plume_melt plume_drag_parameter plume_water_density plume_data_size plume_state_vector Subroutines plume_initialise plume_update plume_read_data plume_write_data plume_solve Variables Type Visibility Attributes Name Initial character(len=9), public, parameter :: hdf_type_name = 'plume' character(len=9), public, parameter :: hdf_thickness = 'thickness' character(len=8), public, parameter :: hdf_velocity = 'velocity' character(len=11), public, parameter :: hdf_temperature = 'temperature' character(len=8), public, parameter :: hdf_salinity = 'salinity' character(len=5), public, parameter :: hdf_delta = 'delta' character(len=2), public, parameter :: hdf_nu = 'nu' character(len=2), public, parameter :: hdf_mu = 'mu' character(len=5), public, parameter :: hdf_r = 'r_val' character(len=3), public, parameter :: hdf_phi = 'phi' Abstract Interfaces abstract interface private pure function scalar_func(location) result(scalar) Abstract interface for function providing the initial values\n for the scalar properties of a plume object when it\n is being instantiated. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the property Return Value real(kind=r8) The value of the scalar quantity at location abstract interface private pure function velocity_func(location) result(vector) Abstract interface for function providing the plume velocity\n when an object is being instantiated. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: location The position $\\vec{x}$ at which to compute the thickness Return Value real(kind=r8),\n  dimension(:), allocatable The velocity vector of the water in the plume at location Derived Types type, public, extends( basal_surface ) :: plume A concrete implementation of the basal_surface abstract data type, representing the buoyant plume beneath an\n ice shelf. Components Type Visibility Attributes Name Initial type(cheb1d_scalar_field), private :: thickness The thickness of the plume type(cheb1d_vector_field), private :: velocity The velocity of the plume type(cheb1d_vector_field), private :: velocity_dx The derivative of the velocity field type(cheb1d_scalar_field), private :: temperature The temperature of the plume type(cheb1d_scalar_field), private :: temperature_dx The derivative of the temperature of the plume type(cheb1d_scalar_field), private :: salinity The salinity of the plume type(cheb1d_scalar_field), private :: salinity_dx The derivative of the salinity of the plume class( abstract_entrainment ), private, allocatable :: entrainment_formulation An object which provides the parameterisation for entrainment\n of water into the plume. class( abstract_melt_relationship ), private, allocatable :: melt_formulation An object which provides the parameterisation for melting,\n salt, and heat fluxes from the plume to the ice. class( ambient_conditions ), private, allocatable :: ambient_conds An object specifying the temperature and salinity of the\n ambient ocean at its interface with the plume. class( equation_of_state ), public, allocatable :: eos An object specifying the equation of state relating the plume\n water's density to its temperature and salinity. class( plume_boundary ), private, allocatable :: boundaries An object specifying the boundary conditions for the plume. real(kind=r8), private :: delta The dimensionless ratio \\delta \\equiv \\frac{D_0}{h_0} real(kind=r8), public :: nu The dimensionless ratio \\nu \\equiv \\frac{\\kappa_0}{x_0U_o} real(kind=r8), private :: mu The dimensionless ratio \\mu \\equiv \\frac{C_dx_0}{D_0} real(kind=r8), private :: r_val The dimensionless ratio of the ocean water density to the\n density of the overlying ice shelf. real(kind=r8), public :: phi The inverse Rossby number, \\Phi \\equiv \\frac{fx_0}{U_0} real(kind=r8), private :: time The time at which the ice shelf is in this state integer, private :: thickness_size The number of data values in the thickness field integer, private :: velocity_size The number of data values in the velocity field integer, private :: temperature_size The number of data values in the temperature field integer, private :: salinity_size the number of data values in the salinity field logical, private, dimension(7) :: lower_bounds = .false. Which variables have boundary conditions at the grounding\n line. logical, private, dimension(7) :: upper_bounds = .false. Which variables have boundary conditions at the calving\n front. type( pseudospec_block ), private :: precond A pseudospectral differentiation block which can be used for\n preconditioning. Type-Bound Procedures procedure, public :: initialise => plume_initialise procedure, public :: basal_melt => plume_melt procedure, public :: basal_drag_parameter => plume_drag_parameter procedure, public :: water_density => plume_water_density procedure, public :: update => plume_update procedure, public :: data_size => plume_data_size procedure, public :: state_vector => plume_state_vector procedure, public :: read_data => plume_read_data procedure, public :: write_data => plume_write_data procedure, public :: solve => plume_solve Functions private function plume_melt (this) result(melt) Author Christopher MacMackin Date April 2016 Computes and returns the melt rate at the bottom of the ice\n shelf due to interaction with the plume. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice shelf. private function plume_drag_parameter (this) result(drag) Author Christopher MacMackin Date April 2016 Computes and returns a quantity which may be necessary to determine\n the frictional drag the plume exerts on the bottom of the ice\n shelf. The plume would actually tend to exert no drag on the bottom\n of the ice shelf, but this method is present so that there is a\n consistent interface with the ground data type. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. private function plume_water_density (this) result(density) Author Christopher MacMackin Date April 2016 Computes and returns the density of the plume water beneath the ice\n shelf. The density of this water would vary depending on how much \n saline ambient water has been entrained into the plume versus how\n much fresh water has been released due to melting. However, the\n Boussinesq approximation is used here and only a single reference \n density is returned. Read more… Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value real(kind=r8) The density of the water at the base of the ice sheet. private function plume_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the plume's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value integer The number of elements in the plume's state vector. private function plume_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the plume. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the plume. Subroutines private subroutine plume_initialise (this, domain, resolution, thickness, velocity, temperature, salinity, entrainment_formulation, melt_formulation, ambient_conds, eos, boundaries, delta, nu, mu, r_val, phi) Author Christopher MacMackin Date April 2016 Instantiates a plume object with initial coniditions\n provided by the arguments.At present only a 1D model is\n supported. If information is provided for higher dimensions then\n it will be ignored. Arguments Type Intent Optional Attributes Name class( plume ), intent(out) :: this A plume object with its domain and initial conditions set according\n to the arguments of the constructor function. real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the plume. The first index represents the dimension for which the\n boundaries apply. If the second index is 1 then it corresponds to\n the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( scalar_func ) :: thickness A function which calculates the initial value of the thickness of \n the plume at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the water at a given location in a plume. procedure( scalar_func ) :: temperature A function which calculates the initial value of the temperature of \n the plume at a given location. procedure( scalar_func ) :: salinity A function which calculates the initial value of the salinity of \n the plume at a given location. class( abstract_entrainment ), intent(inout), optional allocatable :: entrainment_formulation An object which calculates entrainment into the plume. Will\n be unallocated on exit. Defaults to that used by Jenkins\n (1991) with the coefficient $E_0 = 1$. class( abstract_melt_relationship ), intent(inout), optional allocatable :: melt_formulation An object which calculates melting and the resulting thermal\n transfer into/out of the plume. Will be unallocated on\n exit. Defaults to that used by Dallaston et al. (2015),\n scaled to be consistent with the nondimensionalisation used\n here. class( ambient_conditions ), intent(inout), optional allocatable :: ambient_conds An object specifying the salinity and temperature of the\n ambient ocean. Will be unallocated on exit. Defaults to\n uniform ambient salinity and temperature, both of which are\n set to 0 (as temperature and salinity are measured relative\n to some reference value). class( equation_of_state ), intent(inout), optional allocatable :: eos An object specifying the equation of state for the water in\n the plume. Will be unallocated on exit. Defaults to\n linearised equation of state with no temperature dependence\n and a haline contraction coefficient of 1. The reference\n density is set to be 1 in the dimensionless units when\n salinity and temeprature are 0. class( plume_boundary ), intent(inout), optional allocatable :: boundaries An object providing the boundary conditions for the\n plume. Will be unallocated on exit. Defaults to those used by\n Dallaston et al. (2015). real(kind=r8), intent(in), optional :: delta The dimensionless ratio \\delta \\equiv\n \\frac{D_0}{h_0} . Defaults to 0.036. real(kind=r8), intent(in), optional :: nu The dimensionless ratio \\nu \\equiv\n \\frac{\\kappa_0}{x_0U_o} . Defaults to 0. real(kind=r8), intent(in), optional :: mu The dimensionless ratio \\mu \\equiv\n \\frac{\\C_dx_0}{D_0} . Defaults to 0. real(kind=r8), intent(in), optional :: r_val The dimensionless ratio of the water density to the ice shelf\n density, r = \\rho_0/\\rho_i. Defaults to 1.12. real(kind=r8), intent(in), optional :: phi The inverse Rossby number, \\Phi \\equif\n \\frac{fx_0}{U_0} . Defaults to 0. private subroutine plume_update (this, state_vector, ice_thickness) Author Christopher MacMackin Date April 2016 Updates the state of the plume from its state vector. The state\n vector is a real array containing the value of each of the plume's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( plume ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n plume. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate. private subroutine plume_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the plume object from an HDF file in the\n specified group. This sets the thickness, velocity, temperature,\n salinity dataset, and parameter values. Arguments Type Intent Optional Attributes Name class( plume ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine plume_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the plume object to an HDF file in the\n specified group. This will consist of a thickness, a velocity, a\n temperature, and a salinity dataset. Arguments Type Intent Optional Attributes Name class( plume ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine plume_solve (this, ice_thickness, ice_density, ice_temperature, time, success) Author Chris MacMackin Date March 2017 Solves the state of the plume for the specified ice properties,\n at the specified time. This is done using the a\n quasilinearisation method and a GMRES iterative linear solver. Arguments Type Intent Optional Attributes Name class( plume ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise"},{"title":"nitsol_mod – ISOFT","tags":"","loc":"module/nitsol_mod.html","text":"Provides an explicit interface to the NITSOL package. Variables held in common blocks which can be used to\n control NITSOL are also provided here. At some point I may produce\n a proper object oriented interface for it. Also present is an interface to the GMRES solver provided by\n NITSOL. Both a direct interface and a wrapper are provided. The\n wrapper offers a somewhat more general and F90-ish presentation of\n the routine. Uses iso_fortran_env module~~nitsol_mod~~UsesGraph module~nitsol_mod nitsol_mod iso_fortran_env iso_fortran_env module~nitsol_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~nitsol_mod~~UsedByGraph module~nitsol_mod nitsol_mod module~ice_shelf_mod ice_shelf_mod module~ice_shelf_mod->module~nitsol_mod module~glacier_mod glacier_mod module~ice_shelf_mod->module~glacier_mod module~cryosphere_mod cryosphere_mod module~cryosphere_mod->module~nitsol_mod module~cryosphere_mod->module~glacier_mod module~basal_surface_mod basal_surface_mod module~cryosphere_mod->module~basal_surface_mod module~glacier_mod->module~nitsol_mod module~ode_solvers_mod ode_solvers_mod module~ode_solvers_mod->module~nitsol_mod module~basal_surface_mod->module~nitsol_mod module~finite_difference_block_mod finite_difference_block_mod module~finite_difference_block_mod->module~nitsol_mod module~ground_mod ground_mod module~ground_mod->module~basal_surface_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~ode_solvers_mod module~asymmetric_plume_mod->module~basal_surface_mod module~ice_sheet_mod ice_sheet_mod module~ice_sheet_mod->module~glacier_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~ode_solvers_mod module~static_plume_mod->module~basal_surface_mod module~plume_mod plume_mod module~plume_mod->module~ode_solvers_mod module~plume_mod->module~basal_surface_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Common Blocks nitprint nitinfo nitparam Interfaces nitsol nitgm2 nittfq2 nitstb2 ddot dnrm2 Abstract Interfaces dinpr_intr dnorm_intr mat_mult f_intr jacv_intr Subroutines dummy_jacv dummy_f gmres_solve tfqmr_solve bicgstab_solve Common Blocks common /nitprint/ Type Attributes Name Initial integer :: iplvl integer :: ipunit common /nitinfo/ Type Attributes Name Initial real(kind=r8) :: avrate real(kind=r8) :: fcurnrm integer :: instep integer :: newstep integer :: krystat common /nitparam/ Type Attributes Name Initial real(kind=r8) :: choice1_exp real(kind=r8) :: choice2_exp real(kind=r8) :: choice2_coef real(kind=r8) :: eta_cutoff real(kind=r8) :: etamax real(kind=r8) :: thmin real(kind=r8) :: thmax real(kind=r8) :: etafixed $(function () {\n    $('[data-toggle=\"popover\"]').popover()\n    }) Interfaces interface public subroutine nitsol(n, x, f, jacv, ftol, stptol, input, info, rwork, rpar, ipar, iterm, dinpr, dnorm) An explicit interface to the nitsol Newton iterative nonlinear solver. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(inout), dimension(n) :: x Vector of length n, initial guess on input and final\n approximate solution on output procedure( f_intr ) :: f User-supplied subroutine for evaluating the function\n the zero of which is sought. procedure( jacv_intr ) :: jacv User-supplied subroutine for optionally evaluating J\\vec{v} or P&#94;{-1}\\vec{v} , where J is the Jacobian\n of f and P is a right preconditioning operator. If\n neither analytic J\\vec{v} evaluations nor right\n preconditioning is used, this can be a dummy subroutine;\n if right preconditioning is used but not analytic J\\vec{v} evaluations, this need only evaluate P&#94;{-1}\\vec{v} . real(kind=r8), intent(in) :: ftol Stopping tolerance of the f-norm real(kind=r8), intent(in) :: stptol Stopping tolerance of the step-length integer, intent(in), dimension(10) :: input Array containing various user-specified inputs; see above integer, intent(out), dimension(6) :: info Array containing various outputs; see above real(kind=r8), intent(inout), dimension(*) :: rwork Work array with length depending on the solver used as follows: GMRES n\\times(\\text{kdmax}+5)+\\text{kdmax}\\times(\\text{kdmax}+3) ,\n where kdmax is the maximum Krylove subspace dimension, either\n the default value of 20 or another value specified by the user BiCGSTAB 11n TFQMR 14n real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array passed to the f and jacv routines integer, intent(inout), dimension(*) :: ipar Parameter/work array passed to the f and jacv routines integer, intent(out) :: iterm Termination flag. Values have the following meanings: -k illegal value in input(k) 0 normal termination: ||F|| < \\text{ftol} or ||\\text{step}||\n < \\text{stptol} 1 nnimax nonlinar iterations reached without success 2 failure to evaluate F 3 in nitjv , J\\vec{v} failure 4 in nitjv , P&#94;{-1}\\vec{v} failure 5 in nitdrv , insufficient initial model norm reduction for\n adequate progress. Note: This can occur for several\n reasons; examine itrmks on return from the Krylov solver\n for further information. (This will be printed out if \\text{iplvl}\\ge 3 ; see the discussion of optional common\n blocks below.) 6 in nitbt , failure to reach an acceptable step through\n backtracking procedure( dinpr_intr ) :: dinpr User-supplied function for calculating vector inner products.\n This has the same interace as the BLAS routine ddot .\n If the Euclidean inner product is desired then user can link\n to a local BLAS library and provide the name ddot to nitsol . dinpr must be declared as an external function that returns\n a double precision in the calling program. procedure( dnorm_intr ) :: dnorm User-supplied function for calculating vector norms. This\n has the same interface as the BLAS routine dnrm2; if the\n Euclidean norm is desired the user can link to a local\n BLAS library and provide the name dnrm2 to nitsol.  dnorm\n must be declared as an external function that returns a\n double precision value in the calling program. interface public subroutine nitgm2(n, xcur, fcur, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, iresup, ifdord, nfe, njve, nrpre, nli, kdmax, kdmaxp1, vv, rr, svbig, svsml, w, rwork, rsnrm, dinpr, dnorm, itrmks) An interface to my modified versino of the nitsol implementation of the generalised minimal residual method\n ( GMRES )\n for iteratively solving linear systems. It has been modified\n so that the user provides a non-zero initial guess of the\n solution. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(in), dimension(n) :: fcur Array of length n containing current approximate solution real(kind=r8), intent(inout), dimension(n) :: step Vector of of length n containing trial step real(kind=r8), intent(in) :: eta Relative residual reduction factor procedure( f_intr ) :: f User-supplied subroutine for evaluating the function\n the zero of which is sought. procedure( jacv_intr ) :: jacv User-supplied subroutine for optionally evaluating J\\vec{v} or P&#94;{-1}\\vec{v} , where J is the Jacobian\n of f and P is a right preconditioning operator. If\n neither analytic J\\vec{v} evaluations nor right\n preconditioning is used, this can be a dummy subroutine;\n if right preconditioning is used but not analytic J\\vec{v} evaluations, this need only evaluate P&#94;{-1}\\vec{v} . real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array passed to the f and jacv routines integer, intent(inout), dimension(*) :: ipar Parameter/work array passed to the f and jacv routines integer, intent(in) :: ijacv Flag for determining method of J\\vec{v} evaluation. 0\n (default) indicates finite-difference evaluation, while 1\n indicates analytic evaluation. integer, intent(in) :: irpre Flag for right preconditioning. 0 indicates no\n preconditioning, while 1 inidcates right preconditioning. integer, intent(in) :: iksmax Maximum allowable number of GMRES iterations integer, intent(in) :: iresup Residual update flag. On GMRES restarts, the residual can\n be updated using a linear combination ( iresup == 0 ) or by\n direct evaluation ( iresup == 1 ). The first is cheap (one\n n-vector saxpy) but may lose accuracy with extreme residual\n reduction; the second retains accuracy better but costs one J\\vec{v} product. integer, intent(in) :: ifdord Order of the finite-difference formula (sometimes) used on\n GMRES restarts when J\\vec{v} products are evaluated\n using finite- differences. When ijacv = 0 on input to\n nitsol, ifdord is set to 1, 2, or 4 in nitsol; otherwise,\n it is irrelevant. When ijacv = 0 on input to this\n subroutine, the precise meaning is as follows: With GMRES, ifdord matters only if iresup = 1, in which case it determines the order of the finite-difference formula used \n in evaluating the initial residual at each GMRES restart (default 2). If iresup = 1 and ijacv = 0 on input to this subroutine, then ijacv is temporarily reset to -1 at each restart below to force a finite-difference evaluation of order\n ifdord. NOTE: This only affects initial residuals at restarts;\n first-order differences are always used within each GMRES cycle. Using higher-order differences at restarts only should \n give the same accuracy as if higher-order differences were used throughout; see K. Turner and H. F. Walker, \"Efficient high accuracy solutions with GMRES(m),\" SIAM J. Sci. Stat. Comput., 13 (1992), pp. 815--825. integer, intent(inout) :: nfe Number of function evaluations integer, intent(inout) :: njve Number of J\\vec{v} evaluations integer, intent(inout) :: nrpre Number of P&#94;{-1}\\vec{v} evaluations integer, intent(inout) :: nli Number of linear iterations integer, intent(in) :: kdmax Maximum Krylov subspace dimension; default 10. integer, intent(in) :: kdmaxp1 kdmax + 1 real(kind=r8), intent(out), dimension(n, kdmaxp1) :: vv Matrix for storage of Krylov basis in GMRES; on return, the\n residual vector is contained in the first column. real(kind=r8), intent(out), dimension(kdmax, kdmax) :: rr Matrix for storage of triangular matrix in GMRES. real(kind=r8), intent(out), dimension(kdmax) :: svbig Vector for storage of estimate of singular vector of rr with largest singular value. real(kind=r8), intent(out), dimension(kdmax) :: svsml Vector for storage of estimate of singular vector of rr with smallest singular value. real(kind=r8), intent(out), dimension(kdmax) :: w Vector containing right-hand side of triangular system and\n least-squares residual norm in GMRES. real(kind=r8), intent(out), dimension(n) :: rwork Work array real(kind=r8), intent(out) :: rsnrm GMRES residual norm on return procedure( dinpr_intr ) :: dinpr Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ) :: dnorm Norm routine, either user supplied or BLAS dnrm2. integer, intent(out) :: itrmks Termination flag. Values have the following meanings: 0 normal termination: acceptable step found 1 J\\vec{v} failure in nitjv 2 P&#94;{-1}\\vec{v} failure in nitjv 3 Acceptable step not found in iksmax GMRES iterations 4 Insignificant residual norm reduction of a cycle of kdmax steps (stagnation) before an acceptable step has been found. 5 Dangerous ill-conditioning detected before an acceptable \n step has been found. interface public subroutine nittfq2(n, xcur, fcur, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, ifdord, nfe, njve, nrpre, nli, r, rcgs, rtil, d, p, q, u, v, y, rwork1, rwork2, rsnrm, dinpr, dnorm, itrmks) An interface to my modified versino of the nitsol implementation of the transpose-free quasi-minimal residual\n method\n ( TFQMR ) for\n iteratively solving linear systems. It has been modified so\n that the user provides a non-zero initial guess of the\n solution. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(in), dimension(n) :: fcur Array of length n containing current approximate solution real(kind=r8), intent(inout), dimension(n) :: step Vector of of length n containing trial step real(kind=r8), intent(in) :: eta Relative residual reduction factor procedure( f_intr ) :: f User-supplied subroutine for evaluating the function\n the zero of which is sought. procedure( jacv_intr ) :: jacv User-supplied subroutine for optionally evaluating J\\vec{v} or P&#94;{-1}\\vec{v} , where J is the Jacobian\n of f and P is a right preconditioning operator. If\n neither analytic J\\vec{v} evaluations nor right\n preconditioning is used, this can be a dummy subroutine;\n if right preconditioning is used but not analytic J\\vec{v} evaluations, this need only evaluate P&#94;{-1}\\vec{v} . real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array passed to the f and jacv routines integer, intent(inout), dimension(*) :: ipar Parameter/work array passed to the f and jacv routines integer, intent(in) :: ijacv Flag for determining method of J\\vec{v} evaluation. 0\n (default) indicates finite-difference evaluation, while 1\n indicates analytic evaluation. integer, intent(in) :: irpre Flag for right preconditioning. 0 indicates no\n preconditioning, while 1 inidcates right preconditioning. integer, intent(in) :: iksmax Maximum allowable number of TFQMR iterations integer, intent(in) :: ifdord Order of the finite-difference formula used in TFQMR\n when J*v products are evaluated using finite-differences. \n When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or \n 4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on \n input to this subroutine, ifdord determines the order of the \n finite-difference formula used at each TFQMR iteration \n (default 1). In this case, ijacv is set to -1 below to \n signal to nitjv that the order of the finite-difference \n formula is to be determined by ifdord. The original value \n ijacv = 0 is restored on return. integer, intent(inout) :: nfe Number of function evaluations integer, intent(inout) :: njve Number of J\\vec{v} evaluations integer, intent(inout) :: nrpre Number of P&#94;{-1}\\vec{v} evaluations integer, intent(inout) :: nli Number of linear iterations real(kind=r8), intent(out), dimension(n) :: r Residual vector (for the QMR process) real(kind=r8), intent(out), dimension(n) :: rcgs Residual vector (of the underlying CGS process) real(kind=r8), intent(out), dimension(n) :: rtil 'Shadow' residual vector used in bi-orthogonalization real(kind=r8), intent(out), dimension(n) :: d Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: p Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: q Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: u Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: v Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: y Vector used in TFQMR real(kind=r8), intent(out), dimension(n) :: rwork1 Work vector, passed on to nitjv real(kind=r8), intent(out), dimension(n) :: rwork2 Work vector, passed on to nitjv real(kind=r8), intent(out) :: rsnrm TFQMR residual norm on return procedure( dinpr_intr ) :: dinpr Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ) :: dnorm Norm routine, either user supplied or BLAS dnrm2. integer, intent(out) :: itrmks Termination flag. Values have the following meanings: 0 normal termination: acceptable step found 1 J\\vec{v} failure in nitjv 2 P&#94;{-1}\\vec{v} failure in nitjv 3 Acceptable step not found in iksmax TFQMR iterations 4 TFQMR breakdown 5 Floating point error (the underlying CGS iteration\n has probably blown up) interface public subroutine nitstb2(n, xcur, fcur, step, eta, f, jacv, rpar, ipar, ijacv, irpre, iksmax, ifdord, nfe, njve, nrpre, nli, r, rtil, p, phat, v, t, rwork1, rwork2, rsnrm, dinpr, dnorm, itrmks) An interface to my modified versino of the nitsol implementation of the biconjugate gradient stabilized method\n ( BiCGSTAB )\n for iteratively solving linear systems. It has been modified\n so that the user provides a non-zero initial guess of the\n solution. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(in), dimension(n) :: fcur Array of length n containing current approximate solution real(kind=r8), intent(inout), dimension(n) :: step Vector of of length n containing trial step real(kind=r8), intent(in) :: eta Relative residual reduction factor procedure( f_intr ) :: f User-supplied subroutine for evaluating the function\n the zero of which is sought. procedure( jacv_intr ) :: jacv User-supplied subroutine for optionally evaluating J\\vec{v} or P&#94;{-1}\\vec{v} , where J is the Jacobian\n of f and P is a right preconditioning operator. If\n neither analytic J\\vec{v} evaluations nor right\n preconditioning is used, this can be a dummy subroutine;\n if right preconditioning is used but not analytic J\\vec{v} evaluations, this need only evaluate P&#94;{-1}\\vec{v} . real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array passed to the f and jacv routines integer, intent(inout), dimension(*) :: ipar Parameter/work array passed to the f and jacv routines integer, intent(in) :: ijacv Flag for determining method of J\\vec{v} evaluation. 0\n (default) indicates finite-difference evaluation, while 1\n indicates analytic evaluation. integer, intent(in) :: irpre Flag for right preconditioning. 0 indicates no\n preconditioning, while 1 inidcates right preconditioning. integer, intent(in) :: iksmax Maximum allowable number of BiCGSTAB iterations integer, intent(in) :: ifdord Order of the finite-difference formula used in BiCGSTAB \n when J*v products are evaluated using finite-differences. \n When ijacv = 0 on input to nitsol, ifdord is set to 1, 2, or \n 4 in nitsol; otherwise, it is irrelevant. When ijacv = 0 on \n input to this subroutine, ifdord determines the order of the \n finite-difference formula used at each BiCGSTAB iteration \n (default 1). In this case, ijacv is set to -1 below to \n signal to nitjv that the order of the finite-difference \n formula is to be determined by ifdord. The original value \n ijacv = 0 is restored on return. integer, intent(inout) :: nfe Number of function evaluations integer, intent(inout) :: njve Number of J\\vec{v} evaluations integer, intent(inout) :: nrpre Number of P&#94;{-1}\\vec{v} evaluations integer, intent(inout) :: nli Number of linear iterations real(kind=r8), intent(out), dimension(n) :: r Residual vector real(kind=r8), intent(out), dimension(n) :: rtil \\tilde{r} vector used in BiCGSTAB real(kind=r8), intent(out), dimension(n) :: p Vector used in BiCGSTAB real(kind=r8), intent(out), dimension(n) :: phat Vector used in BiCGSTAB real(kind=r8), intent(out), dimension(n) :: v Vector used in BiCGSTAB real(kind=r8), intent(out), dimension(n) :: t Vector used in BiCGSTAB real(kind=r8), intent(out), dimension(n) :: rwork1 Work vector, passed on to nitjv real(kind=r8), intent(out), dimension(n) :: rwork2 Work vector, passed on to nitjv real(kind=r8), intent(out) :: rsnrm BiCGSTAB residual norm on return procedure( dinpr_intr ) :: dinpr Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ) :: dnorm Norm routine, either user supplied or BLAS dnrm2. integer, intent(out) :: itrmks Termination flag. Values have the following meanings: 0 normal termination: acceptable step found 1 J\\vec{v} failure in nitjv 2 P&#94;{-1}\\vec{v} failure in nitjv 3 Acceptable step not found in iksmax BiCGSTAB iterations 4 BiCGSTAB breakdown interface public function ddot(n, x, sx, y, sy) An interface to the BLAS routine for calculating Euclidean\n inner product. This can be passed to nitsol for the\n argument dinpr . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=r8), intent(in), dimension(*) :: x integer, intent(in) :: sx real(kind=r8), intent(in), dimension(*) :: y integer, intent(in) :: sy Return Value real(kind=r8) interface public function dnrm2(n, x, sx) An interface to the BLAS routine for calculating Euclidean\n norm. This can be passed to nitsol for the argument dnorm . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=r8), intent(in), dimension(*) :: x integer, intent(in) :: sx Return Value real(kind=r8) Abstract Interfaces abstract interface public function dinpr_intr(n, x, sx, y, sy) Interface for function which calculates vector inner products.\n This has the same interace as the BLAS routine ddot . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The length of the vectors real(kind=r8), intent(in), dimension(*) :: x The first input vector integer, intent(in) :: sx The stride in memory between successive elements of x real(kind=r8), intent(in), dimension(*) :: y The second input vector integer, intent(in) :: sy The stride in memory between successive elements of y Return Value real(kind=r8) Inner product of x and y abstract interface public function dnorm_intr(n, x, sx) Interface for function which calculates vector norms. This\n has the same interface as the BLAS routine dnrm2. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n The length of the array real(kind=r8), intent(in), dimension(*) :: x The input vector integer, intent(in) :: sx The stride in memory between consecutive elements of x Return Value real(kind=r8) The vector norm of x abstract interface public function mat_mult(v, xcur, rhs, rpar, ipar, success) Interface for operations representing the multiplication of a\n vector by a matrix, such as that for a linear operator or a\n preconditioner. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:) :: v The vector to be multiplied real(kind=r8), intent(in), dimension(:) :: xcur Array containing the current estimate of the independent\n variables in the linear system. This may not be needed, but\n is provided just in case. real(kind=r8), intent(in), dimension(:) :: rhs Array containing the right hand side of the linear\n system. This may not be needed, but is provided just in\n case. real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array integer, intent(inout), dimension(*) :: ipar Parameter/work array logical, intent(out) :: success Indicates whether operation was completed succesfully Return Value real(kind=r8),\n  dimension(size(xcur)) Result of the operation abstract interface public subroutine f_intr(n, xcur, fcur, rpar, ipar, itrmf) Interface for a subroutine which evaluates the function\n the zero of which is sought. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(out), dimension(n) :: fcur Array of length n containing f(xcur) on output real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array integer, intent(inout), dimension(*) :: ipar Parameter/work array integer, intent(out) :: itrmf Termination flag. 0 means normal termination, 1 means\n failure to produce f(xcur) abstract interface public subroutine jacv_intr(n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) Interface for a subroutine which optionally evaluates J\\vec{v} or P&#94;{-1}\\vec{v} , where J is the Jacobian\n of f and P is a right preconditioning operator. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(in), dimension(n) :: fcur Array of length n containing the current f(x) value integer, intent(in) :: ijob Integer flag indicating which product is desired. 0\n indicates z = J\\vec{v} . 1 indicates z = P&#94;{-1}\\vec{v} . real(kind=r8), intent(in), dimension(n) :: v An array of length n to be multiplied real(kind=r8), intent(out), dimension(n) :: z An array of length n containing the desired product on\n output. real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array integer, intent(inout), dimension(*) :: ipar Parameter/work array integer, intent(out) :: itrmjv Termination flag. 0 indcates normal termination, 1\n indicatesfailure to prodce J\\vec{v} , and 2 indicates\n failure to produce P&#94;{-1}\\vec{v} Subroutines public subroutine dummy_jacv (n, xcur, fcur, ijob, v, z, rpar, ipar, itrmjv) Author Chris MacMackin Date November 2016 A dummy subroutine which does not apply a preconditioner or\n calculate an analytic Jacobian. This can be passed to nitsol for the argument jacv . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=r8), intent(in), dimension(n) :: xcur real(kind=r8), intent(in), dimension(n) :: fcur integer, intent(in) :: ijob real(kind=r8), intent(in), dimension(n) :: v real(kind=r8), intent(out), dimension(n) :: z real(kind=r8), intent(inout), dimension(*) :: rpar integer, intent(inout), dimension(*) :: ipar integer, intent(out) :: itrmjv public subroutine dummy_f (n, xcur, fcur, rpar, ipar, itrmf) Author Chris MacMackin Date March 2017 A dummy subroutine which does not calculate the function. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of the problem real(kind=r8), intent(in), dimension(n) :: xcur Array of length n containing the current x value real(kind=r8), intent(out), dimension(n) :: fcur Array of length n containing f(xcur) on output real(kind=r8), intent(inout), dimension(*) :: rpar Parameter/work array integer, intent(inout), dimension(*) :: ipar Parameter/work array integer, intent(out) :: itrmf Termination flag. 0 means normal termination, 1 means\n failure to produce f(xcur) public subroutine gmres_solve (solution, lhs, rhs, resid_norm, flag, nlhs, nrpre, nli, tol, precond, rpar, ipar, resid_update, iter_max, krylov_dim, inner_prod, norm) Author Chris MacMackin Date March 2017 A wraper for the nitsol implementation of the generalised minimal residual method\n ( GMRES )\n for iteratively solving linear systems. This provides a more\n general interface not specifically intended for use with Newton\n iteration. It also uses Fortran 90 features to provide a more\n convenient call signature. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(inout), dimension(:) :: solution On input, an initial guess of the solution to the linear\n system. On output, the iteratively determined solution. procedure( mat_mult ) :: lhs The linear operator on the left hand side of the linear\n system. real(kind=r8), intent(in), dimension(:) :: rhs The right hand side of the linear system being solved real(kind=r8), intent(out) :: resid_norm GMRES residual norm on return integer, intent(out) :: flag Termination flag. Values have the following meanings: Read more… integer, intent(out), optional :: nlhs Number of evaluations of the left hand side of the system integer, intent(out), optional :: nrpre Number of evaluations of the right-preconditioner integer, intent(out), optional :: nli Number of iterations real(kind=r8), intent(in), optional :: tol The tolerance for the solution. Default is size(solution) * 1e-8 . procedure( mat_mult ), optional :: precond A right-preconditioner which may be used to improve\n convergence of the solution. real(kind=r8), intent(inout), optional dimension(*) :: rpar Parameter/work array passed to the lhs and precond routines. integer, intent(inout), optional dimension(*) :: ipar Parameter/work array passed to the lhs and precond routines integer, intent(in), optional :: resid_update Residual update flag. On GMRES restarts, the residual can\n be updated using a linear combination ( iresup == 0 ) or by\n direct evaluation ( iresup == 1 ). The first is cheap (one\n n-vector saxpy) but may lose accuracy with extreme residual\n reduction; the second retains accuracy better but costs one J\\vec{v} product. Default is 0. integer, intent(in), optional :: iter_max Maximum allowable number of GMRES iterations. Default is\n 1000. integer, intent(in), optional :: krylov_dim Maximum Krylov subspace dimension; default 10. procedure( dinpr_intr ), optional :: inner_prod Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ), optional :: norm Norm routine, either user supplied or BLAS dnrm2. public subroutine tfqmr_solve (solution, lhs, rhs, resid_norm, flag, nlhs, nrpre, nli, tol, precond, rpar, ipar, resid_update, iter_max, krylov_dim, inner_prod, norm) Author Chris MacMackin Date March 2017 A wraper for the nitsol implementation of the transpose-free quasi-minimal residual method\n ( TFQMR )\n for iteratively solving linear systems. This provides a more\n general interface not specifically intended for use with Newton\n iteration. It also uses Fortran 90 features to provide a more\n convenient call signature. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(inout), dimension(:) :: solution On input, an initial guess of the solution to the linear\n system. On output, the iteratively determined solution. procedure( mat_mult ) :: lhs The linear operator on the left hand side of the linear\n system. real(kind=r8), intent(in), dimension(:) :: rhs The right hand side of the linear system being solved real(kind=r8), intent(out) :: resid_norm TFQMR residual norm on return integer, intent(out) :: flag Termination flag. Values have the following meanings: Read more… integer, intent(out), optional :: nlhs Number of evaluations of the left hand side of the system integer, intent(out), optional :: nrpre Number of evaluations of the right-preconditioner integer, intent(out), optional :: nli Number of iterations real(kind=r8), intent(in), optional :: tol The tolerance for the solution. Default is size(solution) * 1e-8 . procedure( mat_mult ), optional :: precond A right-preconditioner which may be used to improve\n convergence of the solution. real(kind=r8), intent(inout), optional dimension(*) :: rpar Parameter/work array passed to the lhs and precond routines. integer, intent(inout), optional dimension(*) :: ipar Parameter/work array passed to the lhs and precond routines integer, intent(in), optional :: resid_update Residual update flag. On GMRES restarts, the residual can\n be updated using a linear combination ( iresup == 0 ) or by\n direct evaluation ( iresup == 1 ). The first is cheap (one\n n-vector saxpy) but may lose accuracy with extreme residual\n reduction; the second retains accuracy better but costs one J\\vec{v} product. Meaningless in this routine, but kept\n for consistent interface. integer, intent(in), optional :: iter_max Maximum allowable number of TFQMR iterations. Default is\n 1000. integer, intent(in), optional :: krylov_dim Maximum Krylov subspace dimension; default 10. procedure( dinpr_intr ), optional :: inner_prod Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ), optional :: norm Norm routine, either user supplied or BLAS dnrm2. public subroutine bicgstab_solve (solution, lhs, rhs, resid_norm, flag, nlhs, nrpre, nli, tol, precond, rpar, ipar, resid_update, iter_max, krylov_dim, inner_prod, norm) Author Chris MacMackin Date March 2017 A wraper for the nitsol implementation of the biconjugate gradient stabilized method\n ( BiCGSTAB )\n for iteratively solving linear systems. This provides a more\n general interface not specifically intended for use with Newton\n iteration. It also uses Fortran 90 features to provide a more\n convenient call signature. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(inout), dimension(:) :: solution On input, an initial guess of the solution to the linear\n system. On output, the iteratively determined solution. procedure( mat_mult ) :: lhs The linear operator on the left hand side of the linear\n system. real(kind=r8), intent(in), dimension(:) :: rhs The right hand side of the linear system being solved real(kind=r8), intent(out) :: resid_norm BiCGSTAB residual norm on return integer, intent(out) :: flag Termination flag. Values have the following meanings: Read more… integer, intent(out), optional :: nlhs Number of evaluations of the left hand side of the system integer, intent(out), optional :: nrpre Number of evaluations of the right-preconditioner integer, intent(out), optional :: nli Number of iterations real(kind=r8), intent(in), optional :: tol The tolerance for the solution. Default is size(solution) * 1e-8 . procedure( mat_mult ), optional :: precond A right-preconditioner which may be used to improve\n convergence of the solution. real(kind=r8), intent(inout), optional dimension(*) :: rpar Parameter/work array passed to the lhs and precond routines. integer, intent(inout), optional dimension(*) :: ipar Parameter/work array passed to the lhs and precond routines integer, intent(in), optional :: resid_update Residual update flag. On GMRES restarts, the residual can be\n updated using a linear combination ( iresup == 0 ) or by\n direct evaluation ( iresup == 1 ). The first is cheap (one\n n-vector saxpy) but may lose accuracy with extreme residual\n reduction; the second retains accuracy better but costs one J\\vec{v} product. Meaningless in this routine, but kept\n for consistent interface. integer, intent(in), optional :: iter_max Maximum allowable number of TFQMR iterations. Default is\n 1000. integer, intent(in), optional :: krylov_dim Maximum Krylov subspace dimension; default 10. procedure( dinpr_intr ), optional :: inner_prod Inner-product routine, either user-supplied or BLAS ddot . procedure( dnorm_intr ), optional :: norm Norm routine, either user supplied or BLAS dnrm2."},{"title":"prescribed_eos_mod – ISOFT","tags":"","loc":"module/prescribed_eos_mod.html","text":"Provides an equation of state where the salinity is prescribed\n such that SD = {\\rm constant} . This is useful for testing and\n debugging the plume model. Uses iso_fortran_env factual_mod equation_of_state_mod module~~prescribed_eos_mod~~UsesGraph module~prescribed_eos_mod prescribed_eos_mod factual_mod factual_mod module~prescribed_eos_mod->factual_mod iso_fortran_env iso_fortran_env module~prescribed_eos_mod->iso_fortran_env module~equation_of_state_mod equation_of_state_mod module~prescribed_eos_mod->module~equation_of_state_mod module~equation_of_state_mod->factual_mod module~equation_of_state_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables absolute_zero Interfaces prescribed_eos Derived Types prescribed_eos Functions constructor prescribed_water_density prescribed_water_deriv prescribed_haline_contraction prescribed_thermal_contraction Subroutines prescribed_assign Variables Type Visibility Attributes Name Initial real(kind=r8), private, parameter :: absolute_zero = -273.15_r8 Interfaces public interface prescribed_eos private function constructor (const, beta_s, thickness) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: const The constant to which SD is equal. real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S , relating\n salinity and density. class(scalar_field), intent(in) :: thickness The thickness of the plume, from which the salinity is calculated. Return Value type( prescribed_eos ) Derived Types type, public, extends( equation_of_state ) :: prescribed_eos An equation of state, depending only on salinity, where the\n salinity is prescribed such that SD = {\\rm constant} for\n some specified thickness D . The salinity is related to the\n density by the haline contraction coefficient \\beta_S . The\n only real use for this is testing and debugging the plume model. Components Type Visibility Attributes Name Initial class(scalar_field), private, allocatable :: density The density calculated from the prescribed salinity real(kind=r8), private :: beta_s The haline contraction coefficient Constructor private  function constructor (const, beta_s, thickness) Type-Bound Procedures procedure, public :: water_density => prescribed_water_density procedure, public, pass(rhs) :: prescribed_assign generic, public :: assignment(=) => prescribed_assign procedure, public :: water_density_derivative => prescribed_water_deriv procedure, public :: haline_contraction => prescribed_haline_contraction procedure, public :: thermal_contraction => prescribed_thermal_contraction Functions private function constructor (const, beta_s, thickness) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: const The constant to which SD is equal. real(kind=r8), intent(in) :: beta_s The haline contraction coefficient, \\beta_S , relating\n salinity and density. class(scalar_field), intent(in) :: thickness The thickness of the plume, from which the salinity is calculated. Return Value type( prescribed_eos ) private function prescribed_water_density (this, temperature, salinity) result(density) Author Chris MacMackin Date March 2017 Returns the density corresponding to the prescribed salinity, as\n calculated in the constructor. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water private function prescribed_water_deriv (this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Author Chris MacMackin Date July 2017 Calculates the derivative of the water density. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the density of the water private function prescribed_haline_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date June 2017 Returns the haline contraction coefficient. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable private function prescribed_thermal_contraction (this, temperature, salinity) result(coef) Author Chris MacMackin Date June 2017 Returns the thermal contraction coefficient. Arguments Type Intent Optional Attributes Name class( prescribed_eos ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Subroutines private subroutine prescribed_assign (lhs, rhs) Author Chris MacMackin Date March 2017 Assigns this object to another equation of state object,\n allowing the definided assignment for the precalculated density\n field to work correctly. Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(out) :: lhs class( prescribed_eos ), intent(in) :: rhs"},{"title":"equation_of_state_mod – ISOFT","tags":"","loc":"module/equation_of_state_mod.html","text":"Provides an abstract derived type which can be subtyped in order to\n implement an equation of state. Uses iso_fortran_env factual_mod module~~equation_of_state_mod~~UsesGraph module~equation_of_state_mod equation_of_state_mod factual_mod factual_mod module~equation_of_state_mod->factual_mod iso_fortran_env iso_fortran_env module~equation_of_state_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~equation_of_state_mod~~UsedByGraph module~equation_of_state_mod equation_of_state_mod module~ave_linear_eos_mod ave_linear_eos_mod module~ave_linear_eos_mod->module~equation_of_state_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~equation_of_state_mod module~asymmetric_plume_mod->module~ave_linear_eos_mod module~linear_eos_mod linear_eos_mod module~asymmetric_plume_mod->module~linear_eos_mod module~prescribed_eos_mod prescribed_eos_mod module~prescribed_eos_mod->module~equation_of_state_mod module~linear_eos_mod->module~equation_of_state_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~equation_of_state_mod module~static_plume_mod->module~linear_eos_mod module~plume_mod plume_mod module~plume_mod->module~equation_of_state_mod module~plume_mod->module~linear_eos_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces get_property get_property_dx get_coef Derived Types equation_of_state Abstract Interfaces abstract interface private function get_property(this, temperature, salinity) result(density) Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: salinity A field containing the salinity of the water Return Value class(scalar_field),\n  pointer A field containing the density of the water abstract interface private function get_property_dx(this, temperature, d_temperature, salinity, d_salinity, dir) result(d_density) Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(in) :: this class(scalar_field), intent(in) :: temperature A field containing the temperature of the water class(scalar_field), intent(in) :: d_temperature A field containing the derivative of the temperature of the\n water, in teh same direction as dir class(scalar_field), intent(in) :: salinity A field containing the salinity of the water class(scalar_field), intent(in) :: d_salinity A field containing the derivative of the salinity of the\n water, in the same direction as dir integer, intent(in) :: dir The direction in which to take the derivative Return Value class(scalar_field),\n  pointer A field containing the derivative of the density of the\n water in direction dir abstract interface private function get_coef(this, temperature, salinity) result(coef) Arguments Type Intent Optional Attributes Name class( equation_of_state ), intent(in) :: this class(scalar_field), intent(in) :: temperature class(scalar_field), intent(in) :: salinity Return Value class(scalar_field),\n  allocatable Derived Types type, public, abstract :: equation_of_state An abstract type with a procedure for calculating water density\n from its temperature and salinity. Type-Bound Procedures procedure(get_property), public :: water_density Returns the water density for the given temperature and salinity. procedure(get_property_dx), public :: water_density_derivative Returns the derivative of the water density for the given\n temperature and salinity. procedure(get_coef), public :: haline_contraction Returns a (possibly approximated) haline contraction coefficient. procedure(get_coef), public :: thermal_contraction Returns a (possibly approximated) therma contraction coefficient."},{"title":"ground_mod – ISOFT","tags":"","loc":"module/ground_mod.html","text":"Provides a concrete implementation of the basal_surface data type,\n representing solid ground. Uses iso_fortran_env basal_surface_mod factual_mod hdf5 module~~ground_mod~~UsesGraph module~ground_mod ground_mod factual_mod factual_mod module~ground_mod->factual_mod hdf5 hdf5 module~ground_mod->hdf5 module~basal_surface_mod basal_surface_mod module~ground_mod->module~basal_surface_mod iso_fortran_env iso_fortran_env module~ground_mod->iso_fortran_env module~basal_surface_mod->factual_mod module~basal_surface_mod->hdf5 module~basal_surface_mod->iso_fortran_env module~nitsol_mod nitsol_mod module~basal_surface_mod->module~nitsol_mod module~nitsol_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces ground Derived Types ground Functions constructor ground_melt ground_drag_parameter ground_water_density ground_data_size ground_state_vector Subroutines ground_update ground_read_data ground_write_data ground_solve Interfaces public interface ground private function constructor () result(this) Author Christopher MacMackin Date April 2016 Instantiates a ground object. Arguments None Return Value type( ground ) Derived Types type, public, extends( basal_surface ) :: ground A concrete implementation of the basal_surface abstract data type,\n representing the ground beneath an ice sheet. At the moment this\n doesn't actually do anything. Constructor private  function constructor () Instantiates a ground object. Type-Bound Procedures procedure, public :: basal_melt => ground_melt procedure, public :: basal_drag_parameter => ground_drag_parameter procedure, public :: water_density => ground_water_density procedure, public :: update => ground_update procedure, public :: data_size => ground_data_size procedure, public :: state_vector => ground_state_vector procedure, public :: read_data => ground_read_data procedure, public :: write_data => ground_write_data procedure, public :: solve => ground_solve Functions private function constructor () result(this) Author Christopher MacMackin Date April 2016 Instantiates a ground object. Arguments None Return Value type( ground ) private function ground_melt (this) result(melt) Author Christopher MacMackin Date April 2016 Computes and returns the melt rate at the bottom of the ice\n sheet due to interaction with the ground. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate at the base of the ice sheet. private function ground_drag_parameter (this) result(drag) Author Christopher MacMackin Date April 2016 Computes and returns a quantity which may be necessary to determine\n the frictional drag the ground exerts on the bottom of the ice\n sheet. An example would be the coefficient of friction. The \n description of this method is left deliberately vague so that as not\n to constrain how the drag is parameterized. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of a paramter describing the drag of the ground on the\n ice sheet. private function ground_water_density (this) result(density) Author Christopher MacMackin Date April 2016 Computes and returns the density of the water beneath the ice sheet.\n This water would be subglacial discharge and would tend to lubricate\n the motion of the ice sheet. The density probably won't be important\n in the case of an ice sheet, but is included so that the ground data\n type can have the same interface as the plume data type. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value real(kind=r8) The density of any water at the base of the ice sheet. private pure function ground_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the ground's state vector.\n This is the size of the vector returned by state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value integer The number of elements in the ground's state vector. private pure function ground_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the ground. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the ground. Subroutines private subroutine ground_update (this, state_vector, ice_thickness) Author Christopher MacMackin Date April 2016 Updates the state of the ground from its state vector. The state\n vector is a real array containing the value of each of the ground's\n properties at each of the locations on the grid used in discretization. Arguments Type Intent Optional Attributes Name class( ground ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n ground. class(scalar_field), intent(in), optional :: ice_thickness The ice thickness which, if present, will be used to update\n the calculation of the melt rate and/or drag parameter. private subroutine ground_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the ground object from the specified group in\n an HDF file. Arguments Type Intent Optional Attributes Name class( ground ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group from which this data is\n meant to be read. character(len=*), intent(in) :: group_name The name of the group in the HDF5 file storing the\n ground's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine ground_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the ground object to an HDF file in the\n specified group. Arguments Type Intent Optional Attributes Name class( ground ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ground's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine ground_solve (this, ice_thickness, ice_density, ice_temperature, time, success) Author Chris MacMackin Date April 2017 Solves the state of the ground for the specified ice properties,\n at the specified time. Arguments Type Intent Optional Attributes Name class( ground ), intent(inout) :: this class(scalar_field), intent(in) :: ice_thickness Thickness of the ice above the basal surface real(kind=r8), intent(in) :: ice_density The density of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: ice_temperature The temperature of the ice above the basal surface, assumed uniform real(kind=r8), intent(in) :: time The time to which the basal surface should be solved logical, intent(out) :: success True if the solver is successful, false otherwise"},{"title":"plume_boundary_mod – ISOFT","tags":"","loc":"module/plume_boundary_mod.html","text":"Provides an abstract derived type which can be subtyped in order to\n specify the boundary conditions for plume types. Uses iso_fortran_env factual_mod boundary_types_mod module~~plume_boundary_mod~~UsesGraph module~plume_boundary_mod plume_boundary_mod factual_mod factual_mod module~plume_boundary_mod->factual_mod iso_fortran_env iso_fortran_env module~plume_boundary_mod->iso_fortran_env module~boundary_types_mod boundary_types_mod module~plume_boundary_mod->module~boundary_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~plume_boundary_mod~~UsedByGraph module~plume_boundary_mod plume_boundary_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~plume_boundary_mod module~upstream_plume_mod upstream_plume_mod module~asymmetric_plume_mod->module~upstream_plume_mod module~simple_plume_boundary_mod simple_plume_boundary_mod module~asymmetric_plume_mod->module~simple_plume_boundary_mod module~upstream_plume_mod->module~plume_boundary_mod module~simple_plume_boundary_mod->module~plume_boundary_mod module~dallaston2015_seasonal_mod dallaston2015_seasonal_mod module~dallaston2015_seasonal_mod->module~plume_boundary_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~plume_boundary_mod module~static_plume_mod->module~upstream_plume_mod module~static_plume_mod->module~simple_plume_boundary_mod module~plume_mod plume_mod module~plume_mod->module~plume_boundary_mod module~plume_mod->module~upstream_plume_mod module~plume_mod->module~simple_plume_boundary_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types plume_boundary Functions scalar_bound vector_bound Subroutines bound_info set_time Derived Types type, public :: plume_boundary A type in which procedures for getting the boundary conditions\n of plumes are to be specified. The descendent types can contain\n whatever data is needed to compute the result. Read more… Type-Bound Procedures procedure, public :: thickness_bound_info => bound_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: velocity_bound_info => bound_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: temperature_bound_info => bound_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: salinity_bound_info => bound_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: thickness_bound => scalar_bound Produces a field containing the boundary conditions for plume\n thickness at the specified location. procedure, public :: velocity_bound => vector_bound Produces a field containing the boundary conditions for plume\n velocity at the specified location. procedure, public :: temperature_bound => scalar_bound Produces a field containing the boundary conditions for plume\n temperature at the specified location. procedure, public :: salinity_bound => scalar_bound Produces a field containing the boundary conditions for plume\n salinity at the specified location. procedure, public :: set_time Specifies the time at which to calculate the boundary\n conditions. Functions private function scalar_bound (this, location) Author Chris MacMackin Date March 2017 Returns a field containing the boundary values for the specified\n boundary location. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer private function vector_bound (this, location) Author Chris MacMackin Date March 2017 Returns a field containing the boundary values for the specified\n boundary location. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer Subroutines private subroutine bound_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Provides information about the type of boundary, and the number\n of layers of data-points needed to describe it. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. private subroutine set_time (this, time) Author Chris MacMackin Date May 2017 Sets the time at which boundary conditions are to be calculated. Arguments Type Intent Optional Attributes Name class( plume_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: time"},{"title":"ice_sheet_mod – ISOFT","tags":"","loc":"module/ice_sheet_mod.html","text":"Provides a concrete implementation of the glacier type, using\n a vertically integrated model of an ice sheet. Uses iso_fortran_env glacier_mod factual_mod viscosity_mod jacobian_block_mod hdf5 logger_mod module~~ice_sheet_mod~~UsesGraph module~ice_sheet_mod ice_sheet_mod logger_mod logger_mod module~ice_sheet_mod->logger_mod factual_mod factual_mod module~ice_sheet_mod->factual_mod hdf5 hdf5 module~ice_sheet_mod->hdf5 module~glacier_mod glacier_mod module~ice_sheet_mod->module~glacier_mod module~jacobian_block_mod jacobian_block_mod module~ice_sheet_mod->module~jacobian_block_mod iso_fortran_env iso_fortran_env module~ice_sheet_mod->iso_fortran_env module~viscosity_mod viscosity_mod module~ice_sheet_mod->module~viscosity_mod module~glacier_mod->logger_mod module~glacier_mod->factual_mod module~glacier_mod->hdf5 module~glacier_mod->iso_fortran_env penf penf module~glacier_mod->penf module~nitsol_mod nitsol_mod module~glacier_mod->module~nitsol_mod module~jacobian_block_mod->logger_mod module~jacobian_block_mod->factual_mod module~jacobian_block_mod->iso_fortran_env module~jacobian_block_mod->penf f95_lapack f95_lapack module~jacobian_block_mod->f95_lapack module~boundary_types_mod boundary_types_mod module~jacobian_block_mod->module~boundary_types_mod module~viscosity_mod->factual_mod module~viscosity_mod->iso_fortran_env module~nitsol_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces ice_sheet Derived Types ice_sheet Functions constructor sheet_thickness sheet_velocity sheet_density sheet_temperature sheet_residual sheet_precondition sheet_data_size sheet_state_vector sheet_time_step Subroutines sheet_update sheet_set_time sheet_solve_velocity sheet_read_data sheet_write_data sheet_assign Interfaces public interface ice_sheet private function constructor (domain, resolution, thickness, velocity, viscosity_law, lambda, chi) result(this) Author Christopher MacMackin Date April 2016 Creates a new ice_sheet object with initial conditions provided\n by the arguments. At present only a 1D model is supported. If\n information is provided for higher dimensions then it will be ignored. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the ice sheet. The first index represents the dimension for which\n the boundaries apply. If the second index is 1 then it corresponds\n to the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( thickness_func ) :: thickness A function which calculates the initial value of the thickness of \n the ice sheet at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the ice at a given location in an ice sheet. class( abstract_viscosity ), intent(in), optional :: viscosity_law An object which calculates the viscosity of the ice. real(kind=r8), intent(in), optional :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real(kind=r8), intent(in), optional :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Return Value type( ice_sheet ) An ice sheet object with its domain and initial conditions set\n according to the arguments of the constructor function. Derived Types type, public, extends( glacier ) :: ice_sheet A concrete implementation of the glacier type, using a vertically\n integrated model of an ice sheet. This model is 1-dimensional only. Components Type Visibility Attributes Name Initial type(cheb1d_scalar_field), private :: thickness Thickness of ice sheet, $h$ type(cheb1d_vector_field), private :: velocity Flow velocity of ice sheet, $\\vec{u}$ real(kind=r8), private :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real(kind=r8), private :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ class( abstract_viscosity ), private, allocatable :: viscosity_law An object representing the model used for ice viscosity. real(kind=r8), private :: time The time at which the ice sheet is in this state Constructor private  function constructor (domain, resolution, thickness, velocity, viscosity_law, lambda, chi) Creates a new ice_sheet object with initial conditions provided\n by the arguments. At present only a 1D model is supported. If\n information is provided for higher dimensions then it will be ignored. Type-Bound Procedures generic, public :: assignment(=) => assign procedure, public :: integrate => glacier_integrate Performs a time-step of the integration, taking the state of\n the glacier to the specified time using the provided\n melt-rate data. procedure, public :: integrate_layers => glacier_integrate_layers Dummy routine which can be over-ridden to integrate internal\n layers of the glacier to the specified time. procedure, public :: ice_thickness => sheet_thickness procedure, public :: ice_density => sheet_density procedure, public :: ice_temperature => sheet_temperature procedure, public :: residual => sheet_residual procedure, public :: update => sheet_update procedure, public :: precondition => sheet_precondition procedure, public :: set_time => sheet_set_time procedure, public :: data_size => sheet_data_size procedure, public :: state_vector => sheet_state_vector procedure, public :: solve_velocity => sheet_solve_velocity procedure, public :: read_data => sheet_read_data procedure, public :: write_data => sheet_write_data procedure, public :: time_step => sheet_time_step procedure, private :: assign => sheet_assign Functions private function constructor (domain, resolution, thickness, velocity, viscosity_law, lambda, chi) result(this) Author Christopher MacMackin Date April 2016 Creates a new ice_sheet object with initial conditions provided\n by the arguments. At present only a 1D model is supported. If\n information is provided for higher dimensions then it will be ignored. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), dimension(:,:) :: domain An array containing the upper and lower limits of the domain for\n the ice sheet. The first index represents the dimension for which\n the boundaries apply. If the second index is 1 then it corresponds\n to the lower bound. If the second index is 2 then it corresponds to\n the upper bound. integer, intent(in), dimension(:) :: resolution The number of data points in each dimension procedure( thickness_func ) :: thickness A function which calculates the initial value of the thickness of \n the ice sheet at a given location. procedure( velocity_func ) :: velocity A function which calculates the initial value of the velocity \n (vector) of the ice at a given location in an ice sheet. class( abstract_viscosity ), intent(in), optional :: viscosity_law An object which calculates the viscosity of the ice. real(kind=r8), intent(in), optional :: lambda The dimensionless ratio \n $\\lambda \\equiv \\frac{\\rho_0m_0x_0}{\\rho_iH-0u_0}$ real(kind=r8), intent(in), optional :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Return Value type( ice_sheet ) An ice sheet object with its domain and initial conditions set\n according to the arguments of the constructor function. private pure function sheet_thickness (this) result(thickness) Author Christopher MacMackin Date April 2016 Returns the thickness of the ice sheet across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value class(scalar_field),\n  pointer The ice thickness. private function sheet_velocity (this) result(velocity) Author Christopher MacMackin Date July 2016 Returns the velocity of the ice sheet across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value class(vector_field),\n  allocatable The ice velocity. private pure function sheet_density (this) result(density) Author Christopher MacMackin Date April 2016 Returns the density of the ice in the sheet, which is assumed to be\n uniform across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8) The ice density. private pure function sheet_temperature (this) result(temperature) Author Christopher MacMackin Date April 2016 Returns the density of the ice in the sheet, which is assumed to be\n uniform across its domain. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8) The ice density. private function sheet_residual (this, previous_states, melt_rate, basal_drag_parameter, water_density) result(residual) Author Christopher MacMackin Date April 2016 Returns the residual when the current state of the glacier is run\n through the system of equations describing it. The residual takes the\n form of a 1D array, with each element respresenting the residual for\n one of the equations in the system. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most recent\n state, but the fact that this is an array allows overriding\n methods to use older states for higher-order integration\n methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier. class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate the\n drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier. Return Value real(kind=r8),\n  dimension(:), allocatable The residual of the system of equations describing the glacier. private function sheet_precondition (this, previous_states, melt_rate, basal_drag_parameter, water_density, delta_state) result(preconditioned) Author Chris MacMackin Date January 2016 Provides a preconditioner for the nonlinear solver trying to\n bring the residual to zero. The Jacobian is approximated as a\n block matrix, where each block is a tridiagonal matrix using a\n finite difference method for differentiation. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this class( glacier ), intent(in), dimension(:) :: previous_states The states of the glacier in the previous time steps. The\n first element of the array should be the most recent. The\n default implementation will only make use of the most\n recent state, but the fact that this is an array allows\n overriding methods to use older states for higher-order\n integration methods. class(scalar_field), intent(in) :: melt_rate Thickness of the ice above the glacier class(scalar_field), intent(in) :: basal_drag_parameter A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. real(kind=r8), intent(in) :: water_density The density of the water below the glacier real(kind=r8), intent(in), dimension(:) :: delta_state The change to the state vector which is being preconditioned. Return Value real(kind=r8),\n  dimension(:), allocatable The result of applying the preconditioner to delta_state . private pure function sheet_data_size (this) Author Christopher MacMackin Date August 2016 Returns the number of elements in the ice sheet's state vector.\n This is the size of the vector returned by residual and state_vector and taken as an argument by update . Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value integer The number of elements in the ice sheet's state vector. private pure function sheet_state_vector (this) result(state_vector) Author Christopher MacMackin Date April 2016 Returns the state vector for the current state of the ice sheet. \n This takes the form of a 1D array. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8),\n  dimension(:), allocatable The state vector describing the ice sheet. private function sheet_time_step (this) result(dt) Author Chris MacMackin Date December 2016 Calculates the time step for integrating the ice sheet, using\n the CFL condition. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this Return Value real(kind=r8) The time-step to use Subroutines private subroutine sheet_update (this, state_vector) Author Christopher MacMackin Date April 2016 Updates the state of the ice sheet from its state vector. The state\n vector is a real array containing the value of each of the ice sheet's\n properties at each of the locations on the grid used in descretization. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this real(kind=r8), intent(in), dimension(:) :: state_vector A real array containing the data describing the state of the\n glacier. private subroutine sheet_set_time (this, time) Author Christopher MacMackin Date November 2016 Sets the time information held by the ice sheet object. This is\n the time at which the ice sheet is in its current state. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this real(kind=r8), intent(in) :: time The time at which the glacier is in the present state. private subroutine sheet_solve_velocity (this, basal_drag, success) Author Chris MacMackin Date May 2017 Computes the ice sheet velocity at the current time with the\n current ice thickness. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this class(scalar_field), intent(in) :: basal_drag A paramter, e.g. coefficient of friction, needed to calculate\n the drag on basal surface of the glacier. logical, intent(out) :: success True if the integration is successful, false otherwise private subroutine sheet_read_data (this, file_id, group_name, error) Author Chris MacMackin Date April 2017 Reads the state of the ice shelf object from the specified group\n in an HDF5 file. This sets the thickness, the velocity, and\n parameter values. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(inout) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice shelf's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine sheet_write_data (this, file_id, group_name, error) Author Chris MacMackin Date November 2016 Writes the state of the ice sheet object to an HDF file in the\n specified group. This will consist of a thickness and a velocity\n dataset. Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(in) :: this integer(kind=hid_t), intent(in) :: file_id The identifier for the HDF5 file/group in which this data is\n meant to be written. character(len=*), intent(in) :: group_name The name to give the group in the HDF5 file storing the\n ice sheet's data. integer, intent(out) :: error Flag indicating whether routine ran without error. If no\n error occurs then has value 0. private subroutine sheet_assign (this, rhs) Author Chris MacMackin Date February 2017 Copies the data from one ice sheet into another. This is only\n needed due to a bug in gfortran which means that the intrinsic\n assignment for glacier types is not using the appropriate\n defined assignment for the field components. Read more… Arguments Type Intent Optional Attributes Name class( ice_sheet ), intent(out) :: this class( glacier ), intent(in) :: rhs The ice sheet to be assigned to this one."},{"title":"finite_difference_block_mod – ISOFT","tags":"","loc":"module/finite_difference_block_mod.html","text":"Provides a derived type which representes a finite difference\n matrix/operator. This can be useful for preconditioning problems\n which use a spectral discretisation. Uses iso_fortran_env factual_mod boundary_types_mod f95_lapack nitsol_mod penf logger_mod module~~finite_difference_block_mod~~UsesGraph module~finite_difference_block_mod finite_difference_block_mod logger_mod logger_mod module~finite_difference_block_mod->logger_mod factual_mod factual_mod module~finite_difference_block_mod->factual_mod f95_lapack f95_lapack module~finite_difference_block_mod->f95_lapack iso_fortran_env iso_fortran_env module~finite_difference_block_mod->iso_fortran_env penf penf module~finite_difference_block_mod->penf module~nitsol_mod nitsol_mod module~finite_difference_block_mod->module~nitsol_mod module~boundary_types_mod boundary_types_mod module~finite_difference_block_mod->module~boundary_types_mod module~nitsol_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables no_extra_derivative Interfaces fin_diff_block Derived Types fin_diff_block Functions constructor fin_diff_block_solve_scalar fin_diff_block_solve_vector Variables Type Visibility Attributes Name Initial integer, private, parameter :: no_extra_derivative = -1 Interfaces public interface fin_diff_block private function constructor (template, boundary_locs, boundary_types) result(this) Author Chris MacMackin Date December 2016 Build a tridiagonal matrix block for finite differences. See the\n end of the documentation of the fin_diff_block type\n for a description of how boundary conditions are treated. Arguments Type Intent Optional Attributes Name class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. integer, intent(in), optional dimension(:) :: boundary_locs The locations in the raw representation of rhs for which\n boundary conditions are specified. Defaults to there being\n none. integer, intent(in), optional dimension(:) :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. Defaults to Dirichlet. The\n order in which they are stored must match that of boundary_locs . Return Value type( fin_diff_block ) A new finite difference operator Derived Types type, public :: fin_diff_block A data type representing a matrix finite difference operator. It\n can be useful when preconditioning systems which use a spectral\n discretisation. It is inherently 1-D in its implementation. Note\n that multiplication of a field will simply call that field's\n differentiation operator, which may or may not use a finite\n difference method. Read more… Components Type Visibility Attributes Name Initial real(kind=r8), private, dimension(:), allocatable :: diagonal The diagonal of the tridiagonal matrix representation of this\n block. real(kind=r8), private, dimension(:), allocatable :: super_diagonal The super-diagonal of the tridiagonal matrix representation\n of this block. real(kind=r8), private, dimension(:), allocatable :: sub_diagonal The sub-diagonal of the tridiagonal matrix representation of\n this block. real(kind=r8), private, dimension(:), allocatable :: l_multipliers Multipliers defining the L matrix in the LU factorisation of\n the tridiagonal matrix representation of this block. real(kind=r8), private, dimension(:), allocatable :: u_diagonal The diagonal of the U matrix in the LU factorisation of\n the tridiagonal matrix representation of this block. real(kind=r8), private, dimension(:), allocatable :: u_superdiagonal1 The first superdiagonal of the U matrix in the LU\n factorisation of the tridiagonal matrix representation of\n this block. real(kind=r8), private, dimension(:), allocatable :: u_superdiagonal2 The second superdiagonal of the U matrix in the LU\n factorisation of the tridiagonal matrix representation of\n this block. integer, private, dimension(:), allocatable :: pivots Pivot indicies from the LU factorisation of the tridiagonal\n matrix representation of this block. integer, private, dimension(:), allocatable :: boundary_locs Locations in the raw arrays which are used to specify\n boundary conditions. integer, private, dimension(:), allocatable :: boundary_types The types of boundary conditions, specified using the\n parameters found in boundary_types_mod . logical, private :: had_offset = .true. True if the factorisation was computed from a tridiagonal\n system in which an offset was added to the diagonal. Constructor private  function constructor (template, boundary_locs, boundary_types) Build a tridiagonal matrix block for finite differences. See the\n end of the documentation of the fin_diff_block type\n for a description of how boundary conditions are treated. Type-Bound Procedures procedure, private :: fin_diff_block_solve_scalar procedure, private :: fin_diff_block_solve_vector generic, public :: solve_for => fin_diff_block_solve_scalar, fin_diff_block_solve_vector Functions private function constructor (template, boundary_locs, boundary_types) result(this) Author Chris MacMackin Date December 2016 Build a tridiagonal matrix block for finite differences. See the\n end of the documentation of the fin_diff_block type\n for a description of how boundary conditions are treated. Arguments Type Intent Optional Attributes Name class(abstract_field), intent(in) :: template A scalar field with the same grid as any fields passed as\n arguments to the solve_for method. integer, intent(in), optional dimension(:) :: boundary_locs The locations in the raw representation of rhs for which\n boundary conditions are specified. Defaults to there being\n none. integer, intent(in), optional dimension(:) :: boundary_types Integers specifying the type of boundary condition. The type\n of boundary condition corresponding to a given integer is\n specified in boundary_types_mod . Only Dirichlet and\n Neumann conditions are supported. Defaults to Dirichlet. The\n order in which they are stored must match that of boundary_locs . Return Value type( fin_diff_block ) A new finite difference operator private function fin_diff_block_solve_scalar (this, rhs, offset) result(solution) Author Chris MacMackin Date December 2016 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a scalar field). Optionally, the differential\n operator can be augmented by adding an offset, i.e. a scalar\n field which is added to the operator. Read more… Arguments Type Intent Optional Attributes Name class( fin_diff_block ), intent(inout) :: this class(scalar_field), intent(in) :: rhs The right hand side of the linear(ised) system. class(scalar_field), intent(in), optional :: offset An offset to add to the differential operator Return Value class(scalar_field),\n  pointer private function fin_diff_block_solve_vector (this, rhs, offset) result(solution) Author Chris MacMackin Date December 2016 Solves the linear(ised) system represented by this finite\n difference block, for a given right hand side state vector\n (represented by a vector field). Optionally, the differential\n operator can be augmented by adding an offset, i.e. a vector\n field which is added to the operator. Read more… Arguments Type Intent Optional Attributes Name class( fin_diff_block ), intent(inout) :: this class(cheb1d_vector_field), intent(in) :: rhs The right hand side of the linear(ised) system. class(cheb1d_vector_field), intent(in), optional :: offset An offset to add to the differential operator Return Value class(vector_field),\n  pointer"},{"title":"entrainment_mod – ISOFT","tags":"","loc":"module/entrainment_mod.html","text":"Provides an abstract data type to model entrainment into a\n vertically integrated plume. Uses iso_fortran_env factual_mod module~~entrainment_mod~~UsesGraph module~entrainment_mod entrainment_mod factual_mod factual_mod module~entrainment_mod->factual_mod iso_fortran_env iso_fortran_env module~entrainment_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~entrainment_mod~~UsedByGraph module~entrainment_mod entrainment_mod module~jenkins1991_entrainment_mod jenkins1991_entrainment_mod module~jenkins1991_entrainment_mod->module~entrainment_mod module~kochergin1987_entrainment_mod kochergin1987_entrainment_mod module~kochergin1987_entrainment_mod->module~entrainment_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~entrainment_mod module~asymmetric_plume_mod->module~jenkins1991_entrainment_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~entrainment_mod module~static_plume_mod->module~jenkins1991_entrainment_mod module~plume_mod plume_mod module~plume_mod->module~entrainment_mod module~plume_mod->module~jenkins1991_entrainment_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces get_entrainment Derived Types abstract_entrainment Abstract Interfaces abstract interface private function get_entrainment(this, velocity, thickness, depth, density_diff, time) result(property) Arguments Type Intent Optional Attributes Name class( abstract_entrainment ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is being \n entrained. class(scalar_field), intent(in) :: thickness The thickness of the plume into which fluid is being\n entrained class(scalar_field), intent(in) :: depth The depth of the upper surface of the plume into which\n fluid is being entrained class(scalar_field), intent(in) :: density_diff The difference between the ambient density and the density of\n the plume into which the ambient fluid is being entrained. real(kind=r8), intent(in), optional :: time The time at which the entrainment is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the entrainment Derived Types type, public, abstract :: abstract_entrainment An abstract data type for calculating entrainment of ambient\n ocean water into a vertically integrated plume . Type-Bound Procedures procedure(get_entrainment), public :: entrainment_rate Returns the entrainment rate for ambient water into the plume."},{"title":"uniform_ambient_mod – ISOFT","tags":"","loc":"module/uniform_ambient_mod.html","text":"Provides a derived type specifying uniform ambient temperature and\n salinity conditions beneath an ice shelf. Uses iso_fortran_env factual_mod ambient_mod module~~uniform_ambient_mod~~UsesGraph module~uniform_ambient_mod uniform_ambient_mod module~ambient_mod ambient_mod module~uniform_ambient_mod->module~ambient_mod factual_mod factual_mod module~uniform_ambient_mod->factual_mod iso_fortran_env iso_fortran_env module~uniform_ambient_mod->iso_fortran_env module~ambient_mod->factual_mod module~ambient_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~uniform_ambient_mod~~UsedByGraph module~uniform_ambient_mod uniform_ambient_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~uniform_ambient_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~uniform_ambient_mod module~plume_mod plume_mod module~plume_mod->module~uniform_ambient_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces uniform_ambient_conditions Derived Types uniform_ambient_conditions Functions constructor uniform_temperature uniform_salinity Interfaces public interface uniform_ambient_conditions private function constructor (temperature, salinity) result(this) Author Chris MacMackin Date November 2016 Produces an ambient object which will return the specified\n salinity and temeprature values. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: temperature The temperature of the ambient ocean. Default is 0. real(kind=r8), intent(in), optional :: salinity The salinity of the ambient ocean. Default is 0. Return Value type( uniform_ambient_conditions ) Derived Types type, public, extends( ambient_conditions ) :: uniform_ambient_conditions An derived type with procedures for getting the ambient ocean\n conditions. This implementation takes these conditions to be\n everywhere uniform. Components Type Visibility Attributes Name Initial type(uniform_scalar_field), private :: temperature type(uniform_scalar_field), private :: salinity Constructor private  function constructor (temperature, salinity) Produces an ambient object which will return the specified\n salinity and temeprature values. Type-Bound Procedures procedure, public :: ambient_temperature => uniform_temperature Returns the ambient ocean temperature procedure, public :: ambient_salinity => uniform_salinity Returns the ambient ocean temperature Functions private function constructor (temperature, salinity) result(this) Author Chris MacMackin Date November 2016 Produces an ambient object which will return the specified\n salinity and temeprature values. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: temperature The temperature of the ambient ocean. Default is 0. real(kind=r8), intent(in), optional :: salinity The salinity of the ambient ocean. Default is 0. Return Value type( uniform_ambient_conditions ) private function uniform_temperature (this, depth, t) result(property) Author Chris MacMackin Date November 2016 Returns the ambient ocean temperature. Arguments Type Intent Optional Attributes Name class( uniform_ambient_conditions ), intent(in) :: this class(scalar_field), intent(in) :: depth A field containing the depths at which the ambient temperature\n is to be calculated. real(kind=r8), intent(in) :: t The time at which the ambient conditions are to be calculated. Return Value class(scalar_field),\n  pointer A field containing the ambient temperature at the depth specified\n for each location. private function uniform_salinity (this, depth, t) result(property) Author Chris MacMackin Date November 2016 Returns the ambient ocean salinity. Arguments Type Intent Optional Attributes Name class( uniform_ambient_conditions ), intent(in) :: this class(scalar_field), intent(in) :: depth A field containing the depths at which the ambient salinity\n is to be calculated. real(kind=r8), intent(in) :: t The time at which the ambient conditions are to be calculated. Return Value class(scalar_field),\n  pointer A field containing the ambient salinity at the depth specified\n for each location."},{"title":"simple_plume_boundary_mod – ISOFT","tags":"","loc":"module/simple_plume_boundary_mod.html","text":"Provides a derived type which specifies the boundary conditions\n for a 1-D plume model. Dirichlet boundary conditions are used at\n the grounding line, while an outflow condition is used at the end\n of the domain. Uses iso_fortran_env factual_mod plume_boundary_mod boundary_types_mod module~~simple_plume_boundary_mod~~UsesGraph module~simple_plume_boundary_mod simple_plume_boundary_mod module~plume_boundary_mod plume_boundary_mod module~simple_plume_boundary_mod->module~plume_boundary_mod factual_mod factual_mod module~simple_plume_boundary_mod->factual_mod iso_fortran_env iso_fortran_env module~simple_plume_boundary_mod->iso_fortran_env module~boundary_types_mod boundary_types_mod module~simple_plume_boundary_mod->module~boundary_types_mod module~plume_boundary_mod->factual_mod module~plume_boundary_mod->iso_fortran_env module~plume_boundary_mod->module~boundary_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~simple_plume_boundary_mod~~UsedByGraph module~simple_plume_boundary_mod simple_plume_boundary_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~simple_plume_boundary_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~simple_plume_boundary_mod module~plume_mod plume_mod module~plume_mod->module~simple_plume_boundary_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables dummy Interfaces simple_plume_boundary Derived Types simple_plume_boundary Functions constructor simple_thickness_bound simple_velocity_bound simple_temperature_bound simple_salinity_bound Subroutines simple_thickness_info simple_info Variables Type Visibility Attributes Name Initial type(uniform_scalar_field), private :: dummy Interfaces public interface simple_plume_boundary private pure function constructor (thickness, velocity, temperature, salinity) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: thickness The water thickness at the inflowing plume boundary real(kind=r8), intent(in), dimension(2) :: velocity The longitudinal water velocity at the inflowing plume boundary real(kind=r8), intent(in) :: temperature The water temperature at the inflowing plume boundary real(kind=r8), intent(in) :: salinity The water salinity at the inflowing plume boundary Return Value type( simple_plume_boundary ) Derived Types type, public, extends( plume_boundary ) :: simple_plume_boundary A type with procedures for getting the boundary conditions of\n the plume model. Dirichlet boundary conditions are used at the\n grounding line. In order to approximate an outflow condition,\n the derivatives of velocity, temperature, and salinity are set\n to 0 at the end of the domain. Plume thickness is left free\n there, as only a single boundary condition is needed for it. Components Type Visibility Attributes Name Initial real(kind=r8), private :: thickness = 0.0_r8 The thickness of the plume at the inflowing boundary real(kind=r8), private, dimension(2) :: velocity = 1.0_r8 The velocity of the plume at the inflowing boundary real(kind=r8), private :: salinity = 0.0_r8 The salinity of the plume at the inflowing boundary real(kind=r8), private :: temperature = 0.0_r8 The tempreature of the plume at the inflowing boundary Constructor private pure function constructor (thickness, velocity, temperature, salinity) Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Type-Bound Procedures procedure, public :: set_time Specifies the time at which to calculate the boundary\n conditions. procedure, public :: thickness_bound_info => simple_thickness_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: velocity_bound_info => simple_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: temperature_bound_info => simple_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: salinity_bound_info => simple_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: thickness_bound => simple_thickness_bound Produces a field containing the boundary conditions for plume\n thickness at the specified location. procedure, public :: velocity_bound => simple_velocity_bound Produces a field containing the boundary conditions for plume\n velocity at the specified location. procedure, public :: temperature_bound => simple_temperature_bound Produces a field containing the boundary conditions for plume\n temperature at the specified location. procedure, public :: salinity_bound => simple_salinity_bound Produces a field containing the boundary conditions for plume\n salinity at the specified location. Functions private pure function constructor (thickness, velocity, temperature, salinity) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: thickness The water thickness at the inflowing plume boundary real(kind=r8), intent(in), dimension(2) :: velocity The longitudinal water velocity at the inflowing plume boundary real(kind=r8), intent(in) :: temperature The water temperature at the inflowing plume boundary real(kind=r8), intent(in) :: salinity The water salinity at the inflowing plume boundary Return Value type( simple_plume_boundary ) private function simple_thickness_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the thickness boundary values for the\n specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer private function simple_velocity_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the velocity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer private function simple_temperature_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the temperature boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer private function simple_salinity_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the salinity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Subroutines private subroutine simple_thickness_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is free. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. private subroutine simple_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( simple_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition."},{"title":"dallaston2015_seasonal_mod – ISOFT","tags":"","loc":"module/dallaston2015_seasonal_mod.html","text":"Provides a derived type which specifies the boundary conditions\n for a 1-D plume model, when subglacial discharge is oscillating\n over time. This corresponds to Dirichlet conditions at the\n grounding line and Neumann conditions (wth a gradient of 0) at the\n calving front. Uses iso_fortran_env factual_mod plume_boundary_mod boundary_types_mod module~~dallaston2015_seasonal_mod~~UsesGraph module~dallaston2015_seasonal_mod dallaston2015_seasonal_mod module~plume_boundary_mod plume_boundary_mod module~dallaston2015_seasonal_mod->module~plume_boundary_mod factual_mod factual_mod module~dallaston2015_seasonal_mod->factual_mod iso_fortran_env iso_fortran_env module~dallaston2015_seasonal_mod->iso_fortran_env module~boundary_types_mod boundary_types_mod module~dallaston2015_seasonal_mod->module~boundary_types_mod module~plume_boundary_mod->factual_mod module~plume_boundary_mod->iso_fortran_env module~plume_boundary_mod->module~boundary_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables dummy Interfaces dallaston2015_seasonal_boundary Derived Types dallaston2015_seasonal_boundary Functions constructor seasonal_thickness_bound seasonal_velocity_bound seasonal_temperature_bound seasonal_salinity_bound Subroutines seasonal_thickness_info seasonal_info seasonal_set_time Variables Type Visibility Attributes Name Initial type(uniform_scalar_field), private :: dummy Interfaces public interface dallaston2015_seasonal_boundary private pure function constructor (thickness, frequency, amplitude, mean, temperature) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with\n seasonal variations in subglacial discharge. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: thickness The plume thickness at the inflowing plume boundary, defaults\n to 0.1 real(kind=r8), intent(in), optional :: frequency The angular frequency of the oscillations in discharge,\n defaults to 1.0 real(kind=r8), intent(in), optional :: amplitude The amplitude of the oscillations in discharge, defaults to\n 1.0 real(kind=r8), intent(in), optional :: mean The time-average of the discharge, about which it oscillates,\n defaulting to 1.0 real(kind=r8), intent(in), optional :: temperature The water temperature at the inflowing plume boundary,\n defaults to 0.0 Return Value type( dallaston2015_seasonal_boundary ) Derived Types type, public, extends( plume_boundary ) :: dallaston2015_seasonal_boundary A type with procedures for getting the boundary conditions of\n the plume model. It represents the case where subglacial\n discharge is varying in time, altering the boundary conditions\n for velocity and salinity using scalings similar to those in\n Dallaston et al. (2015). Dirichlet boundary conditions are used\n at the grounding line. In order to approximate an outflow\n condition, the derivatives of velocity, temperature, and\n salinity are set to 0 at the end of the domain. Plume thickness\n is left free there, as only a single boundary condition is\n needed for it. Components Type Visibility Attributes Name Initial real(kind=r8), private :: thickness = 0.1_r8 The thickness of the plume at the inflowing boundary real(kind=r8), private :: frequency = 1.0_r8 The angular frequency of the oscillations in discharge real(kind=r8), private :: amplitude = 1.0_r8 The amplitude of the oscillations in discharge real(kind=r8), private :: mean = 1.0_r8 The time-average of the discharge, about which it oscillates real(kind=r8), private :: discharge = 1.0_r8 The current discharge value real(kind=r8), private :: temperature = 0.0_r8 The tempreature of the plume at the inflowing boundary Constructor private pure function constructor (thickness, frequency, amplitude, mean, temperature) Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with\n seasonal variations in subglacial discharge. Type-Bound Procedures procedure, public :: thickness_bound_info => seasonal_thickness_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: velocity_bound_info => seasonal_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: temperature_bound_info => seasonal_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: salinity_bound_info => seasonal_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: thickness_bound => seasonal_thickness_bound Produces a field containing the boundary conditions for plume\n thickness at the specified location. procedure, public :: velocity_bound => seasonal_velocity_bound Produces a field containing the boundary conditions for plume\n velocity at the specified location. procedure, public :: temperature_bound => seasonal_temperature_bound Produces a field containing the boundary conditions for plume\n temperature at the specified location. procedure, public :: salinity_bound => seasonal_salinity_bound Produces a field containing the boundary conditions for plume\n salinity at the specified location. procedure, public :: set_time => seasonal_set_time Specifies the time at which to calculate the boundary\n conditions. Functions private pure function constructor (thickness, frequency, amplitude, mean, temperature) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with\n seasonal variations in subglacial discharge. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: thickness The plume thickness at the inflowing plume boundary, defaults\n to 0.1 real(kind=r8), intent(in), optional :: frequency The angular frequency of the oscillations in discharge,\n defaults to 1.0 real(kind=r8), intent(in), optional :: amplitude The amplitude of the oscillations in discharge, defaults to\n 1.0 real(kind=r8), intent(in), optional :: mean The time-average of the discharge, about which it oscillates,\n defaulting to 1.0 real(kind=r8), intent(in), optional :: temperature The water temperature at the inflowing plume boundary,\n defaults to 0.0 Return Value type( dallaston2015_seasonal_boundary ) private function seasonal_thickness_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the thickness boundary values for the\n specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer private function seasonal_velocity_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the velocity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer private function seasonal_temperature_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the temperature boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer private function seasonal_salinity_bound (this, location) result(bound) Author Chris MacMackin Date March 2017 Returns a field containing the salinity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Subroutines private subroutine seasonal_thickness_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is free. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. private subroutine seasonal_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date March 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. private subroutine seasonal_set_time (this, time) Author Chris MacMackin Date May 2017 Sets the time at which boundary conditions are to be calculated. Arguments Type Intent Optional Attributes Name class( dallaston2015_seasonal_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: time"},{"title":"seasonal_glacier_boundary_mod – ISOFT","tags":"","loc":"module/seasonal_glacier_boundary_mod.html","text":"Provides a derived type which specifies the boundary conditions\n for the ice shelf model used by Dallaston et al. (2015), except\n that the ice flux at the grounding line varies sinusoidally in\n time.  There are Dirichlet conditions at the lower bound of the\n first condition as well as, for thickness, the upper bound. Uses iso_fortran_env factual_mod boundary_types_mod glacier_boundary_mod module~~seasonal_glacier_boundary_mod~~UsesGraph module~seasonal_glacier_boundary_mod seasonal_glacier_boundary_mod module~glacier_boundary_mod glacier_boundary_mod module~seasonal_glacier_boundary_mod->module~glacier_boundary_mod factual_mod factual_mod module~seasonal_glacier_boundary_mod->factual_mod iso_fortran_env iso_fortran_env module~seasonal_glacier_boundary_mod->iso_fortran_env module~boundary_types_mod boundary_types_mod module~seasonal_glacier_boundary_mod->module~boundary_types_mod module~glacier_boundary_mod->factual_mod module~glacier_boundary_mod->iso_fortran_env module~glacier_boundary_mod->module~boundary_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces seasonal_glacier_boundary Derived Types seasonal_glacier_boundary Functions constructor seasonal_lower_bound seasonal_upper_bound seasonal_lower_type seasonal_upper_type seasonal_residuals Interfaces public interface seasonal_glacier_boundary private pure function constructor (thickness, frequency, amplitude, mean, chi, square) result(this) Author Chris MacMackin Date October 2017 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with the ice\n flux at the grounding line varying in time. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: thickness The ice thickness at the inflowing ice shelf boundary,\n defaults to 1.0 real(kind=r8), intent(in), optional :: frequency The angular frequency of the oscillations in ice flux,\n defaults to 0.5 real(kind=r8), intent(in), optional :: amplitude The amplitude of the oscillations in ice flux, defaults to\n 1.0 real(kind=r8), intent(in), optional :: mean The time-average of the discharge, about which it oscillates,\n defaulting to 1.0 real(kind=r8), intent(in), optional :: chi The dimensionless ratio \\chi \\equiv\n \\frac{\\rho_igh_0x_x}{2\\eta_0u_0} , defaults to 1.0 logical, intent(in), optional :: square If present and true, produce a square wave. Otherwise produce\n a sinusoid. Return Value type( seasonal_glacier_boundary ) Derived Types type, public, extends( glacier_boundary ) :: seasonal_glacier_boundary A type with procedures for getting the boundary conditions of\n the ice shelf model used by Dallaston et al. (2015), but with\n the ice flux at the grounding line varying sinusoidally in\n time. There are Dirichlet conditions at the lower bound of the\n first condition as well as, for thickness, the upper bound. Components Type Visibility Attributes Name Initial real(kind=r8), private :: thickness = 1.0_r8 The thickness of the glacier at the inflowing boundary real(kind=r8), private :: frequency = 1.0_r8 The angular frequency of the oscillations in ice flux real(kind=r8), private :: amplitude = 0.5_r8 The amplitude of the oscillations in ice flux real(kind=r8), private :: mean = 1.0_r8 The time-average of the ice flux, about which it oscillates real(kind=r8), private :: chi = 1.0_r8 The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ logical, private :: square = .false. If true, produce a square wave, otherwise produce a sinusoid Constructor private pure function constructor (thickness, frequency, amplitude, mean, chi, square) Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with the ice\n flux at the grounding line varying in time. Type-Bound Procedures procedure, public :: thickness_upper_bound => bound_array Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the thickness\n field. procedure, public :: thickness_upper_type => bound_type Returns an array indicating what type of boundary conditions\n apply for thickness at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: thickness_lower_bound => seasonal_lower_bound Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the thickness\n field. procedure, public :: velocity_lower_bound => seasonal_lower_bound Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the velocity\n field. procedure, public :: velocity_upper_bound => seasonal_upper_bound Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the velocity\n field. procedure, public :: thickness_lower_type => seasonal_lower_type Returns an array indicating what type of boundary conditions\n apply for thickness at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: velocity_lower_type => seasonal_lower_type Returns an array indicating what type of boundary conditions\n apply for velocity at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: velocity_upper_type => seasonal_upper_type Returns an array indicating what type of boundary conditions\n apply for velocity at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: boundary_residuals => seasonal_residuals Returns an array consisting of the difference between the\n required boundary values and those which actually exist. This\n can then be appended to a glacier's state vector. The order\n in which these are listed is as follows: lower thickness\n boundary, upper thickness boundary, lower velocity boundary,\n and upper velocity boundary. Functions private pure function constructor (thickness, frequency, amplitude, mean, chi, square) result(this) Author Chris MacMackin Date October 2017 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015), but with the ice\n flux at the grounding line varying in time. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), optional :: thickness The ice thickness at the inflowing ice shelf boundary,\n defaults to 1.0 real(kind=r8), intent(in), optional :: frequency The angular frequency of the oscillations in ice flux,\n defaults to 0.5 real(kind=r8), intent(in), optional :: amplitude The amplitude of the oscillations in ice flux, defaults to\n 1.0 real(kind=r8), intent(in), optional :: mean The time-average of the discharge, about which it oscillates,\n defaulting to 1.0 real(kind=r8), intent(in), optional :: chi The dimensionless ratio \\chi \\equiv\n \\frac{\\rho_igh_0x_x}{2\\eta_0u_0} , defaults to 1.0 logical, intent(in), optional :: square If present and true, produce a square wave. Otherwise produce\n a sinusoid. Return Value type( seasonal_glacier_boundary ) private pure function seasonal_lower_bound (this) result(bound_array) Author Chris MacMackin Date October 2017 Indicates that one layer of cells at the lower boundary in the\n first dimension should be omitted. This is appropriate for\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) private pure function seasonal_upper_bound (this) result(bound_array) Author Chris MacMackin Date October 2017 Indicates that one layer of cells at the upper boundary in the\n first dimension should be omitted for thickness. This is\n appropriate for Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) private pure function seasonal_lower_type (this) result(bound_type) Author Chris MacMackin Date January 2017 Specifies that the lower boundary in the first dimension has\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable private pure function seasonal_upper_type (this) result(bound_type) Author Chris MacMackin Date January 2017 Specifies that the upper boundary in the first dimension has\n Neumann boundary conditions. Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable private function seasonal_residuals (this, thickness, velocity, viscosity, t) result(residuals) Author Chris MacMackin Date October 2017 Returns the difference between the glacier conditions of the\n plume and the Dirichlet conditions prescribed in the model of\n Dallaston et al. (2015) Arguments Type Intent Optional Attributes Name class( seasonal_glacier_boundary ), intent(in) :: this class(scalar_field), intent(in) :: thickness A field containing the thickness of the glacier class(vector_field), intent(in) :: velocity A field containing the flow velocity of the glacier class(scalar_field), intent(in) :: viscosity A field containing the viscosity of the ice in the glacier. real(kind=r8), intent(in) :: t The time at which the boundary conditions are to be\n calculated. Return Value real(kind=r8),\n  allocatable, dimension(:) An array containing the difference between the required\n boundary values and those which are actually present. They\n are stored in the order: lower thickness boundary, upper\n thickness boundary, lower velocity boundary, and upper\n velocity boundary."},{"title":"upstream_plume_mod – ISOFT","tags":"","loc":"module/upstream_plume_mod.html","text":"Provides a derived type which specifies the boundary conditions\n for a 1-D plume model. In order to avoid boundary layer effects,\n an ODE solver is used to integrate the plume a little way\n upstream, past the boundary layer. Uses iso_fortran_env logger_mod penf factual_mod uniform_gradient_field_mod plume_boundary_mod boundary_types_mod rksuite_90 module~~upstream_plume_mod~~UsesGraph module~upstream_plume_mod upstream_plume_mod logger_mod logger_mod module~upstream_plume_mod->logger_mod factual_mod factual_mod module~upstream_plume_mod->factual_mod module~plume_boundary_mod plume_boundary_mod module~upstream_plume_mod->module~plume_boundary_mod module~rksuite_90 rksuite_90 module~upstream_plume_mod->module~rksuite_90 module~uniform_gradient_field_mod uniform_gradient_field_mod module~upstream_plume_mod->module~uniform_gradient_field_mod iso_fortran_env iso_fortran_env module~upstream_plume_mod->iso_fortran_env penf penf module~upstream_plume_mod->penf module~boundary_types_mod boundary_types_mod module~upstream_plume_mod->module~boundary_types_mod module~plume_boundary_mod->factual_mod module~plume_boundary_mod->iso_fortran_env module~plume_boundary_mod->module~boundary_types_mod module~rksuite_90_prec rksuite_90_prec module~rksuite_90->module~rksuite_90_prec module~uniform_gradient_field_mod->factual_mod module~uniform_gradient_field_mod->iso_fortran_env utils_mod utils_mod module~uniform_gradient_field_mod->utils_mod module~rksuite_90_prec->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~upstream_plume_mod~~UsedByGraph module~upstream_plume_mod upstream_plume_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~upstream_plume_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~upstream_plume_mod module~plume_mod plume_mod module~plume_mod->module~upstream_plume_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables dummy Interfaces upstream_plume_boundary Abstract Interfaces bound_vals non_diff Derived Types upstream_plume_boundary Functions constructor upstream_thickness_bound upstream_velocity_bound upstream_temperature_bound upstream_salinity_bound Subroutines upstream_thickness_info upstream_info upstream_calculate Variables Type Visibility Attributes Name Initial type(uniform_scalar_field), private :: dummy Interfaces public interface upstream_plume_boundary private pure function constructor (bound_calculator, distance, thresholds) result(this) Author Chris MacMackin Date July 2017 Constructs a boundary condition object which integrates an IVP\n from actual boundary values to calculate the staet of the plume\n a little upstream. This can be used to avoid boundary layers. Arguments Type Intent Optional Attributes Name procedure( bound_vals ) :: bound_calculator Calculates the \"actual\" inflow boundary conditions, used to\n initiate the integration to find the values to use in the\n simulation. real(kind=r8), intent(in) :: distance The distance upstream which the plume should be integrated. real(kind=r8), intent(in), optional dimension(:) :: thresholds The thresholds to use when evaluating the error of the\n integration. This is done according to the formula abs(e) / max(magnitude_y, THRESHOLDS) <= TOLERANCE . Return Value type( upstream_plume_boundary ) Abstract Interfaces abstract interface private pure subroutine bound_vals(time, D, U, T, S) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: time The time at which the boundary values are being calculated real(kind=r8), intent(out) :: D Plume thickness boundary condition real(kind=r8), intent(out), dimension(:), allocatable :: U Plume velocity boundary condition real(kind=r8), intent(out) :: T Plume temperature boundary condition real(kind=r8), intent(out) :: S Plume salinity boundary condition abstract interface private subroutine non_diff(D, U, T, S, b, DU_x, DUU_x, DUT_x, DUS_x) Arguments Type Intent Optional Attributes Name class(scalar_field), intent(in) :: D The plume thickness class(vector_field), intent(in) :: U The plume velocity class(scalar_field), intent(in) :: T The plume temperature class(scalar_field), intent(in) :: S The plume salinity class(scalar_field), intent(in) :: b The debth of the base of the ice shelf class(scalar_field), intent(out) :: DU_x The derivative of the product DU class(vector_field), intent(out) :: DUU_x The derivative of the product DUU class(scalar_field), intent(out) :: DUT_x The derivative of the product DUT class(scalar_field), intent(out) :: DUS_x The derivative of the product DUS Derived Types type, public, extends( plume_boundary ) :: upstream_plume_boundary A type with procedures for getting the boundary conditions of\n the plume model. For given boundary conditions, it integrates\n the plume upstream slightly and then returns these when asked\n for boundary values. This allows boundary layers, which can\n cause numerical difficulties, to be avoided. Inflow boundaries\n must be Dirichlet, while outflow boundaries for velocity,\n salinity, and temperature are set to have a gradient of zero. Read more… Components Type Visibility Attributes Name Initial procedure( bound_vals ), private, nopass, pointer :: get_boundaries => null() Calculate the \"actual\" boundary values, used to initiate the\n integration, for the specified time. real(kind=r8), private :: distance = 0.05_r8 The distance upstream which the plume should be integrated real(kind=r8), private :: thickness = 0.1_r8 The thickness of the plume at the inflowing boundary real(kind=r8), private, dimension(:), allocatable :: velocity The velocity of the plume at the inflowing boundary real(kind=r8), private :: temperature = 0.0_r8 The tempreature of the plume at the inflowing boundary real(kind=r8), private :: salinity = 1.0_r8 The salinity of the plume at the inflowing boundary real(kind=r8), private :: boundary_time The time at which the boundaries were most recently\n calculated real(kind=r8), private, dimension(:), allocatable :: thresholds Thresholds to use when calculating error in the integration. Constructor private pure function constructor (bound_calculator, distance, thresholds) Constructs a boundary condition object which integrates an IVP\n from actual boundary values to calculate the staet of the plume\n a little upstream. This can be used to avoid boundary layers. Type-Bound Procedures procedure, public :: set_time Specifies the time at which to calculate the boundary\n conditions. procedure, public :: thickness_bound_info => upstream_thickness_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: velocity_bound_info => upstream_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: temperature_bound_info => upstream_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: salinity_bound_info => upstream_info Indicates the type and depth of the thickness boundary at\n different locations. procedure, public :: thickness_bound => upstream_thickness_bound Produces a field containing the boundary conditions for plume\n thickness at the specified location. procedure, public :: velocity_bound => upstream_velocity_bound Produces a field containing the boundary conditions for plume\n velocity at the specified location. procedure, public :: temperature_bound => upstream_temperature_bound Produces a field containing the boundary conditions for plume\n temperature at the specified location. procedure, public :: salinity_bound => upstream_salinity_bound Produces a field containing the boundary conditions for plume\n salinity at the specified location. procedure, public :: calculate => upstream_calculate Calculates the upstreamed boundary conditions for the given\n time and ice thickness. Functions private pure function constructor (bound_calculator, distance, thresholds) result(this) Author Chris MacMackin Date July 2017 Constructs a boundary condition object which integrates an IVP\n from actual boundary values to calculate the staet of the plume\n a little upstream. This can be used to avoid boundary layers. Arguments Type Intent Optional Attributes Name procedure( bound_vals ) :: bound_calculator Calculates the \"actual\" inflow boundary conditions, used to\n initiate the integration to find the values to use in the\n simulation. real(kind=r8), intent(in) :: distance The distance upstream which the plume should be integrated. real(kind=r8), intent(in), optional dimension(:) :: thresholds The thresholds to use when evaluating the error of the\n integration. This is done according to the formula abs(e) / max(magnitude_y, THRESHOLDS) <= TOLERANCE . Return Value type( upstream_plume_boundary ) private function upstream_thickness_bound (this, location) result(bound) Author Chris MacMackin Date July 2017 Returns a field containing the thickness boundary values for the\n specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer private function upstream_velocity_bound (this, location) result(bound) Author Chris MacMackin Date July 2017 Returns a field containing the velocity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(vector_field),\n  pointer private function upstream_temperature_bound (this, location) result(bound) Author Chris MacMackin Date July 2017 Returns a field containing the temperature boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer private function upstream_salinity_bound (this, location) result(bound) Author Chris MacMackin Date July 2017 Returns a field containing the salinity boundary values for\n the specified boundary location. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. Return Value class(scalar_field),\n  pointer Subroutines private subroutine upstream_thickness_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date July 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is free. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. private subroutine upstream_info (this, location, bound_type, bound_depth) Author Chris MacMackin Date July 2017 Indicates that the lower boundary is Dirichlet and the upper\n boundary is Neumann. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(in) :: this integer, intent(in) :: location Which boundary information is to be provided for.  The\n boundary will be the one normal to dimension of number abs(boundary) . If the argument is negative, then the lower\n boundary is returned. If positive, then the upper boundary is\n returned. integer, intent(out) :: bound_type An integer representing what sort of boundary condition is\n used. The integer value corresponding to each boundary type is\n specified in the boundary_types_mod . integer, intent(out) :: bound_depth The number of layers of data-points needed to specify the\n boundary condition. private subroutine upstream_calculate (this, t, func, b) Author Chris MacMackin Date July 2017 Calculates the boundary values to use at the current time with\n the current ice thickness. Arguments Type Intent Optional Attributes Name class( upstream_plume_boundary ), intent(inout) :: this real(kind=r8), intent(in) :: t The time at which to calculate the boundary values. procedure( non_diff ) :: func A function which returns the non-diffusive, non-inertial\n components of the ODEs describing the plume. class(scalar_field), intent(in) :: b The depth of the ice shelf base."},{"title":"dallaston2015_glacier_boundary_mod – ISOFT","tags":"","loc":"module/dallaston2015_glacier_boundary_mod.html","text":"Provides a derived type which specifies the boundary conditions\n for the ice shelf model used by Dallaston et al. (2015).  These\n are Dirichlet conditions at the lower bound of the first condition\n as well as, for thickness, the upper bound. Uses iso_fortran_env factual_mod boundary_types_mod glacier_boundary_mod module~~dallaston2015_glacier_boundary_mod~~UsesGraph module~dallaston2015_glacier_boundary_mod dallaston2015_glacier_boundary_mod module~glacier_boundary_mod glacier_boundary_mod module~dallaston2015_glacier_boundary_mod->module~glacier_boundary_mod factual_mod factual_mod module~dallaston2015_glacier_boundary_mod->factual_mod iso_fortran_env iso_fortran_env module~dallaston2015_glacier_boundary_mod->iso_fortran_env module~boundary_types_mod boundary_types_mod module~dallaston2015_glacier_boundary_mod->module~boundary_types_mod module~glacier_boundary_mod->factual_mod module~glacier_boundary_mod->iso_fortran_env module~glacier_boundary_mod->module~boundary_types_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~dallaston2015_glacier_boundary_mod~~UsedByGraph module~dallaston2015_glacier_boundary_mod dallaston2015_glacier_boundary_mod module~ice_shelf_mod ice_shelf_mod module~ice_shelf_mod->module~dallaston2015_glacier_boundary_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces dallaston2015_glacier_boundary Derived Types dallaston2015_glacier_boundary Functions constructor dallaston2015_lower_bound dallaston2015_upper_bound dallaston2015_lower_type dallaston2015_upper_type dallaston2015_residuals Interfaces public interface dallaston2015_glacier_boundary private pure function constructor (thickness, velocity, chi) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: thickness The ice thickness at the inflowing ice shelf boundary real(kind=r8), intent(in) :: velocity The longitudinal ice velocity at the inflowing ice shelf boundary real(kind=r8), intent(in) :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Return Value type( dallaston2015_glacier_boundary ) Derived Types type, public, extends( glacier_boundary ) :: dallaston2015_glacier_boundary A type with procedures for getting the boundary conditions of\n the ice shelf model used by Dallaston et al. (2015). These are\n Dirichlet conditions at the lower bound of the first condition\n as well as, for thickness, the upper bound. Read more… Components Type Visibility Attributes Name Initial real(kind=r8), private :: thickness = 1.0_r8 The thickness of the glacier at the inflowing boundary real(kind=r8), private :: velocity = 1.0_r8 The velocity of the glacier at the inflowing boundary real(kind=r8), private :: chi = 1.0_r8 The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Constructor private pure function constructor (thickness, velocity, chi) Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Type-Bound Procedures procedure, public :: thickness_upper_bound => bound_array Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the thickness\n field. procedure, public :: thickness_upper_type => bound_type Returns an array indicating what type of boundary conditions\n apply for thickness at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: thickness_lower_bound => dallaston2015_lower_bound Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the thickness\n field. procedure, public :: velocity_lower_bound => dallaston2015_lower_bound Returns a 1D array which should be passed as the exclude_lower_bound / provide_lower_bound argument when\n getting or setting the raw representation of the velocity\n field. procedure, public :: velocity_upper_bound => dallaston2015_upper_bound Returns a 1D array which should be passed as the exclude_upper_bound / provide_upper_bound argument when\n getting or setting the raw representation of the velocity\n field. procedure, public :: thickness_lower_type => dallaston2015_lower_type Returns an array indicating what type of boundary conditions\n apply for thickness at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: velocity_lower_type => dallaston2015_lower_type Returns an array indicating what type of boundary conditions\n apply for velocity at the lower boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: velocity_upper_type => dallaston2015_upper_type Returns an array indicating what type of boundary conditions\n apply for velocity at the upper boundary of each\n dimension. The types are specified using the parameters in\n [boundary_types_mod]. procedure, public :: boundary_residuals => dallaston2015_residuals Returns an array consisting of the difference between the\n required boundary values and those which actually exist. This\n can then be appended to a glacier's state vector. The order\n in which these are listed is as follows: lower thickness\n boundary, upper thickness boundary, lower velocity boundary,\n and upper velocity boundary. Functions private pure function constructor (thickness, velocity, chi) result(this) Author Chris MacMackin Date November 2016 Constructs a boundary condition object for an ice shelf based on\n the conditions used in Dallaston et al. (2015). Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: thickness The ice thickness at the inflowing ice shelf boundary real(kind=r8), intent(in) :: velocity The longitudinal ice velocity at the inflowing ice shelf boundary real(kind=r8), intent(in) :: chi The dimensionless ratio\n $\\chi \\equiv \\frac{\\rho_igh_0x_x}{2\\eta_0u_0}$ Return Value type( dallaston2015_glacier_boundary ) private pure function dallaston2015_lower_bound (this) result(bound_array) Author Chris MacMackin Date November 2016 Indicates that one layer of cells at the lower boundary in the\n first dimension should be omitted. This is appropriate for\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) private pure function dallaston2015_upper_bound (this) result(bound_array) Author Chris MacMackin Date November 2016 Indicates that one layer of cells at the upper boundary in the\n first dimension should be omitted for thickness. This is\n appropriate for Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(2) private pure function dallaston2015_lower_type (this) result(bound_type) Author Chris MacMackin Date January 2017 Specifies that the lower boundary in the first dimension has\n Dirichlet boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable private pure function dallaston2015_upper_type (this) result(bound_type) Author Chris MacMackin Date January 2017 Specifies that the upper boundary in the first dimension has\n Neumann boundary conditions. Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this Return Value integer,\n  dimension(:), allocatable private function dallaston2015_residuals (this, thickness, velocity, viscosity, t) result(residuals) Author Chris MacMackin Date November 2016 Returns the difference between the glacier conditions of the\n plume and the Dirichlet conditions prescribed in the model of\n Dallaston et al. (2015) Arguments Type Intent Optional Attributes Name class( dallaston2015_glacier_boundary ), intent(in) :: this class(scalar_field), intent(in) :: thickness A field containing the thickness of the glacier class(vector_field), intent(in) :: velocity A field containing the flow velocity of the glacier class(scalar_field), intent(in) :: viscosity A field containing the viscosity of the ice in the glacier. real(kind=r8), intent(in) :: t The time at which the boundary conditions are to be\n calculated. Return Value real(kind=r8),\n  allocatable, dimension(:) An array containing the difference between the required\n boundary values and those which are actually present. They\n are stored in the order: lower thickness boundary, upper\n thickness boundary, lower velocity boundary, and upper\n velocity boundary."},{"title":"ave_one_equation_melt_mod – ISOFT","tags":"","loc":"module/ave_one_equation_melt_mod.html","text":"Provides an implementation of melt similar to that used by\n Dallaston, Hewitt, and Wells (2015), prior to their neglecting\n certain terms on scaling arguments. This implementation has been\n modified to account for transverse variation in a\n horizontally-integrated model. Uses iso_fortran_env factual_mod melt_relationship_mod module~~ave_one_equation_melt_mod~~UsesGraph module~ave_one_equation_melt_mod ave_one_equation_melt_mod factual_mod factual_mod module~ave_one_equation_melt_mod->factual_mod iso_fortran_env iso_fortran_env module~ave_one_equation_melt_mod->iso_fortran_env module~melt_relationship_mod melt_relationship_mod module~ave_one_equation_melt_mod->module~melt_relationship_mod module~melt_relationship_mod->factual_mod module~melt_relationship_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces ave_one_equation_melt Derived Types ave_one_equation_melt Functions constructor one_equation_heat one_equation_salt ave_one_equation_melt_rate one_equation_has_heat one_equation_has_salt Subroutines one_equation_solve Interfaces public interface ave_one_equation_melt private pure function constructor (coef1, coef2, fresh_sal, melt_temp, a_UabsT) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coef1 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), intent(in) :: coef2 The unitless multiplier applied to the theram forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), intent(in), optional :: fresh_sal The salinity of fresh water. Defaults to 0. real(kind=r8), intent(in), optional :: melt_temp The melting point of the ice. Defaults to 0. real(kind=r8), intent(in), optional :: a_UabsT The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy, where f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the\n variables |\\vec{U}| and T in the transverse\n direction. Defaults to 1. Return Value type( ave_one_equation_melt ) The newly created object representing the melt relationship. Derived Types type, public, extends( abstract_melt_relationship ) :: ave_one_equation_melt A parameterisation of melting into a plume which comes from\n heavily simplifying the 3 equation model. It can work with\n horizontally-integrated plume models, taking account of the\n plume's transverse profile. It is taken from Dallaston, Hewitt,\n and Wells (2015), prior to the their dropping some terms based\n on scaling arguments. The melt rate, as well as effect on\n termperature and salinity, are calculated by calling solve_for_melt and then accessed\n using melt_rate , heat_equation_terms , salt_equation_terms . Components Type Visibility Attributes Name Initial class(scalar_field), public, allocatable :: forcing_values Stores the resulting forcing values. real(kind=r8), public :: coef1 = 0.018208_r8 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), public :: coef2 = 0.023761_r8 The unitless multiplier applied to the thermal forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), public :: sal_forcing = 0._r8 The unitless multiplier applied to the forcing values to get\n the salinity forcing. It corresponds to the product of coef2 and the ice salinity. Typically this would be zero,\n but it might be positive if there is some marine ice\n present. Alternatively, depending on how the salinity has\n been scaled, it may have a negative value. real(kind=r8), public :: melt_temp = 0._r8 The melting temperature. While intuitively it makes sense to\n set this to zero, it can be useful to scale temperature in\n such a way that it will have a negative value. real(kind=r8), public :: a_UabsT = 1._r8 The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy, where f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the\n variables |\\vec{U}| and T in the transverse\n direction. Constructor private pure function constructor (coef1, coef2, fresh_sal, melt_temp, a_UabsT) Type-Bound Procedures procedure, public :: solve_for_melt => one_equation_solve procedure, public :: heat_equation_terms => one_equation_heat Returns the terms this melt formulation contributes to the\n heat equation, after they have been solved for using solve_for_melt . procedure, public :: salt_equation_terms => one_equation_salt Returns the terms this melt formulation contributes to the\n salt equation, after they have been solved for using solve_for_melt . procedure, public :: melt_rate => ave_one_equation_melt_rate Returns the melt rate calculated using this formulation,\n after it has been solved for using solve_for_melt . procedure, public :: has_heat_terms => one_equation_has_heat Whether this formulation of melting contributes any terms to\n a plume's heat equation. procedure, public :: has_salt_terms => one_equation_has_salt Whether this formulation of melting contributes any terms to\n a plume's salinity equation. Functions private pure function constructor (coef1, coef2, fresh_sal, melt_temp, a_UabsT) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coef1 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), intent(in) :: coef2 The unitless multiplier applied to the theram forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), intent(in), optional :: fresh_sal The salinity of fresh water. Defaults to 0. real(kind=r8), intent(in), optional :: melt_temp The melting point of the ice. Defaults to 0. real(kind=r8), intent(in), optional :: a_UabsT The shape coefficient for a horizontally-integrated model. It\n is defined as \\alpha_{|\\vec{U}|T} = \\frac{1}{y_2 - y_1}\n \\int&#94;{y_2}_{y_1} f_{|\\vec{U}|}f_T dy, where f_{|\\vec{U}|}(y) and f_T(y) are the shapes of the\n variables |\\vec{U}| and T in the transverse\n direction. Defaults to 1. Return Value type( ave_one_equation_melt ) The newly created object representing the melt relationship. private function one_equation_heat (this) result(heat) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the heat equation for a plume private function one_equation_salt (this) result(salt) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the salt equation for a plume private function ave_one_equation_melt_rate (this) result(melt) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate from the ice into the plume water. private pure function one_equation_has_heat (this) result(has_heat) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat equation of the plume. private pure function one_equation_has_salt (this) result(has_salt) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the salinity equation of the plume. Subroutines private subroutine one_equation_solve (this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( ave_one_equation_melt ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed."},{"title":"newtonian_viscosity_mod – ISOFT","tags":"","loc":"module/newtonian_viscosity_mod.html","text":"Provides a simple concrete implementation for the abstract_viscosity type, for a Newtonian fluid. Uses iso_fortran_env factual_mod viscosity_mod module~~newtonian_viscosity_mod~~UsesGraph module~newtonian_viscosity_mod newtonian_viscosity_mod module~viscosity_mod viscosity_mod module~newtonian_viscosity_mod->module~viscosity_mod factual_mod factual_mod module~newtonian_viscosity_mod->factual_mod iso_fortran_env iso_fortran_env module~newtonian_viscosity_mod->iso_fortran_env module~viscosity_mod->factual_mod module~viscosity_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~newtonian_viscosity_mod~~UsedByGraph module~newtonian_viscosity_mod newtonian_viscosity_mod module~ice_shelf_mod ice_shelf_mod module~ice_shelf_mod->module~newtonian_viscosity_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces newtonian_viscosity Derived Types newtonian_viscosity Functions constructor newtonian_ice_viscosity Interfaces public interface newtonian_viscosity private pure function constructor (viscosity_value) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: viscosity_value The numerical value of the viscosity which this type is meant \n to return. Return Value type( newtonian_viscosity ) The viscosity object being created. Derived Types type, public, extends( abstract_viscosity ) :: newtonian_viscosity An implementation of Newtonian (constant) viscosity for a glacier. Components Type Visibility Attributes Name Initial real(kind=r8), private :: viscosity_value = 1.0_r8 Constructor private pure function constructor (viscosity_value) Type-Bound Procedures procedure, public :: ice_viscosity => newtonian_ice_viscosity Returns the viscosity for the ice. Functions private pure function constructor (viscosity_value) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: viscosity_value The numerical value of the viscosity which this type is meant \n to return. Return Value type( newtonian_viscosity ) The viscosity object being created. private function newtonian_ice_viscosity (this, velocity, temperature, time) result(viscosity) Arguments Type Intent Optional Attributes Name class( newtonian_viscosity ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the ice for which the velocity is\n being calculated real(kind=r8), intent(in) :: temperature The temperature of the ice for which viscosity is being\n calculated. real(kind=r8), intent(in), optional :: time The time at which the viscosity is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the viscosity"},{"title":"glens_law_mod – ISOFT","tags":"","loc":"module/glens_law_mod.html","text":"Provides a concrete implementation for the abstract_viscosity type using Glen's flow law. Uses iso_fortran_env factual_mod viscosity_mod module~~glens_law_mod~~UsesGraph module~glens_law_mod glens_law_mod module~viscosity_mod viscosity_mod module~glens_law_mod->module~viscosity_mod factual_mod factual_mod module~glens_law_mod->factual_mod iso_fortran_env iso_fortran_env module~glens_law_mod->iso_fortran_env module~viscosity_mod->factual_mod module~viscosity_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces glens_law_viscosity Derived Types glens_law_viscosity Functions constructor glens_ice_viscosity Interfaces public interface glens_law_viscosity private pure function constructor (b_val, index) result(this) Author Christopher MacMackin Date April 2017 Instantiates an instance of a viscosity object implementing\n Glen's flow law. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: b_val The coefficient, B , in Glen's flow law. real(kind=r8), intent(in) :: index The index, n , in the exponent of Glen's flow law. Return Value type( glens_law_viscosity ) The viscosity object being created. Derived Types type, public, extends( abstract_viscosity ) :: glens_law_viscosity An implementation of Glen's flow law to describe glacier\n viscosity. It takes the form \\eta = \\frac{1}{2}BD&#94;{1/n-1}, where D = \\sqrt{D_{ij}D_{ij}/2 is the second invarient of\n the strain rate D_{ij} = \\frac{1}{2}\\left(\\frac{\\partial\n u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i}\n \\right). Here, B is treated as a constant, although it may\n be parameterised as a function of temperature. Components Type Visibility Attributes Name Initial real(kind=r8), private :: b_val = 1.0_r8 real(kind=r8), private :: index = 3._r8 Constructor private pure function constructor (b_val, index) Instantiates an instance of a viscosity object implementing\n Glen's flow law. Type-Bound Procedures procedure, public :: ice_viscosity => glens_ice_viscosity Returns the viscosity for the ice. Functions private pure function constructor (b_val, index) result(this) Author Christopher MacMackin Date April 2017 Instantiates an instance of a viscosity object implementing\n Glen's flow law. Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: b_val The coefficient, B , in Glen's flow law. real(kind=r8), intent(in) :: index The index, n , in the exponent of Glen's flow law. Return Value type( glens_law_viscosity ) The viscosity object being created. private function glens_ice_viscosity (this, velocity, temperature, time) result(viscosity) Author Christopher MacMackin Date April 2017 Calculates the viscosity of ice using Glen's flow law. See the\n documentation of the glens_law_viscosity object for a\n description of this parameterisation. Arguments Type Intent Optional Attributes Name class( glens_law_viscosity ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the ice for which the velocity is\n being calculated real(kind=r8), intent(in) :: temperature The temperature of the ice for which viscosity is being\n calculated. real(kind=r8), intent(in), optional :: time The time at which the viscosity is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the viscosity"},{"title":"kochergin1987_entrainment_mod – ISOFT","tags":"","loc":"module/kochergin1987_entrainment_mod.html","text":"Provides a concrete implementation of abstract_entrainment in the form of the parameterisation described by Kochergin (1987). Uses iso_fortran_env factual_mod entrainment_mod module~~kochergin1987_entrainment_mod~~UsesGraph module~kochergin1987_entrainment_mod kochergin1987_entrainment_mod factual_mod factual_mod module~kochergin1987_entrainment_mod->factual_mod iso_fortran_env iso_fortran_env module~kochergin1987_entrainment_mod->iso_fortran_env module~entrainment_mod entrainment_mod module~kochergin1987_entrainment_mod->module~entrainment_mod module~entrainment_mod->factual_mod module~entrainment_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces kochergin1987_entrainment Derived Types kochergin1987_entrainment Functions constructor kochergin1987_rate Interfaces public interface kochergin1987_entrainment private pure function constructor (coefficient, delta) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coefficient The entrainment coefficient c_L&#94;2x_0/D_0 real(kind=r8), intent(in) :: delta The ratio D_0/h_0 Return Value type( kochergin1987_entrainment ) A new entrainment object Derived Types type, public, extends( abstract_entrainment ) :: kochergin1987_entrainment A parameterisation of entrainment ( e ) as described by\n Kochergin (1987): e =\n \\frac{c_L&#94;2}{S_m}\\sqrt{|\\vec{U}|&#94;2+\\frac{g'D}{S_m}}. Here, c_L is an entrainment coefficient, \\vec{U} is the\n velocity of the plume, g' is the reduced gravity, and S_m is the turbulent Schmidt number. The latter-most can be\n expressed as S_m = \\frac{Ri}{0.0725(Ri + 0.186 -\n \\sqrt{Ri&#94;2 - 0.316Ri + 0.0346})} , where Ri =\n g'D/|\\vec{U}|&#94;2 is the Richardson number. Components Type Visibility Attributes Name Initial real(kind=r8), private :: coefficient = 1.0_r8 The entrainment coefficient c_L&#94;2x_0/D_0 real(kind=r8), private :: delta = 0.036_r8 The ratio D_0/h_0 Constructor private pure function constructor (coefficient, delta) Type-Bound Procedures procedure, public :: entrainment_rate => kochergin1987_rate Returns the entrainment rate for ambient water into the plume. Functions private pure function constructor (coefficient, delta) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coefficient The entrainment coefficient c_L&#94;2x_0/D_0 real(kind=r8), intent(in) :: delta The ratio D_0/h_0 Return Value type( kochergin1987_entrainment ) A new entrainment object private function kochergin1987_rate (this, velocity, thickness, depth, density_diff, time) result(entrainment) Author Christopher MacMackin Date Feburary 2018 e = \\frac{c_L&#94;2}{S_m}\\sqrt{|\\vec{U}|&#94;2+\\frac{g'D}{S_m}}. Here, c_L is an entrainment coefficient, \\vec{U} is the\n velocity of the plume, g' is the reduced gravity, and S_m is the turbulent Schmidt number. The Schmidt number is a\n function of the Richardson number Ri = g'D/|\\vec{U}|&#94;2 : S_m = \\frac{Ri}{0.0725(Ri + 0.186 -\n \\sqrt{Ri&#94;2 - 0.316Ri + 0.0346})}. Arguments Type Intent Optional Attributes Name class( kochergin1987_entrainment ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is being \n entrained. class(scalar_field), intent(in) :: thickness The thickness of the plume into which fluid is being\n entrained class(scalar_field), intent(in) :: depth The depth of the upper surface of the plume into which\n fluid is being entrained class(scalar_field), intent(in) :: density_diff The difference between the ambient density and the density of\n the plume into which the ambient fluid is being entrained. real(kind=r8), intent(in), optional :: time The time at which the entrainment is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the entrainment"},{"title":"jenkins1991_entrainment_mod – ISOFT","tags":"","loc":"module/jenkins1991_entrainment_mod.html","text":"Provides a concrete implementation of abstract_entrainment in the form of the parameterisation used by Jenkins (1991). Uses iso_fortran_env factual_mod entrainment_mod module~~jenkins1991_entrainment_mod~~UsesGraph module~jenkins1991_entrainment_mod jenkins1991_entrainment_mod factual_mod factual_mod module~jenkins1991_entrainment_mod->factual_mod iso_fortran_env iso_fortran_env module~jenkins1991_entrainment_mod->iso_fortran_env module~entrainment_mod entrainment_mod module~jenkins1991_entrainment_mod->module~entrainment_mod module~entrainment_mod->factual_mod module~entrainment_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~jenkins1991_entrainment_mod~~UsedByGraph module~jenkins1991_entrainment_mod jenkins1991_entrainment_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~jenkins1991_entrainment_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~jenkins1991_entrainment_mod module~plume_mod plume_mod module~plume_mod->module~jenkins1991_entrainment_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces jenkins1991_entrainment Derived Types jenkins1991_entrainment Functions constructor jenkins1991_rate Interfaces public interface jenkins1991_entrainment private pure function constructor (coefficient) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coefficient The entrainment coefficient, $E_0$ to be used Return Value type( jenkins1991_entrainment ) A new entrainment object Derived Types type, public, extends( abstract_entrainment ) :: jenkins1991_entrainment A parameterisation of entrainment ( e ) as described by Jenkins\n (1991): e = E_0 |\\vec{U}\\sin(\\theta) \\simeq\n E_0|\\vec{U}||\\nabla b|. Here, E_0 is a coefficient typically\n taken to be 0.036 (the default value), \\vec{U} is the velocity\n of the plume, \\theta is the angle of slope of the ice shelf\n base, and b is the basal depth of the ice shelf. Components Type Visibility Attributes Name Initial real(kind=r8), private :: coefficient = 1.0_r8 The entrainment coefficient $E_0$ Constructor private pure function constructor (coefficient) Type-Bound Procedures procedure, public :: entrainment_rate => jenkins1991_rate Returns the entrainment rate for ambient water into the plume. Functions private pure function constructor (coefficient) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coefficient The entrainment coefficient, $E_0$ to be used Return Value type( jenkins1991_entrainment ) A new entrainment object private function jenkins1991_rate (this, velocity, thickness, depth, density_diff, time) result(entrainment) Author Christopher MacMackin Date October 2016 e = E_0 |\\vec{U}\\sin(\\theta) \\simeq E_0|\\vec{U}||\\nabla b| Here, E_0 is a coefficient typically taken to be 0.036 (the\n default value), \\vec{U} is the velocity of the plume, \\theta is the angle of slope of the ice shelf base, and b is the\n basal depth of the ice shelf. Read more… Arguments Type Intent Optional Attributes Name class( jenkins1991_entrainment ), intent(in) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is being \n entrained. class(scalar_field), intent(in) :: thickness The thickness of the plume into which fluid is being\n entrained class(scalar_field), intent(in) :: depth The depth of the upper surface of the plume into which\n fluid is being entrained class(scalar_field), intent(in) :: density_diff The difference between the ambient density and the density of\n the plume into which the ambient fluid is being entrained. real(kind=r8), intent(in), optional :: time The time at which the entrainment is being calculated. If not\n present then assumed to be same as previous value passed. Return Value class(scalar_field),\n  pointer The value of the entrainment"},{"title":"dallaston2015_melt_mod – ISOFT","tags":"","loc":"module/dallaston2015_melt_mod.html","text":"Provides an implementation of abstract_melt_relationship which\n mimics the simple model used by Dallaston, Hewitt, and Wells\n (2015) for an ice shelf melting into a vertically integrated\n plume. Uses iso_fortran_env factual_mod melt_relationship_mod module~~dallaston2015_melt_mod~~UsesGraph module~dallaston2015_melt_mod dallaston2015_melt_mod factual_mod factual_mod module~dallaston2015_melt_mod->factual_mod iso_fortran_env iso_fortran_env module~dallaston2015_melt_mod->iso_fortran_env module~melt_relationship_mod melt_relationship_mod module~dallaston2015_melt_mod->module~melt_relationship_mod module~melt_relationship_mod->factual_mod module~melt_relationship_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~dallaston2015_melt_mod~~UsedByGraph module~dallaston2015_melt_mod dallaston2015_melt_mod module~asymmetric_plume_mod asymmetric_plume_mod module~asymmetric_plume_mod->module~dallaston2015_melt_mod module~static_plume_mod static_plume_mod module~static_plume_mod->module~dallaston2015_melt_mod module~plume_mod plume_mod module~plume_mod->module~dallaston2015_melt_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces dallaston2015_melt Derived Types dallaston2015_melt Functions constructor dallaston2015_heat dallaston2015_salt dallaston2015_melt_rate dallaston2015_has_heat dallaston2015_has_salt Subroutines dallaston2015_solve Interfaces public interface dallaston2015_melt private pure function constructor (beta, melt_conversion, salinity_denom) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: beta The inverse stefan number, \\frac{c(T_a - T_m)}{L} real(kind=r8), intent(in) :: melt_conversion The factor to convert between the scale for melt used by\n Dallaston et al. (2015) and that used in ISOFT, \\frac{m_0x_0}{D_0U_0}, where m_0 is the melt scale\n used by Dalalston et al. real(kind=r8), intent(in), optional :: salinity_denom The factor which, when used to divide the melt_conversion term, produces a conversion factor for the melt-terms in the\n salinity equation of Dallaston et al. (2015). It has the form \\frac{Q_{g0}}{D_0U_0}, where Q_{g0} is the\n subglacial discharge across the grounding line. Return Value type( dallaston2015_melt ) The newly created object representing the melt relationship. Derived Types type, public, extends( abstract_melt_relationship ) :: dallaston2015_melt A parameterisation of melting into a plume which comes from\n heavily simplifying the 3 equation model. It is taken from\n Dallaston, Hewitt, and Wells (2015). The melt rate, as well as\n effect on termperature and salinity, are calculated by calling solve_for_melt and then accessed\n using melt_rate , heat_equation_terms , salt_equation_terms . Components Type Visibility Attributes Name Initial class(scalar_field), public, allocatable :: melt_values Stores the resulting melt rate real(kind=r8), public :: coef = 1449.29936 The coefficient by which the melt rate is multiplied in order\n to determine the contribution to the heat equation. real(kind=r8), public :: melt_conversion = 6.9e-4_r8 The factor to convert between the scale for melt used by\n Dallaston et al. (2015) and that used in ISOFT, \\frac{m_0x_0}{D_0U_0}, where m_0 is the melt scale\n used by Dalalston et al. real(kind=r8), public :: salinity_denom = 1e100_r8 Constructor private pure function constructor (beta, melt_conversion, salinity_denom) Type-Bound Procedures procedure, public :: solve_for_melt => dallaston2015_solve procedure, public :: heat_equation_terms => dallaston2015_heat Returns the terms this melt formulation contributes to the\n heat equation, after they have been solved for using solve_for_melt . procedure, public :: salt_equation_terms => dallaston2015_salt Returns the terms this melt formulation contributes to the\n salt equation, after they have been solved for using solve_for_melt . procedure, public :: melt_rate => dallaston2015_melt_rate Returns the melt rate calculated using this formulation,\n after it has been solved for using solve_for_melt . procedure, public :: has_heat_terms => dallaston2015_has_heat Whether this formulation of melting contributes any terms to\n a plume's heat equation. procedure, public :: has_salt_terms => dallaston2015_has_salt Whether this formulation of melting contributes any terms to\n a plume's salinity equation. Functions private pure function constructor (beta, melt_conversion, salinity_denom) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: beta The inverse stefan number, \\frac{c(T_a - T_m)}{L} real(kind=r8), intent(in) :: melt_conversion The factor to convert between the scale for melt used by\n Dallaston et al. (2015) and that used in ISOFT, \\frac{m_0x_0}{D_0U_0}, where m_0 is the melt scale\n used by Dalalston et al. real(kind=r8), intent(in), optional :: salinity_denom The factor which, when used to divide the melt_conversion term, produces a conversion factor for the melt-terms in the\n salinity equation of Dallaston et al. (2015). It has the form \\frac{Q_{g0}}{D_0U_0}, where Q_{g0} is the\n subglacial discharge across the grounding line. Return Value type( dallaston2015_melt ) The newly created object representing the melt relationship. private function dallaston2015_heat (this) result(heat) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the heat equation for a plume private function dallaston2015_salt (this) result(salt) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the salt equation for a plume private function dallaston2015_melt_rate (this) result(melt) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate from the ice into the plume water. private pure function dallaston2015_has_heat (this) result(has_heat) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat equation of the plume. private pure function dallaston2015_has_salt (this) result(has_salt) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the salinity equation of the plume. Subroutines private subroutine dallaston2015_solve (this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( dallaston2015_melt ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed."},{"title":"one_equation_melt_mod – ISOFT","tags":"","loc":"module/one_equation_melt_mod.html","text":"Provides an implementation of melt similar to that used by\n Dallaston, Hewitt, and Wells (2015), prior to their neglecting\n certain terms on scaling arguments. Uses iso_fortran_env factual_mod melt_relationship_mod module~~one_equation_melt_mod~~UsesGraph module~one_equation_melt_mod one_equation_melt_mod factual_mod factual_mod module~one_equation_melt_mod->factual_mod iso_fortran_env iso_fortran_env module~one_equation_melt_mod->iso_fortran_env module~melt_relationship_mod melt_relationship_mod module~one_equation_melt_mod->module~melt_relationship_mod module~melt_relationship_mod->factual_mod module~melt_relationship_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces one_equation_melt Derived Types one_equation_melt Functions constructor one_equation_heat one_equation_salt one_equation_melt_rate one_equation_has_heat one_equation_has_salt Subroutines one_equation_solve Interfaces public interface one_equation_melt private pure function constructor (coef1, coef2, fresh_sal, melt_temp) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coef1 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), intent(in) :: coef2 The unitless multiplier applied to the theram forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), intent(in), optional :: fresh_sal The salinity of fresh water. Defaults to 0. real(kind=r8), intent(in), optional :: melt_temp The melting point of the ice. Defaults to 0. Return Value type( one_equation_melt ) The newly created object representing the melt relationship. Derived Types type, public, extends( abstract_melt_relationship ) :: one_equation_melt A parameterisation of melting into a plume which comes from\n heavily simplifying the 3 equation model. It is taken from\n Dallaston, Hewitt, and Wells (2015), prior to the their dropping\n some terms based on scaling arguments. The melt rate, as well as\n effect on termperature and salinity, are calculated by calling solve_for_melt and then accessed\n using melt_rate , heat_equation_terms , salt_equation_terms . Components Type Visibility Attributes Name Initial class(scalar_field), public, allocatable :: forcing_values Stores the resulting forcing values. real(kind=r8), public :: coef1 = 0.018208_r8 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), public :: coef2 = 0.023761_r8 The unitless multiplier applied to the thermal forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), public :: sal_forcing = 0._r8 The unitless multiplier applied to the forcing values to get\n the salinity forcing. It corresponds to the product of coef2 and the ice salinity. Typically this would be zero,\n but it might be positive if there is some marine ice\n present. Alternatively, depending on how the salinity has\n been scaled, it may have a negative value. real(kind=r8), public :: melt_temp = 0._r8 The melting temperature. While intuitively it makes sense to\n set this to zero, it can be useful to scale temperature in\n such a way that it will have a negative value. Constructor private pure function constructor (coef1, coef2, fresh_sal, melt_temp) Type-Bound Procedures procedure, public :: solve_for_melt => one_equation_solve procedure, public :: heat_equation_terms => one_equation_heat Returns the terms this melt formulation contributes to the\n heat equation, after they have been solved for using solve_for_melt . procedure, public :: salt_equation_terms => one_equation_salt Returns the terms this melt formulation contributes to the\n salt equation, after they have been solved for using solve_for_melt . procedure, public :: melt_rate => one_equation_melt_rate Returns the melt rate calculated using this formulation,\n after it has been solved for using solve_for_melt . procedure, public :: has_heat_terms => one_equation_has_heat Whether this formulation of melting contributes any terms to\n a plume's heat equation. procedure, public :: has_salt_terms => one_equation_has_salt Whether this formulation of melting contributes any terms to\n a plume's salinity equation. Functions private pure function constructor (coef1, coef2, fresh_sal, melt_temp) result(this) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in) :: coef1 The unitless multiplier on the thermal forcing term, \\Gamma_Tx_0/D_0 . real(kind=r8), intent(in) :: coef2 The unitless multiplier applied to the theram forcing term to\n get the melt rate, c_oT_0/L . real(kind=r8), intent(in), optional :: fresh_sal The salinity of fresh water. Defaults to 0. real(kind=r8), intent(in), optional :: melt_temp The melting point of the ice. Defaults to 0. Return Value type( one_equation_melt ) The newly created object representing the melt relationship. private function one_equation_heat (this) result(heat) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the heat equation for a plume private function one_equation_salt (this) result(salt) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The value of the contribution made by melting/thermal\n transfer to the salt equation for a plume private function one_equation_melt_rate (this) result(melt) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value class(scalar_field),\n  pointer The melt rate from the ice into the plume water. private pure function one_equation_has_heat (this) result(has_heat) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the heat equation of the plume. private pure function one_equation_has_salt (this) result(has_salt) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(in) :: this Return Value logical Whether this formulation of melting contributes terms to\n the salinity equation of the plume. Subroutines private subroutine one_equation_solve (this, velocity, pressure, temperature, salinity, plume_thickness, time) Arguments Type Intent Optional Attributes Name class( one_equation_melt ), intent(inout) :: this class(vector_field), intent(in) :: velocity The velocity field of the plume into which fluid is melting. class(scalar_field), intent(in) :: pressure The water pressure at the interface where the melting occurs. class(scalar_field), intent(in) :: temperature The temperature of the plume into which fluid is melting. class(scalar_field), intent(in) :: salinity The salinity of the plume into which fluid is melting. class(scalar_field), intent(in) :: plume_thickness The thickness of the plume into which fluid is melting. real(kind=r8), intent(in), optional :: time The time at which the melting is being solved for. If not\n present then assumed to be same as previous value passed."},{"title":"meta_implementation_mod – ISOFT","tags":"","loc":"module/meta_implementation_mod.html","text":"Implements functions specifying the version of ISOFT, time of\n compilation, etc. This is done in a submodule because it should be\n recompiled with every build (so that compilation time is accurate)\n but without a submodule that would require every module using it\n to be recompiled as well. Uses Ancestors: meta_mod module~~meta_implementation_mod~~UsesGraph module~meta_implementation_mod meta_implementation_mod module~meta_mod meta_mod module~meta_implementation_mod->module~meta_mod iso_fortran_env iso_fortran_env module~meta_mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables compile_time_val version_num Module Functions version compile_time compile_info Variables Type Visibility Attributes Name Initial character(len=20), private, parameter :: compile_time_val = \"Dec 11 2018\"//' '//\"16:39:58\" character(len=5), private, parameter :: version_num = '1.0.0' Module Functions module function version () Interface → Arguments None Return Value real module function compile_time () Interface → Arguments None Return Value real module function compile_info () Interface → Arguments None Return Value real"},{"title":"Documentation – ISOFT","tags":"","loc":"page//index.html","text":"ISOFT: Ice Shelf/Ocean Fluid and Thermodynamics ISOFT is a piece of software/suite of tools which I developed while\nworking on my PhD thesis to simulate the evolution of ice shelves\ncoupled to ocean plumes. It attempts to provide an object oriented,\nextensible framework with which to model glacial flow using modern\nFortran. Though developed for ice shelves, it could in principle be\nmodified to simulated grounded ice dynamics as well. I've published\nthe code and documentation to GitHub in the hopes that it might be\nuseful to others. As much as practical, ISOFT was kept agnostic as to whether it was\nhandling a 1-D or a 2-D representation of an ice shelf/plume. However,\nthe current implementation does explicitly assume a 1-D system in a\nnumber of instances and would thus need to be modified to handle 2-D\nproblems.  1-D simulations were sufficiently fast that they could be\nrun in serial. Multithreading could easily be implemented in many\nparts of the code where arithmetic is performed on arrays. Indeed,\nmost of these cases are simple enough that a compiler may be able to\nparallelise them automatically. More sophisticated approaches\ninvolving message passing would likely be necessary to make 2-D\nsimulations practical, but this would be far more difficult to\nimplement and would likely require substantial refactoring of the\ncode. In particular, the nonlinear solvers would likely need to be\nreplaced. Quick Start The build-script for FORD assumes you have the libraries and header\nfiles for FFTW3 , HDF5 , an implementation of BLAS , and LAPACK installed on your computer. It\nalso requires you to have the virtualenv installed. ISOFT\nis known to compile with gfortran v6.2 and, barring regressions,\nshould work with all subsequent releases.  There are a number of\nother, more obscure libraries upon which ISOFT depends, but the\nMakefile handles the downloading and building of these itself. You can\nbuild ISOFT on an Ubuntu-like operating system using the commands\nbelow: sudo apt-get install libfftw3-dev libhdf5-dev libopenblas-dev liblapack-dev python-virtualenv gfortran-6\ngit clone --recurse-submodules https://github.com/cmacmackin/isoft\ncd isoft\nmake lib            # Builds libisoft.a\nmake tests          # Builds and runs unit tests\nmake script         # Creates a compile-script you can use to build and\n                    # link your own programs with the ISOFT library This builds a static library which provides derived types for\nsimulating the evolution of an ice shelf. You initialise these objects\nin your own programs and then call their methods to start the\nsimulation. An example of such a program can be found in the sample\nfile main.f90 . This can be built and run as follows: compile.sh main.f90 isoft_example\n./isoft_example The compile.sh script was generated specifically for your build of\nISOFT and can be used, without modification from any directory on your\ncomputer. It's call signature is ./compile.sh [ main-file-name [ executable-name ] ] where main-file-name is the program file to be compiled and executable-name is the name to give the resulting executable. These\ndefault to main.f90 and isoft , respectively. Documentation Information on how to install and use ISOFT is available on GitHub Pages . This includes\nsections (taken from my thesis) on the numerical methods and code\ndesign choices which were made. A detailed description of the API\nis also provided. This documentation can be generated locally using the FORD tool .  To\ninstall FORD in a virtual environment and then run it to generate the\ndocumentation, execute make doc If FORD is already present on your system then you can simply run ford doc.md License ISOFT is licensed under the GNU General Public License (GPL) v3.0 or\nlater. The terms are provided in the file LICENSE . The Lesser General\nPublic License (LGPL) would have been used, but the Chebyshev pseudo-spectral\nimplementation uses the FFTW3 library, which is licensed under the GPL."},{"title":"Using ISOFT – ISOFT","tags":"","loc":"page/1-running/index.html","text":"ISOFT isn't so much a program or library in the traditional sense, as\na suite of tools for simulating the evolution of an ice shelf. It\nprovides: a library of derived types to run these simulations a sample program making use of this library a compile script to link your programs with the necessary libraries a set of python scripts for plotting the output of simulations This section will walk you through compiling the library and programs\nwhich use it. The plotting scripts are discussed in the section Plotting ISOFT Output ."},{"title":"Compiling the Code – ISOFT","tags":"","loc":"page/1-running/1-build.html","text":"The easiest way to obtain ISOFT is by downloading it from GitHub: make clone --recurse-submodules https://github.com/cmacmackin/isoft This will download all libraries included in ISOFT as submodules\n(listed below). Dependencies ISOFT depends on a number of external pieces of software. Mostly these\nare libraries which it uses, although there are also a few programs\nwhich are used at build-time. Except for the compiler, the latter are\nall Python-based and the Makefile will automatically install them in a\nvirtual environment. Of the libraries, those which are widely used\nmust be installed on your system prior to building ISOFT. The\nremainder are distributed with ISOFT and will automatically be\ncompiled as part of the build process.  Builds have been tested with\nthe gfortran compiler and are known to work with v6.2. In principle,\nsubsequent releases of gfortran should also work, barring any\nregressions. The following libraries and programs must be installed on your operating system\nprior to starting the build process. The corresponding package name in\nUbuntu is given in parentheses. FFTW3 (libfftw3-dev) HDF5 (libhdf5-dev) An implementation of BLAS (e.g., libopenblas-dev) LAPACK (liblapack-dev) virtualenv (python-virtualenv) gfortran (gfortran-6) The following programs are required during the build process. They\nwill be installed in a virtual environment called buildtools in the\ntop of the ISOFT directory. fypp , a preprocessor for Fortran FoBiS.py , a simple build system for Fortran FORD , a documentation tool for Fortran The following libraries were downloaded with ISOFT as submodules and\nwill automatically be compiled as part of the build process: FACE factual flogging lapack95 nitsol PENF pFUnit The Makefile A Makefile is provided which can handle the build process on Unix-like\noperating systems in most cases. It features the following build\ntargets: all : alias for lib (default) all_objects : rebuilds all object files for the library clean : deletes object files, module files, dependency files, and Emacs backup files doc : generates HTML documentation for ISOFT script : writes a script for compiling and linking programs which use the ISOFT library tests : builds and runs the unit tests lib : builds the static library of ISOFT routines and derived types At the top of the Makefile are two definitions used for finding\nlibraries installed on your system. These are SYSTEM_LIB := /usr/lib # Paths containing external libraries SYSTEM_INC := /usr/include # Paths containing module/include files # for external libraries These defaults should work on Ubuntu-like operating systems. \nThey may be overridden if necessary. Multiple paths may also be\nprovided, separated by white-space. Building After having amended the Makefile as described above, building ISOFT\nshould be straightforward. Simply run make lib to compile the necessary dependencies and create the libisoft.a file.\nThen run make script to generate a script which can compile and link programs using ISOFT. Unit Tests An extensive set of unit tests has been written, using the pFUnit framework. These ensure that\nmethods behave as expected and, where possible, test that simulations\nconverge to analytically-predicted solutions. These tests can be built\nand run with the command make tests"},{"title":"Writing Software Using the ISOFT Framework – ISOFT","tags":"","loc":"page/1-running/2-writing.html","text":"The Basics Before proceeding with using ISOFT, you need to initialise the logging\ntool which it uses, provided by flogging . This allows you to\nspecify what level of information to output to the terminal and the\nlog file. This is done as follows: use logger_mod , only : error , info , logger => master_logger , logger_init ! ... call logger_init ( 'isoft.log' , error , info , info ) logger % trivia ( 'isoft' , 'Logger initialised successfully.' ) logger % info ( 'isoft' , 'Welcome to ISOFT.' ) The first line in this code fragment imports the module providing the logger object. The parameters error and info specify different priorities\nof messages which can be sent to the logger. The master_logger is a\nglobal logging object which is used within the ISOFT library. It is\ninitialised using the logger_init routine, which specifies the name of the log file and what priorities\nof messages get printed to the terminal and the log file. Methods of the logger object can be used to write out messages of different priority\nlevels: \"debug\", \"trivia\", \"info\", \"warning\", \"error\", and \"fatal\". It is also necessary to initialise the HDF5 library, in order to allow I/O\nto be performed. This is done by running use hdf5 ! ... integer :: hdf_err ! ... call h5open_f ( hdf_err ) if ( hdf_err < 0 ) error stop Similarly, at the end of your simulation you should deactivate HDF5 by\nrunning call h5close_f ( hdf_err ) if ( hdf_err < 0 ) error stop To run simulations with ISOFT, you must first build a cryosphere object using the initialise method. This takes, as arguments, allocatable polymorphic objects of class glacier and basal_surface . These objects must be\ninitialised with concrete types such as ice_shelf and plume (likely to be the most frequently used implementations). glacier and basal_surface objects will typically\nfeature initialise methods. However, such methods are unique to each\nsub-type. Thus, the concrete type of the glacier or basal_surface objects must be known when they are being\ninitialised The simplest way to do this is to work with allocatable\nvariables with those concrete types and then use the intrinsic move_alloc routine to transfer the object a polymorphic variable: type ( ice_shelf ), allocatable :: shelf_obj class ( glacier ), allocatable :: glacier_obj allocate ( shelf_obj ) call shelf_obj % initialise (...) call move_alloc ( shelf_obj , glacier_obj ) The initialisation methods allow you to choose various parameter\nvalues, specify initial conditions, set boundary conditions, and\nselect which parameterisations to use in the simulation. A number of\nadditional objects must be created to accomplish the latter two. As\nbefore, the arguments must be allocatable objects of polymorphic\ntype. However, classes representing boundary conditions and\nparameterisations have constructor functions, meaning that it is not\nnecessary to use the move_alloc intrinsic. Instead, these objects\ncan be initialised as below: type ( abstract_viscosity ), allocatable :: viscosity allocate ( viscosity , source = newtonian_viscosity ( 1.0d0 )) which creates an abstract_viscosity object using the newtonian_viscosity constructor. A full description of all the derived types which can be used to\nconstruct a cryosphere object is beyond the scope of this\nsection. An overview can be found in the discussion of the code design and by consulting the API documentation . After creating a cryosphere object, you can optionally\ninitialise it using the output from a previous simulation. This is\ndone with the read_data method. The simulation is\nrun by integrating forward in time using the integrate method. At any point during the\nsimulation, the state of the cryosphere can be written to the disk as\nan HDF5 file using the write_data method. This\noutput can be used to initialise future simulations or be analysed\nusing the provided set of plotting scripts . An Example Below is an example of a simple ISOFT simulation, designed to run to a\nsteady state. It is provided as main.f90 in the top directory of ISOFT. ! !  main.f90 !  This file is part of ISOFT. ! !  Copyright 2018 Chris MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 3 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! program isoft !* Author: Chris MacMackin !  Date: April 2017 !  License: GPLv3 ! ! This is the driver program for ISOFT. ! use iso_fortran_env , only : r8 => real64 use logger_mod , only : trivia , info , error , logger => master_logger , logger_init use hdf5 use penf , only : str use meta_mod use cryosphere_mod , only : cryosphere use glacier_mod , only : glacier use ice_shelf_mod , only : ice_shelf use viscosity_mod , only : abstract_viscosity use newtonian_viscosity_mod , only : newtonian_viscosity use glacier_boundary_mod , only : glacier_boundary use dallaston2015_glacier_boundary_mod , only : dallaston2015_glacier_boundary use basal_surface_mod , only : basal_surface use plume_mod , only : plume use entrainment_mod , only : abstract_entrainment use jenkins1991_entrainment_mod , only : jenkins1991_entrainment use melt_relationship_mod , only : abstract_melt_relationship use one_equation_melt_mod , only : one_equation_melt use ambient_mod , only : ambient_conditions use uniform_ambient_mod , only : uniform_ambient_conditions use equation_of_state_mod , only : equation_of_state use linear_eos_mod , only : linear_eos use plume_boundary_mod , only : plume_boundary use upstream_plume_mod , only : upstream_plume_boundary use specfun_mod , only : ei implicit none ! Simulation parameters integer :: grid_points real ( r8 ), dimension ( 2 , 2 ) :: domain real ( r8 ) :: end_time character ( len = :), allocatable :: restart_file logical :: restart_from_file , restart_at_0 ! Output parameters real ( r8 ) :: output_interval character ( len = :), allocatable :: hdf_base_name , logfile integer :: stdout_lim , stderr_lim , logfile_lim , output_start ! Ice shelf parameters real ( r8 ) :: chi , lambda , zeta , ice_temperature , courant , max_dt ! Viscosity parameters real ( r8 ) :: visc_coefficient ! Ice shelf boundary parameters real ( r8 ) :: ice_thickness_lower real ( r8 ), dimension ( 2 ) :: ice_velocity_lower ! Entrainment parameters real ( r8 ) :: ent_coefficient ! Plume parameters real ( r8 ) :: delta , nu , mu , r_val ! Melt parameters real ( r8 ) :: alpha1 , alpha2 ! Ambient condition parameters real ( r8 ) :: ambient_salinity , ambient_temperature real ( r8 ) :: fresh_sal , melt_temp ! Equation of state parameters real ( r8 ) :: ref_density , ref_temperature , ref_salinity , & beta_s , beta_t ! Plume boundary parameters real ( r8 ) :: discharge , offset real ( r8 ) :: plume_thickness_lower , plume_temperature_lower , & plume_salinity_lower real ( r8 ), dimension ( 2 ) :: plume_velocity_lower ! Variables for use in the program integer :: i , hdf_err real ( r8 ) :: time real :: cpu_start , cpu_setup , cpu_end character ( len = 18 ), parameter :: hdf_file_format = '(a,\"-\",i0.4,\".h5\")' character ( len = 50 ) :: hdf_filename type ( cryosphere ) :: system !! The ice-ocean system which is being simulated class ( glacier ), allocatable :: ice type ( ice_shelf ), allocatable :: shelf class ( abstract_viscosity ), allocatable :: viscosity class ( glacier_boundary ), allocatable :: ice_bound class ( basal_surface ), allocatable :: sub_ice type ( plume ), allocatable :: water class ( abstract_entrainment ), allocatable :: entrainment class ( abstract_melt_relationship ), allocatable :: melt_relationship class ( equation_of_state ), allocatable :: eos class ( ambient_conditions ), allocatable :: ambient class ( plume_boundary ), allocatable :: water_bound logical :: success call cpu_time ( cpu_start ) ! Initialise variables to defaults grid_points = 100 domain ( 1 ,:) = [ 0._r8 , 6._r8 ] domain ( 2 ,:) = [ - 1._r8 , 1._r8 ] end_time = 1 0.0_r8 restart_file = \"steady-nodrag.h5\" restart_from_file = . false . restart_at_0 = . true . output_interval = 0.05_r8 hdf_base_name = \"isoft\" logfile = \"isoft.log\" stdout_lim = info stderr_lim = error logfile_lim = trivia output_start = 0 chi = 4._r8 lambda = 1.e2_r8 ice_temperature = - 7._r8 courant = 1._r8 max_dt = 1.e-3_r8 visc_coefficient = 1._r8 ice_thickness_lower = 1._r8 ice_velocity_lower = [ 1._r8 , 0._r8 ] ent_coefficient = 1._r8 delta = 3.6e-2_r8 nu = 3.69e-2_r8 mu = 0.799_r8 r_val = 1.12_r8 alpha1 = 0.0182_r8 alpha2 = 4.86e-4_r8 ambient_salinity = 0._r8 ambient_temperature = 0._r8 fresh_sal = - 203 5.3_r8 melt_temp = - 5 4.92_r8 ref_density = 3.05e5_r8 ref_temperature = 0._r8 ref_salinity = 0._r8 beta_s = 1.336e-5_r8 beta_t = 1.409e-6_r8 discharge = 1.e-3_r8 offset = 3.e-4_r8 plume_thickness_lower = 0.048361028 plume_temperature_lower = - 1.772_r8 plume_salinity_lower = - 2 8.1123_r8 plume_velocity_lower = [ 1.6266415_r8 , 0._r8 ] ! Set up IO call logger_init ( logfile , stderr_lim , stdout_lim , logfile_lim ) call h5open_f ( hdf_err ) if ( hdf_err < 0 ) error stop ! Print welcome message call logger % info ( 'isoft' , 'Welcome to ISOFT: Ice Shelf/Ocean ' // & 'Fluid- and Thermodynamics' ) call logger % info ( 'isoft' , 'ISOFT v' // version () // ', compiled on ' // & compile_time ()) call logger % trivia ( 'isoft' , trim ( compile_info ())) ! Initialise ice shelf allocate ( viscosity , source = newtonian_viscosity ( visc_coefficient )) allocate ( ice_bound , & source = dallaston2015_glacier_boundary ( ice_thickness_lower , & ice_velocity_lower ( 1 ), chi )) allocate ( shelf ) call shelf % initialise ( domain , [ grid_points ], h , u_ice , ice_temperature , & viscosity , ice_bound , lambda , chi , zeta , courant , & max_dt ) ! Initialise plume allocate ( entrainment , source = jenkins1991_entrainment ( ent_coefficient )) allocate ( melt_relationship , source = one_equation_melt ( alpha1 , alpha2 , & fresh_sal , melt_temp )) allocate ( ambient , & source = uniform_ambient_conditions ( ambient_temperature , & ambient_salinity )) allocate ( eos , & source = linear_eos ( ref_density , ref_temperature , ref_salinity , & beta_t , beta_s )) allocate ( water_bound , & source = upstream_plume_boundary ( bound_vals , & 0.05_r8 , [ 1._r8 , 1._r8 , 1._r8 , 1._r8 ])) allocate ( water ) call water % initialise ( domain , [ grid_points ], D , U_plume , T , S , & entrainment , melt_relationship , ambient , eos , & water_bound , delta , nu , mu , r_val ) if (. not . restart_from_file ) then call water % solve ( shelf % ice_thickness (), shelf % ice_density (), & shelf % ice_temperature (), time , success ) end if ! Initialise cryosphere call move_alloc ( shelf , ice ) call move_alloc ( water , sub_ice ) call system % initialise ( ice , sub_ice ) if ( restart_from_file ) then call system % read_data ( restart_file , . not . restart_at_0 ) end if call cpu_time ( cpu_setup ) call logger % info ( 'isoft' , 'Finished setting up simulation. Took ' // & trim ( str ( cpu_setup - cpu_start )) // 's.' ) ! Run simulation i = output_start time = system % get_time () do while ( end_time - time > courant * 1.e-5_r8 / grid_points ) write ( hdf_filename , hdf_file_format ) hdf_base_name , i time = min ( time + output_interval , end_time ) call system % write_data ( trim ( hdf_filename )) call system % integrate ( time ) i = i + 1 end do ! Clean up call logger % info ( 'isoft' , 'Successfully simulated ice shelf ' // & 'evolution to time ' // trim ( str ( time ))) write ( hdf_filename , hdf_file_format ) hdf_base_name , i call system % write_data ( trim ( hdf_filename )) call h5close_f ( hdf_err ) if ( hdf_err < 0 ) error stop call logger % info ( 'isoft' , 'Wrote final ice shelf state to file ' // & trim ( hdf_filename )) ! Print goodbye message call cpu_time ( cpu_end ) call logger % info ( 'isoft' , 'Finished running isoft. This took ' // & trim ( str ( cpu_end - cpu_start )) // 's, of which ' // & trim ( str ( cpu_end - cpu_setup )) // 's were ' // & 'needed to run the simulation.' ) contains pure function h ( x ) !! Initial ice thickness. real ( r8 ), dimension (:), intent ( in ) :: x real ( r8 ) :: h real ( r8 ), parameter :: big_x = 7._r8 h = ice_thickness_lower * (( 1._r8 - x ( 1 ) / big_x ) / sqrt ( 1._r8 + big_x - & big_x * ( 1._r8 - x ( 1 ) / big_x ) ** 2 )) end function h pure function u_ice ( x ) !! Initial ice velocity real ( r8 ), dimension (:), intent ( in ) :: x real ( r8 ), dimension (:), allocatable :: u_ice real ( r8 ) :: big_x big_x = 1._r8 / lambda allocate ( u_ice ( 1 )) u_ice ( 1 ) = ice_velocity_lower ( 1 ) + 0.25_r8 * ice_thickness_lower * chi * ( x ( 1 ) & - x ( 1 ) ** 2 / ( 2.2 * domain ( 1 , 2 ))) end function u_ice pure function D ( x ) !! Initial guess for plume thickness real ( r8 ), dimension (:), intent ( in ) :: x real ( r8 ) :: D D = plume_thickness_lower + ( h ([ 0._r8 ]) - h ( x )) / r_val end function D pure function U_plume ( x ) !! Initial guess for plume velocity real ( r8 ), dimension (:), intent ( in ) :: x real ( r8 ), dimension (:), allocatable :: U_plume allocate ( U_plume ( 1 )) U_plume = plume_velocity_lower ( 1 ) end function U_plume pure function S ( x ) !! Initial guess of the plume salinity real ( r8 ), dimension (:), intent ( in ) :: x real ( r8 ) :: S S = plume_salinity_lower * D ([ 0._r8 ]) / D ( x ) - 0.1 * x ( 1 ) end function S pure function T ( x ) !! Initial guess of the plume temperature real ( r8 ), dimension (:), intent ( in ) :: x real ( r8 ) :: T T = plume_temperature_lower * D ([ 0._r8 ]) / D ( x ) + 0.1 * x ( 1 ) end function T pure subroutine bound_vals ( time , D , U , T , S ) !! Calculates the inflow properties for the plume. In this routine !! they are non-oscillating. real ( r8 ), intent ( in ) :: time !! The time at which the boundary values are being calculated real ( r8 ), intent ( out ) :: D !! Plume thickness boundary condition real ( r8 ), dimension (:), allocatable , intent ( out ) :: U !! Plume velocity boundary condition real ( r8 ), intent ( out ) :: T !! Plume temperature boundary condition real ( r8 ), intent ( out ) :: S !! Plume salinity boundary condition D = offset allocate ( U ( 1 )) U = discharge / offset S = fresh_sal T = melt_temp end subroutine bound_vals end program isoft"},{"title":"Linking to the Library – ISOFT","tags":"","loc":"page/1-running/3-compile.html","text":"As previously discussed , by running make script you will produce a script which can be used to compile programs that\nuse ISOFT. It will contain information on the location of all the\nlibrary files needed for ISOFT to run. This script is called compile.sh and has the following call signature: ./compile.sh [ main-file-name [ executable-name ] ] where main-file-name is the program file to be compiled and executable-name is the name to give the resulting executable. These\ndefault to main.f90 and isoft , respectively. The example program provided earlier can be\ncompiled and run as follows: . / compile . sh . / isoft The provided script assumes that your ISOFT-dependent code is all in a\nsingle source file. It is trivial to modify the script should further\nfiles need to be compiled and linked."},{"title":"Numerical Methods – ISOFT","tags":"","loc":"page/2-numerics/index.html","text":"ISOFT simulates the evolution of ice shelves and meltwater plumes\nbeneath them. A cartoon diagram of such a can be found below. The ice\nflow has a vertically integrated velocity \\vec{u} , with longitudinal and\ntransverse components u and v , respectively. h is the thickness of the\nice shelf, while b is the depth of its lower surface below sea\nlevel. Subglacial discharge at the grounding line, with volume flux Q_g , feeds a plume of thickness D flowing underneath the ice shelf with\nvertically integrated velocity \\vec{U} . This velocity also has\nlongitudinal, U , and transverse, V , components. The plume has a\ntemperature, T , and salinity, S , which drive melting m at the base of\nthe ice shelf. The plume is further fed by turbulent entrainment, e ,\nof the ambient ocean water. This water has its own temperature and\nsalinity: T_a and S_a , respectively. This section of the documentation describes the mathematics behind\nISOFT. First, the equations describing ice shelf and plume behaviour\nare provided. The solvers used for the shelf and plume components are\ndescribed in turn. Finally, an overview of a benchmarking problem is\nprovided."},{"title":"Shelf/Plume Equations – ISOFT","tags":"","loc":"page/2-numerics/1-equations.html","text":"The basic equations used in ISOFT to describe ice and plume dynamics\nare similar to those of Sergienko (2013) , except that the\nplume is assumed to be in quasi-steady state.  All equations were\nnondimensionalised. Scales for this were chosen to be able to work\nwith multiple choices of parameterisations. This requirement of\nflexibility sometimes resulted in otherwise suboptimal choices. Ice Shelf Equations After rescaling, the dimensionless ice shelf equations have the form \\begin{equation}\n    h_{t} + \\nabla\\cdot(h\\vec{u}) = -\\lambda m, \\label{eq:ice-height-nd}\n\\end{equation} \\begin{equation}\n    {\\left[2\\eta h\\left(2u_x + v_y\\right)\\right]}_{x} + {\\left[\\eta\n    h\\left(u_y + v_x\\right)\\right]}_{y} - \\chi{\\left(h&#94;2\\right)}_x = 0, \\label{eq:ice-mom-x}\n\\end{equation} \\begin{equation}\n    {\\left[\\eta h\\left(u_y + v_x\\right)\\right]}_{x} + {\\left[2\\eta\n    h\\left(u_x + 2v_y\\right)\\right]}_{y} - \\chi{\\left(h&#94;2\\right)}_y = 0. \\label{eq:ice-mom-y}\n\\end{equation} In these equations h is the ice thickness (scaled by reference\nthickness h_0 ), \\vec{u} = (u,v) is the velocity at which the ice\nflows (scaled by reference u_0 ), m is the rate at which the ice\nshelf is melting (rescaled by reference m_0 , defined below), and \\eta is the rescaled ice viscosity. The dimensionless parameters \\begin{equation}\\label{eq:ice-parameters}\n  \\lambda \\equiv \\frac{\\rho_0 m_0 x_0}{\\rho_i h_0 u_0},\n  \\quad \\chi \\equiv \\frac{\\rho_i gh_0x_0}{2\\eta_0 u_0}\\left(1 - \\frac{\\rho_i}{\\rho_0}\\right)\n\\end{equation} represent the ratio of melt versus influx of ice and the stretching rate\n(ratio of gravitational stresses that drive stretching versus viscous\nstresses resisting), respectively. The ice density is \\rho_i , while the reference density for\nocean water is \\rho_0 . Otherwise, the subscript nought indicates a\ntypical scale for a variable. The timescale for ice flow is given by t_0 = x_0/u_0 . Gravitational acceleration is g . If viscosity is\nmodelled as being Newtonian, then the dimensionless \\eta is set to 1.\nAlternatively, Glen’s Law can be nondimensionalised to take the form \\begin{equation}\\label{eq:glens-nd}\n  \\eta = \\frac{1}{2}\\xi D&#94;{1/n - 1}_{2},\n  \\end{equation} where D_2 = \\sqrt{D_{i,j}D_{i,j}/2} is the second invariant of the strain\nrate and the dimensionless coefficient \\begin{equation}\\label{eq:glens-coef-nd}\n  \\xi \\equiv \\frac{B}{\\eta_0} {\\left(\\frac{u_0}{x_0}\\right)}&#94;{1/n - 1}.\n  \\end{equation} Typically, n=3 . Plume Equations The plume equations are scaled according to \\begin{equation}\\label{eq:scaling}\n  \\begin{gathered}\n    U_0&#94;2 = \\frac{h_0g\\Delta\\rho}{\\rho_0},\n    \\quad e_0=m_0=\\gamma_{T0}=\\gamma_{S0} = \\frac{D_0U_0}{x_0}, \\\\\n    \\quad \\Delta T_0 = \\frac{\\Gamma&#94;{*}_T x_0}{D_0}(T_a - T_m),\n    \\quad \\Delta S_0 = \\frac{c_0\\rho_0\\Delta T_0(S_a - S_m)}{\\rho_i L}.\n  \\end{gathered}\n\\end{equation} As before, the subscript nought indicates the typical\nscale for a variable. The exception to this is \\rho_0 , which is a\nrepresentative value for the water density. Because the density\ndifference is used in the plume equation and this difference is quite\nsmall, it was found useful to adopt a different scale, \\Delta\\rho , to\nuse when nondimensionalising \\rho_a - \\rho , \\rho_x , and \\rho_y .\nSimilarly, temperature and salinity were scaled according to typical\ndifferences rather than by their absolute values. An arbitrary point\ncould be set to zero for these two variables and it proved convenient to\nchoose the ambient values as the zero-point. The basal depth, b , is\nscaled by h_0 . Note that the scale m_0 does not correspond to\ntypical physical values of melting but is chosen because it is\nconvenient to have it equal to those of the other variables; as a\nresult, m \\ll 1 . This yields the dimensionless system \\begin{equation}\n    \\nabla\\cdot\\left(D\\vec{U}\\right) = e + m, \\label{eq:plume-cont}\n\\end{equation} \\begin{equation}\n    \\nabla\\cdot\\left(D\\vec{U}U\\right) = D(\\rho_a - \\rho)\\left(b_x -\n                                        \\delta D_x\\right) +\n                                        \\frac{\\delta D&#94;2}{2}\\rho_x +\n                                        \\nu\\nabla\\cdot\\left(D\\nabla\n                                        U\\right) -\n                                        \\mu|\\vec{U}|U, \\label{eq:plume-mom-x}\n\\end{equation} \\begin{equation}\n    \\nabla\\cdot\\left(D\\vec{U}V\\right) = D(\\rho_a - \\rho)\\left(b_y -\n                                        \\delta D_y\\right) +\n                                        \\frac{\\delta D&#94;2}{2}\\rho_y +\n                                        \\nu\\nabla\\cdot\\left(D\\nabla\n                                        V\\right) -\n                                        \\mu|\\vec{U}|V, \\label{eq:plume-mom-y}\n\\end{equation} \\begin{equation}\n    \\nabla\\cdot\\left(D\\vec{U}S\\right) = eS_a\n                                        + \\nu\\nabla\\cdot\\left(D\\nabla S\\right) + mS_m -\n                                        \\gamma_S(S-S_m), \\label{eq:plume-salt}\n\\end{equation} \\begin{equation}\n    \\nabla\\cdot\\left(D\\vec{U}T\\right) = eT_a\n                                        + \\nu\\nabla\\cdot\\left(D\\nabla T\\right) + mT_m -\n                                        \\gamma_T(T-T_m). \\label{eq:plume-temp}\n\\end{equation} These equations were constructed\nwithout making any assumptions about the form of m , e , or \\rho .\nFor this reason different, more generic, scales are adopted for these\nvalues. The velocity scale depends on the density scale, rather than on\nbuoyancy input from subglacial discharge. Instead of scaling the\nsalinity in terms of buoyancy input, its scale is based the level of\nmelt-water input, which is the dominant source of salinity forcing\nacross most of the domain. The dimensionless parameters \\begin{equation}\\label{eq:plume-parameters}\n  \\delta \\equiv \\frac{D_0}{h_0},\n  \\quad r = \\frac{\\rho_0}{\\rho_i},\n  \\quad \\nu \\equiv \\frac{\\kappa}{x_0U_0},\n  \\quad \\mu \\equiv \\frac{C_dx_0}{D_0}\n\\end{equation} represent the dimensionless\nbuoyancy correction, density ratio, turbulent eddy diffusivity, and\nturbulent drag coefficient, respectively. The latter two depend on the\ndimensional eddy diffusivity \\kappa , which is assumed to be equal to\nthe eddy viscosity,\nand the unscaled turbulent drag coefficient C_d . The simple entrainment parameterisation of Jenkins (1991) can\nbe nondimensionalised to have the form \\begin{equation}\n\\label{eq:entrainment-jenkins-nd}\n  e = \\frac{E_0}{\\delta}|\\nabla b||\\vec{U}|,\n  \\end{equation} suggesting it is\nconvenient to take \\delta = E_0 (or equivalently, D_0 = E_0 h ). The more complex parameterisation of Kochergin (1987) nondimensionalises to \\begin{equation}\n\\label{eq:entrainment-koch-nd}\n  e = \\frac{K}{S_m}\\sqrt{|\\vec{U}|&#94;2 + \\frac{\\delta(\\rho_a - \\rho)D}{S_m}},\n  \\end{equation} with the dimensionless coefficient \\begin{equation}\\label{eq:ent-koch-coef-nd}\n  K = \\frac{c_L&#94;2 x_0}{D_0}.\n\\end{equation} The turbulent Schmidt number, S_m ,\ndepends on the Richardson number: S_m = \\frac{Ri}{0.0725(Ri + 0.186 - \\sqrt{Ri&#94;2 - 0.316Ri 0.0346})}. With these scales, the Richardson number is given by Ri = \\delta(\\rho_a - \\rho)D/|\\vec{U}|&#94;2 . The simplified melt rate\nparameterisation taken from Dallaston, Hewitt, and Wells (2015) ,\nhas the dimensionless form \\begin{equation}\\label{eq:melt-nondim}\n  m = \\zeta_1\\zeta_2|\\vec{U}|(T - T_m),\n\\end{equation} where \\begin{equation}\\label{eq:thermal-zetas}\n  \\zeta_1 = \\frac{\\Gamma&#94;{*}_T x_0}{D_0}, \\quad \\zeta_2 =\n  \\frac{c\\Delta T_0}{L}.\n\\end{equation} Due to the low efficiency of thermal transfer\nto the ice shelf, compared to the high rate of entrainment, \\zeta_1 \\ll 1 . The large latent heat of ice results in \\zeta_2 \\ll 1 , as well. Together, these results mean m \\ll e \\sim 1 ,\nso that the mass gain by meltwater input is much smaller than by\nentrainment. It can be seen that the thermal transfer coefficient\nnondimensionalises to give \\begin{equation}\\label{eq:therm-trans-nondim}\n  \\gamma_T = \\zeta_1 |\\vec{U}|.\n  \\end{equation} The water density is set using a linear equation of state of the form \\begin{equation}\n  \\label{eq:lin-eos}\n  \\rho_w = \\rho_{\\rm ref}[1 + \\beta_S(S-S_{\\rm ref})-\\beta_T(T-T_{\\rm ref})].\n\\end{equation} Here, \\beta_S is the haline contraction coefficient, \\beta_T is the thermal expansion coefficient, and S_{\\rm ref} , T_{\\rm ref} , and \\rho_{\\rm ref} are reference values for salinity,\ntemperature, and density about which the relation has been\nlinearised. Typical Scales and Parameter Values Typical scales and values for ice shelf and plume properties are\nlisted in the table below, along with the values of non-dimensional\nparameters which result. “Repr.  val.” stands for “representative\nvalue”. [J11] refers to Jenkins (2011) ,\n[B11] to Bindschadler, Vaughan, and Vornberger (2011) ,\n[D15] to Dallaston, Hewitt, and Wells (2015) ,\n[J91] to Jenkins (1991) ,\n[J96] to Jacobs, Hellmer, and Jenkins (1996) ,\n[K87] to Kochergin (1987) , and\n[S13] to Sergienko (2013) .\nScales in the third column are chosen to be comparable\nto the conditions of the PIG ice shelf and come from the indicated\nsource. Where a scaling is unconstrained it was chosen to provide\nconvenient parameter values (e.g. x_0 fixed by \\chi ). The value of c_L was chosen so that its entrainment parameterisation resulted\nin a similar melt rate as that of Jenkins (1991) . Due to an error, \\zeta_2 is a factor of r too large. \\newcommand{\\unit}[1]{{\\rm\\thinspace #1}}\n\\newcommand{\\m}{\\unit{m}}\n\\newcommand{\\km}{\\unit{km}}\n\\newcommand{\\kg}{\\unit{kg}}\n\\newcommand{\\s}{\\unit{s}}\n\\newcommand{\\yr}{\\unit{yr}}\n\\newcommand{\\J}{\\unit{J}}\n\\newcommand{\\K}{\\unit{K}}\n\\newcommand{\\Pa}{\\unit{Pa}}\n\\newcommand{\\hPa}{\\unit{hPa}}\n\\newcommand{\\kPa}{\\unit{kPa}}\n\\newcommand{\\rad}{\\unit{rad}}\n\\newcommand{\\psu}{\\unit{psu}}\n\\newcommand{\\mps}{\\m\\s&#94;{-1}}\n\\newcommand{\\mpss}{\\m\\s&#94;{-2}}\n\\newcommand{\\mpyr}{\\m\\yr&#94;{-1}}\n\\newcommand{\\kmpyr}{\\km\\yr&#94;{-1}}\n\\newcommand{\\C}{\\rm &#94;{\\circ}\\thinspace C}\n\\newcommand{\\kgpmc}{\\kg\\m&#94;{-3}}\n\\newcommand{\\ppsu}{\\psu&#94;{-1}}\n\\newcommand{\\msps}{\\m&#94;{2}\\s&#94;{-1}}\n\\newcommand{\\Pas}{\\Pa\\s}\n\\newcommand{\\Jpkg}{\\J\\kg&#94;{-1}}\n\\newcommand{\\JpkgpK}{\\Jpkg\\K&#94;{-1}} Variable Description Value Source \\rho_0 Reference water density 1030\\kgpmc Common \\rho_i Ice density 916\\kgpmc Common g Acceleration due to gravity 9.8\\mpss Common L Latent heat of fusion 3.35\\times 10&#94;{5}\\Jpkg Common c Specific heat of water 3.98\\times 10&#94;{3}\\JpkgpK Common E_0 Entrainment coefficient (J91) 0.036 [J11] c_L Entrainment coefficient (K87) 0.1059 \\beta_S Haline contraction coefficient 7.86\\times 10&#94;{-4}\\psu&#94;{-1} [J11] \\beta_T Thermal contraction coefficient 3.87\\times 10&#94;{-5}\\K&#94;{-1} [J11] C_d Turbulent drag coefficient 2.5\\times 10&#94;{-3} [J11] \\Gamma&#94;{*}_T Thermal transfer coefficient 5.7\\times 10&#94;{-5} [D15] \\kappa Turbulent diffusivity/viscosity 10 – 100\\m&#94;2\\s&#94;{-1} Repr. val. \\eta_0 Ice viscosity 2.6\\times 10&#94;{13}\\Pa\\s Repr. val. B Glen’s Law coefficient 1.6\\times 10&#94;{8}\\Pa\\s&#94;{1/3} [S13] S_g Subglacial discharge salinity 0\\psu Repr. val. S_a Ambient salinity 34.6\\psu [J96] T_a - T_m Thermal Forcing 2\\C [J96] u_0 Ice velocity scale 2.5\\kmpyr [B11] h_0 Ice thickness scale 1200\\m [B11] x_0 Length scale 13.8\\km t_0 Time scale 5.5\\yr m_0 Melt scale 1.94\\times 10&#94;{4} \\mpyr X Dimensionless domain length 6 [B11] Q_g Subglacial discharge 8.5\\times 10&#94;{-3}\\m&#94;2\\s&#94;{-1} Repr. val. D_0 Plume thickness scale 43.2\\m U_0 Plume velocity scale 0.196\\mps \\Delta T_0 Temperature scale 0.0364\\K \\Delta S_0 Salinity scale 0.0170\\psu \\Delta\\rho Density variation scale 3.38\\times 10&#94;{-3}\\kgpmc \\chi Dimensionless stretching rate 4 \\xi Dimensionless Glen’s coefficient 1.919 \\lambda Dimensionless melt rate 100 r Density ratio 1.12 \\nu Dimensionless eddy diffusivity 3.69\\times 10&#94;{-2} \\mu Dimensionless drag coefficient 0.799 \\delta Buoyancy correction 0.036 K Dimensionless K87 coefficient 3.58 \\zeta_1 Dimensionless transfer coefficient 0.0182 \\zeta_2 Dimensionless melt coefficient 4.86\\times 10&#94;{-4}"},{"title":"Spatial Discretisation – ISOFT","tags":"","loc":"page/2-numerics/2-spatial.html","text":"The shelf/plume simulation requires computing various derivatives, for\nwhich a pseudospectral method is used. An introduction to this\ntechnique is provided below; for a more thorough explanation, see Trefethen (2000) . Spectral methods\nprovide a fast and accurate way to numerically differentiate discrete\ndata. While more computationally expensive than finite difference\nmethods for the same number of grid points, spectral methods give\nexponential convergence and thus often require significantly fewer\ngrid points to achieve the same level of accuracy. Numerical accuracy\nis of particular importance here, as the purpose of running\nsimulations is to test the stability of an ice-shelf to potentially\nsmall perturbations. Spectral methdos are often used for problems with\nperiodic boundary conditions, where a Fourier series, \\setcounter{20} f(\\theta) =\n\\sum_k a_k e&#94;{ik\\theta} , can be used to interpolate between grid\npoints. If the grid points are evenly spaced then the coefficients a_k can easily be calculated with a discrete Fourier\ntransform. Typically this would be done using the highly efficient\nfast Fourier transform (FFT) algorithm (Cooley and Tukey, 1965) , which\nrequires O(N\\log N) operations for N grid-points. The derivative\nis then f'(\\theta) = \\sum_k ika_k e&#94;{ik\\theta} and an inverse FFT\ncan be used to convert the new coefficients ika_k to the values of f' at each grid point. However, the boundary conditions for the ice shelf and plume\nare not periodic. Instead, say there is an\ninterpolant F(x) for data mapped onto -1 \\le x \\le 1 using a\nlinear coordinate rescaling. To apply a spectral\nmethod, it is necessary to map the interpolant to a function f(\\theta) , 0 \\le \\theta < 2\\pi , where x = \\cos\\theta . Regardless\nof the boundary conditions on F , f will be periodic and even in \\theta and can thus be differentiated as before. The results can\nthen be mapped back onto the grid points in the x -domain. By\nchoosing x grid points to be Chebyshev collocation points ,\ndefined below, the corresponding grid points in \\theta will be\nequally spaced and an FFT can be used to find the Fourier\ncoefficients. This is known as the Chebyshev pseudospectral\n  method (Trefethen, 2000) . If N + 1 Chebyshev collocation\npoints are needed, their positions are given by \\begin{equation}\n  \\label{eq:cheb-colloc}\n  x_j = \\cos(j\\pi/N), \\quad j = 0, \\ldots,N.\n\\end{equation} This approach provides uneven spacing of points in x , with a\nclustering of resolution near the domain boundaries, and hence is also\nwell suited to capture rapid variation near the grounding line. Following Trefethen (2000) , the practical algorithm used to\ndifferentiate discrete data v_j = v(x_j) , for 0 \\le j \\le N , corresponding to values at Chebyshev collocation\nnodes x_0=1,\\ldots,x_N=-1 , is as follows: Take a type-I discrete cosine transform of the data, to\n  determine the Fourier coefficients \\hat{v}_j = \\frac{\\pi}{N}\\left[v_0 + v_{N}\\cos(\\pi j) +\n    2\\sum&#94;{N-1}_{k=1} v_{k}\\cos\\left(\\frac{\\pi\n        jk}{N-1}\\right)\\right]. Let \\hat{w}_{j} = -j\\hat{v}_{j} for 1\\le j\\le N-1 and \\hat{w}_N = 0 . Take a type-I discrete sine transform of \\hat{w}_j from j=1 to j=N-1 , yielding w_j = \\frac{1}{\\pi}\\sum&#94;{N-1}_{k=1}\\hat{w}_k\\sin\\left(\\frac{\\pi\n      kj}{N}\\right). Compute v_j' =  \\begin{cases}\n    \\frac{1}{2\\pi}\\left[\\frac{N&#94;2}{2}\\hat{v}_N + \\sum_{k=1}&#94;{N-1}\n      k&#94;2\\hat{v}_k \\right], & j = 0 \\\\\n    \\frac{-w_j}{\\sqrt{1-x_j&#94;2}}, & 1 \\le j \\le N - 1 \\\\\n    \\frac{1}{2\\pi}\\left[\\frac{{(-1)}&#94;{N+1}N&#94;2}{2}\\hat{v}_N +\n      \\sum_{k=1}&#94;{N-1} {(-1)}&#94;{k+1}k&#94;2\\hat{v}_k \\right], & j = N\n  \\end{cases}. Discrete sine and cosine transforms are variations of the discrete\nFourier transform which take advantage of data being real and either\neven or odd. The FFTW3 package (Frigo and Johnson, 2005) was used to\ncompute these. A more rigorous and detailed explanation of the above\nmethods for periodic and non-periodic functions is provided by Trefethen (2000) in chapters 3 and\n8, respectively. If a domain other than -1 \\le x \\le 1 is desired then the\nCollocation points can be scaled and offset as necessary, giving a\ncoordinate system x&#94;*_j . The above differentiation algorithm is\napplied unchanged, except that the result is scaled by twice the\ninverse of the domain-width."},{"title":"Shelf Solver – ISOFT","tags":"","loc":"page/2-numerics/3-shelf-solver.html","text":"Simulating the evolution the ice shelf mass balance using equation 1 requires a time-stepping scheme. In\norder to allow numerical stability with large time steps, a\nsemi-implicit method is used. This works by defining the residual\noperator \\def\\bm#1{{\\boldsymbol{#1}}}\n\\newcommand{\\dx}{\\mathcal{D}_x}\n\\setcounter{21} \\begin{equation}\n  \\label{eq:shelf-resid}\n  \\bm{f}(h_n) =\n  \\frac{h_n - h_{n-1}}{\\Delta t} +\n  \\frac{\\partial}{\\partial x}(h_{n}u_n(h_n)) + \\lambda m_{n-1}\n\\end{equation} where the subscript n indicates the value at the time step being\nsolved for, while subscript n - 1 indicates the value at the\nprevious time step. This is a semi-implicit scheme (rather than fully\nimplicit) because melt rate m_{n-1} is used from the previous time\nstep, rather using m_n from the current time step. In this equation, h_n and u_n represent vectors of thickness and velocity values at\neach grid point at time step n , while h_{n-1} is a vector of\nthickness values at the previous time step and \\partial/\\partial x is evaluated using the Chebyshev differentiation procedure previously described. This is a nonlinear system\nand can be solved using Newton's method, where the root is determined\niteratively by solving the linear equation \\begin{equation}\n  \\label{eq:newton}\n  \\bm{J}\\delta\\bm{s}&#94;k_n = -\\bm{f}(\\bm{s}&#94;k_n).\n\\end{equation} Here, \\bm{s}_n = h_n is the current value of the ice thickness, \\bm{J} is the Jacobian of f ,\nand the new iterate \\bm{s}&#94;{k+1}_n = \\bm{s}&#94;{k}_n + \\delta\\bm{s}&#94;k_n . In order to avoid having to evaluate the Jacobian of this system, a\nJacobian-free Newton-Krylov method (Knoll and Keyes, 2004) is used. This\nsolves the linear equation 23 iteratively via a Krylov\nmethod which only requires the product of the Jacobian with the\niterate, and not the actual Jacobian itself. This product is\napproximated as a finite difference: \\begin{equation}\n  \\label{eq:jac-fin-diff}\n  \\bm{J}\\bm{v} \\approx \\frac{\\bm{f}(\\bm{s} + \\epsilon\\bm{v}) -\n    \\bm{f}(\\bm{s})}{\\epsilon}.\n\\end{equation} The NITSOL implementation (Pernice and Walker, 1998) of a Newton-Krylov\nsolver was chosen, as it is very flexible and written in Fortran,\nwhich was the language other portions of the code were to be\nimplemented with. The spectral discretisation used here corresponds to dense matrices,\nmaking equation 23 very poorly conditioned. As a\nresult, the Krylov solvers in NITSOL were unable to converge on a\nsolution without a preconditioner. Even with relatively-sparse\nmatrices, preconditioners are often needed for iterative methods\n(e.g.: Pernice and Walker, 1998 ; Knoll and Keyes, 2004 ). A right preconditioner, \\bm{P}&#94;{-1} , is chosen so that the modified problem (\\bm{J}\\bm{P}&#94;{-1})\\bm{q} = -\\bm{f}(\\bm{s}) is well-conditioned and\ncan be solved for \\bm{q} . It is then easy to find \\bm{s} using \\bm{P}\\delta\\bm{s} = \\bm{q} \\Rightarrow \\delta\\bm{s} =\n\\bm{P}&#94;{-1}\\bm{q} . A good preconditioner will have \\bm{P}&#94;{-1} \\approx \\bm{J}&#94;{-1} , so that \\bm{J}\\bm{P}&#94;{-1} \\approx \\bm{I} to a decent approximation. A\ntradeoff must be made between a preconditioner which is a sufficiently\ngood approximation of \\bm{J}&#94;{-1} to be useful and one which is not\ntoo expensive or unstable to apply (e.g. P&#94;{-1} = J&#94;{-1} would be a\nperfect preconditioner but constructing it is of equal difficulty to\nsolving the original, unpreconditioned problem). The Jacobian of equation 1 can be expressed as \\begin{equation}\n  \\label{eq:shelf-jacob}\n  \\bm{J} = \\frac{1}{\\Delta t} + \\dx u,\n\\end{equation} where we define \\dx A \\equiv \\partial A/\\partial x + A\\Delta_x , and \\Delta_x is the differential operator in the x -direction. Although \\Delta_x will be a dense matrix when using a spectral method, it can\nbe approximated as a sparse finite difference operator, as proposed\nby Orszag (1980) . In this case \\Delta_x , and thus also \\dx ,\nare tridiagonal matrices. This means that the finite difference form\nof the Jacobian can be \"inverted\" simply by solving the tridiagonal\nsystem, which can be done efficiently using a routine in LAPACK (Anderson et al., 1999) .\nThis proved effective at preconditioning the\nKrylov solver in NITSOL, whilst maintaining the accuracy of the\nunderlying pseudospectral method. The u_n(h_n) term in equation 1 can itself be\nfound by solving a nonlinear system, this time with the form \\begin{equation}\n  \\label{eq:u-resid}\n  \\bm{f}(u_n) =\n  \\frac{\\partial}{\\partial x}\\left(4\\eta_{n}h_{n}\\frac{\\partial\n      u_n}{\\partial x}\\right) - \\chi \\frac{\\partial h_n&#94;2}{\\partial x}.\n\\end{equation} This has a Jacobian \\begin{equation}\n  \\label{eq:u-jacob}\n  \\bm{J} = \\dx(4\\eta h)\\Delta_x.\n\\end{equation} Every time a new residual is calculated using equation 22 , equation 26 is solved iteratively using NITSOL. It is also possible to construct a nonlinear system which takes both h_n and u_n as arguments and solve for both simultaneously. While\nthis avoids the need to repeatedly solve for u_n , it proved to be much\nless stable and tended to require smaller time-steps in order to\nprevent failure. As such, the approach outlined above proved to be\ncomputationally cheaper overall. Of the three linear solvers provided with NITSOL, only GMRES proved\nreliable, with the BiCGSTAB and TFQMR solvers typically\nfailing. Consult Pernice and Walker (1998) for more details on these\nroutines. It was also found that the \"backtracking\" globalisation\nused in NITSOL, which is meant to prevent the solution from starting\nto diverge, had a tendency to make the solver get trapped in local\nminima for this problem. As such, it was turned off and this was found\nto greatly improve the robustness of the nonlinear solver."},{"title":"Plume Solver – ISOFT","tags":"","loc":"page/2-numerics/4-plume-solver.html","text":"For a one-dimensional domain, equations 8-12 become\nsecond order ODEs. If boundary conditions are applied only at the grounding\nline then this means that they can be solved using initial value\nproblem methods such as Runge-Kutta integration. However, the\ndiffusive terms in equations 8-12 require two\nboundary conditions each for velocity, salinity, and temperature. The\nlogical choice would use Dirichlet conditions at the grounding line\nand outflow conditions (setting the first derivative to zero) at the\ncalving front. This turns the plume equations into a boundary\nvalue problem and makes it more difficult to solve. \\def\\bm#1{{\\boldsymbol{#1}}}\n\\setcounter{27} One strategy for solving boundary value problems such as this is the\nshooting method (see, e.g., Press et al.) . With this\ntechnique, unknown boundary values are guessed at the grounding line\nto create an initial value problem. This initial value problem is then\nintegrated and the difference between the values at the calving front\nand the required boundary conditions there is noted. A nonlinear\nsolver is then used to change the guesses at the grounding line in\norder to get the correct boundary conditions at the calving\nfront. However, the diffusion term in these equations leads to\nsolutions involving exponential growth. If the guesses of grounding\nline conditions are not sufficiently good then these exponentials can\nlead to overflow and the failure of the solver. It was found that this\nmade the shooting method unsuitable in practice. A relaxation method was also tried, wherein a time-dependent version\nof the plume model was evolved\nforward in time (using an explicit method) until it reached steady\nstate. However, the weakness of the diffusion coefficient and nearly\nhyperbolic character of the time-dependent plume model means that\nsignificant waves often arise, and considerable time is needed to\nreach a steady state. Finally, an approach called the quasilinearisation method (Mandelzweig and Tabakin, 2001) ,\nor QLM, was tried. This is a technique, based\non Newton's method, for solving boundary value problems. Though Mandelzweig and Tabakin (2001) present the technique for single-variable\nproblems, it is trivial to generalise it to the multivariate\ncase. Consider the differential equation \\begin{equation}\n  \\label{eq:qlm-equation}\n  L&#94;{(n)}\\bm{s}(x) = \\bm{f}[\\bm{s}(x),\n  \\bm{s}&#94;{(1)}(x), \\ldots, \\bm{s}&#94;{(n-1)}(x), x], \\qquad \\bm{s}\n  \\in \\mathbb{R}&#94;{m},\n\\end{equation} being solved on the domain [0,b] . Here, L&#94;{(n)} is an n&#94;{\\rm th} order linear differential operator, \\bm{f} is a nonlinear function,\nand \\bm{s}&#94;{(i)} is the i&#94;{\\rm th} derivative of \\bm{s} . Boundary conditions are specified by \\begin{align}\n  \\label{eq:qlm-boundaries}\n  g_k[\\bm{s}(0), \\bm{s}&#94;{(1)}(0), \\ldots, \\bm{s}&#94;{(n-1)}(0)] &= 0,& k = 1, \\ldots, l; \\nonumber \\\\\n  g_k[\\bm{s}(b), \\bm{s}&#94;{(1)}(b), \\ldots, \\bm{s}&#94;{(n-1)}(b)] &= 0,& k = l+1, \\ldots, mn;\n\\end{align} where g_1, g_2, \\ldots, g_{mn} are (potentially) nonlinear\nfunctions. This can be solved iteratively for the r+1 iterate \\bm{s}_{r+1} using the equation \\begin{multline}\n  \\label{eq:qlm-iter}\n  L&#94;{(n)}\\bm{s}_{r+1}(x) = \\bm{f}[\\bm{s}_{r}(x),\n  \\bm{s}&#94;{(1)}_{r}(x), \\ldots, \\bm{s}&#94;{n-1}_{r}(x), x] + \\\\\n  \\sum_{i=0}&#94;{n-1}\\bm{f}_{\\bm{s}&#94;{(i)}}[\\bm{s}_{r}(x),\n  \\bm{s}&#94;{(1)}_{r}(x), \\ldots, \\bm{s}&#94;{n-1}_{r}(x),\n  x]\\left[\\bm{s}&#94;{(i)}_{r+1}(x) - \\bm{s}&#94;{(i)}_{r}(x)\\right],\n\\end{multline} with boundary conditions for each iteration set by \\begin{align}\n  \\label{eq:qlm-boundaries-iter}\n  \\sum_{i=0}&#94;{n-1}\n  g_{k,\\bm{s}&#94;{(s)}}[\\bm{s}_r(0), \\bm{s}&#94;{(1)}_r(0), \\ldots,\n  \\bm{s}&#94;{n-1}_r(0), x]\\cdot[\\bm{s}&#94;{(i)}_{r+1}(0) -\n  \\bm{s}&#94;{(i)}_r(0)] &= 0,&  k=1,\\ldots,l; \\nonumber \\\\\n  \\sum_{i=0}&#94;{n-1}\n  g_{k,\\bm{s}&#94;{(i)}}[\\bm{s}_r(b), \\bm{s}&#94;{(1)}_r(b), \\ldots,\n  \\bm{s}&#94;{n-1}_r(b), x]\\cdot[\\bm{s}&#94;{(i)}_{r+1}(b) -\n  \\bm{s}&#94;{(i)}_r(b)] &= 0,&  k=l+1,\\ldots,mn.\n\\end{align} In these equations, \\bm{f}_{\\bm{s}&#94;{(i)}} = \\partial \\bm{f}/\\partial \\bm{s}&#94;{(i)} (i.e.\\\nthe Jacobian of \\bm{f} ) and g_{k,\\bm{s}&#94;{(i)}} = \\partial g_{k}/\\partial \\bm{s}&#94;{(i)} . Note\nthat, for linear boundary conditions, equation 31 reduces to the boundary\nconditions being constant across iterations.  This technique can be\nproven to give quadratic convergence to the solution given certain\neasily-satisfied assumptions (see Mandelzweig and Tabakin, 2001, for details) .\nFurthermore, convergence is often monotonic. To apply this method to the plume model, new variables U' = U_x , V' = V_x , S' = S_x , and T' = T_x were introduced, where a\nsubscript x denotes a derivative. Equation 8 was rewritten so that the left-hand-side is just D_x , while equations 9-12 were rewritten\nsuch that the left hand sides are U'_{x} , V'_{x} , etc. This\nallowed a linear operator to be constructed with the form \\begin{equation}\n  \\label{eq:L-form}\n  L{[D, U, U', S, S', T, T']}&#94;T = {\\left[\\frac{d D}{d x}, \n      \\frac{d U}{d x} - U',\n      \\frac{d U'}{d x},\n      \\frac{d S}{d x} - S',\n      \\frac{d S'}{d x},\n      \\frac{d T}{d x} - T',\n      \\frac{d T'}{d x}\\right]}&#94;T.\n\\end{equation} The nonlinear operator is zero for U , S , and T and elsewhere\nconsists of the right-hand-side of the rearranged version of equations 8-12 . In order to find successive iterates, a linear equation must be\nsolved, consisting of the linear operator and the Jacobian \\bm{f}_{\\bm{s}&#94;{(i)}} = \\partial \\bm{f}/\\partial \\bm{s}&#94;{(i)} . It\nis neither feasible nor efficient to explicitly evaluate the Jacobian,\nespecially if the solver is to be agnostic to parameterisation\nchoices. The iterative GMRES solver implemented in NITSOL (very\nslightly modified to accept an initial guess of the solution) was used\nbecause it can work knowing only the product of the Jacobian and the\ncurrent iterate. Initially these products were calculated using the\nfinite-difference approximation to the Jacobian described for the shelf solver . While this\nwas sufficiently accurate to run many simple simulations, it proved\nunreliable when the plume undergoes a sudden change or when nonlinear\nparameterisations are used.  To address this, automatic\ndifferentiation (Neidinger 2010) was applied instead and this proved far more robust. This calculated\nthe product of the Jacobian with a vector (i.e., the directional\nderivative) via operator overloading. See the code design section for\nfurther details of the implementation. All results displayed in this\nchapter were obtained using automatic differentiation. The GMRES algorithm required preconditioning to work properly, as was\nthe case with the ice shelf solver. The preconditioner was chosen to\nbe \\bm{P}&#94;{-1}=L&#94;{-1} , equivalent to finding the inverse of equation 32 , which involves integration of the\nderivatives. Spectral integration was performed by reversing the steps\nfor spectral differentiation described on the Spatial Discretisation . A similarly modified\nversion of the NITSOL implementation of the biconjugate gradient\nstabilised method (BiCGSTAB) was also found to work when solving the\npreconditioned linear system, but it proved less robust. When solving the linear equation at each iteration, the initial guess\nwas the previous iterate. The GMRES solver was expected to reduce the\nerror in the linear system by a factor \\epsilon compared to the\ninitial guess. It was found that gradually decreasing the magnitude of \\epsilon over each nonlinear iteration, the final answer could be\ndetermined with a residual norm smaller than 7N \\times 10&#94;{-9} ,\nwhere N is the number of grid points used and 7 indicates the number\nof plume variables being solved for. The QLM proved to be highly\nefficient, typically converging within a few iterations of equations 30 and 31 ,\nalthough up to a few hundred iterations would often be needed by the\nGMRES solver to perform the necessary intermediate linear solves."},{"title":"Testing and Benchmarking – ISOFT","tags":"","loc":"page/2-numerics/5-benchmarking.html","text":"Ice Shelf After programming the nonlinear solver using the algorithms described\nin the previous section, various tests were run to ensure that it\nwould give the correct results. First, the ice shelf component was\ntested with a prescribed melt rate matching that of the analytic\nsteady state solution found by Dallaston, Hewitt, and Wells (2015) .\nIt was confirmed that when the ice shelf was initialised to the matching\nsteady state it remained there. Initialising the ice shelf to a\nwedge-shape, it was found to evolve to the correct steady state. As a test of the time-stepping for transient evolution, the 1-D shelf\nequations were analysed for the special case where there is no\nstretching ( \\setcounter{32} \\chi = 0 ) and the melt rate m is constant in t and x . The velocity of the ice at the grounding line (and thus across\nthe entire shelf, since there is no stretching) was prescribed to be u(t) = \\bar{u} + \\tilde{u}_0\\sin(\\omega t) . With these assumptions, equation 1 becomes \\begin{equation}\n  \\label{eq:ice-cont-nostretch}\n  \\frac{\\partial h}{\\partial t} - u(t)\\frac{\\partial h}{\\partial x} =\n  - \\lambda m,\n\\end{equation} which can be solved using the method of characteristics. In this\nmethod, a Lagrangian coordinate s is introduced such that the\nthickness of a parcel of ice following the trajectory x(s) , t(s) evolves according to h(s) . It can then be shown that \\frac{d  x}{d  s} = u(t), \\quad \\frac{d \n  t}{d  s} = 1, \\quad \\frac{d  h}{d  s} = -\\lambda\nm. With the initial conditions x = \\sigma , t = 0 , and h = h_0(\\sigma) these equations can be integrated to yield the\ntransient solution \\begin{equation}\n  \\label{eq:h-transient-sol}\n  h = h_0(\\sigma) - \\lambda mt,\n\\end{equation} where \\sigma can be computed from x and t according to \\sigma = x - \\bar{u}t + \\tilde{u}/\\omega\\left[\\cos(\\omega t) -\n  1\\right] . This solution applies to ice starting in the domain, but\na different form is needed for ice parcels crossing the grounding\nline at time t = t_g > 0 . Then \\sigma < 0 and the initial conditions are\nset to x = 0 and h = 1 . In this case the method of characteristics\nprovides the implicit solution \\begin{equation}\n  \\label{eq:h-implicit-sol}\n  h - \\frac{\\lambda m\\tilde{u}_0}{\\omega\\bar{u}}\\cos\\left[\\omega t +\n    \\frac{\\omega}{\\lambda m}(h-1)\\right] = 1 - \\frac{\\lambda\n    m}{\\bar{u}}\\left[x + \\frac{\\tilde{u}_0}{\\omega}\\cos(\\omega t) \\right].\n\\end{equation} This algebraic equation can easily be solved numerically for h using\na bisection-secant method, such as that of Brent (1973, Chapter 4) .\nPossible solutions can be bracketed using the physical insight that h \\in [0,1] . These solutions provide a way to test accuracy of the ice shelf solver in\ntime and space. However, the fact the melt rate is constant means\nthat the semi-implicit approach to time-discretisation is not fully\ntested. Using the same technique, a solution can be found for melt\nrate m = m_t t , where m_t is a constant rate of change in the\nmelt. For \\sigma > 0 (calculated as before) the transient\nsolution applies: \\begin{equation}\n  \\label{eq:h-transient-sol2}\n  h = h_0(\\sigma) - \\frac{\\lambda m_t}{2}t&#94;2.\n\\end{equation} Elsewhere, the solution is again given implicitly: \\begin{equation}\n  \\label{eq:h-implicit-sol2}\n  h - 1 + \\lambda m_t (t_g + s/2)s = 0\n\\end{equation} where the time since the ice parcel crossed the grounding line and the\ntime at which it crossed the grounding line are given by s = \\frac{x}{\\bar{u}} + \\frac{\\tilde{u}_0}{\\omega\n  \\bar{u}}\\left(\\cos(\\omega t) - \\cos(\\omega t_g)\\right), \\quad t_g =\n\\sqrt{\\frac{2(h - 1)}{\\lambda m_t} + t&#94;2}, respectively.\nBracketing this solution is slightly more difficult than in the\nconstant-melt case, as if the value of h is too small it will result\nin an imaginary value of t_g . As such, the lower bound was set to\nthe value of h = 1 - \\lambda m_t t&#94;2/2 , which corresponds\nto t_g=0 at the time being solved\nfor, plus some small value \\epsilon to ensure that floating point\nerror does not become an issue. The upper bound remains set to 1. A series of simulations were run under these conditions using\ndifferent time steps. Parameter values \\bar{u}=1 , \\tilde{u}_0=0.5 , \\lambda = 100 , m_t = 2\\times 10&#94;{-4} , and \\omega=34.56 were chosen,\ncorresponding to the scale choices described in the next section. A\ndomain of x \\in [0,6] was used, with a wedge-shaped initial ice\nprofile h_0(x) = 1 - 0.1x . All simulations used 300 grid-points. The first of the figures above shows the results of two simulations at\ntime t=5 , with time-steps fixed at 10&#94;{-2} and 10&#94;{-4} ,\ncompared to the analytical solution given in equations 36 and 37 . Both simulations give\nreasonably good agreement with the large-scale features of the\nsolution, although there is more significant error at the transition\nto the transient solution. The numerical solutions tend to smooth out\nthose sorts of discontinuities, although reducing the time-step helps\nwith this considerably. The main issue, however, is how the numerical\nsolution handles the ripples which form due to the seasonal forcing of\nshelf velocity. These are very small in magnitude, meaning that very\nhigh levels of accuracy are demanded to resolve them. Even the\nsimulation with the smaller time-step shows signs of diffusion,\ncausing the ripples to loose amplitude as they move across the domain. This can be seen more clearly in the second of the figures above,\nwhich is produced at t=10 when the transient feature has been\nadvected out of the domain. All results in this plot are differences\nbetween the time-dependent solution h with \\tilde{u}_0 = 0.5 and the steady-state result \\bar{h} of equation 37 for \\tilde{u}_0 = 0 , which\ncorresponds to the unforced background state. In order to make the\nplot easier to read, the domain only goes to x=1.5 . As can be\nseen, the amplitude of the ripples decays, indicating the presence of\nsome numerical diffusion. Smaller time-steps result in less of this\ndiffusion. The root-mean-square (dashed lines) and the maximum error\n(solid lines) at times t=5 and t=10 were found for a range of\ntime-steps (see figure below). The error declines fairly slowly with\nthe time-step. Given that high accuracy is needed for these\nsimulations, in any future developments of this algorithm it may be\nuseful to update the time-integration to a second-order or third-order\nmethod, allowing larger time-steps to be used. The memory requirements\nof this would be fairly modest, as only the ice thickness would need\nto be saved between time-steps. Similarly, the error was found to fall with an increasing number of\nChebyshev nodes used in the calculation. However, after a certain\npoint, the error stagnated and adding more nodes did not cause further\nimprovement. The point at which this stagnation occurs seems to depend\non the time-step, with smaller time-steps permitting higher numbers of\nnodes before stagnation. Similarly, the beginnings of stagnation with\nany further reductions in the time step can be seen for small\ntime-steps in the above figure. This is consistent with the total\nerror being the sum of error arising due to temporal discretisation\nand spatial discretisation. Increased resolution was found to be a\nmore computationally expensive means to improve accuracy than reducing\nthe time-step. Plotting the root-mean-square and maximum error (dashed and solid lines, respectively) over the course of a\nsimulation shows that both grow approximately linearly\n(see first figure above), although the latter is very\nnoisy. Presumably this noise is due to aliasing of small-scale\nfeatures of the oscillations onto a discrete grid. The rate of growth\nincreases with the size of the time-step. There is a spike in error\nwhich occurs as the kink at the transient feature reaches the end of\nthe domain around t=6 . The reason for the continued error growth\nafter the transient has been advected away is the growth in melt\nrate. This means that ripples will tend to be larger and thus display\nlarger absolute error. Running a simulation with a constant melt rate\nof m=10&#94;{-3} and comparing to the solution in equations 34 and 35 indicates that the error becomes roughly constant after the transient\nfeature leaves the domain (second figure above). Experiments with this benchmarking problem showed that using 320\ngrid-points with a time step of 10&#94;{-5} resulted in absolute error\nno larger than 10&#94;{-4} . Error in the amplitude of the ripples at the\nend of the domain was no more than ~10%, which was felt to be\nacceptable when running simulations. Plume Testing the plume solver was more difficult, as the structure of the\nsolver required a non-zero diffusivity, while the analytic solution of Dallaston, Hewitt, and Wells (2015) assumed \\nu=0 . To avoid this problem, the equation of state was\naltered for the benchmark test so that it would always return the same\ndensity profile, regardless of plume salinity or temperature. The\ndensity was chosen so that the plume would have the same velocity as\nin the analytic solution. Now uncoupled from the continuity and\nmomentum equations 8 and 9 ,\nthe salinity and temperature equations 11 and 12 could\nbe analytically solved individually. A plume was initialised by giving\nthis analytic solution a sinusoidal perturbation of amplitude 0.1 and\na wavelength twice the size of the domain. Starting from this initial\nguess and a prescribed wedge-shaped ice thickness, the solver was able\nto converge to the expected result. The coupled behaviour of the ice shelf/ocean received less rigorous\ntesting as there are no analytical benchmark solutions available for\nthe full nonlinear problem. The two components were initialised much\nas they were in the plume test (except that the plume density was now\nmade dependent on salinity) and then allowed to evolve together. As\nthe resulting steady-state was not known, it was simply ensured that\nnumerical convergence was achieved as the number of Chebyshev nodes\nincreased and the time step reduced, and that the results looked\nplausible."},{"title":"Horizontally-Integrated Plume Equations – ISOFT","tags":"","loc":"page/2-numerics/6-horzint.html","text":"The plume solver described earlier assumed\nthat the plume is uniform in the transverse direction, with no\ntransverse velocity component. While this is a reasonable\napproximation for narrow ice shelves, past modelling has shown that\nthe Coriolis force steers plume flow within subglacial cavities of\nwide ice shelves Although 2-D plume models have been developed and\napplied before (e.g. Sergienko, 2013) , they are\ncomputationally expensive. Instead, ISOFT implements a\n\"horizontally_integrated\" 1-D model, containing information on the\ntransverse flow. In addition to its computational simplicity, the\nhorizontally-integrated model provides a conceptual tool which can be\nuseful in understanding of the results of observations and more\ncomplex simulations. The full derivation of this model can be found in\nChapter 4 of MacMackin (2019) . What\nfollows is an overview of the results. In this model, illustrated in figures above,\nthe plume variables are averaged over both the thickness of the plume\nand also some lateral width \\setcounter{37} \\Delta y across the shelf. At the lower limit of\nthis domain in y is a sidewall of the subglacial cavity, through which\nthere can be no plume flow. The location of the upper limit is a\nparameter which can be adjusted, but it is assumed to be an open\nboundary through which transverse outflow is allowed. In order for\ntransverse flow to begin there must be something to break the\nhorizontal symmetry in the plume equations. This naturally arises due\nto the Coriolis force. Simulations indicate that, in a rotational\nplume such as this, there would be a narrow longitudinal boundary\ncurrent on the opposite side of the cavity. The presence of such a\nboundary current is assumed here, rather than being explicitly\nmodelled; this current would act to drain the transverse flux of water\nout from under the ice shelf. The plume variables are assumed to be separable in x and y , with the forms \\begin{equation}\n  \\label{eq:plume-var-sep}\n  D(x,y) = \\hat{D}(x)f_D(y), \\quad U(x,y) = \\hat{U}(x)f_U(y), \\quad\\ldots\n\\end{equation} and similar for V , T , and S .  A width-averaging operator,\nrepresented by an over-bar, is defined according to \\begin{equation}\n  \\label{eq:averaging}\n  \\overline{G} = \\frac{1}{\\Delta y}\\int&#94;{y_2}_{y_1}G(y)dy,\n\\end{equation} where G is an arbitrary y -dependent variable and \\Delta y = y_2 - y_1 .\nThe shape functions f(y) are defined such that \\overline{f_D} = 1, \\quad \\overline{f_U} = 1, \\quad\\ldots There is no general way to relate \\widehat{|\\vec{U}|}(x) to \\hat{U}(x) and \\hat{V}(x) , so instead\nit is treated as an independent variable with its own shape function: \\begin{equation}\n  \\label{eq:Ubar-sep}\n  |\\vec{U}(x,y)| = \\widehat{|\\vec{U}|}(x)f_{|\\vec{U}|}(y).\n\\end{equation} However, \\widehat{|\\vec{U}|} = \\sqrt{\\hat{U}&#94;2 + \\hat{V}&#94;2} is\nexactly true if f_U(y) = f_V(y) or approximately true if U \\gg V or V \\gg U . With these definitions in mind, the horizontally-integrated plume equations can be written as \\begin{align}\n    \\alpha_{DU}\\frac{d}{d x}\\left(DU\\right) +\n    \\left.\\frac{f_D f_V}{\\Delta y}\\right\\rvert&#94;{y_2}_{y_1}DV &=\n                                                               \\overline{e} + \\overline{m}, \\label{eq:plume-cont-int} \\\\\n    \\alpha_{DU&#94;2}\\frac{d}{d x}\\left(DU&#94;2\\right) +\n    \\left.\\frac{f_D f_U f_V}{\\Delta y}\\right\\rvert&#94;{y_2}_{y_1}DUV &=\n                                                                    D\\rho_a\\frac{d}{d x}\\left(b - \\delta\\alpha_{D&#94;2} D\\right)\\label{eq:plume-mom-x-int}\\\\ \\nonumber\n                                                             &- D\\left(\\overline{\\rho}\\frac{d b}{d x}\n                                                               - \\delta\\alpha_{D&#94;2}\\tilde{\\rho}\\frac{d D}{d x}\\right) \\\\ \\nonumber\n                                                             &+ \\nu\\alpha_{DU}\\frac{d}{dx}\\left(D\\frac{dU}{dx}\\right)\n                                                               + \\left.\\nu\\frac{DU}{\\Delta\n                                                               y}f_{D}f'_{U}\\right\\rvert&#94;{y_2}_{y_1} \\\\ \\nonumber\n                                                             &- \\mu\\alpha_{|\\vec{U}|U}|\\vec{U}|U\n                                                               + \\frac{\\delta\\alpha_{D&#94;2} D&#94;2}{2}\\frac{d\\tilde{\\rho}}{d x}\n                                                               + \\Phi\\alpha_{DV}DV, \\\\\n    \\alpha_{DUV}\\frac{d}{d x}\\left(DUV\\right) +\n    \\left.\\frac{f_D f_V&#94;2}{\\Delta y}\\right\\rvert&#94;{y_2}_{y_1}DV&#94;2 &=\n                                                                   \\nu\\alpha_{DV}\\frac{d}{dx}\\left(D\\frac{dV}{dx}\\right) \n                                                                   + \\left.\\nu\\frac{DV}{\\Delta y}f_{D}f'_{V}\\right\\rvert&#94;{y_2}_{y_1} \\label{eq:plume-mom-y-int}\\\\ \\nonumber\n                                                             &-\\mu\\alpha_{|\\vec{U}|V}|\\vec{U}|V - \\left.\\frac{\\delta D&#94;2}{2\\Delta y}f_D&#94;2[\\rho_a\n                                                               - \\rho(x,y)]\\right\\rvert&#94;{y_2}_{y_1}\\\\ \\nonumber\n                                                             &- \\Phi\\alpha_{DU}DU,\n  \\end{align} \\begin{align}\n    \\alpha_{DUS}\\frac{d}{d x}\\left(DUS\\right) +\n    \\left.\\frac{f_D f_S f_V}{\\Delta y}\\right\\rvert&#94;{y_2}_{y_1}DSV &= \\overline{e}S_a\n                                                                    + \\nu\\alpha_{DS}\\frac{d}{dx}\\left(D\\frac{dS}{dx}\\right) \\label{eq:plume-salt-int}\\\\ \\nonumber\n                                                                  &+ \\left.\\nu\\frac{DS}{\\Delta y}f_{D}f'_{S}\\right\\rvert&#94;{y_2}_{y_1}\n                                                                    + \\overline{m}S_m - \\overline{\\gamma_S(S-S_m)}, \\\\\n    \\alpha_{DUT}\\frac{d}{d x}\\left(DUT\\right) +\n    \\left.\\frac{f_D f_T f_V}{\\Delta y}\\right\\rvert&#94;{y_2}_{y_1}DTV &= \\overline{e}T_a\n                                                                    + \\nu\\alpha_{DT}\\frac{d}{d x}\\left(D\\frac{d T}{d x}\\right) \\label{eq:plume-temp-int}\\\\ \\nonumber\n                                                                  &+ \\left.\\nu\\frac{DT}{\\Delta y}f_{D}f'_{T}\\right\\rvert&#94;{y_2}_{y_1}\n                                                                    + \\overline{m}T_m - \\overline{\\gamma_T(T-T_m)}.\n  \\end{align} The constants involving \\alpha are defined below. This result\nassumes a linear equation of state, for which \\begin{equation}\n  \\overline{\\rho} = \\rho_{\\rm ref}[1 + \\beta_S(\\alpha_{DS}S-S_{\\rm\n    ref}) - \\beta_T(\\alpha_{DT}T-T_{\\rm ref})],\\label{eq:rho-bar}\n\\end{equation} and \\begin{equation}\n  \\tilde{\\rho} = \\rho_{\\rm ref}[1 + \\beta_S(\\tilde{\\alpha}_{DS}S-S_{\\rm\n    ref}) - \\beta_T(\\tilde{\\alpha}_{DT}T-T_{\\rm ref})].\\label{eq:rho-tilde}\n\\end{equation} The entrainment parameterisation in equation 14 is unchanged. The one-equation\nmelt formulation of equation 17 becomes \\begin{equation}\n  \\label{eq:horz-melt}\n  \\overline{m} = \\zeta_1\\zeta_2|\\vec{U}|(\\alpha_{|\\vec{U}|T}T - T_m),\n\\end{equation} when horizontally integrated. The ice is assumed to be impermeable to\nsalt, meaning \\overline{\\gamma_S(S - S_m)} = \\overline{m}S_m =\n0 . After horizontal integration, the thermal transfer term becomes \\begin{equation}\n  \\label{eq:horz-therm-trans}\n  \\overline{\\gamma_T(T-T_m)} = \\zeta_1|\\vec{U}|(\\alpha_{|\\vec{U}|T}T - T_m).\n\\end{equation} The \\alpha coefficients in these equations contain information on the transverse\nshape of the plume variables and are defined as \\begin{align}\n\\newcommand{\\horzint}[1]{\\frac{1}{\\Delta{}y}\\int&#94;{y_2}_{y_1}#1 dy}\n  \\nonumber\n  \\alpha_{DU} &= \\overline{f_{D}f_{U}}, &\n                                          \\alpha_{DU&#94;2} &= \\overline{f_{D}f_{U}&#94;2}, &\n                                                                                      \\alpha_{D&#94;2} &= \\overline{f_{D}&#94;2},\\\\\n  \\nonumber\n  \\alpha_{DV} &= \\overline{f_{D}f_{V}}, &\n                                          \\alpha_{DUV} &= \\overline{f_{D}f_{U}f_{V}}, &\n                                                                                        \\alpha_{|\\vec{U}|V} &= \\overline{f_{|\\vec{U}|}f_{V}},\\\\\n  \\label{eq:shape-coefs}\n  \\alpha_{|\\vec{U}|U} &= \\overline{f_{|\\vec{U}|}f_{U}}, &\n                                                          \\alpha_{DUS} &= \\overline{f_{D}f_{U}f_{S}}, &\n                                                                                                        \\alpha_{DUT} &= \\overline{f_{D}f_{U}f_{T}},\\\\\n  \\nonumber\n  \\alpha_{|\\vec{U}|T} &= \\overline{f_{|\\vec{U}|}f_{T}}, &\n                                                          \\quad\\alpha_{DS} &= \\overline{f_{D}f_{S}}, &\n                                                                                                       \\alpha_{DT} &= \\overline{f_{D}f_{T}},\\\\\n  \\nonumber\n  \\tilde{\\alpha}_{DS} &= \\frac{\\overline{f&#94;2_D f_S}}{\\alpha_{D&#94;2}}, &\n                                                                      \\tilde{\\alpha}_{DT} &= \\frac{\\overline{f_{D}&#94;2f_{T}}}{\\alpha_{D&#94;2}}. &\n\\end{align} The same numerical methods used to solve the\noriginal set of plume equations could be used to solve equations 41-45 .  The linear\noperator for the plume solver, defined in equation 32 , was\nmodified to contain the Coriolis forcing terms, becoming \\begin{multline}\n  \\label{eq:L-form-horzint}\n  L{[D, U, U', S, S', T, T']}&#94;T = \\left[\\frac{d D}{d x}, \n    \\frac{d U}{d x} - U',\n    \\frac{d U'}{d x} - \\frac{\\Phi\\alpha_{DV}}{\\nu\\alpha_{DU}} V,\n    \\frac{d V}{d x} - V',\\right.\\\\\\left.\n    \\frac{d V'}{d x} + \\frac{\\Phi\\alpha_{DU}}{\\nu\\alpha_{DV}} U,\n    \\frac{d S}{d x} - S',\n    \\frac{d S'}{d x},\n    \\frac{d T}{d x} - T',\n    \\frac{d T'}{d x}\\right]&#94;T.\n\\end{multline} Shape coefficients, drainage terms, and the equation for y -momentum\nwere added to the nonlinear operator. It was found that the existing\npreconditioner was adequate to solve the modified equations. The\nsolver was tested first by running it in the trivial case with \\Phi = 0 and V=0 throughout the domain, with uniform thickness in y , to ensure that it converged to the solutions used for benchmarking . It was then further tested by checking\nthat the values of each variable at the end of the domain agreed with\nthe asymptotic predictions described in MacMackin (2019) when \\Phi \\ne 0 and b_x was constant."},{"title":"Code Design – ISOFT","tags":"","loc":"page/3-codeDesign/index.html","text":"This section of the documentation provides an overview of the\nstructure of ISOFT and an explanation of the design choices made. It\nis limited to a discussion of code architecture, with numerical\nmethods already having been described in the previous section . A number of design patterns\nwere consciously used when developing ISOFT. The names of these are\nindicated in the text by small-caps.  An understanding of object\noriented programming techniques in general and object oriented\nfeatures in Fortran, in particular, will be useful when reading these\nnotes; see, for example, Rouson, Xia, and Xu (2014) . Familiarity\nwith Universal Modelling Language (UML) diagrams will also be helpful (Rouson, Xia, and Xu, 2014) . Note that,\nin the UML diagrams in this section, names of derived types are shown\nin camel case, as is the convention for class names in most object\noriented languages. However, as Fortran is case-insensitive, the\ndecision was made to use underscore separation within the code."},{"title":"Representing the Coupled Ice Shelf/Plume – ISOFT","tags":"","loc":"page/3-codeDesign/1-representing.html","text":"ISOFT uses a large number of derived types (equivalent to classes in other object oriented languages) in order to model the full glacial\nsystem. The system as a whole is contained within a [[cryosphere(type]] type,\nwith methods for saving/loading data to/from the disk as HDF5 files\nand for integrating forward in time.  The cryosphere contains\nobjects of abstract classes basal_surface and glacier , the latter\nrepresenting a glacier and the former representing whatever is\nunderneath it. Objects of these types have their own methods for\nreading and writing data, integration, and accessing useful\ninformation. Both are general enough to allow ISOFT to model either\nfloating or grounded ice. Below are class diagrams showing the\ninheritance/encapsulation relationships between different derived\ntypes, as well as methods for the cryosphere , glacier , and basal_surface types. The only concrete existing implementation of the glacier class is\nthe ice_shelf type. As its name suggests, this models the behaviour\nof an ice shelf. While the implementation of the continuity equation\nis agnostic towards whether the model is 1-D or 2-D, at present the\nice momentum equation is explicitly 1-D. Ideally this will be fixed in\nthe future. The ice_shelf type may optionally feature a Lagrangian\ntracer, assumed to indicate the age of the ice as would be measured\nfrom internal reflectors.  There is stub for a grounded ice_sheet type, but its methods have not been implemented. A few implementations of the basal_surface class are available. The\nmost commonly used of these is the plume type, modelling the 1-D\nsubglacial plume. In principle this can model a second\nvelocity component, but such a model is physically unstable. There is\nalso the static_plume type, which does not evolve from the state with\nwhich it is initialised or has loaded from saved data. This is useful if\na simulation is to be performed with a fixed melt rate. The asym_plume provides an implementation of a\nhorizontally-integrated model. Various parameters describing the\ntransverse profile of this plume are provided through the associated plume_shape derived type. Finally, a ground type exists as a stub,\nwhich could be fully implemented in future to provide a basal surface\nwith frictional information for a grounded ice sheet. All of these implementations contain field types (described in the next section ) for each variable, describing\ntheir state. They also contain objects representing the boundary\nconditions and choices of parameterisations, described in more detail\nin the Parameterisations and Boundary Conditions section. This is illustrated in the preceding figure, showing the\nstate of the objects at the beginning of a representative\nsimulation. The cryosphere class is a Puppeteer pattern which, as\ndescribed by Rouson, Xia, and Xu (2014) ,\ncoordinates interactions between various other classes\n( glacier and basal_surface , in this case) without\nthem needing to directly interact with each other. Thus,\ninterdependencies between different modules of code are\nsimplified. For each time-step, the following sequence of steps\noccurs, as illustrated in the UML sequence diagram which follows: The cryosphere first gets the ice thickness from the glacier . This information is sent to the basal_surface object, with which\n    it can solve for its state at the current time using the QLM solver. The cryosphere gets the current melt rate and/or friction\n    parameters from the basal_surface . This information is sent to the glacier object, where it is used\n    to integrate its state forward in time with NITSOL."},{"title":"Discretisation – ISOFT","tags":"","loc":"page/3-codeDesign/2-discretisation.html","text":"Spatial derivatives of the variables describing the state of the ice\nshelf and plume are frequently needed. Multiple approaches exist to\ndiscretise these variables and compute their gradients (e.g. finite\ndifference, finite element, pseudospectral, etc.) and the desire was\nto avoid restricting ISOFT to a particular one. To this end, the Abstract Calculus design\npattern, described by Rouson, Xia, and Xu (2014, Chapter 6) ,\nwas adopted. This design pattern attempts to resolve the disconnect\nbetween high-level mathematical notation and the low-level\nrepresentation of data and operators in code. A hierarchy of derived\ntypes was written representing mathematical fields of both scalar and\nvector quantities, as illustrated in the UML class diagram\nbelow. These fields overloaded all of the standard arithmetic and\nintrinsic mathematical functions, as well as offering methods for\nvarious differential operators. Calculations involving these field\ntypes could then be written to be agnostic with regards to field\ngeometry or discretisation technique. In order to send field data to\nexternal libraries of numerical methods, such as NITSOL, methods were\nalso provided to return them as an array of double precision values. Properties such as geometry and discretisation are specified within\nthe concrete implementations of the field types. As shown in the class\ndiagram above, two groups of these concrete field types exist. The\nfirst is the cheb1d_scalar_field / cheb1d_vector_field , which offers\na 1-D field on a Chebyshev grid. The Chebyshev pseudo-spectral method is\nused to calculate derivatives, with Fast Fourier Transforms performed\nusing the FFTW3 library (Frigo and Johnson, 2005) . These were\nsubtypes of the abstract classes array_scalar_field / array_vector_field . The array field types\nprovide standard implementations of arithmetic and mathematical\nfunctions, leaving only those methods involving grid-layout or\ncalculus to be implemented by concrete type-descendents. This allows\neasier creation of new field types with reduced code duplication. The\nother pair of concrete field types are uniform_scalar_field / uniform_vector_field which, as the names\nsuggest, are uniform throughout all space. These were written to allow\nsome optimisation for cases where a variable proves to be uniform. The hope was that ISOFT could remain agnostic about which concrete\ntype of field is being used. However, bugs in the version of the gfortran compiler used (v6.2.0) made this impossible and in many\nsituations the cheb1d implementations are explicitly specified. As a\nresult of this (and some lazy code design) ISOFT has come to depend on\nusing those particular implementations in a number of areas,\nparticularly around preconditioning (discussed in the Nonlinear Solvers section). However, relatively\nminor refactoring should allow this issue to be resolved in future. Despite the conceptual elegance of the Abstract Calculus design, a\nnumber of practical issues mean it was likely a mistake to use it so\nextensively within ISOFT. First is the problem of compiler bugs,\nmentioned earlier. One of these resulted in memory leaks when a\ndynamically-allocated field object was returned from a function\ncall. A workaround using an Object Pool was ultimately\nfound. The Object Pool pattern passes pointers to preallocated objects, rather than creating\nnew ones, and releases them back to the pool once they are no longer\nbeing used Grand (2002, Chapter 5) . This avoided\nmemory leaks but required frequent calls to book-keeping functions\nwhich ensured objects were released to the pool at the appropriate\ntime. These calls eliminated much of the elegance of Abstract\nCalculus . Furthermore, overloading the arithmetic operators\nintroduced overhead and likely prevented the compiler from making many\noptimisations. With hindsight, a better approach would have been to\nstore the data in standard Fortran arrays and have calculus functions\nprovided by a set of derived types according to the Strategy pattern (discussed in\nthe Parameterisations and Boundary Conditions section). However, one situation in which using the field types proved useful\nwas when implementing automatic differentiation (Neidinger, 2010) . This works by\napplying the chain rule to the arithmetic operations and elementary\nmathematical functions applied to data in order to calculate the\nderivative of the result with respect to one or more pieces of the\ndata used to produce it. The simpler of the two approaches to doing\nthis is to overload the arithmetic operators and elementary functions\nto propagate the derivative using the chain rule. (The other\ntechnique, known as source transformation , automatically rewrites\nthe entire code prior to compilation so that propagation of the\nderivative is performed inline.) Consider ordered pairs of the form \\langle u, u'\\rangle , where u is some value u' is a\ndifferential associated with that value. Then: \\begin{aligned}\n  \\langle u, u' \\rangle + \\langle v, v' \\rangle &=  \\langle u + v, u'\n                                                  + v' \\rangle, \\\\\n  \\langle u, u' \\rangle \\times \\langle v, v' \\rangle &=  \\langle uv,\n                                                       u'v + uv' \\rangle, \\\\\n  \\sin\\langle u, u'\\rangle &= \\langle \\sin u, u'\\cos u \\rangle, \\\\\n                                                & \\vdots\\end{aligned} with all other arithmetic and mathematical functions similarly\noverloaded. As the field types already provide overloading of these\noperators and routines, adding automatic differentiation required less\neffort to implement than would otherwise have been necessary. Automatic differentiation was provided as an optional feature, which the\nabstract field types support but which subtypes are not required to\nimplement; if the feature is not implemented in a subtype then trying to\nuse the default implementation in the abstract class will result in a\nrun-time error. Methods are provided with which one field can be used to\nset the derivative values for another. If the derivative for a field has\nbeen set then it will be propagated through all subsequent mathematical\noperations involving that field. Otherwise, no automatic differentiation\noccurs. The derivative value of the result can be retrieved with a\ngetter method. Automatic differentiation is turned off with a method\nwhich clears the derivative information. The array fields and their\nsubtypes provide automatic differentiation, but the uniform fields do\nnot. These field types were sufficiently general that they could be used in a\nnumber of settings other than ISOFT. As such, they were written as a\nseparate library called FACTUAL (Fortran Abstract Calculus Types, Usable\nand Aesthetic Library). This is distributed with ISOFT but can also be\ndownloaded on its own."},{"title":"Nonlinear Solvers – ISOFT","tags":"","loc":"page/3-codeDesign/3-solvers.html","text":"Ice Shelf Solver: NITSOL As described earlier , when\nintegrating the ice shelf the nonlinear solver NITSOL (Pernice and Walker, 1998) was\nused. This is a legacy package written in FORTRAN77. ISOFT contains an\nexplicit interface to the main NITSOL subroutine so that arguments can\nbe checked by the compiler when it is invoked. NITSOL takes as an\nargument a subroutine which receives the current estimate of the state\nof the system and returns the corresponding residual according to equation 22 or 26 , depending\non whether solving for the ice\nthickness or velocity. The state of the system and the residual are\nboth represented as 1-D arrays of real values. When the state array is\nreceived by the residual subroutine it is used to update the value of\na field type (see the previous page ).\nOperations are performed using the field type to calculate a\nresidual field. A 1-D array containing the data of the residual field\nis then extracted and returned by the subroutine. For NITSOL to converge it required a preconditioner which inverts the\nJacobian operator \\mathcal{D}_x A \\equiv \\partial A/\\partial x +\nA\\Delta_x (where \\Delta_x is the differential operator in the x -direction).  NITSOL receives the preconditioner as an additional\nsubroutine which takes as an argument an array to be preconditioned\nand returns the result of that preconditioning as an array. Similarly\nto the calculation of the residual, the preconditioner subroutine\nconverts the array to a field type, performs the preconditioning, and\nthen converts back to an array. As previously described , the operator\ncan be inverted by solving a tridiagonal matrix approximating the\nJacobian using finite-difference discretisation. A derived type called\na jacobian_block (see below) was written to encapsulate this\nprocess, reinitialised every time a new value of A is needed by the\noperator. This derived type is also able to represent two variations\non the \\mathcal{D}_x operator: \\alpha + \\mathcal{D}_x X , where \\alpha is a scalar; and \\mathcal{D}_x A\\Delta_x . In addition\nto inverting the operator on a field, jacobian_block objects can\napply the forward operator to fields. Plume Solver: QLM The plume is solved using the quasi-linearisation method (QLM).\nAs the QLM is an obscure algorithm, a custom implementation was\nwritten in modern Fortran for ISOFT. It takes as arguments functions\nrepresenting the linear and nonlinear portions of the nonlinear system\nof ODEs being solved. It also requires a function which computes the\nproduct of the Jacobian of the nonlinear operator with an arbitrary\nstate vector and, optionally, a preconditioner function. All of these\noperate on and return arrays of real data. The QLM requires solving a\nlinear system at each iteration and this is done using a slightly\nmodified version of the GMRES implementation in NITSOL. The\nmodification allows the GMRES solver to use an initial guess of the\nsolution to the linear system, rather than assume a good initial guess\nto be zero (as made sense in the context of NITSOL). An explicit\ninterface was written to this FORTRAN77 implementation, along with a\nwrapper which makes many of the arguments optional, automatically\ncreates the necessary work arrays, and allows for less verbose\ndefinitions of the linear system. Much as when solving for the state of the ice shelf, the linear and\nnonlinear plume operators take 1-D arrays of real values as arguments.\nThey then use a method of the plume class to update the various fields\nrepresenting the plume variables from this array. The necessary\nmathematics is performed using these fields and the results converted\nback to 1-D arrays which are then returned to the QLM solver. The\npreconditioner works by inverting the linear operator of the plume,\ntaking the anti-derivative of each variable. A derived type called the pseudospec_block (see figure above) was written to apply\nthis to field types, reversing the Chebyshev differentiation algorithm\ndescribed on page . A similar derived type called fin_diff_block was also written which performs the same\noperation using a tridiagonal matrix representing a finite-difference\napproach to differentiation. However, the much greater accuracy and\ncomparable computational cost of the pseudospec_block made it the\nbetter choice. As previously mentioned, it was found that to get the level of\naccuracy needed for the plume solver to converge, the product of the\nJacobian could not simply be evaluated using a finite difference\napproximation. Instead, the automatic differentiation feature of the\nfield types described on the previous page was used. The vector to be multiplied by the Jacobian is used to\nprovide derivative values for the plume variables. The nonlinear\noperator is then applied for the current plume state, with the\noverloaded operators of the field types applying the chain rule at\neach step to propagate the derivative. The derivative of the operator\nresult will then be the product of the Jacobian and the initial\nvector."},{"title":"Parameterisations and Boundary Conditions – ISOFT","tags":"","loc":"page/3-codeDesign/4-parameterisations.html","text":"One of the goals of ISOFT is to allow choices of parameterisations to\neasily be changed. This is achieved using the Strategy pattern (Rouson, Xia, and Xu, 2014, Chapter 7) ,\nwhich provides a common abstract interface to accomplish some task,\nwith subtypes implementing different strategies to do so. In ISOFT,\nthe methods in the abstract types were generally given a large number\nof arguments, to ensure sufficient information is available for all\npotential parameterisations. Parameter and coefficient values can be\nspecified for each parameterisation when initialising its object. The only parameterisation for the ice shelf is viscosity. The general\ninterface is provided by the abstract_viscosity type. It’s subtypes\nare newtonian_viscosity , which returns a uniform_field all\ncases, and glens_law_viscosity which calculates the viscosity from\nthe ice velocity as described in equation 5 . Currently Glen’s law is\nonly implemented for the 1-D case, as attempting to implement it for\nhigher dimensions resulted in a compiler bug. A class diagram is provided below. The plume contains a few parameterisations. The subtypes of abstract_entrainment calculate an entrainment rate for the\nplume. These are jenkins1991_entrainment and kochergin1987_entrainment , implementing equations 14 and 15 ,\nrespectively.  The abstract_melt_relationship provides an\ninterface for calculating the melt rate of the ice, in addition to the\nheat and salt fluxes resulting from melting. The one equation\napproximation of equation 17 was implemented as one_equation_melt . A variation of this\nwas implemented as ave_one_equation_melt , implementing the\nhorizontally-averaged version of the one equation formulation found in equations 48 and 49 .\nThe subtype dallaston2015_melt provides a way\nto convert from the scaling choices used by Dallaston, Hewitt, and Wells (2015) to those used in ISOFT, which was useful for writing unit\ntests. Finally, the abstract type equation_of_state sets out\nthe interface for calculating the density of water from salinity and\ntemperature. Subtype linear_eos implements the linearised\nequation of state in equation 20 . The\nrelated ave_linear_eos provides additional methods methods for\ncalculating \\overline{\\rho} and \\tilde{\\rho} , as defined in equations 46 and 47 , respectively.\nLast, the subtype prescribed_eos calculates the density assuming no dependence on temperature and using\na prescribed salinity profile; this is also useful in unit\ntests. Class diagrams for each set of derived types are provided\nbelow. A similar approach was taken for boundary conditions and ambient ocean\nproperties. The types glacier_boundary and plume_boundary (class diagrams below) provide interfaces for\nidentifying the types of boundary conditions at different locations\nand determining the appropriate values. The default implementations\neffectively do not specify boundary conditions and the methods must be\noverridden to be useful. The interface provided by plume_boundary is quite different from that provided by glacier_boundary . The latter should ideally be refactored to\nbe closer to the more usable interface provided by the former. The\nsubtypes for glacier_boundary are dallaston2015_glacier_boundary , which prescribes a\ntime-independent ice thickness and velocity at the grounding line and\na balance between normal stress and hydrostatic pressure at the\ncalving front, and seasonal_glacier_boundary , which modifies\nintroduces sinusoidal or square-wave variation to the grounding line\nvelocity. The first subtype of plume_boundary is simple_plume_boundary , which implements Dirichlet boundary\nconditions at the grounding line and Neumann conditions (zero\ngradient) for velocity, salinity, and temperature at the calving\nfront.  Closely related to this type is dallaston2015_seasonal_boundary , which modifies the boundary\nconditions by sinusoidally perturbing the plume thickness and velocity\nat the grounding line. The type which was ultimately used in all\nsimulations was upstream_plume_boundary .  This takes a\nuser-provided function which specifies the inflow value of each plume\nvariable and then, assuming no diffusion, integrates the plume a small\ndistance upstream along the current basal draft of the ice shelf using rksuite_90 (Brankin and Gladwell, 1994) . This\nallows the plume solver itself to avoid handling narrow boundary\nlayers where the plume salinity and temperature change\nrapidly. Outflow conditions remain unchanged. Ambient ocean conditions\nare described according to the interface defined by the abstract type ambient_conditions . As shown in the class diagram below, at\npresent only one implementation is provided\n( uniform_ambient_conditions ), specifying constant ambient\nsalinity and temperature."},{"title":"Plotting ISOFT Output – ISOFT","tags":"","loc":"page/4-plotting/index.html","text":"ISOFT provides a small library of plotting scripts with which to\nanalyse the HDF5 files which it outputs. This is divided into two parts: A set of routines which read and process the HDF5 data. A selection of executable scripts which actually produce plots. The scripts provide some basic functionality with which to visualise\nthe output of ISOFT. However, you will likely want to write some\nscripts of your own to provide more complex, bespoke analysis."},{"title":"Reader Objects – ISOFT","tags":"","loc":"page/4-plotting/1-readers.html","text":"The most basic part of the plotting library is the classes it provides\nfor reading the HDF5 files which ISOFT produces. These can be found in\nthe plotting/ readers.py file. The class which you will mostly use\nis ShelfPlumeCryosphere , which loads files from simulations run with\nthe ice_shelf and plume (or static_plume or asym_plume ) derived types.\nReaders of this type are created using the constructor ShelfPlumeCryosphere ( hdf_file ) where hdf_file is the name of an HDF5 file created by ISOFT. This reader object a number of properties which provide information on\nthe state of the simulation. Arrays containing simulation variables\nmay, in principle, be multidimensional. However, as code currently\nexists only for 1-D simulations, they are all 1-D in practice (except uvec and Uvec , which are 2-D). isoft_version : Version number of ISOFT which generated the HDF5 file compilation_time : Time and date at which the ISOFT library used\n  to generate the HDF5 file was compiled output_time : Wall-clock time the HDF5 file was created time : Time within the simulation when the HDF5 file was created grid : The coordinates of the grid discretising the domain glacier_type : The type of glacier object which created this data h : Array containing thickness of the glacier's ice uvec : Array containing glacier ice velocity in vector form, with u = uvec[...,0] and v = uvec[...,1] (if transverse present) u : Array containing longitudinal glacier velocity v : Array containing transverse glacier velocity; will raise an error if not present s : The surface elevation of the glacier, h*(1.-1./r) b : The basal depth of the glacier, -h/r kappa : Array containingTaylor coefficients in z for a Lagrangian tracer field,\n  with kappa[i,...] corresponding to the coefficient for the\n  i-1 th power term; raises an error if not present in\n  simulation output lambd : The dimensionless melt parameter, \\lambda chi : The dimensionless stretching parameter, \\chi basal_surface_type : The type of basal_surface object to create this data D : Array containing the thickness of the subglacial plume Uvec : Array containing plume ice velocity in vector form, with U = Uvec[...,0] and V = Uvec[...,1] (if transverse present) U : Array containing longitudinal plume velocity V : Array containing transverse plume velocity; will raise an error if not present S : Array containing plume salinity T : Array containing plume temperature delta : The buoyancy correction parameter, \\delta mu : The dimensionless drag coefficient, \\mu nu : The dimensionless eddy diffusivity, \\nu r : The density ratio for ocean water and glacier ice, r phi : The dimensionless Coriolis parameter, \\Phi A simple example of using a reader object to make a plot is provided below: from plotting.readers import ShelfPlumeCryosphere import matplotlib.pyplot as plt cryo = ShelfPlumeCryosphere ( 'isoft-0000.h5' ) plt . plot ( plt . grid , plt . h ) plt . xlabel ( '$x$' ) plt . ylabel ( '$h$' ) plt . show ()"},{"title":"General Plotting Tools – ISOFT","tags":"","loc":"page/4-plotting/3-tools.html","text":"For convenience, a number of additional tools are provided for\nanalysing ISOFT output. These are organised into a series of\nadditional Python modules. plotting/ calculus.py Provides a Differentiator class which can be used to calculate\nderivatives of ISOFT output using the Chebyshev pseudospectral method. Rather than the previously described algorithm using the FFT,\na differentiation matrix is used here (Trefethen, 2000) . The constructor\nfor this object is Differentiator ( size , lower = 0.0 , upper = 1.0 ) where size is the number of Chebyshev pseudo-spectral nodes in the\ndata to be differentiated, lower is the lower bound of the domain,\nand upper is the upper bound. The differentiator object is applied\nby calling it like a function, with the array to be differentiated\npassed as an argument. from plotting.readers import ShelfPlumeCryosphere from plotting.calculus import Differentiator cryo = ShelfPlumeCryosphere ( 'isoft-0000.h5' ) diff = Differentiator ( cryo . grid . size , cryo . grid [ - 1 ], cryo . grid [ 0 ]) dh_dx = diff ( cryo . h ) plotting/ dimensionless_nums.py This module provides routines to calculate dimensionless numbers used\nin fluid dynamics. To date, only the Froude number has been\nimplemented. This has routine froude ( coef , U , drho , D ) where coef is a dimensionless coefficient 1/\\sqrt{\\delta} , U =\nShelfPlumeCryosphere.Uvec is the vector velocity, drho is a\ndensity difference causing buoyant forcing, and D is thickness of\nthe fluid layer. plotting/ entrainment.py This provides classes which can calculate the entrainment rate for a\nsubglacial plume. Two such classes are provided: one for the\nparameterisation of Jenkins (1991) and another for that of Kochergin (1987) . The constructor\nfor the first has the form Jenkins1991Entrainment ( coefficient , size , lower = 0.0 , upper = 1.0 ) where coefficient is the dimensionless entrainment coefficient E_0/\\delta (typically with value 1) and the remaining arguments\nhave the same meaning as those in the constructor for the Differentiator type . The constructor for the latter\nhas the form Kochergin1987Entrainment ( coefficient , delta ) where coefficient is K = c_L&#94;2 x_0/D_0 , as described in equation 16 ,\nand delta is the buoyancy correction \\delta . For both of these classes, the entrainment is calculated by calling\nthe object like a function. For an entrainment object named ent , the\ncall signature is ent ( U , D , b , rho_diff ) where U is the vector velocity of the plume, D is the plume\nthickness, b is the basal depth of the ice shelf, and rho_diff is\nthe density difference between the ambient ocean and the plume. The\nlast argument is not used and may be omitted for the Jenkins1991Entrainment class. plotting/ eos.py This provides a class, LinearEos , for calculating the plume density\naccording to the linearisation in equation 20 . The\nconstructor for this class LinearEos ( ref_density , beta_T , beta_S , T_ref , S_ref ) where the arguments are the reference density, thermal contraction\ncoefficient, haline contraction coefficient, reference temperature,\nand reference salinity. All quantities should be scaled to be in\nnondimensional units. The resulting object (called, say, eos ) is\ncalled like a function: eos ( T , S ) where T is the plume temperature and S is the plume salinity. plotting/ melt.py This module provides classes which can calculate the melt rate of the\nice shelf and melt contributions to the plume's salinity and heat\nequations. The first class is Dallaston2015Melt which calculates the\nmelt rate in the same manner as the dallaston2015_melt derived type. It has constructor Dallaston2015Melt ( beta , epsilon_g , epsilon_m ) where beta is the inverse Stefan number, epsilon_g is the ratio of\nsubglacial flux to entrained flux, and epsilon_g is the ratio of\nsubshelf melt and entrained flux. The other class is OneEquationMelt ,\nwhich calculates the melt rate in the manner of the one_equation_melt derived type. It has constructor OneEquationMelt ( coef1 , coef2 , fresh_sal = 0. , melt_temp = 0. ) where coef1 and coef2 correspond to \\zeta_1 and \\zeta_2 in equation 18 , fresh_sal is the salinity value which is designated as \"fresh\", and melt_temp is the temperature at which melting occurs (scale analysis\nshows that it often makes sense for these to be non-zero). For both classes, the melt rate is calculated by calling the melt\nobject (here named m ) like a function. Additionally, there are\nmethods thermal_forcing and saline_forcing to calculate the\ncontribution of melting to the plume heat and salinity equations,\nrespectively. These can be called as follows: m ( U , p , T , S , D ) m . thermal_forcing ( U , p , T , S , D ) m . saline_forcing ( U , p , T , S , D ) In each case, U refers to the plume vector velocity, p to the\npressure at the base of the ice shelf, T to the plume temperature, S to the plume salinity, and D to the plume thickness. plotting/ viscosity.py Finally, this module provides two classes which can calculate the\nviscosity of the glacier: NewtonianViscosity and GlensLaw . The\nfirst of these is a trivial implementation with a constructor NewtonianViscosity ( value = 1.0 ) Making calls to objects of this type will return an array filled with\nthe value with which the viscosity object was initialised. The\nsecond implementation is GlensLaw , which treats viscosity as a\npower law of strain (equation 5) . It\nhas constructor GlensLaw ( size , lower = 0.0 , upper = 1.0 , coef = 1.0 , index = 3 ) The first 3 arguments have the same meaning as in the constructor for\nthe Differentiator class . The argument coef corresponds to \\xi , as defined in equation 6 and index is the value of n in the equation for Glen's Law. Both viscosity classes are called like functions and (if an instance\nof them is named visc ) have the call signature visc ( uvec , temperature =- 15.0 , time = 0 ) where uvec is the vector ice velocity, temperature is the\ntemperature of the ice, and time is the time during the simulation\nat which the calculation is being performed. The latter two arguments\nare not used in either implementation of viscosity."},{"title":"Plotting Internal Layers – ISOFT","tags":"","loc":"page/4-plotting/5-layers.html","text":"ISOFT has the ability to simulate the advection of a Lagrangian tracer\ndistributed in the z-direction. The main use for this is to track the\nevolution of isochrones, which correspond to internal radar reflectors\nobserved in ice sheets and shelves. ISOFT achieves this by expressing\nthe tracer as a Taylor expansion in z and then calculating changes\nto the Taylor coefficients. It is only the coefficients which are\nstored. Visualising this tracer data requires converting it to a 2-D form in x and z . For this purpose, the plotting/ layers.py module\nprovides a routine called compute_layers . This has the call\nsignature x , z , k = compute_layers ( shelf , vertical_resolution = 300 ) where x and z are 2-D arrays containing the coordinates in x and z respectively, k is a 2-D array containing the values of the\ntracer. These are calculated from shelf , which is either a Glacier or a ShelfPlumeCryosphere object (see Reader Objects ). The number of intervals in z on\nwhich to calculate k is set by the argument vertical_ resolution . With this output, a contour plot can be produced, showing the presence\nof internal layers within the ice shelf. This is demonstrated in the\nscript below, along with example output. from plotting.readers import ShelfPlumeCryosphere from plotting.layers import compute_layers import numpy as np import numpy.ma as ma import matplotlib import matplotlib.pyplot as plt cryo = ShelfPlumeCryosphere ( 'isoft-0000.h5' ) nz = 1200 conts = 16 x , z , k = compute_layers ( cryo , nz ) plt . plot ( cryo . grid , cryo . s , 'k' ) plt . plot ( cryo . grid , cryo . b , 'k' ) plt . contour ( x , z , k , conts , linewidths = 0.5 , colors = 'k' ) plt . contourf ( x , z , k , conts , cmap = 'PuBu' ) plt . xlabel ( '$x$' ) plt . ylabel ( '$z$' ) plt . colorbar ( orientation = 'horizontal' , label = r '$k$' ) plt . show ()"},{"title":"Provided Plotting Scripts – ISOFT","tags":"","loc":"page/4-plotting/6-scripts.html","text":"The Python library described in the previous sections allows you to\nproduce plots with tools such as matplotlib . This can be useful when\ncreating bespoke visualisations or undertaking detailed analysis of\nISOFT output. However, there are many simple types of plots which you\nwill want to create regularly. For these, a selection of programs have\nbeen provided in the directory scripts/ . Where it is necessary to\nspecify a scaling or parameterisation choice, the same ones are used\nas in the example program . Unless\notherwise indicated, all scripts have the following call-signature: ./script-name.py [ infile [ outfile ] ] Here, infile refers to the name of the HDF5 file the data in which\nis to be plotted. If not specified, it defaults to isoft-0000.h5 . Conversely, outfile is the name of a file in which\nthe plot should be saved, with the format taken from the file-name\nextension. If this is not specified then the script will produce the\nplot in an interactive graphical interface. scripts/ decompose.py Displays a series of plots, one for each of the equations describing\nthe 1-D plume\n( equations 8, 9, 11, and 12 ). In\neach figure, the magnitude of the individual terms in that equation\nare plotted against each other, alongside their sum (which should be\n0). The script can not save plots to a file and only takes one\nargument. The next plot will be produced once you have closed the\nprevious one. scripts/ display.py Produces a plot of all plume and ice shelf variables. Salinity and\ntemperature are shown on a seperate set of axes, as these values can\nbe quite different from those of the other variables. scripts/ ice_continuity.py Produces a plot showing the value of each term in the continuity\nequation for the ice shelf\n( equation 1 ). scripts/ internal_layers.py Produces a contour plot showing the value of a Lagrangian tracer\n(indicating, e.g., the age of ice). Similar to the plot shown on the previous page . scripts/ plume_momentum.py Produces a plot showing the value of each term in the transverse\nmomentum equation for the plume\n( equation 9 ). scripts/ shock.py A plot of the plume velocity, thickness, and Froude number. This can\nbe useful for diagnosing the presence of a hydrolic shock."},{"title":"Bibliography – ISOFT","tags":"","loc":"page/./6-bibliog.html","text":"Anderson, E. et al. (1999). LAPACK Users’ Guide . Third. Philadelphia, PA: Society for\nIndustrial and Applied Mathematics. Bindschadler, R., D.G. Vaughan, and P. Vornberger (2011). “Variability of basal melt\nbeneath the Pine Island Glacier ice shelf, West Antarctica”. In: Journal of Glaciology 57.204, pp. 581–595. doi: 10.3189/002214311797409802. Brankin, RW and I Gladwell (1994). rksuite 90: software for ODE IVPs . Tech. rep. NAG\nTech. Report, TR6/94, 1994. Brent, R.P. (1973). Algorithms for Minimization Without Derivatives . Prentice-Hall\nseries in automatic computation. Prentice-Hall. Cooley, J.W. and J.W. Tukey (1965). “An algorithm for the machine calculation of\ncomplex fourier series”. In: Mathematics of Computation 19.90, pp. 249–259. doi:\n10.1090/S0025-5718-1965-0178586-1. Dallaston, M.C., I.J. Hewitt, and A.J. Wells (2015). “Channelization of plumes beneath\nice shelves”. In: Journal of Fluid Mechanics 785, pp. 109–134. doi:\n10.1017/jfm.2015.609. Frigo, Matteo and Steven G. Johnson (2005). “The Design and Implementation of\nFFTW3”. In: Proceedings of the IEEE 93.2. Special issue on “Program Generation,\nOptimization, and Platform Adaptation”, pp. 216–231. Grand, Mark (2002). Patterns in Java: A Catalog of Reusable Design Patterns Illustrated\nwith UML, Volume 1 . 2nd ed. New York: Wiley. Jacobs, S.S., H.H. Hellmer, and A. Jenkins (1996). “Antarctic Ice Sheet melting in the\nsoutheast Pacific”. In: Geophysical Research Letters 23.9, pp. 957–960. doi:\n10.1029/96GL00723. Jenkins, A. (1991). “A one-dimensional model of ice shelf-ocean interaction”. English. In: Journal of Geophysical Research 96 (C11), 20671–7. Jenkins, A. (2011). “Convection-driven melting near the grounding lines of ice shelves and\ntidewater glaciers”. In: Journal of Physical Oceanography 41.12, pp. 2279–2294. doi:\n10.1175/JPO-D-11-03.1. Knoll, D.A. and D.E. Keyes (2004). “Jacobian-free Newton-Krylov methods: A survey of\napproaches and applications”. In: Journal of Computational Physics 193.2,\npp. 357–397. doi: 10.1016/j.jcp.2003.08.010. Kochergin, V. P. (1987). “Three-Dimensional Prognostic Models”. In: Three-Dimensional\nCoastal Ocean Models . American Geophysical Union, pp. 201–208. doi:\n10.1029/CO004p0201. MacMackin, C., (2019). Understanding the Effect of Seasonal\nVariability on the Structure of Ice Shelves and Meltwater Plumes ,\nDPhil in Atmospheric, Oceanic, and Planetary Physics, University of\nOxford, Oxford, UK. Mandelzweig, V. B. and F. Tabakin (2001). “Quasilinearization approach to nonlinear\nproblems in physics with application to nonlinear ODEs”. In: Computer Physics\nCommunications 141, pp. 268–281. doi: 10.1016/S0010-4655(01)00415-5. Neidinger, R. (2010). “Introduction to Automatic Differentiation and MATLAB\nObject-Oriented Programming”. In: SIAM Review 52.3, pp. 545–563. doi:\n10.1137/080743627. Orszag, Steven A (1980). “Spectral methods for problems in complex geometries”. In: Journal of Computational Physics 37.1, pp. 70–92. doi:\n10.1016/0021-9991(80)90005-4. Pernice, M. and H.F. Walker (1998). “NITSOL: A Newton iterative solver for nonlinear\nsystems”. In: SIAM Journal on Scientific Computing 19.1, pp. 302–318. Press, William H. et al. (2007). Numerical Recipes 3rd Edition: The Art of Scientific\nComputing . 3rd ed. New York, NY, USA: Cambridge University Press. Rouson, D., J. Xia, and X. Xu (2014). Scientific Software Design: The Object-Oriented\nWay . Cambridge University Press. Sergienko, O. V. (2013). “Basal channels on ice shelves”. In: Journal of Geophysical\nResearch -- Earth Surface 118.3, 1342–1355. doi: 10.1002/jgrf.20105. Trefethen, L. (2000). Spectral Methods in MATLAB . Society for Industrial and Applied\nMathematics. doi: 10.1137/1.9780898719598. eprint: http://epubs.siam.org/doi/pdf/10.1137/1.9780898719598."}]}